/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function() {
  'use strict';

  var Rome = (function() {
    var hasOwn = Object.prototype.hasOwnProperty;

    var factories = {};
    var modules = {};

    var Rome = {
      declare: function(id, callback) {
        factories[id] = callback;
      },

      declareModule: function(id, module) {
        return modules[id] = {exports: module};
      },

      import: function(id) {
        return Promise.resolve(Rome.require(id));
      },

      requireDefault: function(moduleId) {
        var mod = Rome.require(moduleId);
        return mod.__esModule ? mod.default : mod;
      },

      require: function(moduleId) {
        if (hasOwn.call(modules, moduleId)) {
          return modules[moduleId].exports;
        }

        if (hasOwn.call(factories, moduleId)) {
          const factory = factories[moduleId];
          const module = Rome.declareModule(moduleId, {});
          factory(module, module.exports);
          return module.exports;
        }

        throw new Error('No module ' + moduleId);
      },
    };
    return Rome;
  })();

  // romejs/parser-core/src/types.ts

  const ___$romejs$parser_core$src$types_ts = {};

  // romejs/diagnostics/src/normalize.ts

  const ___$romejs$diagnostics$src$normalize_ts = {
    normalizePosition: ___$romejs$diagnostics$src$normalize_ts$normalizePosition,
    normalizeDiagnostics: ___$romejs$diagnostics$src$normalize_ts$normalizeDiagnostics,
    normalizeDiagnostic: ___$romejs$diagnostics$src$normalize_ts$normalizeDiagnostic,
    normalizeDiagnosticAdviceItem: ___$romejs$diagnostics$src$normalize_ts$normalizeDiagnosticAdviceItem};
  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeLanguage(language) {
    if (language === 'js' || language === 'json') {
      return language;
    }

    return 'js';
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizePositionAssert(position) {
    const normalized = ___$romejs$diagnostics$src$normalize_ts$normalizePosition(position);
    if (normalized === undefined) {
      return {
        index: -1,
        line: 1,
        column: 0};
    } else {
      return normalized;
    }
  }

  function ___$romejs$diagnostics$src$normalize_ts$normalizePosition(position) {
    const {line: line, column: column, index: index} = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeDiagnosticsObject(position);

    if (typeof line !== 'number' ||
    typeof column !== 'number' ||
    typeof index !== 'number') {
      return undefined;
    }

    return {
      index: Math.max(index, -1),
      line: Math.max(line, 1),
      column: Math.max(column, 0)};
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeLogCategory(value) {
    if (value === 'none' ||
    value === 'question' ||
    value === 'info' ||
    value === 'warn' ||
    value === 'error') {
      return value;
    }

    return 'error';
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeStringArray(value) {
    if (Array.isArray(value)) {
      return value.map(item => ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeString(item, 'Nothing provided'));
    } else {
      return [];
    }
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalNumber(value) {
    if (typeof value === 'number') {
      return value;
    } else {
      return undefined;
    }
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(value) {
    if (typeof value === 'string') {
      return value;
    } else {
      return undefined;
    }
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeString(value, def) {
    if (typeof value === 'string') {
      return value;
    } else {
      return def;
    }
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeBoolean(value, def) {
    if (typeof value === 'boolean') {
      return value;
    } else {
      return def;
    }
  }

  function ___$romejs$diagnostics$src$normalize_ts$normalizeDiagnostics(diagnostics, opts) {
    if (Array.isArray(diagnostics)) {
      return diagnostics.map(diag => ___$romejs$diagnostics$src$normalize_ts$normalizeDiagnostic(diag, opts));
    } else {
      return [];
    }
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeFilename(filename, opts) {
    if (filename === undefined) {
      return 'unknown';
    } else if (opts.normalizeFilename === undefined) {
      return filename;
    } else {
      return opts.normalizeFilename(filename);
    }
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeDiagnosticsObject(obj) {
    if (typeof obj !== 'object' || obj == null || Array.isArray(obj)) {
      return {};
    } else {
      return obj;
    }
  }

  function ___$romejs$diagnostics$src$normalize_ts$normalizeDiagnostic(rawDiagnostic, opts) {
    const diagnostic = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeDiagnosticsObject(rawDiagnostic);

    const filename = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeFilename(
    ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(diagnostic.filename),
    opts);
    const advice = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeDiagnosticAdvice(diagnostic.advice, opts);
    const origins = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOrigins(diagnostic.origins);

    const start = ___$romejs$diagnostics$src$normalize_ts$normalizePosition(diagnostic.start);
    const end = ___$romejs$diagnostics$src$normalize_ts$normalizePosition(diagnostic.end);

    const fixable = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeBoolean(diagnostic.fixable, false);
    const code = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(diagnostic.code);
    const language = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeLanguage(diagnostic.language);
    const category = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeString(diagnostic.category, 'unknown');
    const message = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeString(diagnostic.message, 'No message provided');
    const marker = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(diagnostic.marker);

    return {
      category: category,
      message: message,
      origins: origins,
      marker: marker,
      language: language,
      code: code,
      fixable: fixable,
      advice: advice,
      filename: filename,
      start: start,
      end: end};
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOrigins(value) {
    if (Array.isArray(value)) {
      return value.map(str => {
        if (typeof str === 'string') {
          return str;
        } else {
          return 'Unknown origin';
        }
      });
    } else {
      return [];
    }
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceStackFrame(value, opts) {
    return {
      prefix: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(value.prefix),
      suffix: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(value.suffix),
      object: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(value.object),
      property: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(value.property),
      filename: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeFilename(___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(value.filename), opts),
      line: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalNumber(value.line),
      column: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalNumber(value.column),
      code: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(value.code),
      language: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeLanguage(value.language)};
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceStackFrames(value, opts) {
    if (Array.isArray(value)) {
      return value.map(item => ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceStackFrame(item, opts));
    } else {
      return [];
    }
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeDiagnosticAdvice(value, opts) {
    if (Array.isArray(value)) {
      return value.map(item => ___$romejs$diagnostics$src$normalize_ts$normalizeDiagnosticAdviceItem(item, opts));
    } else {
      return [];
    }
  }

  function ___$romejs$diagnostics$src$normalize_ts$normalizeDiagnosticAdviceItem(rawPart, opts) {
    const part = ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeDiagnosticsObject(rawPart);

    if (typeof part.type !== 'string') {
      return {
        type: 'log',
        category: 'error',
        message: `Unsupported diagnostics part with no type`,
        compact: false};
    }

    switch (part.type) {
      case 'log':
        return {
          type: 'log',
          category: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeLogCategory(part.category),
          message: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeString(part.message, 'No message provided'),
          compact: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeBoolean(part.compact, false)};

      case 'list':
        return {
          type: 'list',
          list: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeStringArray(part.list)};

      case 'ordered-list':
        return {
          type: 'ordered-list',
          reverse: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeBoolean(part.reverse, false),
          list: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeStringArray(part.list)};

      case 'code':
        return {
          type: 'code',
          code: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeString(part.code, ''),
          language: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeLanguage(part.language)};

      case 'frame':
        return {
          type: 'frame',
          language: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeLanguage(part.language),
          code: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(part.code),
          marker: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(part.marker),
          filename: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeFilename(
          ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(part.filename),
          opts),
          start: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizePositionAssert(part.start),
          end: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizePositionAssert(part.end)};

      case 'diff':
        return {
          type: 'diff',
          diff: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceDiff(part.diff)};

      case 'action':
        return {
          type: 'action',
          message: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeString(part.message, 'No message provided'),
          cancelable: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeBoolean(part.cancelable, false),
          buttons: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceActionButtons(part.buttons)};

      case 'stacktrace':
        return {
          type: 'stacktrace',
          title: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeOptionalString(part.title),
          frames: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceStackFrames(part.frames, opts)};

      case 'inspect':
        return {
          type: 'inspect',
          data: part.data};

      default:
        return {
          type: 'log',
          category: 'error',
          message: `Unsupported diagnostics part ${part.type}`,
          compact: false};}
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceDiffEntry([op, text]) {
    if (typeof text === 'string' && (op === -1 || op === 0 || op === 1)) {
      return [op, text];
    } else {
      return [0, ''];
    }
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceDiff(value) {
    if (Array.isArray(value)) {
      return value.map(item => {
        if (Array.isArray(item)) {
          return ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceDiffEntry(item);
        } else {
          return ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceDiffEntry([]);
        }
      });
    } else {
      return [];
    }
  }

  function ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeAdviceActionButtons(value) {
    if (Array.isArray(value)) {
      return value.map(item => {
        if (typeof item !== 'object' || item == null) {
          item = {};
        }

        return {
          text: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeString(item.text, 'No text provided'),
          command: ___$$priv$romejs$diagnostics$src$normalize_ts$normalizeString(item.command, '')};
      });
    } else {
      return [];
    }
  }

  // romejs/codec-source-map/src/base64.ts

  const ___$$priv$romejs$codec_source_map$src$base64_ts$intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(
  '');

  function ___$romejs$codec_source_map$src$base64_ts$encode(number) {
    if (0 <= number && number < ___$$priv$romejs$codec_source_map$src$base64_ts$intToCharMap.length) {
      return ___$$priv$romejs$codec_source_map$src$base64_ts$intToCharMap[number];
    } else {
      throw new TypeError('Must be between 0 and 63: ' + number);
    }
  }

  const ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_BASE_SHIFT = 5;

  const ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_BASE = 1 << ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_BASE_SHIFT;

  const ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_BASE_MASK = ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_BASE - 1;

  const ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_CONTINUATION_BIT = ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_BASE;

  function ___$$priv$romejs$codec_source_map$src$base64_ts$toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }

  function ___$$priv$romejs$codec_source_map$src$base64_ts$fromVLQSigned(value) {
    const isNegative = (value & 1) === 1;
    const shifted = value >> 1;
    return isNegative ? -shifted : shifted;
  }

  function ___$romejs$codec_source_map$src$base64_ts$encodeVLQ(value) {
    let encoded = '';
    let vlq = ___$$priv$romejs$codec_source_map$src$base64_ts$toVLQSigned(value);

    do {
      let digit = vlq & ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_BASE_MASK;
      vlq >>>= ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_CONTINUATION_BIT;
      }
      encoded += ___$romejs$codec_source_map$src$base64_ts$encode(digit);
    } while (vlq > 0);

    return encoded;
  }

  function ___$romejs$codec_source_map$src$base64_ts$decode(charCode) {
    var bigA = 65;
    var bigZ = 90;

    var littleA = 97;
    var littleZ = 122;

    var zero = 48;
    var nine = 57;

    var plus = 43;
    var slash = 47;

    var littleOffset = 26;
    var numberOffset = 52;

    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }

    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }

    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    if (charCode === plus) {
      return 62;
    }

    if (charCode === slash) {
      return 63;
    }

    return -1;
  }

  function ___$romejs$codec_source_map$src$base64_ts$decodeVLQ(aStr, aIndex) {
    let strLen = aStr.length;
    let result = 0;
    let shift = 0;
    let continuation = false;
    let digit;

    do {
      if (aIndex >= strLen) {
        throw new Error('Expected more digits in base 64 VLQ value.');
      }

      digit = ___$romejs$codec_source_map$src$base64_ts$decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error('Invalid base64 digit: ' + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_CONTINUATION_BIT);
      digit &= ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += ___$$priv$romejs$codec_source_map$src$base64_ts$VLQ_BASE_SHIFT;
    } while (continuation);

    return [___$$priv$romejs$codec_source_map$src$base64_ts$fromVLQSigned(result), aIndex];
  }

  // romejs/codec-source-map/src/util.ts

  function ___$$priv$romejs$codec_source_map$src$util_ts$strcmp(a, b) {
    if (a === b) {
      return 0;
    }

    if (a === undefined) {
      return 1;
    }

    if (b === undefined) {
      return -1;
    }

    if (a > b) {
      return 1;
    }

    return -1;
  }

  function ___$romejs$codec_source_map$src$util_ts$compareByGeneratedPositionsInflated(mappingA, mappingB) {
    let cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = ___$$priv$romejs$codec_source_map$src$util_ts$strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return ___$$priv$romejs$codec_source_map$src$util_ts$strcmp(mappingA.name, mappingB.name);
  }

  function ___$romejs$codec_source_map$src$util_ts$toRelativeUrl(root, path) {
    if (root === '') {
      root = '.';
    }

    root = root.replace(/\/$/, '');

    let level = 0;
    while (path.indexOf(root + '/') !== 0) {
      const index = root.lastIndexOf('/');
      if (index < 0) {
        return path;
      }

      root = root.slice(0, index);
      if (root.match(/^([^\/]+:\/)?\/*$/)) {
        return path;
      }

      ++level;
    }

    return Array(level + 1).join('../') + path.substr(root.length + 1);
  }

  // romejs/codec-source-map/src/ArraySet.ts

  class ___$romejs$codec_source_map$src$ArraySet_ts$default {
    constructor() {
      this.array = [];
      this.set = new Map();
    }

    static fromArray(array, allowDuplicates) {
      const set = new ___$romejs$codec_source_map$src$ArraySet_ts$default();
      for (const item of array) {
        set.add(item, allowDuplicates);
      }
      return set;
    }

    add(str, allowDuplicates) {
      const isDuplicate = this.has(str);
      const idx = this.array.length;

      if (isDuplicate === false || allowDuplicates === true) {
        this.array.push(str);
      }

      if (isDuplicate === false) {
        this.set.set(str, idx);
      }
    }

    has(str) {
      return this.set.has(str);
    }

    indexOf(str) {
      const idx = this.set.get(str);
      if (idx === undefined || idx < 0) {
        throw new Error(`${str} is not in the set`);
      }
      return idx;
    }

    at(idx) {
      if (idx >= 0 && idx < this.array.length) {
        return this.array[idx];
      } else {
        throw new Error('No element indexed by ' + idx);
      }
    }

    toArray() {
      return this.array.slice();
    }
  }

  // romejs/codec-source-map/src/MappingList.ts

  function ___$$priv$romejs$codec_source_map$src$MappingList_ts$generatedPositionAfter(mappingA, mappingB) {
    const lineA = mappingA.generatedLine;
    const lineB = mappingB.generatedLine;
    const columnA = mappingA.generatedColumn;
    const columnB = mappingB.generatedColumn;
    return lineB > lineA ||
    lineB == lineA && columnB >= columnA ||
    ___$romejs$codec_source_map$src$util_ts$compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  class ___$romejs$codec_source_map$src$MappingList_ts$default {
    constructor() {
      this.array = [];
      this.sorted = true;
      this.last = {
        generatedLine: -1,
        generatedColumn: 0,
        originalLine: -1,
        originalColumn: 0};
    }

    add(mapping) {
      if (___$$priv$romejs$codec_source_map$src$MappingList_ts$generatedPositionAfter(this.last, mapping)) {
        this.last = mapping;
        this.array.push(mapping);
      } else {
        this.sorted = false;
        this.array.push(mapping);
      }
    }

    toArray() {
      if (this.sorted === false) {
        this.array.sort(___$romejs$codec_source_map$src$util_ts$compareByGeneratedPositionsInflated);
        this.sorted = true;
      }
      return this.array;
    }
  }

  // romejs/refinement/src/index.ts

  function ___$romejs$refinement$src$index_ts$isPlainObject(obj) {
    return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
  }

  function ___$romejs$refinement$src$index_ts$isIterable(obj) {
    return typeof obj === 'object' &&
    obj != null &&
    typeof obj[Symbol.iterator] === 'function';
  }

  // romejs/string-ansi/src/regex.ts

  const ___$romejs$string_ansi$src$regex_ts = {
    get pattern() {
      return ___$romejs$string_ansi$src$regex_ts$pattern;
    },
    get regex() {
      return ___$romejs$string_ansi$src$regex_ts$regex;
    },
    get colorRegex() {
      return ___$romejs$string_ansi$src$regex_ts$colorRegex;
    }};
  const ___$romejs$string_ansi$src$regex_ts$pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');

  const ___$romejs$string_ansi$src$regex_ts$regex = new RegExp(___$romejs$string_ansi$src$regex_ts$pattern, 'g');

  const ___$romejs$string_ansi$src$regex_ts$colorRegex = /\u001b\[[3-9][0-9]m/g;

  // romejs/string-ansi/src/format.ts

  const ___$romejs$string_ansi$src$format_ts = {
    get formatAnsi() {
      return ___$romejs$string_ansi$src$format_ts$formatAnsi;
    },
    stripAnsi: ___$romejs$string_ansi$src$format_ts$stripAnsi,
    hasAnsiColor: ___$romejs$string_ansi$src$format_ts$hasAnsiColor,
    hasAnsi: ___$romejs$string_ansi$src$format_ts$hasAnsi};
  function ___$$priv$romejs$string_ansi$src$format_ts$createEscape(num) {
    return `\u001b[${String(num)}m`;
  }

  const ___$romejs$string_ansi$src$format_ts$formatAnsi = {
    reset(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(0) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(0);
    },

    fileHyperlink(name, filename) {
      let href = `file://`;
      const {HOSTNAME: HOSTNAME} = process.env;
      if (HOSTNAME != null) {
        href += `${HOSTNAME}/`;
      }
      href += filename;
      return ___$romejs$string_ansi$src$format_ts$formatAnsi.hyperlink(name, href);
    },

    hyperlink(name, href) {
      return `\u001b]8;;${href}\u0007${name}\u001b]8;;\u0007`;
    },

    rgb(str, color) {
      return `\u001b[38;2;${String(color.r)};${String(color.g)};${String(color.b)}m` +
      str +
      ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    bgRgb(str, color) {
      return `\u001b[48;2;${String(color.r)};${String(color.g)};${String(color.b)}m` +
      str +
      ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bold(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(1) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(22);
    },

    dim(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(2) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(22);
    },

    italic(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(3) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(23);
    },

    underline(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(4) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(24);
    },

    inverse(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(7) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(27);
    },

    hidden(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(8) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(28);
    },

    strikethrough(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(9) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(29);
    },

    black(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(30) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    brightBlack(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(90) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    red(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(31) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    brightRed(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(91) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    green(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(32) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    brightGreen(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(92) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    yellow(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(33) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    brightYellow(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(93) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    blue(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(34) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    brightBlue(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(94) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    magenta(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(35) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    brightMagenta(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(95) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    cyan(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(36) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    brightCyan(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(96) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    white(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(37) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    brightWhite(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(97) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(39);
    },

    bgBlack(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(40) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgBrightBlack(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(100) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgRed(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(41) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgBrightRed(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(101) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgGreen(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(42) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgBrightGreen(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(102) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgYellow(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(43) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgBrightYellow(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(103) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgBlue(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(44) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgBrightBlue(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(104) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgMagenta(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(45) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgBrightMagenta(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(105) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgCyan(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(46) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgBrightCyan(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(106) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgWhite(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(47) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    },

    bgBrightWhite(str) {
      return ___$$priv$romejs$string_ansi$src$format_ts$createEscape(107) + str + ___$$priv$romejs$string_ansi$src$format_ts$createEscape(49);
    }};

  function ___$romejs$string_ansi$src$format_ts$stripAnsi(str) {
    return str.replace(___$romejs$string_ansi$src$regex_ts$regex, '');
  }

  function ___$romejs$string_ansi$src$format_ts$hasAnsiColor(str) {
    return ___$romejs$string_ansi$src$regex_ts$colorRegex.test(str);
  }

  function ___$romejs$string_ansi$src$format_ts$hasAnsi(str) {
    return ___$romejs$string_ansi$src$regex_ts$regex.test(str);
  }

  // romejs/string-ansi/src/pad.ts

  const ___$romejs$string_ansi$src$pad_ts = {
    pad: ___$romejs$string_ansi$src$pad_ts$pad,
    rightPad: ___$romejs$string_ansi$src$pad_ts$rightPad,
    leftPad: ___$romejs$string_ansi$src$pad_ts$leftPad};
  const ___$$priv$romejs$string_ansi$src$pad_ts$DEFAULT_SPACER = ' ';

  function ___$romejs$string_ansi$src$pad_ts$pad(side, str, len, spacerChar = ___$$priv$romejs$string_ansi$src$pad_ts$DEFAULT_SPACER) {
    ___$romejs$invariant$src$index_ts$default(
    side === 'left' || side === 'right',
    'Expected side to be left or right but got',
    side);

    const stripped = ___$romejs$string_ansi$src$format_ts$stripAnsi(str);
    const remainder = len - stripped.length;

    if (remainder <= 0) {
      return str;
    }

    const spacer = spacerChar.repeat(remainder);
    if (side === 'left') {
      return spacer + str;
    } else {
      return str + spacer;
    }
  }

  function ___$romejs$string_ansi$src$pad_ts$rightPad(str, len, spacer = ___$$priv$romejs$string_ansi$src$pad_ts$DEFAULT_SPACER) {
    return ___$romejs$string_ansi$src$pad_ts$pad('right', str, len, spacer);
  }

  function ___$romejs$string_ansi$src$pad_ts$leftPad(str, len, spacer = ___$$priv$romejs$string_ansi$src$pad_ts$DEFAULT_SPACER) {
    return ___$romejs$string_ansi$src$pad_ts$pad('left', str, len, spacer);
  }

  // romejs/string-ansi/src/escapes.ts

  const ___$romejs$string_ansi$src$escapes_ts = {
    get escapes() {
      return ___$romejs$string_ansi$src$escapes_ts$escapes;
    }};
  const ___$romejs$string_ansi$src$escapes_ts$escapes = {
    clearScreen: '\x1bc'};

  // romejs/string-ansi/src/split.ts

  const ___$romejs$string_ansi$src$split_ts = {
    splitAnsiLines: ___$romejs$string_ansi$src$split_ts$splitAnsiLines};
  const ___$$priv$romejs$string_ansi$src$split_ts$startRegex = new RegExp(`^${___$romejs$string_ansi$src$regex_ts$pattern}`);

  function ___$romejs$string_ansi$src$split_ts$splitAnsiLines(input, maxWidth) {
    const lines = [];

    let column = 0;
    let buff = '';

    function pushLine() {
      lines.push(buff);
      column = 0;
      buff = '';
    }

    let index = 0;

    while (index < input.length) {
      const char = input[index];

      if (char === '\x1b' || char === '\x9b') {
        const match = input.slice(index).match(___$$priv$romejs$string_ansi$src$split_ts$startRegex);
        if (match != null) {
          const str = match[0];
          buff += str;
          index += str.length;
          continue;
        }
      }

      if (char === ' ' && column === 0) {
        index++;
        continue;
      }

      if (char === '\n') {
        pushLine();
        index++;
        continue;
      }

      let word = char;
      for (let i = index + 1; i < input.length && input[i] !== ' '; i++) {
        word += input[i];
      }

      const wordLength = ___$romejs$string_ansi$src$format_ts$stripAnsi(word).length;

      let pushedLine = false;
      if (column + wordLength > maxWidth) {
        pushLine();
        pushedLine = true;
      }

      column += wordLength;
      buff += pushedLine ? word.trimLeft() : word;
      index += word.length;
    }

    if (buff !== '') {
      pushLine();
    }

    return lines;
  }

  // romejs/string-ansi/src/index.ts


  // romejs/string-escape/src/messages.ts

  const ___$romejs$string_escape$src$messages_ts = {
    get NOT_ENOUGH_CODE_POINTS() {
      return ___$romejs$string_escape$src$messages_ts$NOT_ENOUGH_CODE_POINTS;
    },
    get INVALID_STRING_CHARACTER() {
      return ___$romejs$string_escape$src$messages_ts$INVALID_STRING_CHARACTER;
    },
    get INVALID_HEX_DIGIT_FOR_ESCAPE() {
      return ___$romejs$string_escape$src$messages_ts$INVALID_HEX_DIGIT_FOR_ESCAPE;
    }};
  const ___$romejs$string_escape$src$messages_ts$NOT_ENOUGH_CODE_POINTS = 'Not enough code point digits';
  const ___$romejs$string_escape$src$messages_ts$INVALID_STRING_CHARACTER = 'Invalid string character (U+0000 to U+001F)';
  const ___$romejs$string_escape$src$messages_ts$INVALID_HEX_DIGIT_FOR_ESCAPE = 'Invalid hex digit for unicode escape';

  // romejs/string-escape/src/constants.ts

  const ___$romejs$string_escape$src$constants_ts = {
    get DOUBLE_QUOTE() {
      return ___$romejs$string_escape$src$constants_ts$DOUBLE_QUOTE;
    },
    get SINGLE_QUOTE() {
      return ___$romejs$string_escape$src$constants_ts$SINGLE_QUOTE;
    },
    get TICK_QUOTE() {
      return ___$romejs$string_escape$src$constants_ts$TICK_QUOTE;
    }};
  const ___$romejs$string_escape$src$constants_ts$DOUBLE_QUOTE = '"';
  const ___$romejs$string_escape$src$constants_ts$SINGLE_QUOTE = '\'';
  const ___$romejs$string_escape$src$constants_ts$TICK_QUOTE = '`';

  // romejs/string-escape/src/escapeString.ts

  const ___$$priv$romejs$string_escape$src$escapeString_ts$PRINTABLE_ASCII = /[ !#-&\(-\[\]-_a-~]/;

  function ___$$priv$romejs$string_escape$src$escapeString_ts$escapeChar(char, ignoreWhitespaceEscapes) {
    switch (char) {
      case '"':
        return '\\"';

      case '\'':
        return '\\\'';

      case '\b':
        return '\\b';

      case '\f':
        return '\\f';

      case '\\':
        return '\\\\';}

    if (ignoreWhitespaceEscapes) {
      return undefined;
    }

    switch (char) {
      case '\n':
        return '\\n';

      case '\r':
        return '\\r';

      case '\t':
        return '\\t';}

    return undefined;
  }

  function ___$romejs$string_escape$src$escapeString_ts$default(str, opts = {}) {
    let index = -1;
    let result = '';

    const quote = opts.quote === undefined ? ___$romejs$string_escape$src$constants_ts$DOUBLE_QUOTE : opts.quote;
    const isJSON = opts.json === undefined ? false : opts.json;
    const ignoreEscapes = opts.ignoreWhitespaceEscapes === undefined ? false : true;

    while (++index < str.length) {
      const char = str[index];

      if (isJSON === false) {
        const charCode = str.charCodeAt(index);
        const isHighSurrogate = charCode >= 55296 && charCode <= 56319;
        const hasNextCodePoint = str.length > index + 1;
        const isSurrogatePairStart = isHighSurrogate && hasNextCodePoint;

        if (isSurrogatePairStart) {
          const nextCharCode = str.charCodeAt(index + 1);
          const isLowSurrogate = nextCharCode >= 56320 && nextCharCode <= 57343;
          if (isLowSurrogate) {
            const codePoint = (charCode - 55296) * 1024 + nextCharCode - 56320 + 65536;
            const hex = codePoint.toString(16);
            result += '\\u{' + hex + '}';
            index++;
            continue;
          }
        }
      }

      if (___$$priv$romejs$string_escape$src$escapeString_ts$PRINTABLE_ASCII.test(char)) {
        result += char;
        continue;
      }

      if (char == ___$romejs$string_escape$src$constants_ts$DOUBLE_QUOTE) {
        result += quote == char ? '\\"' : char;
        continue;
      }

      if (char == ___$romejs$string_escape$src$constants_ts$SINGLE_QUOTE) {
        result += quote == char ? '\\\'' : char;
        continue;
      }

      if (char == ___$romejs$string_escape$src$constants_ts$TICK_QUOTE) {
        result += quote == char ? '\\`' : char;
        continue;
      }

      if (char == '\0' && !isJSON && !___$romejs$parser_core$src$index_ts$isDigit(str[index + 1])) {
        result += '\\0';
        continue;
      }

      const replacement = ___$$priv$romejs$string_escape$src$escapeString_ts$escapeChar(char, ignoreEscapes);
      if (replacement !== undefined) {
        result += replacement;
        continue;
      }

      const hex = char.charCodeAt(0).toString(16);
      const isLonghand = isJSON || hex.length > 2;
      const modifier = isLonghand ? 'u' : 'x';
      const code = ('0000' + hex).slice(isLonghand ? -4 : -2);
      const escaped = '\\' + modifier + code;
      result += escaped;
      continue;
    }

    return quote + result + quote;
  }

  // romejs/string-escape/src/unescapeString.ts

  function ___$$priv$romejs$string_escape$src$unescapeString_ts$unescapeChar(modifier) {
    switch (modifier) {
      case 'b':
        return '\b';

      case 'f':
        return '\f';

      case 'n':
        return '\n';

      case 'r':
        return '\r';

      case 't':
        return '\t';

      case 'v':
        return '\x0b';

      default:
        return modifier;}
  }

  const ___$$priv$romejs$string_escape$src$unescapeString_ts$UNEXPECTED_DEFAULT_THROWER = (message, index) => {
    throw new TypeError(`${message} (${String(index)})`);
  };

  function ___$romejs$string_escape$src$unescapeString_ts$default(input, unexpected = ___$$priv$romejs$string_escape$src$unescapeString_ts$UNEXPECTED_DEFAULT_THROWER) {
    let buffer = '';

    let index = 0;

    while (index < input.length) {
      const char = input[index];
      const prevChar = input[index - 1];
      const prevPrevChar = input[index - 2];
      const isEscaped = prevChar === '\\' && prevPrevChar !== '\\';

      if (isEscaped && char === '\\' || char !== '\\') {
        const codePoint = char.codePointAt(0);
        if (codePoint === undefined) {
          throw new Error('Already validated that this index exists');
        }
        if (codePoint >= 0 && codePoint <= 31) {
          throw unexpected(___$romejs$string_escape$src$messages_ts$INVALID_STRING_CHARACTER, index);
        }

        buffer += char;
        index++;
        continue;
      }

      const modifierIndex = index + 1;
      const modifier = input[modifierIndex];

      if (modifier === 'u') {
        const codeStartIndex = modifierIndex + 1;
        const rawCode = input.slice(codeStartIndex, codeStartIndex + 4);

        if (rawCode.length < 4) {
          const lastDigitIndex = codeStartIndex + rawCode.length - 1;
          throw unexpected(___$romejs$string_escape$src$messages_ts$NOT_ENOUGH_CODE_POINTS, lastDigitIndex);
        }

        for (let i = 0; i < rawCode.length; i++) {
          const char = rawCode[i];
          if (!___$romejs$parser_core$src$index_ts$isHexDigit(char)) {
            const pos = codeStartIndex + i;
            throw unexpected(___$romejs$string_escape$src$messages_ts$INVALID_HEX_DIGIT_FOR_ESCAPE, pos);
          }
        }

        const code = parseInt(rawCode, 16);

        buffer += String.fromCodePoint(code);

        index += 6;
      } else {
        buffer += ___$$priv$romejs$string_escape$src$unescapeString_ts$unescapeChar(modifier);

        index += 2;
      }
    }

    return buffer;
  }

  // romejs/string-escape/src/index.ts

  const ___$romejs$string_escape$src$index_ts$messages = ___$romejs$string_escape$src$messages_ts;

  // romejs/string-utils/src/orderBySimilarity.ts

  const ___$romejs$string_utils$src$orderBySimilarity_ts = {
    orderBySimilarity: ___$romejs$string_utils$src$orderBySimilarity_ts$orderBySimilarity};
  function ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$compareTwoStrings(a, b) {
    let result;

    result = ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$calculateResultIfIdentical(a, b);
    if (result !== undefined) {
      return result;
    }

    result = ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$calculateResultIfEitherIsEmpty(a, b);
    if (result !== undefined) {
      return result;
    }

    result = ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$calculateResultIfBothAreSingleCharacter(a, b);
    if (result !== undefined) {
      return result;
    }

    const pairs1 = ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$wordLetterPairs(a.toUpperCase());
    const pairs2 = ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$wordLetterPairs(b.toUpperCase());
    const union = pairs1.length + pairs2.length;
    let intersection = 0;

    for (const pair1 of pairs1) {
      for (let i = 0; i < pairs2.length; i++) {
        const pair2 = pairs2[i];
        if (pair1 === pair2) {
          intersection++;
          pairs2.splice(i, 1);
          break;
        }
      }
    }

    return 2 * intersection / union;
  }

  function ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$letterPairs(str) {
    const numPairs = str.length - 1;
    const pairs = [];
    for (let i = 0; i < numPairs; i++) {
      pairs[i] = str.substring(i, i + 2);
    }
    return pairs;
  }

  function ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$wordLetterPairs(str) {
    let pairs = [];

    const words = str.split(' ');
    for (const word of words) {
      pairs = pairs.concat(___$$priv$romejs$string_utils$src$orderBySimilarity_ts$letterPairs(word));
    }

    return pairs;
  }

  function ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$calculateResultIfIdentical(a, b) {
    if (a.toUpperCase() == b.toUpperCase()) {
      return 1;
    }

    return undefined;
  }

  function ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$calculateResultIfBothAreSingleCharacter(a, b) {
    if (a.length == 1 && b.length == 1) {
      return 0;
    }
  }

  function ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$calculateResultIfEitherIsEmpty(a, b) {
    if (a.length == 0 && b.length == 0) {
      return 1;
    }

    if (a.length + b.length > 0 && a.length * b.length == 0) {
      return 0;
    }

    return undefined;
  }

  function ___$romejs$string_utils$src$orderBySimilarity_ts$orderBySimilarity(compareStr, targets) {
    ___$romejs$invariant$src$index_ts$default(targets.length > 0, 'At least 1 target string is required');

    const ratings = targets.map(
    target => {
      return {
        target: target,
        rating: ___$$priv$romejs$string_utils$src$orderBySimilarity_ts$compareTwoStrings(compareStr, target)};
    });

    const sortedRatings = ratings.sort((a, b) => {
      return b.rating - a.rating;
    });

    return sortedRatings;
  }

  // romejs/string-charcodes/src/index.ts

  const ___$romejs$string_charcodes$src$index_ts$backSpace = 8;
  const ___$romejs$string_charcodes$src$index_ts$tab = 9;
  const ___$romejs$string_charcodes$src$index_ts$lineFeed = 10;
  const ___$romejs$string_charcodes$src$index_ts$carriageReturn = 13;
  const ___$romejs$string_charcodes$src$index_ts$shiftOut = 14;
  const ___$romejs$string_charcodes$src$index_ts$space = 32;
  const ___$romejs$string_charcodes$src$index_ts$exclamationMark = 33;
  const ___$romejs$string_charcodes$src$index_ts$quotationMark = 34;
  const ___$romejs$string_charcodes$src$index_ts$numberSign = 35;
  const ___$romejs$string_charcodes$src$index_ts$dollarSign = 36;
  const ___$romejs$string_charcodes$src$index_ts$percentSign = 37;
  const ___$romejs$string_charcodes$src$index_ts$ampersand = 38;
  const ___$romejs$string_charcodes$src$index_ts$apostrophe = 39;
  const ___$romejs$string_charcodes$src$index_ts$leftParenthesis = 40;
  const ___$romejs$string_charcodes$src$index_ts$rightParenthesis = 41;
  const ___$romejs$string_charcodes$src$index_ts$asterisk = 42;
  const ___$romejs$string_charcodes$src$index_ts$plusSign = 43;
  const ___$romejs$string_charcodes$src$index_ts$comma = 44;
  const ___$romejs$string_charcodes$src$index_ts$dash = 45;
  const ___$romejs$string_charcodes$src$index_ts$dot = 46;
  const ___$romejs$string_charcodes$src$index_ts$slash = 47;
  const ___$romejs$string_charcodes$src$index_ts$digit0 = 48;
  const ___$romejs$string_charcodes$src$index_ts$digit1 = 49;
  const ___$romejs$string_charcodes$src$index_ts$digit2 = 50;
  const ___$romejs$string_charcodes$src$index_ts$digit3 = 51;
  const ___$romejs$string_charcodes$src$index_ts$digit4 = 52;
  const ___$romejs$string_charcodes$src$index_ts$digit5 = 53;
  const ___$romejs$string_charcodes$src$index_ts$digit6 = 54;
  const ___$romejs$string_charcodes$src$index_ts$digit7 = 55;
  const ___$romejs$string_charcodes$src$index_ts$digit8 = 56;
  const ___$romejs$string_charcodes$src$index_ts$digit9 = 57;
  const ___$romejs$string_charcodes$src$index_ts$colon = 58;
  const ___$romejs$string_charcodes$src$index_ts$semicolon = 59;
  const ___$romejs$string_charcodes$src$index_ts$lessThan = 60;
  const ___$romejs$string_charcodes$src$index_ts$equalsTo = 61;
  const ___$romejs$string_charcodes$src$index_ts$greaterThan = 62;
  const ___$romejs$string_charcodes$src$index_ts$questionMark = 63;
  const ___$romejs$string_charcodes$src$index_ts$atSign = 64;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseA = 65;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseB = 66;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseC = 67;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseD = 68;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseE = 69;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseF = 70;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseG = 71;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseH = 72;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseI = 73;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseJ = 74;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseK = 75;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseL = 76;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseM = 77;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseN = 78;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseO = 79;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseP = 80;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseQ = 81;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseR = 82;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseS = 83;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseT = 84;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseU = 85;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseV = 86;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseW = 87;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseX = 88;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseY = 89;
  const ___$romejs$string_charcodes$src$index_ts$uppercaseZ = 90;
  const ___$romejs$string_charcodes$src$index_ts$leftSquareBracket = 91;
  const ___$romejs$string_charcodes$src$index_ts$backslash = 92;
  const ___$romejs$string_charcodes$src$index_ts$rightSquareBracket = 93;
  const ___$romejs$string_charcodes$src$index_ts$caret = 94;
  const ___$romejs$string_charcodes$src$index_ts$underscore = 95;
  const ___$romejs$string_charcodes$src$index_ts$graveAccent = 96;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseA = 97;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseB = 98;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseC = 99;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseD = 100;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseE = 101;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseF = 102;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseG = 103;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseH = 104;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseI = 105;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseJ = 106;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseK = 107;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseL = 108;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseM = 109;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseN = 110;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseO = 111;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseP = 112;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseQ = 113;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseR = 114;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseS = 115;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseT = 116;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseU = 117;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseV = 118;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseW = 119;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseX = 120;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseY = 121;
  const ___$romejs$string_charcodes$src$index_ts$lowercaseZ = 122;
  const ___$romejs$string_charcodes$src$index_ts$leftCurlyBrace = 123;
  const ___$romejs$string_charcodes$src$index_ts$verticalBar = 124;
  const ___$romejs$string_charcodes$src$index_ts$rightCurlyBrace = 125;
  const ___$romejs$string_charcodes$src$index_ts$tilde = 126;
  const ___$romejs$string_charcodes$src$index_ts$nonBreakingSpace = 160;
  const ___$romejs$string_charcodes$src$index_ts$oghamSpaceMark = 5760;
  const ___$romejs$string_charcodes$src$index_ts$lineSeparator = 8232;
  const ___$romejs$string_charcodes$src$index_ts$paragraphSeparator = 8233;

  function ___$romejs$string_charcodes$src$index_ts$isDigit(code) {
    return code >= ___$romejs$string_charcodes$src$index_ts$digit0 && code <= ___$romejs$string_charcodes$src$index_ts$digit9;
  }

  // romejs/string-utils/src/naturalCompare.ts

  const ___$romejs$string_utils$src$naturalCompare_ts = {
    naturalCompare: ___$romejs$string_utils$src$naturalCompare_ts$naturalCompare};
  function ___$romejs$string_utils$src$naturalCompare_ts$naturalCompare(a, b, insensitive = true) {
    if (insensitive) {
      a = a.toLowerCase();
      b = b.toLowerCase();
    }

    const lengthA = a.length;
    const lengthB = b.length;

    let aIndex = 0;
    let bIndex = 0;

    while (aIndex < lengthA && bIndex < lengthB) {
      let charCodeA = a.charCodeAt(aIndex);
      let charCodeB = b.charCodeAt(bIndex);

      if (___$romejs$string_charcodes$src$index_ts$isDigit(charCodeA)) {
        if (!___$romejs$string_charcodes$src$index_ts$isDigit(charCodeB)) {
          return charCodeA - charCodeB;
        }

        let numStartA = aIndex;
        let numStartB = bIndex;

        while (charCodeA === 48 && ++numStartA < lengthA) {
          charCodeA = a.charCodeAt(numStartA);
        }
        while (charCodeB === 48 && ++numStartB < lengthB) {
          charCodeB = b.charCodeAt(numStartB);
        }

        let numEndA = numStartA;
        let numEndB = numStartB;

        while (numEndA < lengthA && ___$romejs$string_charcodes$src$index_ts$isDigit(a.charCodeAt(numEndA))) {
          ++numEndA;
        }
        while (numEndB < lengthB && ___$romejs$string_charcodes$src$index_ts$isDigit(b.charCodeAt(numEndB))) {
          ++numEndB;
        }

        let difference = numEndA - numStartA - numEndB + numStartB;
        if (difference) {
          return difference;
        }

        while (numStartA < numEndA) {
          difference = a.charCodeAt(numStartA++) - b.charCodeAt(numStartB++);
          if (difference) {
            return difference;
          }
        }

        aIndex = numEndA;
        bIndex = numEndB;
        continue;
      }

      if (charCodeA !== charCodeB) {
        return charCodeA - charCodeB;
      }

      ++aIndex;
      ++bIndex;
    }

    return lengthA - lengthB;
  }

  // romejs/string-utils/src/humanizeNumber.ts

  const ___$romejs$string_utils$src$humanizeNumber_ts = {
    humanizeNumber: ___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber};
  function ___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(num, sep = '_') {
    if (num < 1000) {
      return String(num);
    }

    const decimals = String(num).split('.');

    let intChars = String(decimals.shift()).split('');
    let intParts = [];

    while (intChars.length > 0) {
      const part = intChars.slice(-3).join('');
      intParts.unshift(part);

      intChars = intChars.slice(0, -3);
    }

    return [intParts.join(sep), ...decimals].join('.');
  }

  // romejs/string-utils/src/humanizeTime.ts

  const ___$romejs$string_utils$src$humanizeTime_ts = {
    humanizeTime: ___$romejs$string_utils$src$humanizeTime_ts$humanizeTime};
  function ___$romejs$string_utils$src$humanizeTime_ts$humanizeTime(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    const h = Math.floor(m / 60);

    let buf = '';
    if (h > 0) {
      buf += `${String(h)}h`;
    }
    if (m > 0) {
      buf += `${String(m % 60)}m`;
    }
    buf += `${String(s % 60)}s`;
    return buf;
  }

  // romejs/string-utils/src/removeSuffix.ts

  const ___$romejs$string_utils$src$removeSuffix_ts = {
    removeSuffix: ___$romejs$string_utils$src$removeSuffix_ts$removeSuffix};
  function ___$romejs$string_utils$src$removeSuffix_ts$removeSuffix(value, suffix) {
    if (value.endsWith(suffix)) {
      return value.slice(0, -suffix.length);
    } else {
      return value;
    }
  }

  // romejs/string-utils/src/removePrefix.ts

  const ___$romejs$string_utils$src$removePrefix_ts = {
    removePrefix: ___$romejs$string_utils$src$removePrefix_ts$removePrefix};
  function ___$romejs$string_utils$src$removePrefix_ts$removePrefix(value, prefix) {
    if (value.startsWith(prefix)) {
      return value.slice(prefix.length);
    } else {
      return value;
    }
  }

  // romejs/string-utils/src/index.ts


  // romejs/pretty-format/src/index.ts

  const ___$$priv$romejs$pretty_format$src$index_ts$DEFAULT_OPTIONS = {
    color: false,
    indent: '',
    stack: [],
    compact: false};

  const ___$$priv$romejs$pretty_format$src$index_ts$INDENT = '  ';

  function ___$romejs$pretty_format$src$index_ts$default(obj, rawOpts = {}) {
    const opts = Object.assign({}, ___$$priv$romejs$pretty_format$src$index_ts$DEFAULT_OPTIONS, rawOpts);

    switch (typeof obj) {
      case 'symbol':
        {
          const val = ___$$priv$romejs$pretty_format$src$index_ts$formatSymbol(obj);
          return opts.color ? ___$romejs$string_ansi$src$format_ts$formatAnsi.green(val) : val;
        }

      case 'string':
        {
          const val = ___$$priv$romejs$pretty_format$src$index_ts$formatString(obj);
          return opts.color ? ___$romejs$string_ansi$src$format_ts$formatAnsi.green(val) : val;
        }

      case 'bigint':
      case 'number':
        {
          const val = ___$romejs$pretty_format$src$index_ts$formatNumber(obj);
          return opts.color ? ___$romejs$string_ansi$src$format_ts$formatAnsi.yellow(val) : val;
        }

      case 'boolean':
        {
          const val = ___$$priv$romejs$pretty_format$src$index_ts$formatBoolean(obj);
          return opts.color ? ___$romejs$string_ansi$src$format_ts$formatAnsi.yellow(val) : val;
        }

      case 'undefined':
        {
          const val = ___$$priv$romejs$pretty_format$src$index_ts$formatUndefined();
          return opts.color ? ___$romejs$string_ansi$src$format_ts$formatAnsi.brightBlack(val) : val;
        }

      case 'function':
        return ___$$priv$romejs$pretty_format$src$index_ts$formatFunction(obj, opts);

      case 'object':
        return ___$$priv$romejs$pretty_format$src$index_ts$formatObjectish(obj, opts);

      default:
        throw new Error('Unknown type');}
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$joinList(items, opts) {
    if (items.length === 0) {
      return '';
    }

    const lines = [];

    for (const item of items) {
      lines.push(`${opts.indent}${item}`);
    }

    return lines.join('\n');
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$isNativeFunction(val) {
    return val.toString().endsWith('{ [native code] }');
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatSymbol(val) {
    return String(val);
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatString(val) {
    return ___$romejs$string_escape$src$escapeString_ts$default(val);
  }

  function ___$romejs$pretty_format$src$index_ts$formatNumber(val) {
    if (typeof val === 'bigint') {
      return ___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(val, '_');
    } else if (isNaN(val)) {
      return 'NaN';
    } else if (Object.is(val, -0)) {
      return '-0';
    } else if (isFinite(val)) {
      return ___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(val, '_');
    } else if (Object.is(val, -Infinity)) {
      return '-Infinity';
    } else if (Object.is(val, +Infinity)) {
      return 'Infinity';
    } else {
      throw new Error('Don\'t know how to format this number');
    }
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatUndefined() {
    return 'undefined';
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatNull() {
    return 'null';
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatBoolean(val) {
    return val === true ? 'true' : 'false';
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatFunction(val, opts) {
    const name = val.name === '' ? 'anonymous' : val.name;
    let label = `Function ${name}`;

    if (___$$priv$romejs$pretty_format$src$index_ts$isNativeFunction(val)) {
      label = `Native` + label;
    }

    if (Object.keys(val).length === 0) {
      return label;
    }

    return ___$$priv$romejs$pretty_format$src$index_ts$formatObject(label, val, opts);
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$getExtraObjectProps(obj, opts) {
    const props = [];
    const ignoreKeys = {};

    if (obj instanceof Map) {
      for (const [key, val] of obj) {
        const formattedKey = typeof key === 'string' ? ___$$priv$romejs$pretty_format$src$index_ts$formatKey(key) : ___$romejs$pretty_format$src$index_ts$default(key, opts);
        props.push(`${formattedKey} => ${___$romejs$pretty_format$src$index_ts$default(val, opts)}`);
      }
    } else if (___$romejs$refinement$src$index_ts$isIterable(obj)) {
      let i = 0;
      for (const val of obj) {
        ignoreKeys[String(i++)] = val;
        props.push(`${___$romejs$pretty_format$src$index_ts$default(val, opts)}`);
      }
    }

    return {ignoreKeys: ignoreKeys, props: props};
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatKey(key) {
    if (/[^A-Za-z0-9_$]/g.test(key)) {
      return ___$$priv$romejs$pretty_format$src$index_ts$formatString(key);
    } else {
      return key;
    }
  }

  const ___$$priv$romejs$pretty_format$src$index_ts$PRIORITIZE_KEYS = ['id', 'name', 'key', 'value'];

  function ___$$priv$romejs$pretty_format$src$index_ts$sortKeys(obj) {
    const sortedKeys = new Set(Object.keys(obj).sort(___$romejs$string_utils$src$naturalCompare_ts$naturalCompare));

    const priorityKeys = [];
    const otherKeys = [];
    const objectKeys = [];

    for (const key of ___$$priv$romejs$pretty_format$src$index_ts$PRIORITIZE_KEYS) {
      if (sortedKeys.has(key)) {
        priorityKeys.push({key: key, object: false});
        sortedKeys.delete(key);
      }
    }

    for (const key of sortedKeys) {
      const val = obj[key];

      let isObject = false;
      if (typeof val === 'object' && val != null && Object.keys(val).length > 0) {
        isObject = true;
      }
      if (Array.isArray(val) && val.length > 0) {
        isObject = true;
      }
      if (isObject) {
        objectKeys.push({key: key, object: true});
      } else {
        otherKeys.push({key: key, object: false});
      }
    }

    return [...priorityKeys, ...otherKeys, ...objectKeys];
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$lineCount(str) {
    return str.split('\n').length;
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$lineCountCompare(a, b) {
    return ___$$priv$romejs$pretty_format$src$index_ts$lineCount(a) - ___$$priv$romejs$pretty_format$src$index_ts$lineCount(b);
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatObject(label, obj, opts) {
    const {stack: stack} = opts;
    if (stack.length > 0 && stack.includes(obj)) {
      label = `Circular ${label} ${stack.indexOf(obj)}`;
      return opts.color ? ___$romejs$string_ansi$src$format_ts$formatAnsi.cyan(label) : label;
    }

    const nextOpts = {
      stack: [...stack, obj],
      indent: opts.indent + ___$$priv$romejs$pretty_format$src$index_ts$INDENT,
      compact: opts.compact,
      color: opts.color};
    const {ignoreKeys: ignoreKeys, props: props} = ___$$priv$romejs$pretty_format$src$index_ts$getExtraObjectProps(obj, nextOpts);

    const objProps = [];

    for (const {key: key, object: object} of ___$$priv$romejs$pretty_format$src$index_ts$sortKeys(obj)) {
      const val = obj[key];
      if (key in ignoreKeys && ignoreKeys[key] === val) {
        continue;
      }

      if (opts.compact && val === undefined) {
        continue;
      }

      if (key === 'type' && val === label) {
        continue;
      }

      const prop = `${___$$priv$romejs$pretty_format$src$index_ts$formatKey(key)}: ${___$romejs$pretty_format$src$index_ts$default(val, nextOpts)}`;
      if (object) {
        objProps.push(prop);
      } else {
        props.push(prop);
      }
    }

    for (const prop of objProps.sort(___$$priv$romejs$pretty_format$src$index_ts$lineCountCompare)) {
      props.push(prop);
    }

    for (const sym of Object.getOwnPropertySymbols(obj)) {
      const val = obj[sym];
      props.push(`${___$romejs$pretty_format$src$index_ts$default(sym, opts)}: ${___$romejs$pretty_format$src$index_ts$default(val, nextOpts)}`);
    }

    let open = '{';
    let close = '}';
    if (___$romejs$refinement$src$index_ts$isIterable(obj)) {
      open = '[';
      close = ']';
    }

    let inner = ___$$priv$romejs$pretty_format$src$index_ts$joinList(props, nextOpts);
    if (inner !== '') {
      if (props.length === 1 && !inner.includes('\n')) {
        inner = inner.trim();
      } else {
        inner = `\n${inner}\n${opts.indent}`;
      }
    }

    label = opts.color ? ___$romejs$string_ansi$src$format_ts$formatAnsi.cyan(label) : label;
    return `${label} ${open}${inner}${close}`;
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatRegExp(val) {
    return String(val);
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatDate(val) {
    return val.toISOString();
  }

  function ___$$priv$romejs$pretty_format$src$index_ts$formatObjectish(val, opts) {
    if (val === null) {
      const val = ___$$priv$romejs$pretty_format$src$index_ts$formatNull();
      return opts.color ? ___$romejs$string_ansi$src$format_ts$formatAnsi.bold(val) : val;
    }

    if (val instanceof RegExp) {
      const str = ___$$priv$romejs$pretty_format$src$index_ts$formatRegExp(val);
      return opts.color ? ___$romejs$string_ansi$src$format_ts$formatAnsi.red(str) : str;
    }

    if (val instanceof Date) {
      const str = ___$$priv$romejs$pretty_format$src$index_ts$formatDate(val);
      return opts.color ? ___$romejs$string_ansi$src$format_ts$formatAnsi.magenta(str) : str;
    }

    let label = 'null';

    if (val.constructor !== undefined) {
      label = val.constructor.name;
    }

    if (typeof val.type === 'string') {
      label = val.type;
    }

    return ___$$priv$romejs$pretty_format$src$index_ts$formatObject(label, val, opts);
  }

  // romejs/invariant/src/index.ts

  const ___$$priv$romejs$invariant$src$index_ts$escapeMarkup = str => str;

  class ___$$priv$romejs$invariant$src$index_ts$InvariantError extends Error {
    constructor(message) {
      super(message);
      this.name = 'InvariantError';
      this.__ROME_POP_FRAMES__ = 1;
    }
  }

  function ___$romejs$invariant$src$index_ts$default(condition, rawMessage, ...args) {
    if (!condition) {
      const message = ___$romejs$invariant$src$index_ts$interpolateMessage(rawMessage, args);
      throw new ___$$priv$romejs$invariant$src$index_ts$InvariantError(message);
    }
  }

  function ___$romejs$invariant$src$index_ts$interpolateMessage(msg, args) {
    let argIndex = 0;

    let interpolated = msg.replace(/%s/g, () => ___$romejs$pretty_format$src$index_ts$default(args[argIndex++]));

    if (argIndex < args.length) {
      interpolated += ' ';
      interpolated += args.slice(argIndex).map(arg => ___$$priv$romejs$invariant$src$index_ts$escapeMarkup(___$romejs$pretty_format$src$index_ts$default(arg))).join(' ');
    }

    return interpolated;
  }

  // romejs/codec-source-map/src/SourceMapGenerator.ts

  class ___$romejs$codec_source_map$src$SourceMapGenerator_ts$default {
    constructor(args) {
      this.file = args.file;
      this.sourceRoot = args.sourceRoot;

      this.sourcesContents = new Map();
      this.map = undefined;
      this.sources = new ___$romejs$codec_source_map$src$ArraySet_ts$default();
      this.names = new ___$romejs$codec_source_map$src$ArraySet_ts$default();
      this.mappings = new ___$romejs$codec_source_map$src$MappingList_ts$default();
    }

    assertUnlocked() {
      if (this.map !== undefined) {
        throw new Error('Source map has already been materialized, toJSON() should be your final call');
      }
    }

    addMapping(mapping) {
      this.assertUnlocked();

      const {name: name, source: source} = mapping;

      this.validatePosition(
      'generated',
      mapping.generatedLine,
      mapping.generatedColumn);
      this.validatePosition(
      'original',
      mapping.originalLine,
      mapping.originalColumn);

      if (source !== undefined) {
        this.sources.add(source);
      }

      if (name !== undefined) {
        this.names.add(name);
      }

      this.mappings.add(mapping);
    }

    setSourceContent(source, sourceContent) {
      this.assertUnlocked();

      if (this.sourceRoot !== undefined) {
        source = ___$romejs$codec_source_map$src$util_ts$toRelativeUrl(this.sourceRoot, source);
      }

      if (sourceContent !== undefined) {
        this.sourcesContents.set(source, sourceContent);
      } else {
        this.sourcesContents.delete(source);
      }
    }

    validatePosition(key, line, column) {
      ___$romejs$invariant$src$index_ts$default(
      line > 0,
      '%s line should be greater than 0 but is %s',
      key,
      line);
      ___$romejs$invariant$src$index_ts$default(
      column >= 0,
      '%s column should be greater than 0 but is %s',
      key,
      column);
    }

    serializeMappings() {
      let previousGeneratedColumn = 0;
      let previousGeneratedLine = 1;
      let previousOriginalColumn = 0;
      let previousOriginalLine = 0;
      let previousName = 0;
      let previousSource = 0;
      let result = '';
      let next;
      let mapping;
      let nameIdx;
      let sourceIdx;

      const mappings = this.mappings.toArray();
      for (let i = 0; i < mappings.length; i++) {
        mapping = mappings[i];
        next = '';

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ';';
            previousGeneratedLine++;
          }
        } else if (i > 0) {
          if (!___$romejs$codec_source_map$src$util_ts$compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }

        next += ___$romejs$codec_source_map$src$base64_ts$encodeVLQ(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source !== undefined) {
          sourceIdx = this.sources.indexOf(mapping.source);
          next += ___$romejs$codec_source_map$src$base64_ts$encodeVLQ(sourceIdx - previousSource);
          previousSource = sourceIdx;

          next += ___$romejs$codec_source_map$src$base64_ts$encodeVLQ(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          next += ___$romejs$codec_source_map$src$base64_ts$encodeVLQ(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name !== undefined) {
            nameIdx = this.names.indexOf(mapping.name);
            next += ___$romejs$codec_source_map$src$base64_ts$encodeVLQ(nameIdx - previousName);
            previousName = nameIdx;
          }
        }

        result += next;
      }

      return result;
    }

    generateSourcesContent(sources, sourceRoot) {
      return sources.map(source => {
        if (sourceRoot !== undefined) {
          source = ___$romejs$codec_source_map$src$util_ts$toRelativeUrl(sourceRoot, source);
        }
        const content = this.sourcesContents.get(source);
        if (content === undefined) {
          throw new Error('Expected content');
        }
        return content;
      });
    }

    toJSON() {
      if (this.map !== undefined) {
        return this.map;
      }

      const sources = this.sources.toArray();
      this.map = {
        version: 3,
        file: this.file,
        names: this.names.toArray(),
        mappings: this.serializeMappings(),
        sourceRoot: this.sourceRoot,
        sources: sources,
        sourcesContent: this.generateSourcesContent(sources, this.sourceRoot)};
      return this.map;
    }

    toComment() {
      const jsonMap = this.toString();
      const base64Map = new Buffer(jsonMap).toString('base64');
      const comment = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`;
      return comment;
    }

    toString() {
      return JSON.stringify(this.toJSON());
    }
  }

  // romejs/codec-source-map/src/SourceMapConsumer.ts

  function ___$$priv$romejs$codec_source_map$src$SourceMapConsumer_ts$getCacheKey(line, column) {
    return `${String(line)}:${String(column)}`;
  }

  class ___$romejs$codec_source_map$src$SourceMapConsumer_ts$default {
    constructor(map) {
      this.map = map;
      this.mappings = undefined;
    }

    static charIsMappingSeparator(str, index) {
      const c = str.charAt(index);
      return c === ';' || c === ',';
    }

    static parseMappings(rawStr) {
      const map = new Map();

      let generatedLine = 1;
      let previousGeneratedColumn = 0;
      let previousOriginalLine = 0;
      let previousOriginalColumn = 0;
      let previousSource = '';
      let previousName = '';
      let length = rawStr.length;
      let index = 0;
      let cachedSegments = {};
      let value;

      while (index < length) {
        const char = rawStr[index];
        if (char === ';') {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (char === ',') {
          index++;
        } else {
          const mapping = {
            generatedLine: generatedLine,
            generatedColumn: 0,
            source: undefined,
            originalLine: 0,
            originalColumn: 0,
            name: undefined};

          let end = index;
          for (; end < length; end++) {
            if (___$romejs$codec_source_map$src$SourceMapConsumer_ts$default.charIsMappingSeparator(rawStr, end)) {
              break;
            }
          }
          const str = rawStr.slice(index, end);

          let segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              [value, index] = ___$romejs$codec_source_map$src$base64_ts$decodeVLQ(rawStr, index);
              segment.push(value);
            }

            ___$romejs$invariant$src$index_ts$default(
            segment.length === 1 ||
            segment.length === 4 ||
            segment.length === 5,
            'Expected 1, 4 or 5 segment parts but got %s',
            segment.length);

            cachedSegments[str] = segment;
          }

          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];

            const newOriginalLine = previousOriginalLine + segment[2];
            previousOriginalLine = newOriginalLine;

            mapping.originalLine = newOriginalLine + 1;

            const newOriginalColumn = previousOriginalColumn + segment[3];
            mapping.originalColumn = newOriginalColumn;
            previousOriginalColumn = newOriginalColumn;

            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          map.set(
          ___$$priv$romejs$codec_source_map$src$SourceMapConsumer_ts$getCacheKey(mapping.generatedLine, mapping.generatedColumn),
          mapping);
        }
      }

      return map;
    }

    getMappings() {
      if (this.mappings === undefined) {
        const mappings = ___$romejs$codec_source_map$src$SourceMapConsumer_ts$default.parseMappings(this.map.mappings);
        this.mappings = mappings;
        return mappings;
      } else {
        return this.mappings;
      }
    }

    approxOriginalPositionFor(line, column) {
      while (column >= 0) {
        const mapping = this.exactOriginalPositionFor(line, column);
        if (mapping === undefined) {
          column--;
          continue;
        } else {
          return mapping;
        }
      }

      return undefined;
    }

    exactOriginalPositionFor(line, column) {
      const key = ___$$priv$romejs$codec_source_map$src$SourceMapConsumer_ts$getCacheKey(line, column);
      const mapping = this.getMappings().get(key);
      if (mapping === undefined) {
        return undefined;
      }

      return {
        source: this.map.sources[mapping.source],
        line: mapping.originalLine,
        column: mapping.originalColumn,
        name: mapping.name};
    }
  }

  // romejs/codec-source-map/src/types.ts


  // romejs/codec-source-map/src/index.ts


  // romejs/v8/src/sourceMapManager.ts

  const ___$romejs$v8$src$sourceMapManager_ts = {
    init: ___$romejs$v8$src$sourceMapManager_ts$init,
    teardown: ___$romejs$v8$src$sourceMapManager_ts$teardown,
    resolveLocation: ___$romejs$v8$src$sourceMapManager_ts$resolveLocation,
    addSourceMap: ___$romejs$v8$src$sourceMapManager_ts$addSourceMap,
    getSourceMap: ___$romejs$v8$src$sourceMapManager_ts$getSourceMap};
  let ___$$priv$romejs$v8$src$sourceMapManager_ts$inited = false;
  const ___$$priv$romejs$v8$src$sourceMapManager_ts$maps = new Map();

  function ___$$priv$romejs$v8$src$sourceMapManager_ts$prepareStackTrace(err, frames) {
    try {
      const v8Err = ___$romejs$v8$src$index_ts$errors.toV8Error(err);
      ___$$priv$romejs$v8$src$sourceMapManager_ts$addErrorFrames(v8Err, frames);
      return ___$$priv$romejs$v8$src$sourceMapManager_ts$buildStackString(v8Err);
    } catch (err2) {
      return `${err.name}: ${err.message}\n  Failed to generate stacktrace: ${err2.message}`;
    }
  }

  function ___$romejs$v8$src$sourceMapManager_ts$init() {
    if (!___$$priv$romejs$v8$src$sourceMapManager_ts$inited) {
      ___$$priv$romejs$v8$src$sourceMapManager_ts$inited = true;
      Error.prepareStackTrace = ___$$priv$romejs$v8$src$sourceMapManager_ts$prepareStackTrace;
    }
  }

  function ___$romejs$v8$src$sourceMapManager_ts$teardown() {
    Error.prepareStackTrace = undefined;
  }

  function ___$$priv$romejs$v8$src$sourceMapManager_ts$buildStackString(err) {
    const frames = ___$romejs$v8$src$index_ts$errors.getFrames(err);
    const lines = [];

    lines.push(`${err.name}: ${err.message}`);

    for (const frame of frames) {
      const {
        resolvedLocation: resolvedLocation,
        methodName: methodName,
        functionName: functionName,
        typeName: typeName,
        isNative: isNative,
        isAsync: isAsync,
        isEval: isEval,
        isConstructor: isConstructor,
        filename: filename,
        lineNumber: lineNumber,
        columnNumber: columnNumber} = frame;
      const parts = [];

      if (isAsync) {
        parts.push('await');
      }

      if (isEval) {
        parts.push('eval');
      }

      if (isConstructor) {
        parts.push('new');
      }

      let name = '<anonymous';
      if (functionName !== undefined) {
        name = functionName;
      }
      if (methodName !== undefined) {
        name = methodName;
      }
      if (typeName !== undefined) {
        parts.push(`${typeName}.${name}`);
      } else {
        parts.push(name);
      }

      if (isNative) {
        parts.push('native');
      } else if (filename !== undefined &&
      lineNumber !== undefined &&
      columnNumber !== undefined) {
        parts.push(`(${filename}:${lineNumber}:${columnNumber})`);
      }

      if (resolvedLocation === false) {
        parts.push('generated source location');
      }

      lines.push('  at ' + parts.join(' '));
    }

    return lines.join('\n');
  }

  function ___$$priv$romejs$v8$src$sourceMapManager_ts$noNull(val) {
    if (val === null) {
      return undefined;
    } else {
      return val;
    }
  }

  function ___$$priv$romejs$v8$src$sourceMapManager_ts$addErrorFrames(err, frames) {
    if (err.__ROME_ERROR_FRAMES__) {
      return undefined;
    }

    let builtFrames = frames.map(
    frameApi => {
      const filename = frameApi.getFileName();
      const lineNumber = frameApi.getLineNumber();
      const columnNumber = frameApi.getColumnNumber();

      const frame = {
        typeName: ___$$priv$romejs$v8$src$sourceMapManager_ts$noNull(frameApi.getTypeName()),
        functionName: ___$$priv$romejs$v8$src$sourceMapManager_ts$noNull(frameApi.getFunctionName()),
        methodName: ___$$priv$romejs$v8$src$sourceMapManager_ts$noNull(frameApi.getMethodName()),

        isToplevel: frameApi.isToplevel(),
        isEval: frameApi.isEval(),
        isNative: frameApi.isNative(),
        isConstructor: frameApi.isConstructor(),

        isAsync: false,

        resolvedLocation: true,

        filename: ___$$priv$romejs$v8$src$sourceMapManager_ts$noNull(filename),
        lineNumber: ___$$priv$romejs$v8$src$sourceMapManager_ts$noNull(lineNumber),

        columnNumber: columnNumber == null ? undefined : columnNumber - 1};

      if (frame.filename !== undefined &&
      frame.lineNumber !== undefined &&
      frame.columnNumber !== undefined) {
        const {found: found, line: line, column: column, filename: filename, name: name} = ___$romejs$v8$src$sourceMapManager_ts$resolveLocation(
        frame.filename,
        frame.lineNumber,
        frame.columnNumber);

        return Object.assign({}, frame, {
          functionName: frame.functionName === undefined ? name : frame.functionName,
          methodName: frame.methodName === undefined ? name : frame.methodName,
          resolvedLocation: found,
          lineNumber: line,
          columnNumber: column,
          filename: filename});
      } else {
        return frame;
      }
    });

    if (err.__ROME_POP_FRAMES__ !== undefined) {
      builtFrames = builtFrames.slice(err.__ROME_POP_FRAMES__);
    }

    err.__ROME_ERROR_FRAMES__ = builtFrames;
  }

  function ___$romejs$v8$src$sourceMapManager_ts$resolveLocation(filename, line, column) {
    const map = ___$$priv$romejs$v8$src$sourceMapManager_ts$maps.get(filename);
    if (map === undefined) {
      return {
        found: true,
        filename: filename,
        line: line,
        column: column,
        name: undefined};
    }

    const resolved = map.approxOriginalPositionFor(line, column);
    if (resolved === undefined) {
      return {
        found: false,
        filename: filename,
        line: line,
        column: column,
        name: undefined};
    }

    return {
      found: true,
      filename: resolved.source,
      line: resolved.line,
      column: resolved.column,
      name: resolved.name};
  }

  function ___$romejs$v8$src$sourceMapManager_ts$addSourceMap(filename, map) {
    ___$romejs$v8$src$sourceMapManager_ts$init();
    ___$$priv$romejs$v8$src$sourceMapManager_ts$maps.set(filename, new ___$romejs$codec_source_map$src$SourceMapConsumer_ts$default(map));
  }

  function ___$romejs$v8$src$sourceMapManager_ts$getSourceMap(filename) {
    return ___$$priv$romejs$v8$src$sourceMapManager_ts$maps.get(filename);
  }

  // romejs/v8/src/types.ts

  const ___$romejs$v8$src$types_ts = {};

  // romejs/v8/src/errors.ts

  const ___$romejs$v8$src$errors_ts = {
    get V8Error() {
      return ___$romejs$v8$src$errors_ts$V8Error;
    },
    toV8Error: ___$romejs$v8$src$errors_ts$toV8Error,
    getFramesToPop: ___$romejs$v8$src$errors_ts$getFramesToPop,
    getFrame: ___$romejs$v8$src$errors_ts$getFrame,
    isErrorLike: ___$romejs$v8$src$errors_ts$isErrorLike,
    toErrorLike: ___$romejs$v8$src$errors_ts$toErrorLike,
    getFrames: ___$romejs$v8$src$errors_ts$getFrames,
    getAdvice: ___$romejs$v8$src$errors_ts$getAdvice,
    getSourceLocationFromFrame: ___$romejs$v8$src$errors_ts$getSourceLocationFromFrame};
  Object.keys(___$romejs$v8$src$types_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$v8$src$errors_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$v8$src$types_ts[key];
      }});
  });
  class ___$romejs$v8$src$errors_ts$V8Error extends Error {
    constructor(msg, advice, framesToPop) {
      super(msg);
      this.__ROME_ERROR_FRAMES__ = undefined;
      this.__ROME_ERROR_ADVICE__ = advice;
      this.__ROME_POP_FRAMES__ = framesToPop;
    }
  }

  function ___$romejs$v8$src$errors_ts$toV8Error(err) {
    return err;
  }

  function ___$romejs$v8$src$errors_ts$getFramesToPop(_err) {
    const err = ___$romejs$v8$src$errors_ts$toV8Error(_err);
    return err.__ROME_POP_FRAMES__ === undefined ? 0 : err.__ROME_POP_FRAMES__;
  }

  function ___$romejs$v8$src$errors_ts$getFrame(index) {
    return ___$romejs$v8$src$errors_ts$getFrames(new Error())[index + 1];
  }

  function ___$romejs$v8$src$errors_ts$isErrorLike(err) {
    return ___$romejs$refinement$src$index_ts$isPlainObject(err) &&
    typeof err.message === 'string' &&
    (typeof err.stack === 'string' || err.stack === undefined);
  }

  function ___$romejs$v8$src$errors_ts$toErrorLike(err) {
    if (err instanceof Error) {
      return err;
    }

    let name = 'Error';
    let message = 'Unknown message';
    let stack = undefined;

    if (___$romejs$refinement$src$index_ts$isPlainObject(err)) {
      if (___$romejs$v8$src$errors_ts$isErrorLike(err)) {
        return err;
      }

      if (typeof err.name === 'string') {
        name = err.name;
      }

      if (typeof err.message === 'string') {
        message = err.message;
      }

      if (typeof err.stack === 'string') {
        stack = err.stack;
      }
    }

    return {
      name: name,
      message: message,
      stack: stack};
  }

  function ___$romejs$v8$src$errors_ts$getFrames(_err) {
    if (!___$romejs$v8$src$errors_ts$isErrorLike(_err)) {
      return [];
    }

    const err = ___$romejs$v8$src$errors_ts$toV8Error(_err);

    err.stack;

    const frames = err.__ROME_ERROR_FRAMES__ === undefined ? [] : err.__ROME_ERROR_FRAMES__;
    return frames;
  }

  function ___$romejs$v8$src$errors_ts$getAdvice(_err) {
    if (!___$romejs$v8$src$errors_ts$isErrorLike(_err)) {
      return [];
    }

    const err = ___$romejs$v8$src$errors_ts$toV8Error(_err);
    return err.__ROME_ERROR_ADVICE__ === undefined ? [] : err.__ROME_ERROR_ADVICE__;
  }

  function ___$romejs$v8$src$errors_ts$getSourceLocationFromFrame(frame) {
    const pos = {
      index: -1,
      line: frame.lineNumber === undefined ? 1 : frame.lineNumber,
      column: frame.columnNumber === undefined ? 0 : frame.columnNumber};

    return {
      filename: frame.filename === undefined ? undefined : frame.filename,
      start: pos,
      end: pos};
  }

  // romejs/v8/src/utils.ts

  function ___$romejs$v8$src$utils_ts$hrTime() {
    const hrtime = process.hrtime();
    const ts = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);
    return ts;
  }

  const ___$$priv$romejs$v8$src$utils_ts$FILE_PROTOCOL = 'file://';

  function ___$romejs$v8$src$utils_ts$urlToFilename(url) {
    if (url.startsWith(___$$priv$romejs$v8$src$utils_ts$FILE_PROTOCOL)) {
      return url.slice(___$$priv$romejs$v8$src$utils_ts$FILE_PROTOCOL.length);
    } else {
      return url;
    }
  }

  // romejs/v8/src/Profiler.ts

  const ___$$priv$romejs$v8$src$Profiler_ts$inspector = require('inspector');
  class ___$romejs$v8$src$Profiler_ts$default {
    constructor() {
      this.session = undefined;
      this.memoryInterval = undefined;
      this.memorySamples = [];
    }

    async startProfiling() {
      this.session = new ___$$priv$romejs$v8$src$Profiler_ts$inspector.Session();
      this.session.connect();

      this.memoryInterval = setInterval(() => {
        const time = ___$romejs$v8$src$utils_ts$hrTime();
        const size = process.memoryUsage().heapUsed;
        this.memorySamples.push([time, size]);
      }, 100);

      await Promise.all([this.sendCommand('Profiler.enable'), this.sendCommand('Profiler.start')]);
    }

    async sendCommand(method, params) {
      const {session: session} = this;
      if (session === undefined) {
        return Promise.reject(new Error('No current profiler session'));
      } else {
        return new Promise((resolve, reject) => {
          session.post(method, params, (err, params) => {
            if (err === null) {
              resolve(params);
            } else {
              reject(err);
            }
          });
        });
      }
    }

    destroy() {
      const {session: session} = this;
      if (session !== undefined) {
        if (this.memoryInterval !== undefined) {
          clearInterval(this.memoryInterval);
        }
        this.memorySamples = [];
        session.disconnect();
      }
    }

    async stopProfiling() {
      const {memorySamples: memorySamples} = this;
      const res = await this.sendCommand('Profiler.stop');
      this.destroy();
      return {
        pid: process.pid,
        cpuProfile: res.profile,
        memorySamples: memorySamples};
    }
  }

  // romejs/v8/src/Trace.ts

  class ___$romejs$v8$src$Trace_ts$default {
    constructor() {
      this.tid = 0;
      this.eventId = 0;
      this.events = [];
    }

    getEventId() {
      const id = this.eventId;
      this.eventId++;
      return id;
    }

    decodeProfileSourceMap(profile) {
      for (const node of profile.cpuProfile.nodes) {
        const {callFrame: callFrame} = node;
        const filename = ___$romejs$v8$src$utils_ts$urlToFilename(callFrame.url);
        const sourceMap = ___$romejs$v8$src$sourceMapManager_ts$getSourceMap(filename);
        if (sourceMap === undefined) {
          continue;
        }

        const resolved = sourceMap.approxOriginalPositionFor(
        callFrame.lineNumber + 1,
        callFrame.columnNumber);
        if (resolved !== undefined) {
          callFrame.url = resolved.source;
          callFrame.lineNumber = resolved.line - 1;
          callFrame.columnNumber = resolved.column;

          if (resolved.name !== undefined) {
            callFrame.functionName = resolved.name;
          }
        }
      }
    }

    addProfile(name, profile) {
      this.decodeProfileSourceMap(profile);

      const {startTime: startTime, endTime: endTime} = profile.cpuProfile;

      const common = {
        pid: 1,
        tid: profile.pid};

      this.events.push(Object.assign({}, common, {
        ts: 0,
        ph: 'M',
        cat: '__metadata',
        name: 'thread_name',
        args: {name: name}}));

      this.events.push(Object.assign({}, common, {
        ph: 'P',
        name: 'CpuProfile',
        id: this.getEventId(),
        cat: 'disabled-by-default-v8.cpu_profiler',
        ts: endTime,
        args: {
          data: {
            cpuProfile: profile.cpuProfile}}}));

      this.events.push(Object.assign({}, common, {
        ph: 'X',
        name: 'EvaluateScript',
        id: this.getEventId(),
        cat: 'devtools.timeline',
        ts: startTime,
        dur: endTime - startTime,
        args: {
          data: {
            url: 'rome.js',
            lineNumber: 1,
            columnNumber: 1,
            frame: '0xFFF'}}}));

      for (const [time, size] of profile.memorySamples) {
        this.events.push(Object.assign({}, common, {
          ts: time,
          ph: 'I',
          cat: 'disabled-by-default-devtools.timeline',
          name: 'UpdateCounters',
          args: {
            data: {
              jsHeapSizeUsed: size}},
          s: 't'}));
      }
    }

    build() {
      return this.events;
    }
  }

  // romejs/v8/src/InspectorClient.ts

  class ___$romejs$v8$src$InspectorClient_ts$InspectorClientCloseError extends Error {
    constructor() {
      super('Inspector connection closed');
    }
  }

  class ___$romejs$v8$src$InspectorClient_ts$default {
    constructor(socket) {
      this.socket = socket;
      this.id = 0;

      this.subscriptions = new Map();
      this.callbacks = new Map();

      this.alive = true;

      this.init();
    }

    end() {
      this.socket.end();
    }

    init() {
      const {socket: socket} = this;

      socket.errorEvent.subscribe(err => {
        for (const [, {reject: reject}] of this.callbacks) {
          reject(err);
        }
        this.callbacks.clear();
      });

      socket.endEvent.subscribe(() => {
        this.alive = false;
        for (const [, {reject: reject}] of this.callbacks) {
          reject(new ___$romejs$v8$src$InspectorClient_ts$InspectorClientCloseError());
        }
        this.callbacks.clear();
      });

      socket.messageEvent.subscribe(frame => {
        const json = frame.payload.toString();
        const data = JSON.parse(json);
        const {id: id, method: method, params: params, result: result, error: error} = data;

        if (id) {
          const handler = this.callbacks.get(id);
          if (handler !== undefined) {
            if (error === undefined) {
              handler.resolve(result);
            } else {
              handler.reject(new Error(error.message));
            }
            this.callbacks.delete(id);
          }
          return undefined;
        }

        if (method) {
          const subs = this.subscriptions.get(method);
          if (subs !== undefined) {
            for (const sub of subs) {
              const {callback: callback, once: once} = sub;
              callback(params);
              if (once) {
                subs.delete(sub);
              }
            }
          }
        }
      });
    }

    subscribe(method, sub) {
      let subs = this.subscriptions.get(method);
      if (subs === undefined) {
        subs = new Set();
        this.subscriptions.set(method, subs);
      }
      subs.add(sub);
    }

    assertAlive() {
      if (!this.alive) {
        throw new Error('InspectorClient has no active socket');
      }
    }

    async wait(method) {
      return new Promise(resolve => {
        this.assertAlive();
        this.subscribe(method, {
          once: true,
          callback: resolve});
      });
    }

    call(method, params) {
      const id = ++this.id;

      return new Promise((resolve, reject) => {
        this.assertAlive();
        this.callbacks.set(id, {resolve: resolve, reject: reject});

        this.socket.sendJSON({
          id: id,
          method: method,
          params: params});
      });
    }
  }

  // romejs/v8/src/CoverageCollector.ts

  function ___$$priv$romejs$v8$src$CoverageCollector_ts$createCoverageFileStats(covered, uncovered) {
    const total = uncovered + covered;
    return {
      uncovered: uncovered,
      covered: covered,
      total: total,
      percent: total === 0 ? 100 : 100 / total * covered};
  }

  class ___$romejs$v8$src$CoverageCollector_ts$default {
    constructor() {
      this.sourceMaps = new Map();
    }

    addSourceMap(filename, code, map) {
      this.sourceMaps.set(filename, {
        ranges: [],
        map: map,
        code: code});
    }

    addCoverage(entries) {
      for (const entry of entries) {
        const filename = ___$romejs$v8$src$utils_ts$urlToFilename(entry.url);

        const data = this.sourceMaps.get(filename);
        if (data === undefined) {
          continue;
        }

        for (const {ranges: ranges, functionName: functionName, isBlockCoverage: isBlockCoverage} of entry.functions) {
          data.ranges = data.ranges.concat(
          ranges.map(range => {
            let kind = 'expression';
            if (functionName !== '') {
              kind = 'function';
            } else if (isBlockCoverage) {
              kind = 'branch';
            }
            return Object.assign({
              kind: kind}, range);
          }));
        }
      }
    }

    generate() {
      const insertedLocs = new Map();
      const locs = [];

      for (const data of this.sourceMaps.values()) {
        const {ranges: ranges, code: code, map: map} = data;

        let line = 1;
        let column = 0;
        let index = 0;
        const indexCache = new Map();
        function findIndex(newIndex) {
          const cached = indexCache.get(newIndex);
          if (cached !== undefined) {
            return cached;
          }

          ___$romejs$invariant$src$index_ts$default(
          newIndex >= index,
          'Expected newIndex(%s) >= index(%s)',
          newIndex,
          index);
          ___$romejs$invariant$src$index_ts$default(
          newIndex <= code.length,
          'Expected newIndex(%s) <= code.length(%s)',
          newIndex,
          code.length);

          while (index < newIndex) {
            const char = code[index];
            if (char === '\n') {
              line++;
              column = 0;
            } else {
              column++;
            }
            index++;
          }

          const pos = {
            index: newIndex,
            line: line,
            column: column};
          indexCache.set(newIndex, pos);
          return pos;
        }

        const offsets = [];
        for (const {startOffset: startOffset, endOffset: endOffset} of ranges) {
          offsets.push(startOffset);
          offsets.push(endOffset);
        }
        offsets.sort((a, b) => a - b);
        for (const index of offsets) {
          findIndex(index);
        }

        const sourceMap = new ___$romejs$codec_source_map$src$SourceMapConsumer_ts$default(map);
        for (const {kind: kind, startOffset: startOffset, endOffset: endOffset, count: count} of ranges) {
          const originalStart = findIndex(startOffset);
          const originalEnd = findIndex(endOffset);

          const sourceStart = sourceMap.approxOriginalPositionFor(
          originalStart.line,
          originalStart.column);
          if (sourceStart === undefined) {
            continue;
          }

          const sourceEnd = sourceMap.approxOriginalPositionFor(
          originalEnd.line,
          originalEnd.column);
          if (sourceEnd === undefined) {
            continue;
          }

          ___$romejs$invariant$src$index_ts$default(
          sourceStart.source === sourceEnd.source,
          'Expected the same source for start and end: %s !== %s',
          sourceStart.source,
          sourceEnd.source);

          const key = `${sourceStart.source}:${String(startOffset)}-${String(
          endOffset)}`;
          const alreadyInserted = insertedLocs.get(key);
          if (alreadyInserted !== undefined) {
            alreadyInserted.count += count;
            continue;
          }

          const loc = {
            kind: kind,
            filename: sourceStart.source,
            count: count,
            start: {
              index: startOffset,
              line: sourceStart.line,
              column: sourceStart.column},
            end: {
              index: endOffset,
              line: sourceEnd.line,
              column: sourceEnd.column}};
          insertedLocs.set(key, loc);
          locs.push(loc);
        }
      }

      const rangesByFile = new Map();
      for (const loc of locs) {
        let ranges = rangesByFile.get(loc.filename);
        if (ranges === undefined) {
          ranges = [];
          rangesByFile.set(loc.filename, ranges);
        }
        ranges.push(loc);
      }

      const files = [];
      for (const [filename, ranges] of rangesByFile) {
        const coveredLines = new Set();
        const uncoveredLines = new Set();

        let uncoveredFunctions = new Set();
        let coveredFunctions = new Set();
        let uncoveredBranches = new Set();
        let coveredBranches = new Set();

        for (const {count: count, kind: kind, start: start, end: end} of ranges) {
          for (let i = start.line; i <= end.line; i++) {
            if (count === 0) {
              uncoveredLines.add(i);
            } else {
              coveredLines.add(i);
            }
          }

          if (kind === 'function') {
            if (count === 0) {
              uncoveredBranches.add(start.index);
              uncoveredFunctions.add(start.line);
            } else {
              coveredFunctions.add(start.line);
              coveredBranches.add(start.index);
            }
          } else if (kind === 'branch') {
            if (count === 0) {
              uncoveredBranches.add(start.index);
            } else {
              coveredBranches.add(start.index);
            }
          }
        }

        for (const line of coveredLines) {
          uncoveredLines.delete(line);
        }

        for (const index of coveredBranches) {
          uncoveredBranches.delete(index);
        }

        for (const index of coveredFunctions) {
          uncoveredFunctions.delete(index);
        }

        if (uncoveredLines.size === 0 &&
        uncoveredBranches.size === 0 &&
        uncoveredFunctions.size === 0) {
          continue;
        }

        files.push({
          filename: filename,
          lines: ___$$priv$romejs$v8$src$CoverageCollector_ts$createCoverageFileStats(coveredLines.size, uncoveredLines.size),
          branches: ___$$priv$romejs$v8$src$CoverageCollector_ts$createCoverageFileStats(
          coveredBranches.size,
          uncoveredBranches.size),
          functions: ___$$priv$romejs$v8$src$CoverageCollector_ts$createCoverageFileStats(
          coveredFunctions.size,
          uncoveredFunctions.size)});
      }
      return files;
    }
  }

  // romejs/v8/src/index.ts

  const ___$romejs$v8$src$index_ts$sourceMapManager = ___$romejs$v8$src$sourceMapManager_ts;
  const ___$romejs$v8$src$index_ts$errors = ___$romejs$v8$src$errors_ts;

  // romejs/diagnostics/src/derive.ts

  const ___$romejs$diagnostics$src$derive_ts = {
    mergeDiagnostics: ___$romejs$diagnostics$src$derive_ts$mergeDiagnostics,
    getDiagnosticHeader: ___$romejs$diagnostics$src$derive_ts$getDiagnosticHeader,
    deriveRootAdviceFromDiagnostic: ___$romejs$diagnostics$src$derive_ts$deriveRootAdviceFromDiagnostic,
    deriveDiagnosticFromError: ___$romejs$diagnostics$src$derive_ts$deriveDiagnosticFromError,
    getErrorStackAdvice: ___$romejs$diagnostics$src$derive_ts$getErrorStackAdvice,
    addOriginsToDiagnostics: ___$romejs$diagnostics$src$derive_ts$addOriginsToDiagnostics,
    addOriginsToDiagnostic: ___$romejs$diagnostics$src$derive_ts$addOriginsToDiagnostic};
  function ___$$priv$romejs$diagnostics$src$derive_ts$normalizeArray(val) {
    if (Array.isArray(val)) {
      return val;
    } else {
      return [];
    }
  }

  function ___$romejs$diagnostics$src$derive_ts$mergeDiagnostics(cwd, rootDiag, ...diags) {
    let mergedAdvice = [...___$$priv$romejs$diagnostics$src$derive_ts$normalizeArray(rootDiag.advice)];

    for (const diag of diags) {
      mergedAdvice = [...mergedAdvice, ...___$romejs$diagnostics$src$derive_ts$deriveRootAdviceFromDiagnostic(diag, cwd), ...___$$priv$romejs$diagnostics$src$derive_ts$normalizeArray(diag.advice)];
    }

    return Object.assign({}, rootDiag, {
      advice: mergedAdvice});
  }

  function ___$romejs$diagnostics$src$derive_ts$getDiagnosticHeader(opts) {
    const {start: start, filename: filename} = opts;

    if (filename === undefined) {
      return 'unknown';
    }

    if (start === undefined) {
      return `<filelink filename="${filename}" />`;
    }

    return `<filelink filename="${filename}" line="${start.line}" column="${start.column}" />`;
  }

  function ___$romejs$diagnostics$src$derive_ts$deriveRootAdviceFromDiagnostic(diag, cwd, skipFrame = false) {
    const advice = [];

    let header = ___$romejs$diagnostics$src$derive_ts$getDiagnosticHeader({
      start: diag.start,
      filename: diag.filename,
      cwd: cwd});

    if (diag.category !== undefined) {
      header += ' ' + ___$romejs$string_ansi$src$format_ts$formatAnsi.bold(diag.category);
    }

    if (diag.fixable === true) {
      header += ' ' + ___$romejs$string_ansi$src$format_ts$formatAnsi.inverse(' FIXABLE ');
    }

    advice.push({
      type: 'log',
      category: 'none',
      message: header});

    advice.push({
      type: 'log',
      category: 'error',
      message: diag.message});

    if (skipFrame === false) {
      if (diag.start !== undefined && diag.end !== undefined) {
        advice.push({
          type: 'frame',
          code: diag.code,
          filename: diag.filename,
          marker: diag.marker,
          start: diag.start,
          end: diag.end});
      } else if (diag.marker !== undefined) {
        advice.push({
          type: 'log',
          category: 'error',
          message: diag.marker});
      }
    }

    return advice;
  }

  function ___$romejs$diagnostics$src$derive_ts$deriveDiagnosticFromError(opts) {
    const {error: error, filename: filename, firstAdvice = [], lastAdvice = []} = opts;
    let {name = 'Error'} = opts;

    let targetFilename = filename;
    let targetCode = undefined;
    let targetLoc = undefined;

    let message = '';
    let advice = [];

    if (error != null && typeof error === 'object') {
      const frames = ___$romejs$v8$src$index_ts$errors.getFrames(error);
      for (const frame of frames) {
        if (frame.filename === undefined) {
          continue;
        }

        targetFilename = frame.filename;
        targetLoc = ___$romejs$v8$src$index_ts$errors.getSourceLocationFromFrame(frame);
        break;
      }

      ({name: name, message: message} = ___$romejs$v8$src$errors_ts$toErrorLike(error));

      if (name !== undefined && name !== 'Error') {
        message = `${name}: ${message}`;
      }

      advice = [...firstAdvice, ...___$romejs$diagnostics$src$derive_ts$getErrorStackAdvice(error), ...___$romejs$v8$src$index_ts$errors.getAdvice(error), ...lastAdvice];
    } else {
      message = `Not an error instance: ${String(error)}`;
      advice = [...firstAdvice, ...lastAdvice];
    }

    const diagnostic = {
      filename: targetFilename,
      start: targetLoc === undefined ? undefined : targetLoc.start,
      end: targetLoc === undefined ? undefined : targetLoc.end,
      code: targetCode,
      category: name,
      message: message,
      advice: advice};
    return diagnostic;
  }

  function ___$romejs$diagnostics$src$derive_ts$getErrorStackAdvice(errorLike, title) {
    const error = ___$romejs$v8$src$index_ts$errors.toErrorLike(errorLike);
    const frames = ___$romejs$v8$src$index_ts$errors.getFrames(error);
    const {stack: stack} = error;
    const advice = [];

    if (frames.length === 0 && stack !== undefined) {
      if (title !== undefined) {
        advice.push({
          type: 'log',
          category: 'info',
          message: title});
      }

      let cleanStack = stack;
      let removeMessage = `${error.name}: ${error.message}`;
      if (cleanStack.startsWith(removeMessage)) {
        cleanStack = cleanStack.slice(removeMessage.length);
      }

      advice.push({
        type: 'log',
        category: 'error',
        message: cleanStack});
    } else {
      const adviceFrames = frames.map(frame => {
        const {
          typeName: typeName,
          functionName: functionName,
          methodName: methodName,
          filename: filename,
          lineNumber: lineNumber,
          columnNumber: columnNumber,
          isEval: isEval,
          isNative: isNative,
          isConstructor: isConstructor,
          isAsync: isAsync} = frame;

        const prefixes = [];
        if (isAsync) {
          prefixes.push('await');
        }
        if (isEval) {
          prefixes.push('eval');
        }
        if (isConstructor) {
          prefixes.push('new');
        }
        const prefix = prefixes.length === 0 ? undefined : prefixes.join(' ');

        let object = typeName;
        let property = '<anonymous>';
        if (functionName !== undefined) {
          property = functionName;
        }
        if (methodName !== undefined) {
          property = methodName;
        }

        let suffix;
        if (isNative) {
          suffix = 'native';
        }

        return {
          suffix: suffix,
          prefix: prefix,
          object: object,
          property: property,
          filename: filename,
          line: lineNumber,
          column: columnNumber};
      });

      advice.push({
        type: 'stacktrace',
        title: title,
        frames: adviceFrames});
    }

    return advice;
  }

  function ___$romejs$diagnostics$src$derive_ts$addOriginsToDiagnostics(origins, diagnostics) {
    return diagnostics.map(diag => {
      return ___$romejs$diagnostics$src$derive_ts$addOriginsToDiagnostic(origins, diag);
    });
  }

  function ___$romejs$diagnostics$src$derive_ts$addOriginsToDiagnostic(origins, diag) {
    const newOrigins = diag.origins === undefined ? origins : [...origins, ...diag.origins];
    return Object.assign({}, diag, {
      origins: newOrigins});
  }

  // romejs/diagnostics/src/errors.ts

  const ___$romejs$diagnostics$src$errors_ts = {
    get DiagnosticError() {
      return ___$romejs$diagnostics$src$errors_ts$DiagnosticError;
    },
    get DiagnosticsError() {
      return ___$romejs$diagnostics$src$errors_ts$DiagnosticsError;
    },
    getDiagnosticsFromError: ___$romejs$diagnostics$src$errors_ts$getDiagnosticsFromError};
  const ___$$priv$romejs$diagnostics$src$errors_ts$printToString = () => '';
  const ___$$priv$romejs$diagnostics$src$errors_ts$buildMessageCodeFrame = () => '';
  const ___$$priv$romejs$diagnostics$src$errors_ts$toLines = () => [];
  const ___$$priv$romejs$diagnostics$src$errors_ts$stripAnsi = str => str;

  function ___$$priv$romejs$diagnostics$src$errors_ts$getCodeFrame(message, diagnostic) {
    const {code: code} = diagnostic;
    if (typeof code !== 'string') {
      return undefined;
    }

    const start = ___$romejs$diagnostics$src$normalize_ts$normalizePosition(diagnostic.start);
    const end = ___$romejs$diagnostics$src$normalize_ts$normalizePosition(diagnostic.end);
    if (start === undefined || end === undefined) {
      return undefined;
    }

    const marker = diagnostic.message === message ? undefined : diagnostic.message;
    const lines = ___$$priv$romejs$diagnostics$src$errors_ts$toLines(code);
    const codeFrame = ___$$priv$romejs$diagnostics$src$errors_ts$buildMessageCodeFrame(lines, start, end, marker);
    if (codeFrame.trim() !== '') {
      return ___$$priv$romejs$diagnostics$src$errors_ts$stripAnsi(codeFrame);
    }

    return undefined;
  }

  class ___$romejs$diagnostics$src$errors_ts$DiagnosticError extends Error {
    constructor(message, diagnostic) {
      const codeFrame = ___$$priv$romejs$diagnostics$src$errors_ts$getCodeFrame(message, diagnostic);
      if (codeFrame !== undefined) {
        message += '\n' + codeFrame;
      }

      super(message);
      this.name = 'DiagnosticError';

      if (diagnostic.filename === undefined) {
        diagnostic = ___$romejs$diagnostics$src$derive_ts$mergeDiagnostics(
        process.cwd(),
        ___$romejs$diagnostics$src$derive_ts$deriveDiagnosticFromError({error: this}),
        diagnostic);
      }

      this.diagnostic = diagnostic;
    }
  }

  class ___$romejs$diagnostics$src$errors_ts$DiagnosticsError extends Error {
    constructor(message, diagnostics) {
      super(
      message +
      '\n' +
      ___$$priv$romejs$diagnostics$src$errors_ts$stripAnsi(
      ___$$priv$romejs$diagnostics$src$errors_ts$printToString(diagnostics, {
        origins: ['Wrapped with DiagnosticsError']})));
      this.diagnostics = diagnostics;
      this.name = 'DiagnosticsError';

      if (diagnostics.length === 0) {
        throw new Error('DiagnosticsError constructed with no diagnostics');
      }
    }
  }

  function ___$romejs$diagnostics$src$errors_ts$getDiagnosticsFromError(err) {
    if (err instanceof ___$romejs$diagnostics$src$errors_ts$DiagnosticError) {
      return [err.diagnostic];
    }

    if (err instanceof ___$romejs$diagnostics$src$errors_ts$DiagnosticsError) {
      return err.diagnostics;
    }

    return undefined;
  }

  // romejs/diagnostics/src/types.ts

  const ___$romejs$diagnostics$src$types_ts = {};

  // romejs/diagnostics/src/wrap.ts

  const ___$romejs$diagnostics$src$wrap_ts = {
    catchDiagnostics: ___$romejs$diagnostics$src$wrap_ts$catchDiagnostics,
    catchDiagnosticsAsync: ___$romejs$diagnostics$src$wrap_ts$catchDiagnosticsAsync};
  function ___$romejs$diagnostics$src$wrap_ts$catchDiagnostics(origin, callback) {
    try {
      const value = callback();

      return {
        foundDiagnostics: false,
        value: value,
        diagnostics: []};
    } catch (err) {
      const diagnostics = ___$romejs$diagnostics$src$errors_ts$getDiagnosticsFromError(err);

      if (diagnostics) {
        return {
          foundDiagnostics: true,
          value: undefined,
          diagnostics: ___$romejs$diagnostics$src$derive_ts$addOriginsToDiagnostics([origin], diagnostics)};
      } else {
        throw err;
      }
    }
  }

  async function ___$romejs$diagnostics$src$wrap_ts$catchDiagnosticsAsync(origin, promise) {
    try {
      const value = await promise();

      return {
        foundDiagnostics: false,
        value: value,
        diagnostics: []};
    } catch (err) {
      const diagnostics = ___$romejs$diagnostics$src$errors_ts$getDiagnosticsFromError(err);

      if (diagnostics) {
        return {
          foundDiagnostics: true,
          value: undefined,
          diagnostics: ___$romejs$diagnostics$src$derive_ts$addOriginsToDiagnostics([origin], diagnostics)};
      } else {
        throw err;
      }
    }
  }

  // romejs/diagnostics/src/DiagnosticsProcessor.ts

  const ___$$priv$romejs$diagnostics$src$DiagnosticsProcessor_ts$DEFAULT_UNIQUE = [['category', 'filename', 'message', 'start.line', 'start.column']];

  class ___$romejs$diagnostics$src$DiagnosticsProcessor_ts$default {
    constructor(options) {
      this.diagnostics = [];
      this.filters = [];
      this.options = options;
      this.includedKeys = new Set();
      this.unique =
      options.unique === undefined ? ___$$priv$romejs$diagnostics$src$DiagnosticsProcessor_ts$DEFAULT_UNIQUE : options.unique;
    }

    static createImmediateThrower(origins) {
      const diagnostics = new ___$romejs$diagnostics$src$DiagnosticsProcessor_ts$default({
        origins: origins,
        onDiagnostics() {
          diagnostics.maybeThrowDiagnosticsError();
        }});
      return diagnostics;
    }

    maybeThrowDiagnosticsError() {
      if (this.hasDiagnostics()) {
        throw new ___$romejs$diagnostics$src$errors_ts$DiagnosticsError('Thrown by DiagnosticsProcessor', this.getPartialDiagnostics());
      }
    }

    hasDiagnostics() {
      return this.diagnostics.length > 0;
    }

    addFilter(diag) {
      this.filters.push(diag);
    }

    doesMatchFilter(diag) {
      for (const filter of this.filters) {
        if (filter.message !== undefined && filter.message !== diag.message) {
          continue;
        }

        if (filter.filename !== undefined && filter.filename !== diag.filename) {
          continue;
        }

        if (filter.category !== undefined && filter.category !== diag.category) {
          continue;
        }

        if (filter.start !== undefined && diag.start !== undefined) {
          if (filter.start.line !== diag.start.line ||
          filter.start.column !== diag.start.column) {
            continue;
          }
        }

        return true;
      }

      return false;
    }

    buildDedupeKeys(diag) {
      let {start: start} = diag;

      const keys = [];

      for (const rule of this.unique) {
        const parts = [];

        if (rule.includes('category')) {
          parts.push(`category:${diag.category}`);
        }

        if (rule.includes('filename')) {
          parts.push(`filename:${String(diag.filename)}`);
        }

        if (rule.includes('message')) {
          parts.push(`message:${diag.message}`);
        }

        if (start !== undefined) {
          if (rule.includes('start.line')) {
            parts.push(`start.line:${start.line}`);
          }

          if (rule.includes('start.column')) {
            parts.push(`start.column:${start.column}`);
          }
        }

        const key = parts.join(',');
        keys.push(key);
      }

      return keys;
    }

    addDiagnostic(diag, origin) {
      return this.addDiagnostics([diag], origin).length > 0;
    }

    addDiagnostics(diags, origin) {
      const {max: max} = this.options;
      const added = [];

      const origins = [...this.options.origins];
      if (origin !== undefined) {
        origins.push(origin);
      }
      diags = ___$romejs$diagnostics$src$derive_ts$addOriginsToDiagnostics(origins, diags);

      diagLoop: for (const diag of diags) {
        if (max !== undefined && this.diagnostics.length > max) {
          break;
        }

        if (this.doesMatchFilter(diag)) {
          continue;
        }

        const keys = this.buildDedupeKeys(diag);

        for (const key of keys) {
          if (this.includedKeys.has(key)) {
            continue diagLoop;
          }
        }

        this.diagnostics.push(diag);
        added.push(diag);

        for (const key of keys) {
          this.includedKeys.add(key);
        }
      }

      const {onDiagnostics: onDiagnostics} = this.options;
      if (onDiagnostics !== undefined && added.length > 0) {
        onDiagnostics(added);
      }

      return added;
    }

    getPartialDiagnostics() {
      return [...this.diagnostics];
    }

    getCompleteDiagnostics(markupOptions = {}) {
      return ___$romejs$diagnostics$src$normalize_ts$normalizeDiagnostics(this.diagnostics, markupOptions);
    }

    getCompleteSortedDiagnostics(markupOptions = {}) {
      return this.getCompleteDiagnostics(markupOptions).sort((a, b) => {
        if (a.filename === undefined || b.filename === undefined) {
          return 0;
        } else {
          return ___$romejs$string_utils$src$naturalCompare_ts$naturalCompare(a.filename, b.filename);
        }
      });
    }

    clear() {
      this.includedKeys = new Set();
      this.diagnostics = [];
    }
  }

  // romejs/diagnostics/src/index.ts


  // romejs/parser-core/src/index.ts

  class ___$romejs$parser_core$src$index_ts$ParserSyntaxError extends ___$romejs$diagnostics$src$errors_ts$DiagnosticError {
    constructor(opts) {
      const {start: start, end: end, code: code, name: name, filename: filename, message: message, advice: advice} = opts;

      let formattedMessage = `${message} (${start.line}:${start.column})`;
      if (filename !== undefined) {
        formattedMessage = `${filename}: ${formattedMessage}`;
      }

      super(formattedMessage, {
        category: name,
        start: start,
        end: end === undefined ? start : end,
        code: code,
        filename: filename,
        advice: advice,
        message: message});
      this.name = 'ParserSyntaxError';
    }
  }

  class ___$romejs$parser_core$src$index_ts$ParserCore {
    constructor(opts, parserName, initialState) {
      const {filename: filename, input: input, offsetPosition: offsetPosition, reason: reason} = opts;

      this.filename = filename === undefined ? undefined : filename;
      this.input = input === undefined ? '' : input;
      this.length = this.input.length;
      this.reason = reason;

      this.offsetPosition = offsetPosition;
      this.parserName = parserName;
      this.tokenizing = false;
      this.currLine = offsetPosition === undefined ? 1 : offsetPosition.line;
      this.currColumn = offsetPosition === undefined ? 0 : offsetPosition.column;
      this.startLine = this.currLine;
      this.startColumn = this.currColumn;
      this.nextTokenIndex = 0;
      this.currentToken = undefined;
      this.state = initialState;

      this.eofToken = {
        type: 'EOF',
        start: this.input.length,
        end: this.input.length};
    }

    getFilenameAssert() {
      const {filename: filename} = this;
      if (filename === undefined) {
        throw new Error('Expected a filename to be passed to the Parser but have none');
      }
      return filename;
    }

    tokenize(index, input) {
      throw new Error('Unimplemented');
    }

    tokenizeWithState(index, input, state) {
      const token = this.tokenize(index, input);
      if (token !== undefined) {
        return {token: token, state: state};
      }
    }

    getToken() {
      const {currentToken: currentToken} = this;
      if (currentToken === undefined) {
        return this.nextToken();
      } else {
        return currentToken;
      }
    }

    nextToken() {
      if (this.isEOF()) {
        this.currentToken = this.eofToken;
        return this.eofToken;
      }

      if (this.tokenizing) {
        throw new Error('Can\'t call nextToken while tokenizing');
      }

      const prevToken = this.currentToken;
      const {token: nextToken, state: state} = this.lookahead();

      if (prevToken !== undefined) {
        for (let i = prevToken.start; i < nextToken.start; i++) {
          const char = this.input[i];
          if (char === '\n') {
            this.currLine++;
            this.currColumn = 0;
          } else {
            this.currColumn++;
          }
        }
      }

      this.nextTokenIndex = nextToken.end;
      this.currentToken = nextToken;
      this.state = state;
      return nextToken;
    }

    getPosition() {
      const {currentToken: currentToken} = this;
      return {
        index: currentToken === undefined ? 0 : currentToken.start,
        line: this.currLine,
        column: this.currColumn};
    }

    getEndPosition() {
      const token = this.getToken();
      return this.getPositionFromIndex(token.end);
    }

    lookaheadToken(index) {
      return this.lookahead(index).token;
    }

    lookahead(index = this.nextTokenIndex) {
      if (this.isEOF(index)) {
        return {token: this.eofToken, state: this.state};
      }

      const prevNextTokenIndex = this.nextTokenIndex;
      this.nextTokenIndex = index;

      const wasTokenizing = this.tokenizing;
      this.tokenizing = true;

      const nextToken = this.tokenizeWithState(index, this.input, this.state);
      if (nextToken === undefined) {
        throw this.unexpected({
          start: this.getPositionFromIndex(index)});
      }

      this.tokenizing = wasTokenizing;
      this.nextTokenIndex = prevNextTokenIndex;

      return nextToken;
    }

    getPositionFromIndex(index) {
      let line = this.startLine;
      let column = this.startColumn;

      const currPosition = this.getPosition();
      if (currPosition.index < index) {
        line = currPosition.line;
        column = currPosition.column;
        index = index - currPosition.index;
      }

      for (let i = 0; i < index; i++) {
        const char = this.input[i];

        if (char === '\n') {
          line++;
          column = 0;
        } else {
          column++;
        }
      }

      return {
        index: index,
        line: line,
        column: column};
    }

    unexpected(opts = {}) {
      const {currentToken: currentToken} = this;
      let {message: message, start: start, end: end, loc: loc} = opts;

      if (message === undefined) {
        if (currentToken === undefined) {
          message = 'Unexpected token';
        } else {
          message = `Unexpected token ${this.getToken().type}`;
        }
      }

      if (loc !== undefined) {
        start = loc.start;
        end = loc.end;
      }

      if (start === undefined && end === undefined) {
        end = this.getEndPosition();
      }

      if (start === undefined) {
        start = this.getPosition();
      }

      if (end === undefined) {
        end = start;
      }

      if (end.index === 0) {
        end = start;
      }

      throw new ___$romejs$parser_core$src$index_ts$ParserSyntaxError({
        message: message,
        advice: opts.advice,
        name: this.parserName,
        reason: this.reason,
        code: this.filename === undefined ? this.input : undefined,
        start: start,
        end: end,
        filename: this.filename});
    }

    eatToken(type) {
      if (this.matchToken(type)) {
        return this.nextToken();
      }
    }

    isEOF(index = this.nextTokenIndex) {
      return index >= this.input.length;
    }

    matchToken(type) {
      return this.getToken().type === type;
    }

    expectToken(type, message) {
      const token = this.getToken();
      if (token.type === type) {
        this.nextToken();
        return token;
      } else {
        throw this.unexpected({
          message: message === undefined ? `Expected token ${type} but got ${token.type}` : message});
      }
    }

    readInputFrom(index, callback) {
      const {input: input} = this;
      let value = '';

      while (index < input.length && callback(input[index], index, input)) {
        value += input[index];
        index++;
      }

      return value;
    }

    getRawInput(start, end) {
      return this.input.slice(start, end);
    }

    getLoc(node) {
      if (node === undefined || node.loc === undefined) {
        throw new Error('Tried to fetch node loc start but none found');
      } else {
        return node.loc;
      }
    }

    finishToken(type, end = this.nextTokenIndex + 1) {
      return {
        type: type,
        start: this.nextTokenIndex,
        end: end};
    }

    finishValueToken(type, value, end = this.nextTokenIndex + 1) {
      return {
        type: type,
        value: value,
        start: this.nextTokenIndex,
        end: end};
    }

    finishLoc(start) {
      return this.finishLocAt(start, this.getEndPosition());
    }

    finishLocAt(start, end) {
      return {
        filename: this.filename,
        start: start,
        end: end};
    }

    finalize() {
      if (!this.eatToken('EOF')) {
        throw this.unexpected({
          message: 'Expected end of file'});
      }
    }
  }

  function ___$romejs$parser_core$src$index_ts$isDigit(char) {
    return char !== undefined && /[0-9]/.test(char);
  }

  function ___$romejs$parser_core$src$index_ts$isAlpha(char) {
    return char !== undefined && /[A-Za-z]/.test(char);
  }

  function ___$romejs$parser_core$src$index_ts$isHexDigit(char) {
    return char !== undefined && /[0-9A-Fa-f]/.test(char);
  }

  function ___$romejs$parser_core$src$index_ts$isESIdentifier(char) {
    return char !== undefined && /[A-F0-9a-z_$]/.test(char);
  }

  function ___$romejs$parser_core$src$index_ts$isESIdentifierStart(char) {
    return char !== undefined && /[A-Fa-z_$]/.test(char);
  }

  function ___$romejs$parser_core$src$index_ts$isEscaped(index, input) {
    const prevChar = input[index - 1];
    const prevPrevChar = input[index - 2];
    const isEscaped = prevChar === '\\' && prevPrevChar !== '\\';
    return isEscaped;
  }

  // romejs/string-markup/src/parse.ts

  const ___$romejs$string_markup$src$parse_ts = {
    parse: ___$romejs$string_markup$src$parse_ts$parse};
  const ___$$priv$romejs$string_markup$src$parse_ts$tags = new Map();
  ___$$priv$romejs$string_markup$src$parse_ts$tags.set('emphasis', []);
  ___$$priv$romejs$string_markup$src$parse_ts$tags.set('number', []);
  ___$$priv$romejs$string_markup$src$parse_ts$tags.set('hyperlink', ['target']);
  ___$$priv$romejs$string_markup$src$parse_ts$tags.set('filelink', ['filename', 'column', 'line']);
  ___$$priv$romejs$string_markup$src$parse_ts$tags.set('inverse', []);

  function ___$$priv$romejs$string_markup$src$parse_ts$isStringValueChar(char, index, input) {
    if (char === '"' && !___$romejs$parser_core$src$index_ts$isEscaped(index, input)) {
      return false;
    }

    return true;
  }

  function ___$$priv$romejs$string_markup$src$parse_ts$isTextChar(char, index, input) {
    return char !== '<' || ___$romejs$parser_core$src$index_ts$isEscaped(index, input);
  }

  class ___$$priv$romejs$string_markup$src$parse_ts$Parser extends ___$romejs$parser_core$src$index_ts$ParserCore {
    constructor(opts) {
      super(opts, '@romejs/string-markup', {inTagOpenHead: false});
    }

    tokenizeWithState(index, input, state) {
      const escaped = ___$romejs$parser_core$src$index_ts$isEscaped(index, input);
      const char = input[index];

      if (!escaped && state.inTagOpenHead) {
        if (char === ' ') {
          return this.lookahead(index + 1);
        }

        if (char === '=') {
          return {
            state: state,
            token: this.finishToken('Equals')};
        }

        if (char === '/') {
          return {
            state: state,
            token: this.finishToken('Slash')};
        }

        if (___$romejs$parser_core$src$index_ts$isAlpha(char)) {
          const value = this.readInputFrom(index, ___$romejs$parser_core$src$index_ts$isAlpha);
          return {
            state: state,
            token: this.finishValueToken(
            'Word',
            value,
            index + value.length)};
        }

        if (char === '"') {
          const value = this.readInputFrom(index + 1, ___$$priv$romejs$string_markup$src$parse_ts$isStringValueChar);
          const end = index + value.length + 2;

          if (input[end - 1] !== '"') {
            throw this.unexpected({
              message: 'Unclosed string',
              start: this.getPositionFromIndex(end)});
          }

          const unescaped = ___$romejs$string_escape$src$unescapeString_ts$default(value);
          return {
            state: state,
            token: this.finishValueToken('String', unescaped, end)};
        }

        if (char === '>') {
          return {
            state: {
              inTagOpenHead: false},
            token: this.finishToken('Greater')};
        }
      }

      if (!escaped && char === '<') {
        return {
          state: {
            inTagOpenHead: true},
          token: this.finishToken('Less')};
      }

      const value = this.readInputFrom(index, ___$$priv$romejs$string_markup$src$parse_ts$isTextChar);
      return {
        state: state,
        token: {
          type: 'Text',
          value: ___$$priv$romejs$string_markup$src$parse_ts$normalizeTextValue(value),
          start: index,
          end: index + value.length}};
    }

    atTagEnd() {
      return this.matchToken('Less') && this.lookahead().token.type === 'Slash';
    }

    parseTag() {
      const nameToken = this.expectToken('Word');
      if (nameToken.type !== 'Word') {
        throw new Error('Expected Word');
      }
      const rawName = nameToken.value;

      const allowedAttributes = ___$$priv$romejs$string_markup$src$parse_ts$tags.get(rawName);
      if (allowedAttributes === undefined) {
        throw this.unexpected({
          message: `Unknown tag name ${rawName}`,
          start: this.getPositionFromIndex(nameToken.start)});
      }

      const tagName = rawName;
      const attributes = new Map();
      const children = [];
      let selfClosing = false;

      while (!this.matchToken('EOF') && !this.matchToken('Greater')) {
        const keyToken = this.getToken();

        let key;
        if (keyToken.type === 'Word') {
          key = keyToken.value;

          if (!allowedAttributes.includes(key)) {
            throw this.unexpected({
              message: `${key} is not a valid attribute name for <${tagName}>`});
          }

          this.nextToken();

          this.expectToken('Equals');

          const valueToken = this.expectToken('String');
          if (valueToken.type !== 'String') {
            throw new Error('Expected String');
          }
          const value = valueToken.value;

          attributes.set(key, value);
        } else if (keyToken.type === 'Slash') {
          this.nextToken();
          selfClosing = true;
        } else {
          throw this.unexpected({
            message: 'Expected attribute name'});
        }
      }

      this.expectToken('Greater');

      if (!selfClosing) {
        while (!this.matchToken('EOF') && !this.atTagEnd()) {
          children.push(this.parseChild());
        }

        if (this.matchToken('EOF')) {
          throw this.unexpected({
            message: `Unclosed ${tagName} tag`});
        } else {
          this.expectToken('Less');
          this.expectToken('Slash');

          const name = this.getToken();
          if (name.type === 'Word') {
            if (name.value !== tagName) {
              throw this.unexpected({
                message: `Expected to close ${tagName} but found ${name.value}`});
            }

            this.nextToken();
          } else {
            throw this.unexpected({
              message: 'Expected closing tag name'});
          }

          this.expectToken('Greater');
        }
      }

      return {
        type: 'Tag',
        attributes: attributes,
        name: tagName,
        children: children};
    }

    parseChild() {
      const token = this.getToken();
      this.nextToken();

      if (token.type === 'Text') {
        return {
          type: 'Text',
          value: token.value};
      } else if (token.type === 'Less') {
        return this.parseTag();
      } else {
        throw this.unexpected({
          message: 'Unknown child start'});
      }
    }

    parse() {
      const children = [];
      while (!this.matchToken('EOF')) {
        children.push(this.parseChild());
      }
      return children;
    }
  }

  function ___$romejs$string_markup$src$parse_ts$parse(input) {
    try {
      return new ___$$priv$romejs$string_markup$src$parse_ts$Parser({input: input}).parse();
    } catch (err) {
      throw err;
    }
  }

  function ___$$priv$romejs$string_markup$src$parse_ts$normalizeTextValue(str) {
    return str.replace(/\\</g, '<');
  }

  // romejs/string-markup/src/format.ts

  const ___$romejs$string_markup$src$format_ts = {
    markupToAnsi: ___$romejs$string_markup$src$format_ts$markupToAnsi,
    humanizeMarkupFilename: ___$romejs$string_markup$src$format_ts$humanizeMarkupFilename};
  const ___$$priv$romejs$string_markup$src$format_ts$path = require('path');
  function ___$$priv$romejs$string_markup$src$format_ts$formatReduceFromInput(input, callback) {
    return ___$$priv$romejs$string_markup$src$format_ts$formatReduceFromChildren(___$romejs$string_markup$src$parse_ts$parse(input), callback);
  }

  function ___$$priv$romejs$string_markup$src$format_ts$formatReduceFromChildren(children, callback) {
    let buff = '';
    for (const child of children) {
      if (child.type === 'Text') {
        buff += child.value;
      } else if (child.type === 'Tag') {
        buff += callback(
        child.name,
        child.attributes,
        ___$$priv$romejs$string_markup$src$format_ts$formatReduceFromChildren(child.children, callback));
      } else {
        throw new Error('Unknown child node type');
      }
    }
    return buff;
  }

  function ___$romejs$string_markup$src$format_ts$markupToAnsi(input, opts = {}) {
    return ___$$priv$romejs$string_markup$src$format_ts$formatReduceFromInput(input, (tag, attributes, value) => {
      switch (tag) {
        case 'hyperlink':
          return ___$romejs$string_ansi$src$format_ts$formatAnsi.hyperlink(value, attributes.get('target') || value);

        case 'filelink':
          {
            let filename = attributes.get('filename') || '';
            let origFilename = filename;
            if (opts.normalizeFilename !== undefined) {
              filename = opts.normalizeFilename(filename);
            }

            let text = value;

            if (text === '') {
              text = ___$romejs$string_markup$src$format_ts$humanizeMarkupFilename([filename, origFilename], opts);

              const line = attributes.get('line');
              if (line !== undefined) {
                text += `:${line}`;

                const column = attributes.get('column');
                if (column !== undefined) {
                  text += `:${column}`;
                }
              }
            }

            return ___$romejs$string_ansi$src$format_ts$formatAnsi.fileHyperlink(text, filename);
          }

        case 'inverse':
          return ___$romejs$string_ansi$src$format_ts$formatAnsi.inverse(` ${value} `);

        case 'emphasis':
          return ___$romejs$string_ansi$src$format_ts$formatAnsi.bold(value);

        case 'number':
          return ___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(Number(value));

        default:
          throw new Error('Unknown tag name ' + tag);}
    });
  }

  function ___$romejs$string_markup$src$format_ts$humanizeMarkupFilename(filenames, opts = {}) {
    if (filenames.length === 0) {
      return 'unknown';
    }

    const names = [];

    for (const filename of filenames) {
      names.push(filename);

      const home = process.env.HOME;
      if (home != null && filename.startsWith(home + ___$$priv$romejs$string_markup$src$format_ts$path.sep)) {
        const tildify = filename.slice(home.length);

        names.push(___$$priv$romejs$string_markup$src$format_ts$path.join('~', tildify));
      }

      if (opts.cwd !== undefined) {
        names.push(___$$priv$romejs$string_markup$src$format_ts$path.relative(opts.cwd, filename));
      }
    }

    return names.sort((a, b) => a.length - b.length)[0];
  }

  // romejs/string-markup/src/escape.ts

  const ___$romejs$string_markup$src$escape_ts = {
    markup: ___$romejs$string_markup$src$escape_ts$markup,
    escapeMarkup: ___$romejs$string_markup$src$escape_ts$escapeMarkup};
  function ___$romejs$string_markup$src$escape_ts$markup(strs, ...values) {
    let out = '';

    for (let i = 0; i < strs.length; i++) {
      const str = strs[i];
      out += str;

      const interpolated = values[i];
      if (interpolated !== undefined) {
        out += ___$romejs$string_markup$src$escape_ts$escapeMarkup(interpolated);
      }
    }

    return out;
  }

  function ___$romejs$string_markup$src$escape_ts$escapeMarkup(input) {
    let escaped = '';
    for (let i = 0; i < input.length; i++) {
      const char = input[i];

      if (char === '<' && !___$romejs$parser_core$src$index_ts$isEscaped(i, input)) {
        escaped += '\\<';
      } else if (char === '\\' &&
      !___$romejs$parser_core$src$index_ts$isEscaped(i, input) &&
      i === input.length - 1) {
        escaped += '\\\\';
      } else {
        escaped += char;
      }
    }
    return escaped;
  }

  // romejs/string-markup/src/index.ts


  // romejs/core/package.json

  const ___$romejs$core$package_json$default = {'name': '@romejs/core', 'version': '0.0.51', 'private': true, 'main': 'src/index.ts'};

  // romejs/core/src/common/constants.ts

  const ___$romejs$core$src$common$constants_ts = {
    get CHILD_ARGS() {
      return ___$romejs$core$src$common$constants_ts$CHILD_ARGS;
    },
    get BIN() {
      return ___$romejs$core$src$common$constants_ts$BIN;
    },
    get MAP() {
      return ___$romejs$core$src$common$constants_ts$MAP;
    },
    get MAX_MASTER_BYTES_BEFORE_WORKERS() {
      return ___$romejs$core$src$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS;
    },
    get MAX_WORKER_BYTES_BEFORE_ADD() {
      return ___$romejs$core$src$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD;
    },
    get MAX_WORKER_COUNT() {
      return ___$romejs$core$src$common$constants_ts$MAX_WORKER_COUNT;
    },
    get VERSION() {
      return ___$romejs$core$src$common$constants_ts$VERSION;
    },
    get SOCKET_PATH() {
      return ___$romejs$core$src$common$constants_ts$SOCKET_PATH;
    },
    get CLI_SOCKET_PATH() {
      return ___$romejs$core$src$common$constants_ts$CLI_SOCKET_PATH;
    },
    get ROME_CONFIG_FILENAME() {
      return ___$romejs$core$src$common$constants_ts$ROME_CONFIG_FILENAME;
    },
    get ROME_CONFIG_PACKAGE_JSON_KEY() {
      return ___$romejs$core$src$common$constants_ts$ROME_CONFIG_PACKAGE_JSON_KEY;
    },
    get ROME_CONFIG_WARN_FILENAMES() {
      return ___$romejs$core$src$common$constants_ts$ROME_CONFIG_WARN_FILENAMES;
    }};
  const ___$$priv$romejs$core$src$common$constants_ts$path = require('path');
  const ___$$priv$romejs$core$src$common$constants_ts$os = require('os');
  const ___$romejs$core$src$common$constants_ts$CHILD_ARGS = ['--max-old-space-size=8192'];

  const ___$romejs$core$src$common$constants_ts$BIN = process.mainModule.filename;
  const ___$romejs$core$src$common$constants_ts$MAP = `${___$romejs$core$src$common$constants_ts$BIN}.map`;

  const ___$$priv$romejs$core$src$common$constants_ts$MEGABYTE = 10000;

  const ___$romejs$core$src$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS = 0.5 * ___$$priv$romejs$core$src$common$constants_ts$MEGABYTE;

  const ___$romejs$core$src$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD = 1 * ___$$priv$romejs$core$src$common$constants_ts$MEGABYTE;

  const ___$$priv$romejs$core$src$common$constants_ts$CPU_COUNT = ___$$priv$romejs$core$src$common$constants_ts$os.cpus().length;
  const ___$romejs$core$src$common$constants_ts$MAX_WORKER_COUNT = Math.min(___$$priv$romejs$core$src$common$constants_ts$CPU_COUNT, 4);

  const ___$romejs$core$src$common$constants_ts$VERSION = String(___$romejs$core$package_json$default.version);

  const ___$romejs$core$src$common$constants_ts$SOCKET_PATH = ___$$priv$romejs$core$src$common$constants_ts$path.join(___$$priv$romejs$core$src$common$constants_ts$os.tmpdir(), `rome-${___$romejs$core$src$common$constants_ts$VERSION}.sock`);

  const ___$romejs$core$src$common$constants_ts$CLI_SOCKET_PATH = ___$$priv$romejs$core$src$common$constants_ts$path.join(
  ___$$priv$romejs$core$src$common$constants_ts$os.tmpdir(),
  `rome-wait-${___$romejs$core$src$common$constants_ts$VERSION}.sock`);

  const ___$romejs$core$src$common$constants_ts$ROME_CONFIG_FILENAME = 'rome.rjson';

  const ___$romejs$core$src$common$constants_ts$ROME_CONFIG_PACKAGE_JSON_KEY = 'rome';

  const ___$romejs$core$src$common$constants_ts$ROME_CONFIG_WARN_FILENAMES = ['.romeconfig', '.romerc', '.rome.json', '.rome.rjson', 'rome.json'];

  // romejs/cli-diagnostics/src/types.ts

  const ___$romejs$cli_diagnostics$src$types_ts = {};

  // romejs/cli-reporter/src/util.ts

  const ___$$priv$romejs$cli_reporter$src$util_ts$readline = require('readline');
  const ___$$priv$romejs$cli_reporter$src$util_ts$CLEAR_WHOLE_LINE = 0;
  const ___$$priv$romejs$cli_reporter$src$util_ts$CLEAR_RIGHT_OF_CURSOR = 1;

  function ___$romejs$cli_reporter$src$util_ts$getColumns(stdout) {
    return typeof stdout.columns === 'number' ? stdout.columns : 100;
  }

  function ___$romejs$cli_reporter$src$util_ts$clearLine(stdout) {
    ___$$priv$romejs$cli_reporter$src$util_ts$readline.clearLine(stdout, ___$$priv$romejs$cli_reporter$src$util_ts$CLEAR_WHOLE_LINE);
    ___$$priv$romejs$cli_reporter$src$util_ts$readline.cursorTo(stdout, 0);
  }

  function ___$romejs$cli_reporter$src$util_ts$toStartOfLine(stdout) {
    ___$$priv$romejs$cli_reporter$src$util_ts$readline.cursorTo(stdout, 0);
  }

  function ___$romejs$cli_reporter$src$util_ts$writeOnNthLine(stdout, n, msg) {
    if (n === 0) {
      ___$$priv$romejs$cli_reporter$src$util_ts$readline.cursorTo(stdout, 0);
      stdout.write(msg);
      ___$$priv$romejs$cli_reporter$src$util_ts$readline.clearLine(stdout, ___$$priv$romejs$cli_reporter$src$util_ts$CLEAR_RIGHT_OF_CURSOR);
      return undefined;
    }

    ___$$priv$romejs$cli_reporter$src$util_ts$readline.cursorTo(stdout, 0);
    ___$$priv$romejs$cli_reporter$src$util_ts$readline.moveCursor(stdout, 0, -n);
    stdout.write(msg);
    ___$$priv$romejs$cli_reporter$src$util_ts$readline.clearLine(stdout, ___$$priv$romejs$cli_reporter$src$util_ts$CLEAR_RIGHT_OF_CURSOR);
    ___$$priv$romejs$cli_reporter$src$util_ts$readline.cursorTo(stdout, 0);
    ___$$priv$romejs$cli_reporter$src$util_ts$readline.moveCursor(stdout, 0, n);
  }

  function ___$romejs$cli_reporter$src$util_ts$clearNthLine(stdout, n) {
    if (n === 0) {
      ___$romejs$cli_reporter$src$util_ts$clearLine(stdout);
      return undefined;
    }

    ___$$priv$romejs$cli_reporter$src$util_ts$readline.cursorTo(stdout, 0);
    ___$$priv$romejs$cli_reporter$src$util_ts$readline.moveCursor(stdout, 0, -n);
    ___$$priv$romejs$cli_reporter$src$util_ts$readline.clearLine(stdout, ___$$priv$romejs$cli_reporter$src$util_ts$CLEAR_WHOLE_LINE);
    ___$$priv$romejs$cli_reporter$src$util_ts$readline.moveCursor(stdout, 0, n);
  }

  // romejs/cli-reporter/src/Progress.ts

  const ___$$priv$romejs$cli_reporter$src$Progress_ts$BOUNCER_INTERVAL = 50;
  const ___$$priv$romejs$cli_reporter$src$Progress_ts$BOUNCER_WIDTH = 15;

  class ___$romejs$cli_reporter$src$Progress_ts$default {
    constructor(reporter, onEnd) {
      this.reporter = reporter;
      this.stdout = reporter.stdout;

      this.textStack = [];
      this.text = undefined;
      this.title = undefined;

      this.startTime = Date.now();
      this.lastRenderTime = Date.now();
      this.lastRenderCurrent = 0;

      this.open = true;
      this.current = 0;
      this.total = undefined;
      this.onEnd = onEnd;

      this.delay = 60;
      this.renderEvery = 0;
      ___$romejs$cli_reporter$src$util_ts$clearLine(reporter.stdout);

      this.bounceStart = 0;
      this.startBouncer();

      this.queueRender();
    }

    getElapsedTime() {
      return Date.now() - this.startTime;
    }

    startBouncer() {
      let direction = 'left-to-right';
      let start = 0;

      const tick = () => {
        const end = this.reporter.getColumns() - ___$$priv$romejs$cli_reporter$src$Progress_ts$BOUNCER_WIDTH;

        if (direction === 'left-to-right') {
          start++;

          if (start > end) {
            direction = 'right-to-left';
            start = end - 1;
          }
        }

        if (direction === 'right-to-left') {
          start--;

          if (start <= 0) {
            direction = 'left-to-right';
            start = 0;
          }
        }

        this.bounceStart = start;
        this.bouncerTimer = setTimeout(tick, ___$$priv$romejs$cli_reporter$src$Progress_ts$BOUNCER_INTERVAL);
        this.render();
      };

      this.bouncerTimer = setTimeout(tick, ___$$priv$romejs$cli_reporter$src$Progress_ts$BOUNCER_INTERVAL);
    }

    setCurrent(current) {
      if (this.open === false) {
        return undefined;
      }

      this.current = current;

      if (this.renderTimer === undefined) {
        this.queueRender();
      }

      if (this.isRenderDue()) {
        this.render();
      }

      if (this.total !== undefined && this.current >= this.total) {
        this.end();
      }
    }

    setTotal(total) {
      this.total = total;
      this.renderEvery = Math.round(total / 100);
      this.endBouncer();
      this.queueRender();
    }

    setTitle(title) {
      this.title = title;
      this.queueRender();
    }

    setText(text) {
      this.assertOpen();
      this.text = text;
      this.queueRender();
    }

    pushText(text) {
      this.setText(text);
      this.textStack.push(text);
    }

    popText(text) {
      const {textStack: textStack} = this;
      const index = textStack.indexOf(text);
      if (index === -1) {
        throw new Error(`No pushed text: ${text}`);
      }

      textStack.splice(index, 1);

      const last = textStack[textStack.length - 1];
      this.setText(last === undefined ? '' : last);
    }

    tick() {
      this.setCurrent(this.current + 1);
    }

    isOpen() {
      return this.open;
    }

    assertOpen() {
      if (this.open === false) {
        throw new Error('Progress bar has already been closed');
      }
    }

    queueRender() {
      if (this.open === false) {
        return undefined;
      }

      if (this.renderTimer !== undefined) {
        return undefined;
      }

      this.renderTimer = setTimeout(() => {
        this.render();
      }, this.delay);
    }

    endBouncer() {
      if (this.bouncerTimer !== undefined) {
        clearTimeout(this.bouncerTimer);
      }
      this.bouncerTimer = undefined;
    }

    endRender() {
      if (this.renderTimer !== undefined) {
        clearTimeout(this.renderTimer);
      }
      this.renderTimer = undefined;
    }

    end() {
      this.open = false;
      this.endBouncer();
      this.endRender();
      this.clear();

      if (this.onEnd !== undefined) {
        this.onEnd();
      }
    }

    clear() {
      ___$romejs$cli_reporter$src$util_ts$clearLine(this.stdout);
    }

    isRenderDue() {
      const isDue = this.current > this.lastRenderCurrent + this.renderEvery;
      if (isDue) {
        const timeSinceLastRender = Date.now() - this.lastRenderTime;
        return timeSinceLastRender > 1000;
      } else {
        return false;
      }
    }

    isBoldCharacter(i, ranges) {
      for (const [start, end] of ranges) {
        if (start >= i && end <= i) {
          return true;
        }
      }

      return false;
    }

    splitCharacters(str, boldRanges) {
      return str.split('').map((char, i) => {
        if (this.isBoldCharacter(i, boldRanges)) {
          return [i, ___$romejs$string_ansi$src$format_ts$formatAnsi.bold(char)];
        } else {
          return [i, char];
        }
      });
    }

    buildProgressBouncer(bar) {
      let start = this.bounceStart;
      let fullBar = '';
      for (const [i, char] of bar) {
        const isBounce = i >= start && i < start + ___$$priv$romejs$cli_reporter$src$Progress_ts$BOUNCER_WIDTH;

        if (isBounce) {
          fullBar += ___$romejs$string_ansi$src$format_ts$formatAnsi.white(___$romejs$string_ansi$src$format_ts$formatAnsi.bgYellow(char));
        } else {
          fullBar += char;
        }
      }
      return fullBar;
    }

    buildProgressBar(bar, total) {
      const ratio = Math.min(Math.max(this.current / total, 0), 1);

      const completeLength = Math.round(this.reporter.getColumns() * ratio);
      let fullBar = '';
      for (const [i, char] of bar) {
        if (i < completeLength) {
          fullBar += ___$romejs$string_ansi$src$format_ts$formatAnsi.white(___$romejs$string_ansi$src$format_ts$formatAnsi.bgGreen(char));
        } else {
          fullBar += char;
        }
      }
      return fullBar;
    }

    buildBar() {
      const {total: total, current: current, text: text, title: title} = this;

      const boldRanges = [];

      let prefix = ' ';
      if (title !== undefined) {
        prefix += title;

        boldRanges.push([0, prefix.length - 1]);
      }
      if (text !== undefined) {
        if (title !== undefined) {
          prefix += ': ';
        }
        prefix += text;
      }
      prefix += ' ';

      let suffix = '';

      if (current > 0) {
        const elapsed = this.getElapsedTime();

        const averagePer = current / elapsed;

        const perSecond = Math.round(averagePer * 1000);

        suffix += `${___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(perSecond)} op/s `;
        suffix += `elapsed ${___$romejs$string_utils$src$humanizeTime_ts$humanizeTime(elapsed)} `;

        if (total !== undefined) {
          const left = total - current;

          const eta = left * averagePer;
          suffix += `eta ${___$romejs$string_utils$src$humanizeTime_ts$humanizeTime(eta)} `;
        }
      }

      suffix += `${___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(current)}`;
      if (total !== undefined) {
        suffix += `/${___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(total)}`;
      }
      suffix += ' ';

      const width = this.reporter.getColumns();

      const spacerLength = Math.max(0, width - prefix.length - suffix.length);

      prefix = prefix.slice(0, width - suffix.length);

      const raw = prefix + ' '.repeat(spacerLength) + suffix;

      boldRanges.push([raw.length - suffix.length, raw.length - 1]);

      const chars = this.splitCharacters(raw, boldRanges);

      if (total === undefined) {
        return this.buildProgressBouncer(chars);
      } else {
        return this.buildProgressBar(chars, total);
      }
    }

    render() {
      this.assertOpen();
      this.endRender();

      this.lastRenderCurrent = this.current;
      this.lastRenderTime = Date.now();

      ___$romejs$cli_reporter$src$util_ts$toStartOfLine(this.stdout);
      this.stdout.write(this.buildBar());
    }
  }

  // romejs/cli-reporter/src/Spinner.ts

  const ___$$priv$romejs$cli_reporter$src$Spinner_ts$SPINNER_FRAMES = '\u280b\u2819\u2839\u2838\u283c\u2834\u2826\u2827\u2807\u280f'.split('');
  const ___$$priv$romejs$cli_reporter$src$Spinner_ts$SPINNER_INTERVAL = 80;

  class ___$romejs$cli_reporter$src$Spinner_ts$default {
    constructor(reporter, lineNumber = 0) {
      this.currentFrame = 0;
      this.prefix = '';
      this.lineNumber = lineNumber;
      this.reporter = reporter;
      this.stdout = reporter.stdout;
      this.text = '';
      this.intervalTimer = undefined;
      this.paused = false;
      this.lastRenderedLine = '';
      this.lastRenderTime = 0;
    }

    setPrefix(prefix) {
      this.prefix = prefix;
      this.render();
    }

    setText(text) {
      this.text = text;
      this.render();
    }

    start() {
      this.currentFrame = 0;
      this.render();
    }

    resume() {
      this.paused = false;
    }

    pause() {
      this.paused = true;
    }

    clearTimeout() {
      if (this.intervalTimer !== undefined) {
        clearTimeout(this.intervalTimer);
      }
    }

    clear() {
      this.lastRenderedLine = '';
      ___$romejs$cli_reporter$src$util_ts$clearNthLine(this.stdout, this.lineNumber);
    }

    render() {
      const now = Date.now();
      if (this.lastRenderTime + ___$$priv$romejs$cli_reporter$src$Spinner_ts$SPINNER_INTERVAL > now) {
        return undefined;
      }

      this.clearTimeout();

      let spinnerFrame = ___$$priv$romejs$cli_reporter$src$Spinner_ts$SPINNER_FRAMES[this.currentFrame];

      let msg = `${this.prefix}${spinnerFrame} ${this.text}`;

      const columns = ___$romejs$cli_reporter$src$util_ts$getColumns(this.stdout);
      msg = msg.slice(0, columns);

      if (msg === this.lastRenderedLine) {
        this.queue();
        return undefined;
      } else {
        this.lastRenderedLine = msg;
        this.lastRenderTime = now;
      }

      ___$romejs$cli_reporter$src$util_ts$writeOnNthLine(this.stdout, this.lineNumber, msg);

      if (this.paused === false) {
        this.currentFrame = ++this.currentFrame % ___$$priv$romejs$cli_reporter$src$Spinner_ts$SPINNER_FRAMES.length;
      }

      this.queue();
    }

    queue() {
      this.intervalTimer = setTimeout(
      () => this.render(),
      ___$$priv$romejs$cli_reporter$src$Spinner_ts$SPINNER_INTERVAL);
    }

    stop() {
      this.pause();
      this.clearTimeout();
      this.clear();
    }
  }

  // romejs/cli-reporter/src/spinnerGroup.ts

  const ___$$priv$romejs$cli_reporter$src$spinnerGroup_ts$readline = require('readline');
  function ___$romejs$cli_reporter$src$spinnerGroup_ts$default(reporter, total, workers) {
    const spinners = [];

    let hasClearScreen = reporter.hasClearScreen;

    for (let i = 1; i < workers; i++) {
      reporter.stderr.write('\n');
    }

    reporter.stderr.write('\n');
    const progress = reporter.progress();
    progress.setTotal(total);

    let largestCurrentPad = 0;
    let largestTotalPad = 0;
    const updatePrefixes = [];
    function updateAllPrefixes() {
      for (const updatePrefix of updatePrefixes) {
        updatePrefix();
      }
    }

    if (hasClearScreen) {
      reporter.hasClearScreen = true;
    }

    for (let i = 0; i < workers; i++) {
      const spinner = new ___$romejs$cli_reporter$src$Spinner_ts$default(reporter, i + 1);
      spinner.start();

      let prefix = undefined;
      let total = 0;
      let current = 0;
      const updatePrefix = () => {
        const currentStr = current === 0 ? '-' : ___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(current);
        const totalStr = total === 0 ? '-' : ___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(total);
        const fullStr = `${___$romejs$string_ansi$src$pad_ts$leftPad(
        currentStr,
        largestCurrentPad)}/${___$romejs$string_ansi$src$pad_ts$rightPad(totalStr, largestTotalPad)}`;
        const brackets = `[${fullStr}]`;
        spinner.setPrefix(`${___$romejs$string_ansi$src$format_ts$formatAnsi.dim(brackets)} `);
      };
      updatePrefixes.push(updatePrefix);
      const clear = () => {
        prefix = undefined;
        current = 0;
        updatePrefix();
        spinner.setText('Waiting...');
      };
      clear();

      spinners.unshift({
        clear: clear,

        tick() {
          current++;
          updatePrefix();
        },

        setCurrent(newCurrent) {
          current = newCurrent;

          const ourCurrentPad = ___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(current).length;
          if (ourCurrentPad > largestCurrentPad) {
            largestCurrentPad = ourCurrentPad;
            updateAllPrefixes();
          } else {
            updatePrefix();
          }
        },

        setTotal(newTotal) {
          total = newTotal;

          const ourTotalPad = ___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(total).length;
          if (ourTotalPad > largestTotalPad) {
            largestTotalPad = ourTotalPad;
            updateAllPrefixes();
          } else {
            updatePrefix();
          }
        },

        setPrefix(_prefix) {
          prefix = _prefix;
          spinner.setText(prefix);
          updatePrefix();
        },

        setText(msg) {
          if (prefix !== undefined) {
            msg = `${prefix}: ${msg}`;
          }
          spinner.setText(msg);
        },

        resume() {
          spinner.resume();
        },

        pause() {
          spinner.pause();
        },

        end() {
          spinner.stop();
        }});
    }

    const spinnerGroup = {
      setText(text) {
        progress.setText(text);
      },

      setCurrent(current) {
        progress.setCurrent(current);
      },

      setTotal(total) {
        progress.setTotal(total);
      },

      tick() {
        progress.tick();
      },

      end: () => {
        reporter.activeElements.delete(spinnerGroup);
        progress.end();
        for (const spinner of spinners) {
          spinner.end();
        }
        ___$$priv$romejs$cli_reporter$src$spinnerGroup_ts$readline.moveCursor(reporter.stderr, 0, -workers);
      },

      spinners: spinners};
    reporter.activeElements.add(spinnerGroup);
    return spinnerGroup;
  }

  // romejs/cli-reporter/src/Reporter.ts

  const ___$$priv$romejs$cli_reporter$src$Reporter_ts$tty = require('tty');
  const ___$$priv$romejs$cli_reporter$src$Reporter_ts$stream = require('stream');
  const ___$$priv$romejs$cli_reporter$src$Reporter_ts$NOOP_SPINNER = {
    resume() {},
    pause() {},
    render() {},
    setText() {},
    end() {}};

  const ___$$priv$romejs$cli_reporter$src$Reporter_ts$INDENT = '  ';

  function ___$$priv$romejs$cli_reporter$src$Reporter_ts$indentMessage(msg, level) {
    if (level === 0) {
      return msg;
    } else {
      const indent = ___$$priv$romejs$cli_reporter$src$Reporter_ts$INDENT.repeat(level);
      return indent + msg.replace(/\n/g, '\n' + indent);
    }
  }

  function ___$$priv$romejs$cli_reporter$src$Reporter_ts$createNoopStream() {
    return new ___$$priv$romejs$cli_reporter$src$Reporter_ts$stream.Writable({
      write: (chunk, encoding, callback) => {
        callback();
      }});
  }

  class ___$romejs$cli_reporter$src$Reporter_ts$default {
    constructor(opts = {}) {
      this.programName =
      opts.programName === undefined ? 'rome' : opts.programName;
      this.programVersion = opts.programVersion;

      this.stdout = opts.stdout === undefined ? ___$$priv$romejs$cli_reporter$src$Reporter_ts$createNoopStream() : opts.stdout;
      this.stderr = opts.stderr === undefined ? ___$$priv$romejs$cli_reporter$src$Reporter_ts$createNoopStream() : opts.stderr;

      this.noProgress = process.env.CI === '1';
      this.isJSON = opts.json === true;
      this.isVerbose = Boolean(opts.verbose);
      this.isTTY =
      opts.isTTY === true ||
      this.stdout instanceof ___$$priv$romejs$cli_reporter$src$Reporter_ts$tty.WriteStream && this.stdout.isTTY;

      if (opts.silent === true) {
        this.stdout = ___$$priv$romejs$cli_reporter$src$Reporter_ts$createNoopStream();
      }

      this.startTime = opts.startTime === undefined ? Date.now() : opts.startTime;
      this.hasClearScreen = true;
      this.activeElements = new Set();
      this.indentLevel = 0;
      this.enabled = opts.disabled === true ? 0 : 1;
      this.markupOptions =
      opts.markupOptions === undefined ? {} : opts.markupOptions;
    }

    static fromProcess(opts = {}) {
      return new ___$romejs$cli_reporter$src$Reporter_ts$default(Object.assign({
        stdout: process.stdout,
        stderr: process.stderr}, opts, {
        markupOptions: Object.assign({
          cwd: process.cwd()}, opts.markupOptions)}));
    }

    getColumns() {
      return ___$romejs$cli_reporter$src$util_ts$getColumns(this.stdout);
    }

    isEnabled() {
      return this.enabled > 0;
    }

    enable() {
      let alreadyDisabled = false;

      this.enabled++;

      return () => {
        if (alreadyDisabled) {
          throw new Error('Already disabled Reporter');
        }

        this.enabled--;
        alreadyDisabled = true;
      };
    }

    json(msg) {
      if (this.isJSON) {
        const data = JSON.stringify(msg);
        this.stdout.write(`${String(data.length)}${data}`);
        return true;
      } else {
        return false;
      }
    }

    teardown() {
      for (const elem of this.activeElements) {
        elem.end();
      }
      this.activeElements.clear();
    }

    fork(opts = {}) {
      return new ___$romejs$cli_reporter$src$Reporter_ts$default(Object.assign({
        stdout: this.stdout,
        stderr: this.stderr,
        json: this.isJSON,
        isTTY: this.isTTY,
        verbose: this.isVerbose,
        markupOptions: this.markupOptions}, opts));
    }

    indent() {
      this.indentLevel++;
    }

    dedent() {
      this.indentLevel--;
    }

    prependEmoji(msg, emoji, fallback) {
      if (this.isTTY) {
        if (fallback === undefined) {
          return msg;
        } else {
          return `${fallback} ${msg}`;
        }
      } else {
        return `${emoji} ${msg}`;
      }
    }

    table(head, rawBody) {
      head = head.map(
      field => ___$romejs$string_ansi$src$format_ts$formatAnsi.bold(___$romejs$string_ansi$src$format_ts$formatAnsi.underline(field)));

      const rows = [head];
      for (const row of rawBody) {
        rows.push(
        row.map(field => {
          if (typeof field === 'number') {
            return ___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(field);
          } else {
            return field;
          }
        }));
      }

      const cols = [];
      for (let i = 0; i < head.length; i++) {
        const widths = rows.map(row => ___$romejs$string_ansi$src$format_ts$stripAnsi(row[i]).length);
        cols[i] = Math.max(...widths);
      }

      const builtRows = rows.map(
      row => {
        for (let i = 0; i < row.length; i++) {
          const field = row[i];
          const padding = cols[i] - ___$romejs$string_ansi$src$format_ts$stripAnsi(field).length;

          row[i] = field + ' '.repeat(padding);
        }
        return row.join(' ');
      });

      this.log(builtRows.join('\n'));
    }

    verboseInspect(val) {
      if (this.isVerbose) {
        this.inspect(val);
      }
    }

    inspect(value) {
      if (typeof value !== 'number' && typeof value !== 'string') {
        value = ___$romejs$pretty_format$src$index_ts$default(value, {color: true});
      }

      this._log(String(value));
    }

    clearLine(stdout) {
      if (this.isTTY) {
        ___$romejs$cli_reporter$src$util_ts$clearLine(stdout);
      }
    }

    write(msg) {
      if (this.isJSON || !this.isEnabled()) {
        return undefined;
      }

      this.hasClearScreen = false;
      this.clearLine(this.stdout);
      this.stdout.write(msg);
    }

    getTotalTime() {
      return Date.now() - this.startTime;
    }

    clear() {
      if (this.isJSON) {
        return undefined;
      }

      this.stdout.write(___$romejs$string_ansi$src$escapes_ts$escapes.clearScreen);
      this.hasClearScreen = true;
    }

    heading(text) {
      this.log(___$romejs$string_ansi$src$format_ts$formatAnsi.inverse(___$romejs$string_ansi$src$format_ts$formatAnsi.bold(` ${text} `)));
      this.spacer();
    }

    header(command) {
      let msg = `${this.programName} ${command}`;
      if (this.programVersion !== undefined) {
        msg += ` v${this.programVersion}`;
      }
      this.log(___$romejs$string_ansi$src$format_ts$formatAnsi.bold(msg));
    }

    footer() {
      const totalTime = (this.getTotalTime() / 1000).toFixed(2);
      const msg = `Done in ${totalTime}s.`;
      this.log(this.prependEmoji(msg, '\u2728'));
    }

    hr(text) {
      this.spacer();

      if (this.hasClearScreen) {
        return undefined;
      }

      const len = this.getColumns();
      const prefix = text === undefined ? '' : `${text} `;
      this.log(prefix + '\u2501'.repeat(len - prefix.length));
      this.spacer();
    }

    step(current, total, msg) {
      if (msg.endsWith('?')) {
        msg = `${___$romejs$string_utils$src$removeSuffix_ts$removeSuffix(msg, '?')}...?`;
      } else {
        msg += '...';
      }

      this.log(`${___$romejs$string_ansi$src$format_ts$formatAnsi.dim(`[${current}/${total}]`)} ${msg}`);
    }

    spacer() {
      this.log('');
    }

    markupify(str) {
      return ___$romejs$string_markup$src$format_ts$markupToAnsi(str, this.markupOptions);
    }

    log(msg) {
      const formatted = this.markupify(msg);
      this._log(formatted);
    }

    _log(msg) {
      this.write(___$$priv$romejs$cli_reporter$src$Reporter_ts$indentMessage(msg, this.indentLevel) + '\n');
    }

    formatLogCategory(opts) {
      if (!this.isEnabled()) {
        return {outer: '', inner: ''};
      }

      const {message: message, args: args, prefix: prefix} = opts;

      let formatted = ___$romejs$invariant$src$index_ts$interpolateMessage(message, args);

      formatted = this.markupify(formatted);

      if (this.stdout instanceof ___$$priv$romejs$cli_reporter$src$Reporter_ts$tty.WriteStream) {
        const width = this.stdout.columns;
        const allowedWidth = width - prefix.length - ___$$priv$romejs$cli_reporter$src$Reporter_ts$INDENT.length * this.indentLevel;
        if (___$romejs$string_ansi$src$format_ts$stripAnsi(formatted).length > allowedWidth) {
          const lines = ___$romejs$string_ansi$src$split_ts$splitAnsiLines(formatted, allowedWidth);
          formatted = String(lines.shift());

          for (const line of lines) {
            formatted += '\n' + ' '.repeat(prefix.length) + line;
          }
        }
      }

      if (___$romejs$string_ansi$src$format_ts$hasAnsiColor(message)) {
        return {inner: prefix, outer: formatted};
      } else {
        return {inner: prefix + formatted, outer: ''};
      }
    }

    success(msg, ...args) {
      const {outer: outer, inner: inner} = this.formatLogCategory({
        prefix: '\u2714 ',
        message: msg,
        args: args});
      this._log(___$romejs$string_ansi$src$format_ts$formatAnsi.green(inner) + outer);
    }

    error(msg, ...args) {
      this.clearLine(this.stderr);

      const {outer: outer, inner: inner} = this.formatLogCategory({
        message: msg,
        args: args,
        prefix: '\u2716 '});
      const formatted = ___$romejs$string_ansi$src$format_ts$formatAnsi.red(inner) + outer;
      const indented = ___$$priv$romejs$cli_reporter$src$Reporter_ts$indentMessage(formatted, this.indentLevel);
      this.stderr.write(indented + '\n');
    }

    errorObj(err) {
      this.error(err.stack || err.message || err.name || 'Unknown Error');
    }

    question(msg, ...args) {
      const {outer: outer, inner: inner} = this.formatLogCategory({
        prefix: '\u2753 ',
        message: msg,
        args: args});
      this._log(___$romejs$string_ansi$src$format_ts$formatAnsi.magenta(inner) + outer);
    }

    info(msg, ...args) {
      const {outer: outer, inner: inner} = this.formatLogCategory({
        prefix: '\u2139 ',
        message: msg,
        args: args});
      this._log(___$romejs$string_ansi$src$format_ts$formatAnsi.blue(inner) + outer);
    }

    warn(msg, ...args) {
      this.clearLine(this.stderr);
      const {outer: outer, inner: inner} = this.formatLogCategory({
        prefix: '\u26a0 ',
        message: msg,
        args: args});
      this.stderr.write(___$romejs$string_ansi$src$format_ts$formatAnsi.yellow(inner) + outer + '\n');
    }

    verbose(msg, ...args) {
      if (this.isVerbose) {
        const {outer: outer, inner: inner} = this.formatLogCategory({
          prefix: '\u26a1 ',
          message: msg,
          args: args});
        this._log(___$romejs$string_ansi$src$format_ts$formatAnsi.brightBlack(inner) + outer);
      }
    }

    command(command) {
      this._log(___$romejs$string_ansi$src$format_ts$formatAnsi.dim(`$ ${command}`));
    }

    list(items) {
      for (const item of items) {
        this.log(`  ${___$romejs$string_ansi$src$format_ts$formatAnsi.dim('-')} ${item}`);
      }
    }

    orderedList(items, reverse = false) {
      let numLen = String(items.length).length + 1;

      let nums = [];
      for (let i = 0; i < items.length; i++) {
        nums.push(i);
      }
      if (reverse) {
        nums = nums.reverse();
      }

      for (const i of nums) {
        const num = ___$romejs$string_ansi$src$pad_ts$rightPad(String(i + 1) + '.', numLen);
        const val = items[i];
        this.log(`  ${___$romejs$string_ansi$src$format_ts$formatAnsi.dim(num)} ${val}`);
      }
    }

    spinnerGroup(total, workers) {
      if (!this.isTTY || this.noProgress) {
        return {
          spinners: Array(workers).fill({
            clear() {},
            resume() {},
            tick() {},
            pause() {},
            setCurrent() {},
            setTotal() {},
            setPrefix() {},
            setText() {},
            end() {}}),
          setTotal() {},
          setCurrent() {},
          setText() {},
          tick() {},
          end() {}};
      }

      return ___$romejs$cli_reporter$src$spinnerGroup_ts$default(this, total, workers);
    }

    spinner() {
      if (!this.isTTY || this.noProgress) {
        return ___$$priv$romejs$cli_reporter$src$Reporter_ts$NOOP_SPINNER;
      }

      const spinner = new ___$romejs$cli_reporter$src$Spinner_ts$default(this);
      spinner.start();

      const activity = {
        render() {
          spinner.render();
        },

        resume() {
          spinner.resume();
        },

        pause() {
          spinner.pause();
        },

        setText(name) {
          spinner.setText(name);
        },

        end: () => {
          this.activeElements.delete(activity);
          spinner.stop();
        }};
      this.activeElements.add(activity);
      return activity;
    }

    progress() {
      const bar = new ___$romejs$cli_reporter$src$Progress_ts$default(this, () => {
        this.activeElements.delete(bar);
      });
      this.activeElements.add(bar);
      return bar;
    }
  }

  // romejs/cli-reporter/src/types.ts

  const ___$romejs$cli_reporter$src$types_ts = {};
  const ___$$priv$romejs$cli_reporter$src$types_ts$stream = require('stream');

  // romejs/cli-reporter/src/constants.ts

  const ___$romejs$cli_reporter$src$constants_ts = {
    get JSON_START() {
      return ___$romejs$cli_reporter$src$constants_ts$JSON_START;
    },
    get JSON_END() {
      return ___$romejs$cli_reporter$src$constants_ts$JSON_END;
    }};
  const ___$romejs$cli_reporter$src$constants_ts$JSON_START = {
    type: 'START'};

  const ___$romejs$cli_reporter$src$constants_ts$JSON_END = {
    type: 'END'};

  // romejs/cli-reporter/src/ReporterCollection.ts

  const ___$$priv$romejs$cli_reporter$src$ReporterCollection_ts$stream = require('stream');
  function ___$$priv$romejs$cli_reporter$src$ReporterCollection_ts$createRedirectStream(streams) {
    return new ___$$priv$romejs$cli_reporter$src$ReporterCollection_ts$stream.Writable({
      write: (chunk, encoding, callback) => {
        let remaining = streams.size;

        function done() {
          remaining--;

          if (remaining === 0) {
            callback();
          }
        }

        for (const stream of streams) {
          stream.write(chunk, encoding, done);
        }
      }});
  }

  class ___$romejs$cli_reporter$src$ReporterCollection_ts$default extends ___$romejs$cli_reporter$src$Reporter_ts$default {
    constructor(opts = {}) {
      super(Object.assign({}, opts, {
        disabled: true}));

      this.reporters = new Set();
      this.stdouts = new Set();
      this.stderrs = new Set();

      this.stdout = ___$$priv$romejs$cli_reporter$src$ReporterCollection_ts$createRedirectStream(this.stdouts);
      this.stderr = ___$$priv$romejs$cli_reporter$src$ReporterCollection_ts$createRedirectStream(this.stderrs);
    }

    isEnabled() {
      return this.reporters.size > 0;
    }

    addReporter(reporter) {
      this.reporters.add(reporter);
      this.stdouts.add(reporter.stdout);
      this.stderrs.add(reporter.stderr);
    }

    deleteReporter(reporter) {
      this.reporters.delete(reporter);
      this.stdouts.delete(reporter.stdout);
      this.stderrs.delete(reporter.stderr);
    }
  }

  // romejs/cli-reporter/src/index.ts


  // romejs/cli-diagnostics/src/ansiHighlightCode.ts

  function ___$romejs$cli_diagnostics$src$ansiHighlightCode_ts$default(input) {
    return input;
  }

  // romejs/cli-diagnostics/src/utils.ts

  const ___$$priv$romejs$cli_diagnostics$src$utils_ts$NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

  function ___$romejs$cli_diagnostics$src$utils_ts$showInvisibles(str) {
    let ret = '';
    for (const cha of str) {
      switch (cha) {
        case ' ':
          ret += '\xb7';
          break;
        case '\n':
          ret += '\u23ce\n';
          break;
        case '\t':
          ret += '\u21b9';
          break;
        default:
          ret += cha;
          break;}
    }
    return ret;
  }

  function ___$romejs$cli_diagnostics$src$utils_ts$cleanEquivalentString(str) {
    str = ___$romejs$string_ansi$src$format_ts$stripAnsi(str);

    str = str.replace(/[\s\n]+/g, ' ');

    str = str.replace(/\.+$/, '');

    str = str.replace(/^"(.*?)"$/, '$1');

    return str;
  }

  function ___$romejs$cli_diagnostics$src$utils_ts$splitLines(src) {
    return src.replace(/\t/g, ' ').split(___$$priv$romejs$cli_diagnostics$src$utils_ts$NEWLINE);
  }

  function ___$romejs$cli_diagnostics$src$utils_ts$toLines(src) {
    const highlighted = ___$romejs$cli_diagnostics$src$ansiHighlightCode_ts$default(src);
    const lines = ___$romejs$cli_diagnostics$src$utils_ts$splitLines(highlighted);
    return lines;
  }

  // romejs/string-diff/src/index.ts

  const ___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE = -1;
  const ___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT = 1;
  const ___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL = 0;
  const ___$romejs$string_diff$src$index_ts$constants = {
    DELETE: ___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE,
    EQUAL: ___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL,
    ADD: ___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT};

  function ___$romejs$string_diff$src$index_ts$groupDiffByLines(rawDiffs) {
    const diffsByLine = [];

    let line = [];
    function flushLine() {
      if (line.length > 0) {
        diffsByLine.push(line);
        line = [];
      }
    }

    for (const tuple of rawDiffs) {
      const [type, text] = tuple;

      if (type === ___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE) {
        line.push(tuple);
        continue;
      }

      const parts = text.split('\n');

      if (parts.length <= 1) {
        line.push(tuple);
        continue;
      }

      const [currentLine, ...futureLines] = parts;

      if (currentLine !== '') {
        line.push([type, currentLine]);
      }

      for (const newLine of futureLines) {
        flushLine();
        line.push([type, newLine]);
      }
    }

    flushLine();

    return diffsByLine;
  }

  function ___$romejs$string_diff$src$index_ts$default(text1, text2) {
    return ___$$priv$romejs$string_diff$src$index_ts$main(text1, text2, true);
  }

  function ___$$priv$romejs$string_diff$src$index_ts$main(text1, text2, fixUnicode = false) {
    if (text1 === text2) {
      if (text1) {
        return [[___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL, text1]];
      }
      return [];
    }

    let commonlength = ___$$priv$romejs$string_diff$src$index_ts$commonPrefix(text1, text2);
    let commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);

    commonlength = ___$$priv$romejs$string_diff$src$index_ts$commonSuffix(text1, text2);
    let commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);

    let diffs = ___$$priv$romejs$string_diff$src$index_ts$compute(text1, text2);

    if (commonprefix) {
      diffs.unshift([___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL, commonprefix]);
    }
    if (commonsuffix) {
      diffs.push([___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL, commonsuffix]);
    }
    ___$$priv$romejs$string_diff$src$index_ts$cleanupMerge(diffs, fixUnicode);
    return diffs;
  }

  function ___$$priv$romejs$string_diff$src$index_ts$compute(text1, text2) {
    let diffs = [];

    if (!text1) {
      return [[___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT, text2]];
    }

    if (!text2) {
      return [[___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE, text1]];
    }

    let longtext = text1.length > text2.length ? text1 : text2;
    let shorttext = text1.length > text2.length ? text2 : text1;
    let i = longtext.indexOf(shorttext);
    if (i !== -1) {
      diffs = [[___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT, longtext.substring(0, i)], [___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL, shorttext], [___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT, longtext.substring(i + shorttext.length)]];

      if (text1.length > text2.length) {
        diffs[0][0] = diffs[2][0] = ___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE;
      }
      return diffs;
    }

    if (shorttext.length === 1) {
      return [[___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE, text1], [___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT, text2]];
    }

    let hm = ___$$priv$romejs$string_diff$src$index_ts$halfMatch(text1, text2);
    if (hm) {
      let text1_a = hm[0];
      let text1_b = hm[1];
      let text2_a = hm[2];
      let text2_b = hm[3];
      let mid_common = hm[4];

      let diffs_a = ___$$priv$romejs$string_diff$src$index_ts$main(text1_a, text2_a);
      let diffs_b = ___$$priv$romejs$string_diff$src$index_ts$main(text1_b, text2_b);

      return diffs_a.concat([[___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL, mid_common]], diffs_b);
    }

    return ___$$priv$romejs$string_diff$src$index_ts$bisect(text1, text2);
  }

  function ___$$priv$romejs$string_diff$src$index_ts$bisect(text1, text2) {
    let text1_length = text1.length;
    let text2_length = text2.length;
    let max_d = Math.ceil((text1_length + text2_length) / 2);
    let v_offset = max_d;
    let v_length = 2 * max_d;
    let v1 = new Array(v_length);
    let v2 = new Array(v_length);

    for (let x = 0; x < v_length; x++) {
      v1[x] = -1;
      v2[x] = -1;
    }
    v1[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    let delta = text1_length - text2_length;

    let front = delta % 2 !== 0;

    let k1start = 0;
    let k1end = 0;
    let k2start = 0;
    let k2end = 0;
    for (let d = 0; d < max_d; d++) {
      for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
        let k1_offset = v_offset + k1;
        let x1;
        if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
          x1 = v1[k1_offset + 1];
        } else {
          x1 = v1[k1_offset - 1] + 1;
        }
        let y1 = x1 - k1;
        while (x1 < text1_length &&
        y1 < text2_length &&
        text1.charAt(x1) === text2.charAt(y1)) {
          x1++;
          y1++;
        }
        v1[k1_offset] = x1;
        if (x1 > text1_length) {
          k1end += 2;
        } else if (y1 > text2_length) {
          k1start += 2;
        } else if (front) {
          let k2_offset = v_offset + delta - k1;
          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
            let x2 = text1_length - v2[k2_offset];
            if (x1 >= x2) {
              return ___$$priv$romejs$string_diff$src$index_ts$bisectSplit(text1, text2, x1, y1);
            }
          }
        }
      }

      for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
        let k2_offset = v_offset + k2;
        let x2;
        if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
          x2 = v2[k2_offset + 1];
        } else {
          x2 = v2[k2_offset - 1] + 1;
        }
        let y2 = x2 - k2;
        while (x2 < text1_length &&
        y2 < text2_length &&
        text1.charAt(text1_length - x2 - 1) ===
        text2.charAt(text2_length - y2 - 1)) {
          x2++;
          y2++;
        }
        v2[k2_offset] = x2;
        if (x2 > text1_length) {
          k2end += 2;
        } else if (y2 > text2_length) {
          k2start += 2;
        } else if (!front) {
          let k1_offset = v_offset + delta - k2;
          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
            let x1 = v1[k1_offset];
            let y1 = v_offset + x1 - k1_offset;

            x2 = text1_length - x2;
            if (x1 >= x2) {
              return ___$$priv$romejs$string_diff$src$index_ts$bisectSplit(text1, text2, x1, y1);
            }
          }
        }
      }
    }

    return [[___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE, text1], [___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT, text2]];
  }

  function ___$$priv$romejs$string_diff$src$index_ts$bisectSplit(text1, text2, x, y) {
    let text1a = text1.substring(0, x);
    let text2a = text2.substring(0, y);
    let text1b = text1.substring(x);
    let text2b = text2.substring(y);

    let diffs = ___$$priv$romejs$string_diff$src$index_ts$main(text1a, text2a);
    let diffsb = ___$$priv$romejs$string_diff$src$index_ts$main(text1b, text2b);

    return diffs.concat(diffsb);
  }

  function ___$$priv$romejs$string_diff$src$index_ts$commonPrefix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
      return 0;
    }

    let pointermin = 0;
    let pointermax = Math.min(text1.length, text2.length);
    let pointermid = pointermax;
    let pointerstart = 0;
    while (pointermin < pointermid) {
      if (text1.substring(pointerstart, pointermid) ==
      text2.substring(pointerstart, pointermid)) {
        pointermin = pointermid;
        pointerstart = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }

    if (___$$priv$romejs$string_diff$src$index_ts$is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
      pointermid--;
    }

    return pointermid;
  }

  function ___$$priv$romejs$string_diff$src$index_ts$commonSuffix(text1, text2) {
    if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
      return 0;
    }

    let pointermin = 0;
    let pointermax = Math.min(text1.length, text2.length);
    let pointermid = pointermax;
    let pointerend = 0;
    while (pointermin < pointermid) {
      if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
      text2.substring(text2.length - pointermid, text2.length - pointerend)) {
        pointermin = pointermid;
        pointerend = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }

    if (___$$priv$romejs$string_diff$src$index_ts$is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
      pointermid--;
    }

    return pointermid;
  }

  function ___$$priv$romejs$string_diff$src$index_ts$halfMatch(text1, text2) {
    let longtext = text1.length > text2.length ? text1 : text2;
    let shorttext = text1.length > text2.length ? text2 : text1;
    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
      return undefined;
    }

    let hm1 = ___$$priv$romejs$string_diff$src$index_ts$halfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));

    let hm2 = ___$$priv$romejs$string_diff$src$index_ts$halfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));

    let hm;
    if (!hm1 && !hm2) {
      return undefined;
    } else if (!hm2) {
      hm = hm1;
    } else if (!hm1) {
      hm = hm2;
    } else {
      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }

    if (hm === undefined) {
      throw new Error('Expected half match');
    }

    let text1_a, text1_b, text2_a, text2_b;
    if (text1.length > text2.length) {
      text1_a = hm[0];
      text1_b = hm[1];
      text2_a = hm[2];
      text2_b = hm[3];
    } else {
      text2_a = hm[0];
      text2_b = hm[1];
      text1_a = hm[2];
      text1_b = hm[3];
    }
    let mid_common = hm[4];
    return [text1_a, text1_b, text2_a, text2_b, mid_common];
  }

  function ___$$priv$romejs$string_diff$src$index_ts$halfMatchI(longtext, shorttext, i) {
    let seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    let j = -1;
    let best_common = '';
    let best_longtext_a = '';
    let best_longtext_b = '';
    let best_shorttext_a = '';
    let best_shorttext_b = '';
    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
      let prefixLength = ___$$priv$romejs$string_diff$src$index_ts$commonPrefix(
      longtext.substring(i),
      shorttext.substring(j));
      let suffixLength = ___$$priv$romejs$string_diff$src$index_ts$commonSuffix(
      longtext.substring(0, i),
      shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common =
        shorttext.substring(j - suffixLength, j) +
        shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }

    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return undefined;
    }
  }

  function ___$$priv$romejs$string_diff$src$index_ts$cleanupMerge(diffs, fix_unicode) {
    diffs.push([___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL, '']);
    let pointer = 0;
    let count_delete = 0;
    let count_insert = 0;
    let text_delete = '';
    let text_insert = '';
    let commonlength;
    while (pointer < diffs.length) {
      if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
        diffs.splice(pointer, 1);
        continue;
      }
      switch (diffs[pointer][0]) {
        case ___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          pointer++;
          break;
        case ___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          pointer++;
          break;
        case ___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL:
          let previous_equality = pointer - count_insert - count_delete - 1;
          if (fix_unicode) {
            if (previous_equality >= 0 &&
            ___$$priv$romejs$string_diff$src$index_ts$ends_with_pair_start(diffs[previous_equality][1])) {
              let stray = diffs[previous_equality][1].slice(-1);
              diffs[previous_equality][1] = diffs[previous_equality][1].slice(
              0,
              -1);
              text_delete = stray + text_delete;
              text_insert = stray + text_insert;
              if (!diffs[previous_equality][1]) {
                diffs.splice(previous_equality, 1);
                pointer--;
                let k = previous_equality - 1;
                if (diffs[k] && diffs[k][0] === ___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT) {
                  count_insert++;
                  text_insert = diffs[k][1] + text_insert;
                  k--;
                }
                if (diffs[k] && diffs[k][0] === ___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE) {
                  count_delete++;
                  text_delete = diffs[k][1] + text_delete;
                  k--;
                }
                previous_equality = k;
              }
            }
            if (___$$priv$romejs$string_diff$src$index_ts$starts_with_pair_end(diffs[pointer][1])) {
              let stray = diffs[pointer][1].charAt(0);
              diffs[pointer][1] = diffs[pointer][1].slice(1);
              text_delete += stray;
              text_insert += stray;
            }
          }
          if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
            diffs.splice(pointer, 1);
            break;
          }
          if (text_delete.length > 0 || text_insert.length > 0) {
            if (text_delete.length > 0 && text_insert.length > 0) {
              commonlength = ___$$priv$romejs$string_diff$src$index_ts$commonPrefix(text_insert, text_delete);
              if (commonlength !== 0) {
                if (previous_equality >= 0) {
                  diffs[previous_equality][1] += text_insert.substring(
                  0,
                  commonlength);
                } else {
                  diffs.splice(0, 0, [___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                  pointer++;
                }
                text_insert = text_insert.substring(commonlength);
                text_delete = text_delete.substring(commonlength);
              }

              commonlength = ___$$priv$romejs$string_diff$src$index_ts$commonSuffix(text_insert, text_delete);
              if (commonlength !== 0) {
                diffs[pointer][1] =
                text_insert.substring(text_insert.length - commonlength) +
                diffs[pointer][1];
                text_insert = text_insert.substring(
                0,
                text_insert.length - commonlength);
                text_delete = text_delete.substring(
                0,
                text_delete.length - commonlength);
              }
            }

            let n = count_insert + count_delete;
            if (text_delete.length === 0 && text_insert.length === 0) {
              diffs.splice(pointer - n, n);
              pointer = pointer - n;
            } else if (text_delete.length === 0) {
              diffs.splice(pointer - n, n, [___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT, text_insert]);
              pointer = pointer - n + 1;
            } else if (text_insert.length === 0) {
              diffs.splice(pointer - n, n, [___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE, text_delete]);
              pointer = pointer - n + 1;
            } else {
              diffs.splice(
              pointer - n,
              n,
              [___$$priv$romejs$string_diff$src$index_ts$DIFF_DELETE, text_delete],
              [___$$priv$romejs$string_diff$src$index_ts$DIFF_INSERT, text_insert]);
              pointer = pointer - n + 2;
            }
          }
          if (pointer !== 0 && diffs[pointer - 1][0] === ___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL) {
            diffs[pointer - 1][1] += diffs[pointer][1];
            diffs.splice(pointer, 1);
          } else {
            pointer++;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;}
    }
    if (diffs[diffs.length - 1][1] === '') {
      diffs.pop();
    }

    let changes = false;
    pointer = 1;

    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] === ___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL &&
      diffs[pointer + 1][0] === ___$$priv$romejs$string_diff$src$index_ts$DIFF_EQUAL) {
        if (diffs[pointer][1].substring(
        diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
          diffs[pointer][1] =
          diffs[pointer - 1][1] +
          diffs[pointer][1].substring(
          0,
          diffs[pointer][1].length - diffs[pointer - 1][1].length);
          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
          diffs.splice(pointer - 1, 1);
          changes = true;
        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
        diffs[pointer + 1][1]) {
          diffs[pointer - 1][1] += diffs[pointer + 1][1];
          diffs[pointer][1] =
          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
          diffs[pointer + 1][1];
          diffs.splice(pointer + 1, 1);
          changes = true;
        }
      }
      pointer++;
    }

    if (changes) {
      ___$$priv$romejs$string_diff$src$index_ts$cleanupMerge(diffs, fix_unicode);
    }
  }

  function ___$$priv$romejs$string_diff$src$index_ts$is_surrogate_pair_start(charCode) {
    return charCode >= 55296 && charCode <= 56319;
  }

  function ___$$priv$romejs$string_diff$src$index_ts$is_surrogate_pair_end(charCode) {
    return charCode >= 56320 && charCode <= 57343;
  }

  function ___$$priv$romejs$string_diff$src$index_ts$starts_with_pair_end(str) {
    return ___$$priv$romejs$string_diff$src$index_ts$is_surrogate_pair_end(str.charCodeAt(0));
  }

  function ___$$priv$romejs$string_diff$src$index_ts$ends_with_pair_start(str) {
    return ___$$priv$romejs$string_diff$src$index_ts$is_surrogate_pair_start(str.charCodeAt(str.length - 1));
  }

  // romejs/cli-diagnostics/src/constants.ts

  const ___$romejs$cli_diagnostics$src$constants_ts = {
    get GUTTER() {
      return ___$romejs$cli_diagnostics$src$constants_ts$GUTTER;
    },
    get CODE_FRAME_INDENT() {
      return ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_INDENT;
    },
    get CODE_FRAME_SELECTED_INDENT() {
      return ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_SELECTED_INDENT;
    },
    get FILENAME_INDENT() {
      return ___$romejs$cli_diagnostics$src$constants_ts$FILENAME_INDENT;
    },
    get MAX_CODE_FRAME_LINES() {
      return ___$romejs$cli_diagnostics$src$constants_ts$MAX_CODE_FRAME_LINES;
    },
    get HALF_MAX_CODE_FRAME_LINES() {
      return ___$romejs$cli_diagnostics$src$constants_ts$HALF_MAX_CODE_FRAME_LINES;
    },
    get CODE_FRAME_CONTEXT_LINES() {
      return ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_CONTEXT_LINES;
    }};
  const ___$romejs$cli_diagnostics$src$constants_ts$GUTTER = ' \u2502 ';
  const ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_INDENT = '  ';
  const ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_SELECTED_INDENT = `${___$romejs$string_ansi$src$format_ts$formatAnsi.red('>')} `;
  const ___$romejs$cli_diagnostics$src$constants_ts$FILENAME_INDENT = '  ';

  const ___$romejs$cli_diagnostics$src$constants_ts$MAX_CODE_FRAME_LINES = 8;
  const ___$romejs$cli_diagnostics$src$constants_ts$HALF_MAX_CODE_FRAME_LINES = ___$romejs$cli_diagnostics$src$constants_ts$MAX_CODE_FRAME_LINES / 2;
  const ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_CONTEXT_LINES = 2;

  // romejs/cli-diagnostics/src/buildPatchCodeFrame.ts

  function ___$$priv$romejs$cli_diagnostics$src$buildPatchCodeFrame_ts$formatDiffLine(diffs) {
    return diffs.map(([type, text]) => {
      if (type === ___$romejs$string_diff$src$index_ts$constants.DELETE) {
        return ___$romejs$string_ansi$src$format_ts$formatAnsi.red(___$romejs$cli_diagnostics$src$utils_ts$showInvisibles(text));
      } else if (type === ___$romejs$string_diff$src$index_ts$constants.ADD) {
        return ___$romejs$string_ansi$src$format_ts$formatAnsi.green(___$romejs$cli_diagnostics$src$utils_ts$showInvisibles(text));
      } else {
        return text;
      }
    }).join('');
  }

  const ___$$priv$romejs$cli_diagnostics$src$buildPatchCodeFrame_ts$DELETE_MARKER = ___$romejs$string_ansi$src$format_ts$formatAnsi.red('-');
  const ___$$priv$romejs$cli_diagnostics$src$buildPatchCodeFrame_ts$ADD_MARKER = ___$romejs$string_ansi$src$format_ts$formatAnsi.green('+');

  function ___$romejs$cli_diagnostics$src$buildPatchCodeFrame_ts$default(rawDiffs) {
    const diffsByLine = ___$romejs$string_diff$src$index_ts$groupDiffByLines(rawDiffs);
    let lastVisibleLine = -1;

    const shownLines = new Set();
    for (let i = 0; i < diffsByLine.length; i++) {
      const diffs = diffsByLine[i];

      let hasChange = false;
      for (const [type] of diffs) {
        if (type === ___$romejs$string_diff$src$index_ts$constants.DELETE || type === ___$romejs$string_diff$src$index_ts$constants.ADD) {
          hasChange = true;
          break;
        }
      }

      if (hasChange) {
        for (let start = i - ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_CONTEXT_LINES; start < i + ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_CONTEXT_LINES; start++) {
          shownLines.add(start);

          if (start > lastVisibleLine) {
            lastVisibleLine = start;
          }
        }
      }
    }

    const lineLength = String(lastVisibleLine).length;

    const frame = [];
    let lastDisplayedLine = -1;
    for (let i = 0; i < diffsByLine.length; i++) {
      if (shownLines.has(i) === false) {
        continue;
      }

      const diffs = diffsByLine[i];
      const lineNo = i + 1;

      const deletions = [];
      const addition = [];

      let hasDeletions = false;
      let hasAddition = false;

      for (const tuple of diffs) {
        let [type] = tuple;

        if (type === ___$romejs$string_diff$src$index_ts$constants.DELETE) {
          hasDeletions = true;
          deletions.push(tuple);
        }

        if (type === ___$romejs$string_diff$src$index_ts$constants.ADD) {
          hasAddition = true;
          addition.push(tuple);
        }

        if (type === ___$romejs$string_diff$src$index_ts$constants.EQUAL) {
          addition.push(tuple);
          deletions.push(tuple);
        }
      }

      if (lastDisplayedLine !== lineNo - 1 && lastDisplayedLine !== -1) {
        frame.push(
        ___$romejs$string_ansi$src$format_ts$formatAnsi.bold(___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_INDENT + '.'.repeat(lineLength) + ___$romejs$cli_diagnostics$src$constants_ts$GUTTER));
      }

      const gutter = ___$romejs$string_ansi$src$format_ts$formatAnsi.bold(
      ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_INDENT + ___$romejs$string_ansi$src$pad_ts$leftPad(String(lineNo), lineLength) + ___$romejs$cli_diagnostics$src$constants_ts$GUTTER);

      if (hasAddition) {
        frame.push(gutter + ___$$priv$romejs$cli_diagnostics$src$buildPatchCodeFrame_ts$ADD_MARKER + ' ' + ___$$priv$romejs$cli_diagnostics$src$buildPatchCodeFrame_ts$formatDiffLine(addition));
      }

      if (hasDeletions) {
        frame.push(gutter + ___$$priv$romejs$cli_diagnostics$src$buildPatchCodeFrame_ts$DELETE_MARKER + ' ' + ___$$priv$romejs$cli_diagnostics$src$buildPatchCodeFrame_ts$formatDiffLine(deletions));
      }

      if (!hasAddition && !hasDeletions) {
        frame.push(gutter + '  ' + ___$$priv$romejs$cli_diagnostics$src$buildPatchCodeFrame_ts$formatDiffLine(addition));
      }

      lastDisplayedLine = lineNo;
    }

    return frame.join('\n');
  }

  // romejs/cli-diagnostics/src/buildMessageCodeFrame.ts

  function ___$romejs$cli_diagnostics$src$buildMessageCodeFrame_ts$default(allLines, start, end, maybeMarkerMessage) {
    let markerMessage = maybeMarkerMessage === undefined ? '' : maybeMarkerMessage;

    const startLineIndex = start.line - 1;

    let endLineIndex = end.line - 1;
    let endLineCol = end.column;

    let markerOffset = end.column;
    let markerSize = 1;

    let contextStartIndex = Math.max(
    0,
    startLineIndex - ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_CONTEXT_LINES);
    let contextEndIndex = Math.min(
    allLines.length - 1,
    endLineIndex + ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_CONTEXT_LINES);

    let myLines = [];
    for (let i = contextStartIndex; i <= contextEndIndex; i++) {
      let line = allLines[i];
      if (line === undefined) {
        continue;
      }

      if (line.trim() === '' && myLines.length === 0 && i !== startLineIndex) {
        continue;
      }

      const shouldHighlight = i >= startLineIndex && i <= endLineIndex;

      if (shouldHighlight) {
        let startCol = 0;
        let endCol = line.length;

        if (i === startLineIndex) {
          startCol = start.column;
        }

        if (i === endLineIndex) {
          endCol = endLineCol;

          if (endCol > startCol) {
            markerSize = endCol - startCol;
            markerOffset -= markerSize;
          }
        }
      }

      const lineNo = i + 1;
      let gutter = `${String(lineNo)}${___$romejs$cli_diagnostics$src$constants_ts$GUTTER}`;

      if (shouldHighlight) {
        gutter = `${___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_SELECTED_INDENT}${gutter}`;
      } else {
        gutter = `${___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_INDENT}${gutter}`;
      }

      myLines.push({
        gutter: gutter,
        line: line,
        lineNo: lineNo,
        lineIndex: i});
    }

    if (myLines.length === 0 || end.line === -1 || start.line === -1) {
      return ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_INDENT + markerMessage;
    }

    const pruned = myLines.length > ___$romejs$cli_diagnostics$src$constants_ts$MAX_CODE_FRAME_LINES + 2;
    if (pruned) {
      const start = myLines.slice(0, ___$romejs$cli_diagnostics$src$constants_ts$HALF_MAX_CODE_FRAME_LINES);
      const end = myLines.slice(-___$romejs$cli_diagnostics$src$constants_ts$HALF_MAX_CODE_FRAME_LINES);
      myLines = start.concat([undefined], end);
    }

    const lastLine = myLines[myLines.length - 1];
    if (lastLine === undefined) {
      throw new Error('Expected there to be a last line');
    }

    const maxVisibleLine = lastLine.lineNo;
    const maxGutterLength = String(maxVisibleLine).length + ___$romejs$cli_diagnostics$src$constants_ts$GUTTER.length + ___$romejs$cli_diagnostics$src$constants_ts$CODE_FRAME_INDENT.length;

    if (markerMessage !== '' && start.line === end.line) {
      const text = ___$romejs$string_ansi$src$format_ts$stripAnsi(allLines[start.line - 1]).slice(
      start.column,
      end.column);
      if (___$romejs$cli_diagnostics$src$utils_ts$cleanEquivalentString(text) === ___$romejs$cli_diagnostics$src$utils_ts$cleanEquivalentString(markerMessage)) {
        markerMessage = '';
      }
    }

    const pointerLength = Math.max(markerSize, 1);
    const pointer = ___$romejs$string_ansi$src$format_ts$formatAnsi.red(
    ___$romejs$string_ansi$src$format_ts$formatAnsi.bold('^'.repeat(pointerLength)));
    const gutterIndent = ' '.repeat(maxGutterLength - ___$romejs$cli_diagnostics$src$constants_ts$GUTTER.length);
    const pointerIndent = ' '.repeat(markerOffset);
    const markerLine = `${gutterIndent}${___$romejs$string_ansi$src$format_ts$formatAnsi.bold(
    ___$romejs$cli_diagnostics$src$constants_ts$GUTTER)}${pointerIndent}${pointer} ${markerMessage}`;

    const omittedDots = '...';
    const omittedLine = ___$romejs$string_ansi$src$pad_ts$leftPad(
    ___$romejs$string_ansi$src$format_ts$formatAnsi.bold(omittedDots) + ___$romejs$cli_diagnostics$src$constants_ts$GUTTER,
    maxGutterLength);

    const result = [];
    for (const selection of myLines) {
      if (!selection) {
        result.push(omittedLine);
        continue;
      }

      const {gutter: gutter, line: line, lineIndex: lineIndex} = selection;
      result.push(___$romejs$string_ansi$src$format_ts$formatAnsi.bold(___$romejs$string_ansi$src$pad_ts$leftPad(gutter, maxGutterLength)) + line);
      if (lineIndex === endLineIndex) {
        result.push(markerLine);
      }
    }

    const frame = result.join('\n');
    return frame;
  }

  // romejs/cli-diagnostics/src/printAdvice.ts

  function ___$romejs$cli_diagnostics$src$printAdvice_ts$default(item, opts) {
    switch (item.type) {
      case 'log':
        return ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printLog(item, opts);

      case 'ordered-list':
        return ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printOrderedList(item, opts);

      case 'list':
        return ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printList(item, opts);

      case 'diff':
        return ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printDiff(item, opts);

      case 'code':
        return ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printCode(item, opts);

      case 'frame':
        return ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printFrame(item, opts);

      case 'stacktrace':
        return ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printStacktrace(item, opts);

      case 'action':
        return ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printAction(item, opts);

      case 'inspect':
        return ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printInspect(item, opts);}
  }

  function ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printInspect(item, opts) {
    const {reporter: reporter} = opts;
    reporter.indent();
    reporter.inspect(item.data);
    reporter.dedent();
    return false;
  }

  function ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printDiff(item, opts) {
    opts.reporter.log(___$romejs$string_markup$src$escape_ts$escapeMarkup(___$romejs$cli_diagnostics$src$buildPatchCodeFrame_ts$default(item.diff)));
    return false;
  }

  function ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printList(item, opts) {
    if (item.list.length === 0) {
      return true;
    } else {
      opts.reporter.list(item.list);
      return false;
    }
  }

  function ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printOrderedList(item, opts) {
    if (item.list.length === 0) {
      return true;
    } else {
      opts.reporter.orderedList(item.list, item.reverse);
      return false;
    }
  }

  function ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printCode(item, opts) {
    const {reporter: reporter} = opts;
    const {code: code} = item;
    reporter.indent();
    reporter.log(___$romejs$string_markup$src$escape_ts$escapeMarkup(code));
    reporter.dedent();
    return false;
  }

  function ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printFrame(item, opts) {
    const {reporter: reporter} = opts;
    const {start: start, end: end, filename: filename, code: code, marker: marker} = item;

    let cleanMarker = '';
    if (marker !== undefined) {
      cleanMarker = ___$romejs$string_ansi$src$format_ts$formatAnsi.bold(___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$cleanMessage(marker));
    }

    let lines;
    if (code !== undefined) {
      lines = ___$romejs$cli_diagnostics$src$utils_ts$toLines(code);
    } else if (filename !== undefined) {
      lines = opts.fileSources.get(filename);
    }
    if (lines === undefined) {
      lines = [];
    }

    const frame = ___$romejs$cli_diagnostics$src$buildMessageCodeFrame_ts$default(lines, start, end, cleanMarker);
    if (frame.trim() === '') {
      return true;
    }

    reporter.log(___$romejs$string_markup$src$escape_ts$escapeMarkup(frame));
    return false;
  }

  function ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printAction(item, opts) {
    const {reporter: reporter} = opts;
    reporter.log(`<bold>${item.message}</bold>`);
    reporter.log('You have the following choices:');
    reporter.list(
    item.buttons.map(button => {
      return `${button.text}: \`${button.command}\``;
    }));
    return false;
  }

  function ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printStacktrace(item, opts) {
    const {diagnostic: diagnostic} = opts;
    const {frames: frames} = item;

    let shownCodeFrames = 0;

    const isFirstPart = diagnostic.advice[0] === item;
    if (!isFirstPart) {
      opts.reporter.info(item.title === undefined ? 'Stack trace' : item.title);
      opts.reporter.spacer();
    }

    for (let i = 0; i < frames.length; i++) {
      const {
        filename: filename,
        object: object,
        suffix: suffix,
        property: property,
        prefix: prefix,
        line: line,
        column: column,
        language: language,
        code: code} = frames[i];

      const logParts = [];

      if (prefix !== undefined) {
        logParts.push(___$romejs$string_ansi$src$format_ts$formatAnsi.dim(___$romejs$string_markup$src$escape_ts$escapeMarkup(prefix)));
      }

      const objParts = [];
      if (object !== undefined) {
        objParts.push(___$romejs$string_ansi$src$format_ts$formatAnsi.magenta(___$romejs$string_markup$src$escape_ts$escapeMarkup(object)));
      }
      if (property !== undefined) {
        objParts.push(___$romejs$string_ansi$src$format_ts$formatAnsi.cyan(___$romejs$string_markup$src$escape_ts$escapeMarkup(property)));
      }
      if (objParts.length > 0) {
        logParts.push(objParts.join('.'));
      }

      if (suffix !== undefined) {
        logParts.push(___$romejs$string_ansi$src$format_ts$formatAnsi.green(___$romejs$string_markup$src$escape_ts$escapeMarkup(suffix)));
      }

      if (filename !== undefined && line !== undefined && column !== undefined) {
        const header = ___$romejs$diagnostics$src$derive_ts$getDiagnosticHeader({
          filename: filename,
          start: {
            index: -1,
            line: line,
            column: column},
          cwd: opts.cwd});

        if (logParts.length === 0) {
          logParts.push(header);
        } else {
          logParts.push('(' + ___$romejs$string_ansi$src$format_ts$formatAnsi.dim(header) + ')');
        }
      }

      ___$romejs$cli_diagnostics$src$printAdvice_ts$default(
      {
        type: 'log',
        category: 'none',
        message: `  ${String(i + 1)}. ${logParts.join(' ')}`,
        compact: true},
      opts);

      if (shownCodeFrames < 2 &&
      filename !== undefined &&
      line !== undefined &&
      column !== undefined) {
        const pos = {
          index: -1,
          line: line,
          column: column};

        ___$romejs$cli_diagnostics$src$printAdvice_ts$default(
        {
          type: 'frame',
          language: language,
          filename: filename,
          marker: undefined,
          start: pos,
          end: pos,
          code: code},
        opts);
        shownCodeFrames++;
      }
    }

    return false;
  }

  function ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$printLog(item, opts) {
    const {reporter: reporter} = opts;
    const {message: message, category: category} = item;

    if (message !== undefined) {
      switch (category) {
        case 'none':
          reporter.log(message);
          break;

        case 'warn':
          reporter.warn(message);
          break;

        case 'info':
          reporter.info(message);
          break;

        case 'question':
          reporter.question(message);
          break;

        case 'error':
          reporter.error(message);
          break;

        default:
          ___$romejs$invariant$src$index_ts$default(false, 'Unknown message item log category %s', category);}
    }

    return item.compact;
  }

  function ___$$priv$romejs$cli_diagnostics$src$printAdvice_ts$cleanMessage(msg) {
    msg = msg.trim();
    if (msg.endsWith('.')) {
      msg = msg.slice(0, -1);
    }
    return msg;
  }

  // romejs/cli-diagnostics/src/banners/success.json

  const ___$romejs$cli_diagnostics$src$banners$success_json$default = {'palettes': [[240, 240, 240], [240, 240, 225], [225, 225, 210], [225, 210, 210], [240, 225, 225], [210, 210, 195], [210, 195, 180], [195, 195, 165], [195, 180, 165], [225, 210, 195], [195, 195, 180], [225, 225, 225], [180, 180, 150], [180, 165, 150], [195, 180, 150], [195, 165, 150], [180, 165, 135], [180, 150, 135], [195, 165, 135], [225, 225, 195], [210, 210, 180], [210, 180, 150], [210, 180, 165], [225, 180, 180], [240, 180, 165], [240, 195, 195], [225, 195, 180], [165, 135, 120], [165, 150, 120], [195, 135, 120], [225, 150, 135], [240, 165, 165], [225, 180, 165], [225, 195, 165], [150, 120, 105], [150, 135, 105], [180, 150, 120], [195, 120, 105], [210, 135, 105], [210, 150, 120], [195, 150, 135], [210, 195, 165], [180, 105, 75], [195, 105, 90], [180, 90, 75], [240, 180, 180], [240, 225, 210], [240, 240, 210], [150, 120, 90], [180, 135, 120], [210, 150, 135], [210, 165, 150], [195, 150, 120], [225, 180, 150], [195, 120, 90], [180, 105, 90], [225, 165, 135], [225, 210, 180], [240, 210, 195], [225, 195, 195], [180, 135, 105], [225, 180, 135], [210, 135, 120], [225, 165, 150], [240, 180, 150], [210, 180, 180], [165, 135, 90], [180, 120, 90], [195, 135, 105], [225, 150, 120], [180, 135, 135], [210, 150, 150], [210, 195, 195], [210, 195, 210], [150, 135, 135], [195, 195, 195], [225, 210, 225], [180, 180, 135], [165, 120, 90], [240, 150, 135], [240, 165, 135], [240, 165, 150], [180, 90, 60], [180, 165, 165], [165, 135, 135], [180, 180, 180], [165, 150, 135], [150, 90, 45], [150, 75, 45], [210, 165, 135], [165, 165, 165], [165, 120, 75], [180, 135, 90], [150, 60, 45], [165, 105, 60], [165, 90, 60], [150, 105, 105], [210, 210, 210], [165, 105, 75], [225, 165, 165], [180, 120, 75], [165, 90, 75], [135, 90, 75], [195, 180, 180], [240, 195, 180], [135, 120, 120], [165, 135, 105], [150, 105, 75], [225, 150, 150], [240, 210, 180], [165, 150, 150], [165, 150, 105], [225, 135, 120], [210, 120, 105], [150, 90, 75], [180, 120, 105], [180, 150, 105], [240, 195, 165], [180, 165, 120], [225, 135, 135], [180, 105, 105], [195, 120, 120], [150, 75, 60], [105, 15, 15], [105, 15, 0], [120, 30, 30], [120, 30, 15], [105, 45, 30], [150, 90, 60], [210, 120, 120], [165, 75, 75], [90, 30, 30], [90, 15, 15], [120, 15, 30], [120, 15, 15], [90, 0, 0], [135, 45, 45], [165, 105, 90], [210, 105, 90], [135, 75, 45], [240, 210, 210], [225, 240, 225], [60, 30, 15], [45, 0, 0], [60, 15, 15], [75, 30, 15], [120, 60, 60], [195, 90, 75], [150, 45, 45], [75, 0, 15], [60, 0, 0], [75, 0, 0], [150, 105, 60], [135, 90, 45], [60, 45, 30], [105, 30, 30], [120, 15, 0], [150, 75, 75], [120, 105, 90], [105, 60, 45], [120, 75, 45], [60, 15, 0], [75, 15, 15], [105, 30, 15], [195, 105, 105], [165, 60, 60], [135, 15, 15], [180, 180, 165], [105, 90, 90], [30, 15, 15], [60, 30, 30], [135, 60, 60], [150, 45, 30], [150, 75, 30], [240, 225, 195], [75, 15, 0], [90, 15, 0], [120, 45, 30], [240, 150, 150], [105, 90, 75], [105, 75, 60], [105, 105, 105], [45, 45, 45], [30, 30, 15], [180, 60, 45], [165, 60, 30], [180, 90, 45], [135, 75, 30], [195, 135, 90], [135, 60, 45], [135, 75, 60], [90, 60, 30], [90, 60, 45], [30, 15, 0], [15, 15, 15], [45, 30, 15], [195, 90, 60], [180, 105, 60], [120, 75, 30], [105, 60, 30], [120, 60, 30], [15, 0, 0], [75, 45, 45], [180, 75, 30], [180, 120, 60], [90, 45, 30], [60, 45, 45], [60, 45, 60], [45, 30, 30], [75, 45, 30], [75, 45, 15], [195, 105, 75], [165, 45, 30], [165, 45, 15], [30, 0, 15], [45, 15, 15], [135, 60, 30], [210, 105, 60], [195, 120, 75], [75, 60, 30], [120, 120, 105], [165, 75, 60], [135, 45, 15], [195, 60, 45], [90, 30, 45], [165, 75, 30], [135, 90, 60], [135, 105, 60], [165, 90, 90], [120, 45, 45], [165, 75, 45], [210, 135, 60], [135, 90, 30], [165, 60, 45], [105, 75, 45], [195, 135, 45], [135, 105, 75], [75, 30, 30], [135, 105, 90], [195, 120, 45], [180, 105, 30], [135, 120, 90], [150, 60, 60], [180, 75, 75], [150, 60, 15], [150, 75, 15], [165, 120, 105], [180, 90, 90], [195, 90, 105], [210, 105, 105], [0, 0, 0], [15, 0, 15], [180, 105, 45], [120, 60, 45], [120, 60, 15], [90, 30, 15], [30, 0, 0], [15, 15, 0], [165, 90, 45], [180, 90, 30], [105, 30, 0], [180, 75, 45], [135, 45, 0], [120, 45, 15], [105, 45, 15], [45, 15, 0], [195, 90, 90], [90, 60, 60], [120, 75, 60], [135, 45, 30], [90, 45, 15], [225, 240, 240], [105, 75, 75], [150, 60, 30], [165, 180, 180], [180, 45, 60], [150, 45, 15], [135, 135, 135], [180, 60, 30], [90, 105, 105], [150, 135, 120], [105, 60, 60], [105, 45, 45], [225, 150, 105], [120, 120, 120], [105, 30, 45], [210, 150, 105], [90, 90, 90], [15, 30, 15], [45, 0, 15], [135, 30, 30], [180, 45, 30], [135, 30, 15], [75, 75, 75], [15, 15, 30], [0, 0, 15], [195, 60, 30], [210, 60, 45], [195, 90, 45], [210, 105, 75], [120, 90, 90], [45, 30, 45], [90, 45, 45], [0, 15, 0], [195, 75, 45], [195, 75, 60], [30, 30, 0], [135, 120, 105], [225, 195, 210], [60, 60, 60], [0, 15, 15], [15, 30, 45], [45, 45, 60], [30, 15, 30], [150, 30, 15], [30, 30, 30], [90, 75, 90], [90, 15, 30], [165, 165, 150], [120, 105, 60], [120, 120, 60], [60, 60, 45], [30, 45, 30], [60, 15, 30], [120, 30, 45], [60, 30, 45], [90, 90, 75], [135, 150, 60], [90, 90, 30], [30, 45, 45], [90, 75, 75], [120, 105, 105], [75, 30, 45], [60, 75, 60], [75, 15, 30], [45, 15, 30], [45, 60, 45], [120, 120, 90], [90, 15, 45], [75, 75, 60], [150, 150, 135], [75, 75, 45], [225, 120, 120], [75, 60, 60], [105, 105, 75], [120, 135, 90], [90, 90, 60], [135, 45, 60], [135, 30, 45], [75, 90, 75], [60, 75, 45], [210, 90, 60], [120, 45, 60], [150, 150, 150], [105, 120, 60], [105, 105, 60], [30, 30, 45], [135, 75, 75], [150, 45, 60], [225, 135, 90], [195, 105, 60], [195, 210, 195], [120, 75, 75], [90, 60, 75], [195, 135, 75], [210, 120, 75], [210, 225, 225], [150, 75, 90], [225, 135, 75], [210, 90, 75], [165, 120, 120], [210, 135, 75], [225, 105, 75], [180, 75, 60], [105, 45, 60], [225, 120, 75], [150, 90, 30], [165, 60, 75], [75, 45, 60], [225, 105, 60], [225, 90, 45], [225, 60, 30], [150, 30, 30], [150, 90, 90], [210, 135, 90], [150, 135, 90], [240, 75, 45], [135, 60, 75], [150, 105, 90], [240, 90, 60], [240, 105, 75], [210, 105, 45], [195, 150, 105], [240, 90, 45], [210, 120, 90], [45, 45, 30], [240, 105, 45], [210, 120, 45], [240, 90, 30], [210, 90, 45], [225, 120, 90], [195, 240, 195], [135, 240, 135], [75, 255, 60], [45, 255, 30], [45, 240, 30], [90, 225, 60], [105, 210, 75], [120, 135, 75], [195, 165, 165], [120, 150, 60], [30, 255, 0], [180, 180, 105], [165, 105, 105], [45, 240, 0], [45, 210, 0], [75, 105, 30], [30, 195, 0], [30, 225, 0], [30, 240, 0], [60, 240, 15], [90, 225, 30], [60, 195, 15], [30, 120, 15], [45, 105, 30], [105, 195, 30], [90, 225, 15], [75, 240, 30], [120, 195, 45], [105, 135, 30], [150, 165, 75], [180, 195, 30], [240, 75, 30], [165, 165, 45], [90, 225, 45], [105, 210, 45], [195, 165, 90], [135, 255, 135], [75, 255, 75], [90, 255, 90], [135, 240, 120], [165, 240, 150], [225, 240, 210], [90, 180, 75], [30, 135, 0], [135, 165, 45], [75, 210, 60], [90, 180, 30], [45, 210, 15], [150, 150, 60], [165, 195, 30], [225, 135, 60], [150, 210, 15], [135, 180, 45], [135, 225, 60], [210, 240, 210], [210, 240, 195], [195, 225, 195], [45, 165, 30], [30, 210, 15], [30, 150, 15], [15, 135, 0], [120, 165, 45], [45, 195, 15], [105, 90, 30], [105, 135, 45], [120, 180, 45], [105, 210, 30], [105, 195, 60], [120, 210, 45], [90, 120, 30], [210, 180, 105], [180, 180, 90], [135, 195, 60], [120, 210, 60], [135, 165, 60], [240, 135, 45], [180, 165, 75], [120, 165, 75], [195, 150, 75], [165, 180, 45], [120, 225, 30], [105, 165, 15], [75, 255, 45], [165, 240, 165], [150, 240, 150], [45, 135, 45], [30, 210, 0], [45, 120, 15], [150, 165, 60], [135, 195, 30], [90, 210, 30], [210, 120, 60], [135, 225, 105], [90, 255, 75], [120, 150, 45], [150, 240, 135], [90, 210, 75], [105, 90, 45], [60, 210, 15], [195, 180, 105], [195, 165, 105], [150, 165, 45], [195, 75, 15], [195, 60, 0], [135, 210, 15], [60, 240, 0], [150, 120, 15], [60, 195, 0], [75, 240, 15], [180, 240, 180], [105, 255, 90], [105, 150, 45], [105, 150, 30], [60, 240, 30], [75, 240, 60], [45, 225, 0], [150, 120, 75], [195, 180, 120], [210, 165, 120], [180, 165, 105], [210, 180, 120], [240, 105, 15], [165, 180, 30], [105, 240, 0], [135, 210, 30], [150, 165, 15], [120, 180, 30], [105, 240, 90], [60, 255, 45], [45, 255, 15], [90, 150, 30], [90, 240, 75], [90, 210, 15], [120, 90, 45], [105, 225, 60], [225, 195, 135], [165, 150, 90], [150, 165, 90], [225, 105, 30], [225, 120, 15], [120, 210, 15], [195, 120, 30], [150, 255, 150], [75, 135, 15], [105, 165, 75], [105, 210, 15], [180, 150, 90], [225, 165, 120], [210, 195, 135], [165, 135, 75], [210, 165, 105], [195, 165, 30], [75, 240, 0], [135, 210, 0], [165, 165, 30], [120, 165, 105], [75, 225, 0], [150, 180, 90], [180, 195, 105], [165, 180, 75], [150, 210, 30], [90, 240, 0], [210, 90, 30], [165, 90, 30], [195, 150, 90], [75, 210, 30], [225, 180, 120], [180, 135, 75], [225, 165, 90], [150, 180, 75], [225, 90, 30], [195, 120, 60], [210, 120, 30], [210, 180, 30], [135, 225, 0], [195, 150, 15], [225, 75, 30], [210, 75, 30], [195, 195, 150], [60, 255, 30], [195, 240, 180], [195, 30, 0], [165, 30, 15], [120, 150, 75], [210, 165, 75], [225, 165, 60], [195, 195, 45], [150, 165, 30], [195, 135, 60], [210, 195, 120], [240, 75, 15], [225, 150, 15], [240, 180, 15], [210, 165, 15], [210, 165, 45], [225, 90, 15], [210, 90, 15], [240, 120, 30], [210, 225, 180], [150, 120, 30], [45, 75, 0], [75, 120, 15], [75, 180, 30], [75, 195, 15], [195, 150, 60], [90, 195, 15], [120, 210, 30], [180, 165, 60], [195, 195, 105], [150, 225, 90], [135, 225, 75], [210, 150, 90], [195, 180, 30], [180, 180, 45], [225, 120, 30], [165, 195, 0], [165, 180, 15], [195, 165, 15], [225, 180, 30], [240, 180, 30], [225, 195, 15], [150, 225, 15], [135, 75, 15], [180, 180, 15], [195, 135, 30], [135, 225, 90], [180, 240, 165], [105, 255, 105], [150, 225, 135], [75, 225, 15], [195, 150, 45], [210, 165, 60], [120, 195, 30], [120, 225, 60], [195, 195, 75], [225, 180, 105], [225, 180, 45], [180, 225, 15], [180, 195, 90], [195, 210, 180], [90, 195, 30], [60, 225, 0], [105, 195, 45], [135, 150, 75], [165, 105, 45], [150, 135, 30], [105, 240, 15], [90, 240, 45], [195, 210, 105], [195, 195, 90], [210, 180, 90], [210, 195, 45], [150, 240, 0], [210, 180, 45], [225, 150, 90], [225, 150, 75], [60, 180, 0], [75, 210, 15], [90, 240, 15], [90, 240, 60], [210, 135, 45], [210, 150, 15], [225, 165, 30], [120, 90, 75], [225, 195, 120], [225, 165, 105], [240, 195, 30], [240, 195, 15], [210, 135, 30], [240, 165, 60], [210, 150, 30], [240, 195, 45], [240, 210, 30], [240, 180, 45], [225, 165, 45], [225, 150, 45], [225, 90, 60], [240, 150, 45], [150, 105, 45], [165, 105, 30], [210, 180, 135], [225, 195, 45], [225, 120, 45], [225, 180, 75], [225, 135, 30], [210, 165, 90], [240, 165, 45], [210, 105, 30], [225, 105, 45], [225, 75, 45], [225, 135, 45], [240, 150, 30], [150, 120, 60], [165, 120, 60], [180, 135, 15], [210, 150, 45], [225, 165, 75], [225, 150, 30], [240, 210, 15], [195, 90, 30], [240, 210, 150]], 'rows': [[[0, 95]], [[0, 95]], [[0, 95]], [[0, 25], 1, 1, 2, 1, 1, 3, 4, 1, 1, 5, 5, 2, 0, [1, 3], [0, 54]], [[0, 24], 2, 2, 5, 6, 7, 7, 8, 7, 9, 9, 7, 7, 10, 1, 5, 5, 1, [0, 54]], [[0, 22], 11, 1, 2, 12, 6, 13, 14, 15, 14, 14, 13, [14, 3], 8, 10, 7, 10, 11, [0, 54]], [[0, 21], 11, 3, 6, 7, 12, 15, [16, 3], 14, 14, 16, 16, [14, 4], 8, 8, 2, 1, 1, [0, 52]], [[0, 20], 11, 2, 8, [14, 3], 15, 15, 16, 16, 17, 18, 15, 17, [15, 4], 14, 8, 19, 20, 20, 1, [0, 18], 1, 3, 3, 1, [0, 29]], [[0, 19], 11, 5, 8, 14, 14, 21, 22, 16, 21, 14, 15, 15, 17, 17, 15, 17, 15, 18, 15, 16, 14, 8, 12, 5, 1, [0, 18], 23, 24, 25, 26, 1, [0, 28]], [[0, 17], 1, 1, 10, 12, 13, 15, 14, [21, 4], 18, 15, 17, 15, 27, 17, 28, 16, 16, 15, 28, 13, 16, 13, 6, 5, 11, [0, 16], 4, 29, 30, 31, 32, 4, [0, 28]], [[0, 17], 2, 10, 8, 14, 16, 15, 15, 21, 22, 18, 22, 33, 21, 14, 17, 17, 34, 35, 16, 15, 17, 36, 17, 16, 16, 13, 8, 5, [0, 16], 6, 37, 38, 39, 30, 2, [0, 28]], [[0, 17], 11, 6, 14, 16, 16, 18, 40, 17, 41, 17, 17, [22, 3], 17, 22, 21, 15, 21, 15, 17, 16, 36, 17, 27, 16, 14, 9, 1, [0, 15], 6, 42, 43, 37, 39, 2, [0, 4], 1, 1, [0, 22]], [[0, 17], 1, 10, 16, 18, 15, 22, 27, 27, 18, 17, 17, 15, 22, 22, 16, 21, 15, 22, 22, 21, 18, 36, 36, 27, 27, 16, 13, 8, 5, [0, 15], 8, 42, 44, 43, 39, 9, 0, 0, 1, 26, 45, 26, 46, [0, 21]], [[0, 17], 2, 47, 41, 18, 15, 21, 15, 48, 49, 50, 51, 40, 51, 40, 40, 52, 40, 51, 53, 51, 27, 18, 18, 17, 28, 16, 13, 16, 10, [0, 15], 15, 54, 42, 55, 56, 57, 1, 0, 6, 56, 24, 58, 59, 4, [0, 20]], [[0, 17], 11, 8, 14, [36, 3], 52, 60, 29, [50, 5], [39, 4], 52, 18, 15, 21, 21, 27, 27, 28, 15, 16, 8, 1, [0, 14], 17, 54, 54, 38, 61, 33, 0, 1, 29, 62, 63, 64, 24, 65, 3, 2, 1, [0, 17]], [[0, 17], 11, 8, 18, 66, 67, 67, 68, 39, [30, 7], 62, [69, 3], 40, 15, 22, 18, 36, 18, 15, 14, 14, 8, 1, [0, 14], 70, 67, 67, 37, 56, 53, 1, 9, 55, 37, 38, 38, 71, 72, 73, 74, 75, 3, 76, [0, 15]], [[0, 15], 1, 5, 7, 77, 18, 78, 54, 37, 38, 69, 30, 79, 80, 80, 30, 80, 81, 30, 69, 38, 38, 52, 15, 22, 22, 21, 16, 16, 15, 14, 14, 2, [0, 14], 15, 54, 42, 55, 38, 30, 26, 40, 42, 82, 82, 54, 22, 0, 83, 84, 3, 76, 85, 85, 2, [0, 13]], [[0, 15], 1, 19, 86, 16, 18, 78, 54, 38, 62, 30, 81, 64, [81, 3], 24, 24, 63, 30, 69, 38, 52, 15, 14, 22, 21, 14, 15, 14, 15, 8, 2, [0, 14], 65, 38, 68, 68, 39, 54, 42, 67, 42, 87, 88, 42, 89, 26, 27, 8, 4, 72, 72, 90, 90, [0, 13]], [[0, 16], 1, 5, 14, 36, 91, 67, 38, 39, 81, [24, 6], 45, 24, 63, 69, 38, 52, 51, 21, 21, 14, [15, 3], 16, 14, 32, 26, 46, 1, [0, 11], 22, 67, 67, 92, 92, 42, 93, 42, 94, 95, 95, 54, 69, 39, 39, 40, 18, 96, 15, 11, 97, [0, 13]], [[0, 17], 2, 7, 36, 98, 54, 68, 69, 81, [24, 8], 81, 30, 62, 29, 18, 21, 51, [16, 4], 18, 52, 63, 31, 99, 22, 46, [0, 9], 9, 60, 42, 98, 42, 100, 42, 101, 67, 98, 88, 88, 67, 63, 64, 81, 56, 39, 67, 102, 103, 11, 11, [0, 12]], [[0, 17], 2, 13, 36, 98, 54, 38, 39, 81, 31, 31, [24, 6], 64, 79, 62, 62, 40, 40, 51, 18, 40, 36, 18, 36, 52, 30, 81, 31, 31, 99, 23, 58, 46, 4, 1, 0, 1, 2, 15, 60, 68, 68, 42, 98, 67, 37, 39, 68, 98, 98, 42, 39, 33, 104, 64, 56, 56, 39, 50, 27, 105, 103, [0, 12]], [[0, 17], 2, 8, 106, 107, 54, 38, 39, 63, [31, 3], [24, 5], 81, 30, [62, 3], 40, 40, 18, [36, 4], 60, 39, 30, 81, 31, 31, 24, 81, 108, 50, 51, 22, 51, 50, 68, 68, 29, 68, 37, 68, 68, 29, 39, 50, 78, 95, 82, 39, [109, 2], 63, 39, 69, 56, 56, 39, 96, 110, [0, 12]], [[0, 17], 1, 12, 111, 98, 54, 68, 39, 81, 63, [81, 4], 31, 24, 63, 56, 112, 113, 37, 37, 67, 114, 78, 52, 29, [115, 2], 116, 52, 62, 81, 81, 31, 24, 64, 56, 50, 39, 39, 30, 56, 50, 50, 29, 115, [67, 4], 37, 68, 68, 67, 100, 89, 109, 117, 39, 39, 56, 63, 64, 56, 49, 83, [0, 12]], [[0, 17], 1, 2, 118, 98, 37, 38, 62, 69, 56, 81, 63, 30, 119, 62, 50, 120, 121, 122, 123, 124, [125, 2], 126, 127, 78, 52, 37, 44, 49, 47, 22, 39, 30, 81, 63, 56, 50, 50, 62, 68, 39, 89, 56, 56, 39, 67, 98, 95, [128, 2], 95, 94, 42, 67, 68, 39, 53, 64, 56, 81, [24, 4], 51, 5, [0, 12]], [[0, 18], 5, 118, 128, 98, 101, 37, 37, 62, 30, 30, 129, 130, [131, 2], 132, 133, 134, [135, 2], 123, [136, 2], 137, 52, 52, 38, 138, 37, 3, 1, 72, 49, 39, 38, 39, 62, 38, 38, 68, 89, 89, 50, 69, 62, 54, 98, 94, [87, 3], [139, 3], 128, 92, 68, 56, 30, 63, 64, 24, 63, 24, 24, 140, [0, 12]], [[0, 18], 141, 12, 142, 143, 144, 145, 146, 122, 147, 44, 148, 123, 149, [150, 3], [151, 2], 124, 136, 43, 38, 37, 67, 68, 37, 138, 68, 13, 97, 0, 4, 6, 18, 60, [67, 4], 68, 52, 68, 68, 54, 98, 128, [87, 3], 128, 152, [128, 2], 139, 153, 98, 68, 39, 30, 81, 64, 64, 24, 24, 32, 4, [0, 11]], [[0, 19], 5, 154, [143, 4], 155, 44, 112, 130, 156, 124, [123, 3], [134, 2], 157, 62, 69, 38, 54, 54, [38, 3], 37, 36, 5, [0, 4], 1, 9, 158, 159, 160, 114, [98, 5], 94, [128, 2], 87, [153, 2], 87, 139, 87, 128, 139, 101, 68, 62, 39, 81, 64, 81, 69, 98, 18, 1, [0, 10]], [[0, 19], 1, 105, [143, 2], 161, 162, 163, 164, 81, 30, 165, 156, 166, 156, 166, 148, 164, 30, 69, 62, 37, 54, 54, 62, 69, 113, 68, 16, 167, 2, 1, 0, 0, 11, 168, 169, 170, 171, 172, 173, 88, 128, 95, 94, 98, [100, 3], [98, 3], 128, [87, 4], 128, 68, 38, 80, 63, 80, 62, 78, 21, 174, [0, 10]], [[0, 19], 1, 167, 161, 151, 175, 176, 177, 62, 178, 81, 30, [129, 2], 113, 62, [81, 3], 30, 62, 38, 37, 37, 54, 62, 38, 67, 48, 179, 180, 16, 10, 181, 182, 183, 170, 136, 184, 185, 186, 42, 42, [88, 3], 128, 95, 94, 94, [98, 3], 128, [87, 3], 187, 128, 188, 62, 81, 24, 50, 107, 36, 57, 1, [0, 9]], [[0, 20], 2, 114, 189, 190, 101, 55, 30, 81, 81, 63, 30, 81, 31, 24, 24, 81, 81, 30, 62, 38, 38, 113, 54, 38, 37, 43, 191, 160, 145, 192, 193, 194, 169, 195, 145, 184, 185, 196, 54, 54, 42, 95, 197, 94, 94, 87, 87, 153, 187, 198, 199, 198, 160, 187, 87, 187, 200, 101, 37, 63, 25, 104, 64, 68, 16, 5, [0, 9]], [[0, 20], 1, 67, 113, 30, 119, 55, 112, [30, 3], 62, 29, 63, 24, 24, 63, 30, 69, [38, 3], 37, 54, 37, 43, 67, 127, 185, 144, 194, 201, [169, 2], 202, 95, 203, 82, 54, 68, 68, 67, 94, [197, 2], 204, [94, 3], 128, 205, [206, 2], 207, 208, 154, 209, 210, 205, 60, 62, 63, 32, 117, 89, 8, 11, [0, 9]], [[0, 20], 1, 60, 211, 62, 113, 44, 112, 79, 30, 119, 62, 62, 68, 30, 80, 30, 69, 69, [38, 3], 37, 54, 42, 82, 94, 212, 213, 214, 201, [169, 2], 215, 131, 216, 217, 218, 68, 62, 68, 42, 197, 42, [100, 3], 98, 98, 94, 128, 200, 205, [209, 2], [205, 2], 219, 220, 1, 51, 62, 32, 109, 22, 1, [0, 10]], [[0, 21], 18, 100, 38, 42, 122, 37, 62, 37, 164, 62, 30, 37, 38, 69, 39, 39, 38, 38, 37, 37, 54, 54, 42, 221, 222, 223, 126, 169, 194, [169, 2], 224, 155, 225, 186, 54, 68, 29, 68, [42, 3], [100, 4], 98, 98, 152, 87, 87, 139, 187, 153, 226, 227, 167, 0, 3, 53, 104, 58, 32, 1, [0, 10]], [[0, 21], 14, 197, 54, 95, 88, [122, 2], 228, 55, 55, 37, 37, 54, [38, 4], 37, [54, 4], 55, 229, 212, 230, 143, [169, 3], 215, 180, 189, 230, 231, 60, [68, 3], 42, 94, 42, [100, 4], 91, 98, 94, 87, [187, 2], 232, 153, 227, 48, 46, 1, 4, 63, 117, 104, 23, 1, [0, 10]], [[0, 21], 9, 98, 42, 94, 216, 95, 101, 115, 55, 37, 55, 55, 95, [38, 3], 37, 37, 54, 55, 67, 54, 55, 177, 233, 144, [169, 2], 194, 169, 215, 234, 199, 216, 235, 67, [68, 3], 100, 94, 98, 100, 67, 100, 91, 91, 98, 128, 87, 187, 198, 232, 226, 236, 5, 0, 0, 1, 51, 117, 104, 24, 1, [0, 10]], [[0, 21], 1, 106, 98, 218, 139, 95, 54, 68, 37, 54, 55, 55, 101, 54, 38, 37, 54, 54, 55, 42, 42, 100, 101, 127, 131, 214, 169, [194, 2], 169, 237, 221, 82, 173, 235, 128, [68, 3], 100, 94, 94, 98, [100, 2], 91, 98, 152, 87, 87, 139, 232, 153, 238, 20, 1, [0, 3], 22, 24, 24, 53, 46, [0, 10]], [[0, 22], 6, 98, 218, 87, 216, 177, 101, 55, 228, 177, 189, 190, 98, 38, 54, 54, 42, 98, 98, 42, 42, 160, 193, 201, [169, 2], [194, 3], 144, 95, 225, 239, 240, 187, 67, 68, 68, 67, [94, 5], [128, 2], 87, [187, 3], 198, 241, 2, [0, 5], 72, 24, 117, 32, 2, [0, 10]], [[0, 23], 17, 42, 67, 128, 189, 125, 242, [243, 2], 130, 189, 101, 54, 54, 42, 98, 101, 98, 42, 114, 144, [201, 2], [169, 2], [194, 3], 170, 101, 244, 245, 94, 232, 160, 100, 92, 67, 42, 95, 87, 88, [139, 2], 187, 216, [200, 3], 160, 9, [0, 6], 2, 63, 45, 58, 46, [0, 10]], [[0, 23], 4, 246, 54, 67, 29, 101, 247, 248, 249, 130, 37, 98, 188, 100, 42, 95, 98, 42, 98, 237, 169, 250, 251, 169, [194, 3], 201, 193, 170, 127, 252, 173, 199, 253, 226, 78, 137, 98, 94, 128, 187, 200, 254, 200, [254, 2], 199, 160, 255, 140, [0, 7], 22, 32, 26, 4, [0, 10]], [[0, 24], 2, 48, 98, 37, 62, 130, 129, 71, 115, 62, 54, 95, 42, 94, 95, 42, 42, 159, 256, 194, 250, 194, 169, 194, [169, 2], 194, 257, 102, 258, 203, 259, 258, 216, 127, 159, 128, 94, 94, [87, 3], 187, 216, [200, 2], 159, 145, 124, 6, [0, 7], 1, 3, 2, 1, [0, 10]], [[0, 25], 6, 226, 67, 37, 37, 129, 71, 121, 37, 54, 101, 122, 95, 95, 42, 128, 215, 169, 251, 256, 169, [194, 6], 142, 144, 260, 261, 262, 263, [205, 2], 264, 200, 139, 187, 216, [200, 2], [139, 2], 199, 265, 144, 124, 17, [0, 21]], [[0, 25], 1, 17, 98, 42, 43, 266, [249, 2], 42, 54, 55, 127, 122, 95, 94, 205, 169, 257, 251, 237, 170, [194, 6], 257, 267, 268, 177, 93, 189, 131, 162, 127, 264, 260, 264, [263, 2], 216, 88, 253, 265, 201, 144, 163, 114, 1, [0, 20]], [[0, 25], 1, 2, 102, 98, 101, 247, 44, 221, 44, 55, 98, 205, 253, 122, 253, 215, 194, 257, 215, 268, 237, [194, 6], [257, 2], 209, 145, 139, 264, 269, 255, 162, 127, 270, 264, 163, 260, 263, 93, 155, 215, 201, 143, 134, 189, 5, [0, 20]], [[0, 26], 271, 272, 98, 98, 87, 226, 98, 42, 42, 137, [131, 2], 205, 195, 169, 194, 169, 202, 148, 144, 194, [251, 2], [194, 4], 251, 201, 159, 263, 177, 222, 172, 124, 175, 145, 163, 216, 273, 230, 216, 145, 195, 193, 201, 123, 93, 274, [0, 20]], [[0, 26], 1, 267, 190, 68, 100, 67, 67, 54, 67, 190, 144, 142, 265, [169, 2], 201, 215, 267, 275, 144, [194, 8], 193, 144, 255, 264, 263, 276, 185, 172, 263, 126, 173, 258, 88, 255, 145, 142, 215, 257, 161, 269, 277, [0, 20]], [[0, 25], 1, 15, 125, 142, 246, 98, 42, 95, 55, 98, 205, 215, 237, 142, 169, 194, 169, 170, 272, 134, 215, [194, 8], 214, 237, 256, 131, 126, 269, 273, 278, 217, 258, 216, 200, 163, 264, 270, 145, 144, 257, 256, 216, 279, [0, 20]], [[0, 24], 1, 280, 148, 162, 169, 237, 190, 94, 88, 139, 205, 144, 237, 255, 161, [194, 2], 215, 237, 281, 127, 215, [194, 2], 251, [194, 5], 256, 282, 170, [256, 2], 265, 175, 230, 203, 283, 101, 270, 177, [264, 2], 255, 142, 194, 145, 233, 182, 11, [0, 19]], [[0, 23], 11, 284, 282, 132, 169, 194, 169, 205, 87, 139, 199, 255, 177, 155, 145, 193, 194, [215, 2], 155, 285, 237, 169, [194, 6], 251, 194, 214, 282, 205, [201, 2], 256, 215, 155, 185, 211, 286, 98, 127, [264, 2], 270, 142, 251, 177, 222, 169, 97, [0, 19]], [[0, 22], 11, 287, 144, 215, 257, [194, 2], 169, 145, 198, 187, 200, 216, 222, 163, 162, 169, 250, 288, 145, 229, 155, 170, [194, 9], 251, 255, 253, 144, [250, 2], 251, 289, 290, 291, 196, 69, 226, [127, 2], 270, 142, 256, 292, 216, 183, 75, [0, 19]], [[0, 21], 97, 293, [169, 2], 201, 194, 257, 194, 294, 169, 205, 200, 216, 95, 216, 163, 205, 214, 250, 215, 134, 292, 255, 215, [194, 5], 251, [194, 4], 265, 253, 127, 193, 250, 295, 201, 143, 233, 296, 69, 37, 255, 205, 270, 142, 162, 172, 264, 257, 75, [0, 19]], [[0, 20], 11, 293, 194, 169, 250, [194, 4], 294, 194, 193, 215, 131, 221, 93, 190, 192, 201, 250, 289, 123, 273, 255, 208, 169, [194, 5], 251, [194, 3], 193, 127, 177, 145, 201, [250, 2], 201, 131, 297, 298, 299, 253, 142, 205, 215, 126, 225, 199, 288, 85, [0, 19]], [[0, 20], 284, [194, 2], 169, 201, [194, 2], 251, [194, 2], [169, 2], 194, 144, 177, 101, 22, 300, [250, 2], 251, 301, 302, 145, 169, [194, 6], [251, 2], [194, 2], 257, 144, 189, 253, 215, 201, 303, 250, 251, 290, 304, 305, 255, 265, 151, 163, 263, 255, 306, 257, 75, [0, 19]], [[0, 19], 85, 169, [194, 5], 251, 201, 251, [194, 2], [169, 3], 307, 59, 308, 309, [201, 2], 310, 311, 312, 313, [169, 3], [194, 3], 257, [194, 5], 214, 302, 253, 155, 256, 201, 250, 295, 214, 82, 223, [134, 2], 314, 123, 169, 194, 169, 315, 85, [0, 19]], [[0, 18], 97, 315, [194, 3], 182, 181, 168, 206, [194, 7], 316, 73, 103, 194, [201, 2], [194, 2], 294, 194, [169, 4], 215, 162, 317, 162, 215, 256, [194, 3], 215, [253, 2], 145, 256, 169, 265, 256, 145, 296, 213, 184, 177, 169, 313, 315, 313, 301, 318, [0, 19]], [[0, 17], 97, 287, [194, 2], 169, 315, 287, 319, 320, 321, 322, [194, 3], 251, [194, 3], 83, 110, 257, 201, 250, 194, [169, 7], 323, 155, 324, 136, 253, 285, 289, 256, [194, 2], 209, 253, 229, 144, 194, 215, 162, 144, 273, 298, 263, [169, 2], [194, 2], 315, 325, 277, [0, 19]], [[0, 16], 2, 309, [194, 3], 313, 309, 326, 327, 328, 321, 329, [194, 7], 330, 331, 201, [250, 2], [194, 2], [169, 10], 215, 302, 229, 162, 169, 194, 214, 229, 160, 159, 289, 251, 143, 155, 317, 142, 169, 208, 332, [194, 2], 215, 170, 277, [0, 19]], [[0, 15], 141, 287, [194, 2], 294, 194, 315, [333, 3], 309, 333, 182, 315, 194, 169, [194, 4], 251, 169, 295, 250, [194, 2], [169, 8], [313, 3], [169, 2], 145, 229, 255, 214, 194, 144, 160, 139, 200, 144, 313, 334, 189, 162, 215, 335, 146, 215, 194, 224, 317, 287, [0, 19]], [[0, 15], 85, 169, 170, [169, 3], 315, 207, 309, 336, 326, 337, 326, 182, [194, 6], 201, 144, 256, 303, 194, [169, 10], [313, 3], 183, 313, 144, 253, 131, 214, 194, 205, [128, 2], 253, 335, 313, 159, 242, 144, 294, 302, 170, 169, 282, 338, 309, 141, [0, 18]], [[0, 15], 168, 96, 121, 180, [169, 2], 315, 309, 339, 337, 340, 220, 341, 182, [194, 7], 144, 237, 144, 193, 194, [169, 10], [313, 2], 169, [313, 2], 144, 253, 127, 169, 144, 190, [107, 2], 136, 334, 170, 242, 177, [215, 2], 267, 215, 229, 131, 206, 3, [0, 18]], [[0, 14], 11, 208, 120, 342, 228, 215, 169, 194, 343, 344, 345, 346, 287, 293, 321, [194, 5], 251, 194, 257, 162, 347, 237, [169, 9], [313, 6], 315, 313, 237, 189, 255, 215, 237, 98, 91, 196, 348, 335, 302, 122, 132, 183, 302, 237, 347, 317, 170, 103, [0, 18]], [[0, 14], 97, 251, 120, 112, 55, 142, 294, 194, 315, 309, 333, 349, [350, 2], 182, 315, [194, 6], 257, 256, 127, 282, 169, 313, [169, 2], 313, [169, 2], [313, 3], [169, 2], [313, 5], 315, 127, 171, 144, 208, 159, 196, 351, 101, 282, 144, 171, 136, 169, 131, 224, 352, 237, 208, 105, [0, 18]], [[0, 14], 353, 169, 115, 62, 43, 145, 294, 169, 315, 301, 329, 350, 354, 355, 287, 356, 201, [194, 7], 215, 229, [169, 2], 215, 237, 335, 169, 183, 315, 313, [183, 2], 315, [313, 2], 169, 313, 335, 313, 208, 357, 146, 183, 144, 351, 196, 78, 101, 317, 170, 358, 144, 237, 334, 144, 224, 208, 343, 2, [0, 17]], [[0, 13], 11, 182, 209, 62, 62, 44, 142, 294, [169, 2], 183, 315, 309, 326, 168, 287, 194, 201, [194, 5], 169, 194, 169, 282, 142, 169, 215, 224, 335, 208, 323, 335, 215, 313, [335, 2], 313, 169, [313, 2], [335, 2], 315, 170, 228, 131, 170, 359, 360, 78, 91, 122, 162, 131, 237, 335, 208, 170, 157, 209, 170, 10, [0, 17]], [[0, 13], 361, 194, 362, 62, 38, 114, 193, [169, 2], [194, 3], 182, 363, 330, 315, 194, 251, [194, 6], [169, 2], 282, 177, 169, 215, 282, 323, 332, 352, 171, 229, 131, 215, [313, 5], [335, 2], 313, 315, 302, 228, 145, 364, 365, 101, 78, 91, 165, 162, 142, [215, 2], 170, 165, 282, 208, 74, [0, 17]], [[0, 13], 366, 154, 37, 62, 37, 146, 194, [169, 3], [194, 2], 201, [169, 4], [194, 4], [251, 2], [194, 3], 237, 122, 145, 215, 352, 131, 215, 313, 144, 282, 189, 282, 145, 169, [313, 2], 335, 313, [335, 2], 208, 195, [367, 2], 94, 368, 172, 55, 211, 351, 369, 299, 94, 195, 215, 242, 131, 208, 168, 1, [0, 16]], [[0, 12], 1, 2, 49, 30, 39, 78, 237, 251, [169, 3], 194, 257, 250, 289, [169, 2], 194, 169, 251, [194, 3], 251, 194, 169, 313, 215, [171, 2], 142, 334, 171, 144, 313, 315, 215, 335, 237, [282, 2], 144, 313, 335, 315, 215, 323, [208, 2], 202, 370, 102, 371, 196, 148, 196, 360, 196, 299, 364, 101, 215, 282, 352, 169, 206, 2, [0, 16]], [[0, 11], 1, 20, 246, 98, 54, 68, 114, 215, 251, [169, 3], 194, [201, 2], 323, 169, 313, [169, 2], 251, 169, [194, 3], [169, 2], 313, 169, 237, 157, 171, 144, 347, 171, [335, 2], [313, 2], 169, 215, 282, 189, 237, 313, 169, 334, 224, [335, 2], 195, 96, 78, 82, 372, 172, 102, 106, 55, 157, 145, 190, 281, 215, 146, 323, 315, 5, [0, 16]], [[0, 11], 72, 107, 42, 95, 128, 55, 190, 256, 310, 251, 169, 194, 251, 201, 256, 317, [169, 4], [194, 2], [169, 2], [194, 2], 313, 169, 313, 335, 159, 130, 229, 237, 101, 131, 313, 315, 169, 335, 195, 215, [189, 2], 162, 169, 282, 131, 215, 323, 162, 122, 42, 101, [360, 2], 163, 246, 67, 228, 324, 335, 170, 208, 237, 224, 335, 340, [0, 16]], [[0, 10], 46, 137, 82, 211, 43, 122, 128, 226, 193, 310, 201, 257, [251, 3], 144, 285, 256, 169, 313, 169, 313, 194, 313, 169, [194, 2], 315, 183, 315, 335, 302, 247, 171, 162, 44, 347, [313, 3], [208, 3], 282, 44, 189, 215, 155, 131, 237, 229, 44, 147, [351, 2], 261, 365, 373, 253, 78, 137, 130, 323, 313, 285, 144, 374, 206, 321, 11, [0, 15]], [[0, 9], 1, 28, 258, 95, 95, 112, 42, 128, 268, [201, 4], [251, 2], 194, 334, 324, 256, 194, [169, 2], 313, 194, [169, 3], 214, [194, 3], 214, 302, 171, 145, 144, 242, 136, 215, 315, [208, 4], 237, 228, 221, 317, 155, 189, [195, 2], 215, 144, 157, 43, 211, 138, 375, 273, 228, 48, 44, 285, 208, 229, 282, 352, 282, 136, 103, [0, 15]], [[0, 9], 14, 376, 42, 67, 95, 43, 42, 101, 237, 257, 201, 142, 169, 201, 251, 194, 237, 324, 193, [194, 2], [169, 2], 313, [169, 2], 335, 323, [169, 2], 335, 237, 137, 228, 170, 208, 114, 101, 155, 301, 335, [313, 2], 169, 144, 190, 221, 324, 302, 130, 334, [335, 3], 202, 115, 67, 43, 365, 217, 93, 107, 98, 347, 215, 242, 155, 377, 157, 184, 370, [0, 15]], [[0, 8], 9, 88, 261, 43, 54, 68, 37, 54, 98, 268, 209, 265, 205, 170, 201, [295, 2], 237, 324, 193, 251, 194, [169, 2], 313, [169, 2], 215, 237, 313, 315, 215, 142, 98, 101, 142, 208, 146, 55, 242, [208, 2], 335, 315, 183, 215, 242, 95, 136, 205, 130, 155, 208, 315, 335, 195, 102, 106, 78, 95, 299, 351, 197, 98, 130, 162, 130, 131, 253, 44, 82, 127, 4, [0, 14]], [[0, 7], 2, 236, 230, 95, 43, 54, 67, 54, 38, 38, 68, 68, 67, 114, 159, 142, 201, 250, 265, 155, 215, 251, [194, 2], [169, 2], 315, 169, 144, 131, 294, 313, 378, 363, 98, 211, 229, 145, 323, 101, 44, 125, 208, 301, 170, [208, 2], 157, 55, 221, 145, 228, 148, 144, [315, 2], 335, 170, 48, 78, 78, 82, 379, 304, 373, 130, 131, 130, 125, 317, 373, 304, 165, 5, [0, 14]], [[0, 7], 6, 87, 173, 95, 54, 37, 55, 54, 38, 38, 62, 39, 30, 69, 38, 29, 246, 281, 201, 237, 144, [251, 2], 194, [169, 2], 208, 315, 131, 253, 214, 313, 325, 343, 128, 95, 130, 228, 282, 229, 101, 122, 131, 325, 285, [170, 2], 101, 67, 247, 131, 357, 266, 131, 170, [315, 2], 335, 159, 66, 246, 98, 217, 379, 297, 373, 125, 101, 290, 317, 290, 304, 351, 103, [0, 14]], [[0, 6], 4, 280, 88, 173, 95, 113, 38, 38, 42, 101, 42, 54, 68, 62, 62, 38, 39, 108, 30, 202, 256, 170, 169, [194, 3], 294, 313, 315, 229, 130, 289, [313, 2], 208, 102, 101, 155, 268, 55, 253, 190, 137, 157, 133, 229, 323, 155, 44, 67, 247, 131, 237, [247, 2], 131, 208, [301, 2], 170, 236, 106, 66, 211, 379, 380, 381, 382, 101, 136, [215, 2], 216, 304, 83, [0, 14]], [[0, 6], 3, 236, 173, 87, 94, 54, 37, 38, 38, 62, 38, 55, 122, 189, 122, 114, 55, 50, 62, 202, 201, [215, 2], 257, [194, 2], [169, 3], 282, 130, 215, 313, 315, 335, 357, 247, 285, 144, 226, 42, 177, 383, 98, 305, 136, 323, 155, 147, 188, 384, 93, 237, 282, 43, 157, 170, [208, 3], 209, 106, 385, 211, 380, 372, 386, 223, 130, 387, 215, 313, 215, 185, 89, [0, 14]], [[0, 6], 5, 36, 88, 87, 98, 54, 42, 42, 54, 38, 39, 30, 56, 39, 115, 388, 268, 159, 237, 215, [201, 2], 215, 169, 201, 194, [169, 3], 282, 242, 323, [313, 2], 215, 281, 44, 189, 215, 142, 98, 221, 177, 98, 188, 95, 170, 215, 157, 94, 54, 54, 101, 155, 268, 55, 189, 142, [208, 2], 237, 102, 60, 211, 389, 390, 379, 391, 197, 221, 162, 335, 313, 162, 373, 9, [0, 13]], [[0, 6], 83, 48, 88, 88, 95, 54, 54, 42, 44, 54, 54, 68, [39, 4], 50, 63, 246, 265, 169, 201, 169, 215, 144, 193, [215, 2], 169, 237, 228, 237, 313, 169, 215, 237, 114, 122, 170, 313, 253, 211, 155, 190, 392, 42, 136, 334, 190, 91, 101, 122, 42, 44, 125, 107, 91, 200, 334, 155, 224, 255, 44, 82, [393, 2], 365, 394, 371, 373, 127, [144, 2], 170, 131, 37, 47, [0, 12]], [[0, 6], 72, 281, [216, 2], 88, 98, 113, 68, 78, 42, 221, 128, 98, 67, 43, 37, 62, 63, 115, 161, 145, 331, 395, 143, 145, 162, 237, 282, 334, 215, [114, 2], 323, 313, 335, 215, 190, 101, 131, 335, 237, 82, 93, 237, 38, 100, 373, 131, 159, 66, 137, 165, 190, 78, 101, 229, 137, 42, 253, 242, 334, 173, 196, 211, 396, 393, 217, 37, 371, 211, 233, 101, 233, 125, 144, 136, 89, [0, 12]], [[0, 6], 11, 202, 253, 88, 139, 216, 114, 33, 51, 30, 108, 39, 54, 137, 146, 132, 127, 146, 255, 175, 161, 5, 181, 289, [255, 2], 215, 323, 282, 237, 159, 247, 136, 208, 335, 208, 205, 98, 189, 215, 208, 95, 221, 144, 98, 188, 95, 357, 131, 246, 78, 101, 317, 101, 91, 189, 146, 67, 365, 221, 132, 397, 244, 373, 393, 398, 399, 115, 188, 359, 261, 189, 298, 400, 139, 162, 230, 59, [0, 11]], [0, 0, 401, 402, 403, 404, 403, 405, 406, 407, 408, 357, 409, 13, 410, [411, 3], 412, 30, 30, 413, 151, 414, [411, 2], 415, 11, 284, 256, 255, 127, 416, 417, 418, 414, 419, 420, 421, 422, 423, 335, 208, 137, 101, 334, 424, 425, 426, [414, 2], 427, 426, 428, 429, 98, 78, 430, [411, 9], 431, 259, 292, 380, 432, 433, 434, 420, 414, [420, 2], 426, 435, 436, 177, 282, 42, 174, 401, 437, 438, 404, 403, 439, 440, 441, 442, 0], [0, 441, [411, 8], 443, 272, 300, 202, 444, [411, 3], 445, 101, 62, 120, 151, 414, [411, 2], 446, 0, 90, 201, 205, 447, 419, [411, 7], 448, 323, 208, 357, 37, 447, 419, [411, 7], 421, 122, 78, 449, [411, 9], 450, 451, 126, 217, 452, [411, 8], 453, 360, 162, 173, 454, [411, 8], 401, 0], [455, [411, 2], 403, 456, 1, 1, 457, 458, 459, 460, 208, [201, 2], 461, [411, 3], 462, 200, 255, 162, 175, 414, [411, 2], 440, 0, 75, 201, 463, [411, 3], 459, 423, 191, 464, 465, 466, 467, 334, 208, 237, 468, [411, 3], 469, 470, 199, 471, 472, 473, 474, 136, 60, 475, [411, 3], 475, 221, 190, 115, 128, 114, 100, 476, 203, 477, [411, 2], 420, 478, 78, 226, 479, 480, 481, 482, 211, 200, 429, [411, 2], 483, 455, 1, 1, 442, 401, 402, 401, 0], [484, [411, 2], 485, [0, 3], 1, 340, 193, [251, 2], 295, 310, 461, [411, 3], 462, 253, 145, 144, 161, 414, [411, 2], 402, 0, 0, 486, [411, 3], 487, 313, 169, 162, 136, 162, 190, 55, 229, 144, 488, [411, 3], 454, 100, 253, 130, 68, 61, 188, 92, 221, 98, 430, [411, 3], 489, 44, 163, 388, 137, 132, 128, 391, 399, 490, [411, 2], 491, 128, 114, 139, 365, 492, [298, 2], 189, 42, 422, [411, 2], 493, [0, 8]], [441, [411, 2], 494, 442, [0, 3], 11, 179, 195, [201, 3], 444, [411, 3], 495, 253, 142, 215, 161, 419, [411, 2], 496, 0, 0, 497, [411, 2], 419, 498, [169, 2], 317, 377, 131, 268, 107, 98, 177, 499, [411, 2], 414, 500, 392, 101, [114, 2], 152, 91, 501, 286, 101, 327, [411, 3], 502, 373, 172, 189, 197, 131, 127, 503, 504, 505, [411, 2], 506, 507, 185, 82, 492, 196, 503, 298, 189, 211, 508, [411, 2], 509, 456, [0, 7]], [510, [411, 4], 511, 441, 401, 141, 10, 234, 191, [205, 2], 512, [411, 3], 513, 199, 142, 161, 144, 514, [411, 2], 496, 0, 0, 515, [411, 2], 516, 228, 202, 169, 285, 243, 282, 302, 517, 92, 216, 420, [411, 2], 421, 518, 519, [60, 3], 106, 66, 520, 521, 92, 327, [411, 3], 489, 373, 189, 42, 239, 273, 127, 298, 522, 523, [411, 4], 524, 525, 526, 376, 391, 186, 122, 365, 527, [411, 4], 528, 441, 401, 141, [0, 3]], [141, 529, [411, 6], 530, 485, 12, 199, 127, 177, 429, [411, 3], 531, 179, 340, 83, 103, 532, [411, 2], 496, 0, 0, [411, 3], 533, 216, 268, 170, 229, 130, 282, 237, 78, 116, 534, [411, 3], 535, 521, 536, 392, 60, 60, 78, 78, 66, 521, 537, 538, [411, 9], 163, 221, 539, 540, 506, [411, 6], 419, 541, 542, 186, 211, 239, 506, [411, 6], 530, 543, 0, 0], [0, 455, 494, [411, 7], 402, 6, 180, 270, 544, [411, 3], 545, 3, [0, 3], 494, [411, 2], 496, 0, 0, [411, 3], 546, 273, 192, 323, 131, 242, 155, 208, 92, 547, 227, [411, 3], 491, 548, 549, 392, 92, [78, 3], 550, 551, 537, 538, [411, 9], 225, 122, 298, 398, 552, 553, [411, 7], 554, 380, 351, 196, 555, 553, [411, 7], 496, 0], [[0, 3], 401, 485, 494, [411, 5], 141, 3, 220, 556, [411, 3], 401, [0, 4], 494, [411, 2], 496, 0, 0, 532, [411, 2], 557, 82, 127, 317, 215, 189, 155, 335, 67, 392, 78, 414, [411, 2], 421, 68, 549, 519, 91, 66, 78, 66, 66, 501, 66, 558, [411, 3], 559, 269, 142, 209, 139, 451, 298, 304, 360, 365, 364, 92, 560, 561, 562, [411, 5], 540, 380, [196, 2], 563, 480, 525, 427, [411, 5], 141], [[0, 6], 141, 402, [411, 3], 455, 0, 0, 442, [411, 3], 401, [0, 4], 403, [411, 2], 441, 0, 0, 485, [411, 2], 414, 564, 291, 172, 155, 93, 269, 162, 107, 565, 66, 566, [411, 2], 414, 94, 567, 364, 286, 66, 91, 568, 479, 569, 568, 570, [411, 3], 560, 231, 519, 518, 501, 568, 399, 432, 571, 360, 66, [106, 2], 572, 573, 574, 575, [411, 3], 576, 577, 571, 563, 578, [571, 2], 380, 579, 402, [411, 3], 455], [[0, 7], 442, [411, 3], 442, [0, 3], 580, [411, 2], 484, [0, 3], 141, [411, 3], 581, 0, 0, 455, [411, 3], 541, 582, 583, 290, 101, 190, 132, 242, 572, 568, 584, [411, 3], 467, 360, 371, 567, 392, 188, 568, 565, 585, 586, 587, [411, 3], 588, 589, 519, [590, 2], 436, 360, 577, 591, 577, 197, 218, 100, 572, 592, 593, 594, [411, 3], 595, 596, 577, 571, 597, 598, [577, 2], 360, 599, [411, 3], 442], [510, 496, 401, 442, 1, 0, 141, 485, [411, 2], 494, [0, 4], 485, [411, 2], 403, 456, 0, 141, 440, [411, 2], 529, 141, [0, 3], 484, [411, 3], 541, 600, 199, 601, 602, 603, 604, 94, 589, 605, 606, [411, 3], 607, 608, 521, 471, 609, 610, 611, 521, 612, 613, [411, 3], 614, 564, 67, 501, 590, 521, 548, 492, 615, 616, 554, 617, 618, 619, 620, 621, 622, [411, 2], 414, 623, 397, 450, 505, 624, 619, 573, 571, 625, 626, [411, 2], 494, 0], [627, [411, 8], 530, 456, [0, 4], 1, 628, [411, 7], 404, 401, [0, 5], 629, 419, [411, 7], 630, 258, 173, 631, 632, 633, 419, [411, 7], 634, 521, 590, 635, [411, 9], 611, 636, 637, 638, [411, 8], 414, 639, 197, 187, 447, [411, 8], 530, 456, 0], [141, 510, 496, 628, 494, 404, 529, 511, 441, 442, [0, 7], 581, 440, 403, 404, 529, 628, 441, 141, [0, 6], 271, 640, 641, 630, 506, [414, 2], 642, 643, 644, 60, 189, 175, 645, 239, 646, 633, 647, 506, 414, 420, 648, 610, 649, 536, 590, 650, [411, 9], 474, 636, 651, 652, 638, 653, 524, 562, 414, 506, 562, 622, 654, 655, 656, 631, 470, 657, 658, 659, 553, [414, 2], 660, 441, 442, 0, 0], [[0, 29], 4, 9, 33, 53, 365, 351, 54, 98, 252, 269, 122, 94, 551, 364, 226, 128, 661, 595, 589, 662, 663, 254, 302, 664, [549, 2], 536, 665, 666, 667, 668, 589, 67, 669, 670, 185, 88, 67, 92, 60, 519, 548, 671, 672, 673, 668, [667, 3], 663, 674, 586, 359, 231, 586, 589, 258, 397, 661, 675, 676, 53, [0, 4]], [[0, 27], 1, 57, 364, [676, 2], 391, 677, 360, 128, 244, 678, [186, 2], 669, 542, 98, 153, 679, 235, 631, 204, 680, 671, 637, 680, 190, 392, 519, 681, 590, 636, 682, 667, 671, 92, 93, 564, 397, 683, 231, 371, 218, 384, [371, 2], 612, 684, 637, [667, 2], 620, 586, 675, 620, 675, 669, 397, 676, [685, 2], 573, 542, 573, 53, [0, 4]], [[0, 27], 1, 686, 670, 687, 688, 689, 690, 223, 244, 691, 692, 88, 211, 615, 685, 94, 693, 694, 572, 645, 534, 160, 679, 695, 672, 696, 204, 218, 188, 392, 521, 697, 672, 619, 605, 67, 268, 255, 263, 254, 564, 674, 235, 263, 127, 177, 492, 698, 682, 699, 673, 632, 569, 673, 699, 687, 700, 259, 685, [573, 3], 698, 701, [0, 4]]]};

  // romejs/cli-diagnostics/src/banners/error.json

  const ___$romejs$cli_diagnostics$src$banners$error_json$default = {'palettes': [[0, 0, 0], [15, 0, 0], [30, 15, 15], [30, 15, 30], [15, 15, 15], [75, 60, 60], [45, 30, 30], [30, 30, 30], [90, 75, 75], [120, 90, 90], [105, 75, 75], [60, 45, 45], [90, 75, 60], [90, 60, 60], [105, 90, 90], [180, 135, 135], [150, 120, 120], [165, 135, 120], [120, 105, 90], [150, 120, 105], [105, 75, 90], [45, 45, 45], [30, 30, 15], [195, 165, 165], [195, 165, 150], [165, 120, 120], [180, 150, 150], [165, 135, 135], [15, 0, 15], [75, 60, 45], [165, 150, 135], [210, 165, 165], [210, 180, 180], [225, 180, 180], [135, 105, 105], [60, 30, 30], [60, 60, 45], [210, 180, 165], [225, 195, 180], [225, 195, 195], [75, 45, 45], [45, 15, 15], [135, 120, 105], [180, 150, 135], [195, 150, 150], [135, 105, 90], [240, 210, 195], [240, 195, 195], [30, 15, 0], [150, 135, 120], [180, 165, 150], [240, 210, 210], [240, 195, 180], [105, 90, 75], [135, 120, 120], [225, 180, 165], [210, 165, 150], [240, 210, 180], [60, 45, 30], [120, 105, 105], [240, 225, 210], [225, 210, 195], [195, 150, 135], [75, 75, 60], [180, 165, 165], [240, 225, 225], [225, 195, 165], [195, 165, 135], [210, 150, 135], [210, 180, 150], [180, 135, 105], [195, 180, 165], [165, 120, 90], [165, 105, 75], [180, 120, 105], [210, 165, 135], [195, 135, 120], [225, 165, 150], [195, 150, 120], [210, 195, 180], [150, 90, 75], [225, 180, 150], [180, 120, 90], [195, 135, 105], [150, 75, 45], [180, 135, 120], [45, 15, 30], [210, 150, 120], [165, 105, 90], [165, 120, 105], [135, 90, 75], [135, 90, 90], [180, 120, 75], [165, 90, 60], [150, 90, 45], [135, 60, 30], [135, 75, 60], [150, 105, 75], [180, 150, 120], [15, 15, 0], [165, 135, 105], [240, 195, 165], [180, 105, 75], [165, 90, 45], [195, 135, 90], [150, 90, 60], [135, 90, 60], [150, 105, 90], [150, 135, 105], [45, 45, 30], [210, 135, 120], [195, 120, 90], [180, 105, 60], [165, 75, 45], [105, 75, 60], [210, 135, 105], [225, 150, 105], [225, 135, 105], [210, 120, 90], [195, 105, 75], [195, 120, 75], [195, 90, 60], [180, 90, 45], [150, 75, 30], [135, 75, 45], [240, 150, 105], [240, 135, 105], [210, 105, 75], [180, 90, 60], [195, 105, 60], [150, 75, 60], [135, 90, 45], [255, 150, 105], [240, 150, 120], [240, 165, 120], [240, 165, 135], [225, 120, 90], [180, 75, 45], [180, 75, 30], [165, 75, 30], [225, 150, 135], [255, 165, 120], [240, 180, 150], [255, 195, 165], [240, 150, 135], [210, 105, 60], [195, 90, 45], [150, 60, 15], [150, 60, 30], [45, 30, 45], [225, 165, 135], [255, 150, 120], [255, 210, 180], [225, 120, 75], [165, 90, 75], [195, 120, 105], [255, 210, 195], [255, 195, 180], [255, 180, 165], [240, 120, 90], [180, 105, 105], [120, 90, 75], [240, 135, 90], [255, 135, 105], [255, 180, 150], [195, 120, 120], [135, 120, 90], [255, 165, 135], [240, 180, 165], [165, 60, 30], [150, 60, 45], [180, 105, 90], [240, 165, 150], [255, 165, 150], [165, 75, 60], [165, 105, 60], [120, 105, 75], [240, 135, 120], [240, 120, 105], [195, 90, 75], [135, 45, 30], [255, 135, 90], [210, 120, 75], [225, 150, 120], [225, 135, 90], [240, 120, 75], [135, 45, 15], [75, 45, 30], [150, 120, 90], [240, 135, 75], [180, 75, 60], [150, 105, 105], [210, 105, 90], [135, 75, 30], [120, 90, 60], [255, 150, 135], [225, 120, 105], [120, 45, 15], [120, 60, 15], [210, 135, 90], [165, 60, 45], [105, 45, 0], [135, 105, 75], [180, 90, 75], [105, 60, 15], [225, 105, 75], [210, 90, 75], [210, 90, 60], [195, 75, 45], [105, 30, 0], [120, 75, 45], [120, 60, 30], [120, 30, 15], [120, 30, 0], [135, 30, 0], [150, 45, 15], [165, 45, 15], [165, 60, 15], [105, 30, 15], [105, 45, 15], [75, 60, 30], [105, 15, 0], [105, 0, 0], [120, 0, 0], [120, 15, 0], [135, 15, 0], [150, 30, 0], [90, 0, 0], [75, 0, 0], [75, 15, 0], [90, 15, 0], [90, 30, 0], [120, 60, 45], [45, 30, 15], [150, 45, 0], [165, 30, 0], [165, 45, 0], [180, 60, 30], [135, 45, 0], [120, 45, 0], [225, 165, 165], [105, 75, 45], [90, 30, 15], [120, 45, 30], [60, 30, 15], [180, 45, 0], [45, 0, 0], [90, 30, 30], [150, 45, 30], [120, 45, 45], [105, 60, 45], [30, 0, 0], [180, 60, 45], [195, 15, 0], [225, 135, 75], [105, 30, 30], [105, 15, 15], [60, 0, 0], [135, 30, 30], [180, 0, 0], [210, 0, 0], [195, 105, 90], [120, 30, 30], [165, 0, 0], [120, 75, 60], [210, 150, 105], [240, 150, 90], [135, 60, 45], [135, 60, 15], [165, 15, 0], [195, 0, 0], [195, 75, 30], [195, 60, 30], [180, 15, 0], [255, 150, 90], [165, 30, 15], [165, 45, 30], [105, 45, 30], [195, 75, 60], [90, 45, 15], [150, 30, 15], [180, 45, 30], [225, 105, 60], [225, 105, 90], [150, 15, 0], [210, 90, 45], [210, 120, 105], [90, 60, 45], [225, 135, 120], [225, 120, 60], [90, 45, 30], [135, 30, 15], [195, 105, 45], [75, 30, 15], [45, 15, 0], [180, 60, 15], [60, 15, 15], [195, 90, 30], [180, 75, 15], [165, 60, 0], [150, 75, 15], [105, 60, 60], [150, 60, 0], [180, 90, 30], [165, 75, 15], [180, 105, 45], [165, 90, 30], [180, 120, 60], [165, 105, 45], [150, 90, 30], [135, 60, 0], [120, 90, 105], [165, 150, 150], [75, 30, 0], [75, 30, 30], [135, 105, 120], [60, 15, 0], [135, 120, 135], [165, 135, 150], [90, 60, 75], [60, 60, 60], [75, 60, 75], [150, 135, 135], [255, 0, 0], [240, 0, 0], [225, 45, 15], [135, 75, 15], [105, 90, 105], [60, 45, 60], [195, 60, 15], [60, 30, 0], [75, 15, 15], [225, 30, 0], [120, 60, 0], [45, 30, 0], [225, 0, 0], [225, 15, 0], [195, 165, 180], [90, 75, 90], [150, 0, 0], [195, 30, 0], [210, 15, 15], [180, 150, 165], [150, 120, 135], [75, 75, 75], [75, 45, 15], [195, 45, 0], [210, 30, 30], [225, 60, 30], [210, 75, 30], [240, 45, 15], [210, 30, 15], [225, 75, 30], [180, 30, 0], [210, 15, 0], [105, 90, 60], [240, 210, 165], [225, 105, 45], [75, 45, 60], [60, 60, 30], [165, 120, 75], [60, 45, 15], [210, 105, 45], [225, 90, 45], [210, 30, 0], [240, 60, 30], [240, 45, 30], [210, 45, 15], [195, 150, 105], [105, 45, 45], [240, 15, 0], [240, 75, 45], [150, 45, 45], [150, 105, 60], [255, 75, 60], [45, 45, 15], [90, 90, 75], [180, 60, 0]], 'rows': [[[0, 52], 1, [0, 47]], [[0, 51], 2, [0, 4], 1, [0, 43]], [[0, 46], 3, 0, 0, 4, 1, 5, 6, 6, 1, 7, 2, 2, 4, 4, [0, 40]], [[0, 46], 5, 1, 0, 4, 8, 9, 10, 10, 8, 11, 12, 13, 11, 5, [0, 40]], [[0, 42], 4, [0, 3], 14, 6, 2, 5, 9, 15, 16, 17, 16, 18, 16, 19, 14, 20, 0, 1, 1, [0, 37]], [[0, 40], 11, 6, 21, 2, 3, 22, 16, 9, 8, 16, 17, 23, 23, 24, 25, 26, 23, 27, 27, 9, 0, 28, 14, [0, 37]], [[0, 37], 7, 0, 0, 6, 19, 5, 11, 29, 9, 30, 27, 15, 24, 23, 31, 23, 24, 32, 31, 32, 33, 24, 27, 11, 5, 34, 9, 35, 6, [0, 4], 11, 28, [0, 28]], [[0, 31], 4, [0, 3], 2, 36, 12, 6, 13, 18, 18, 27, 13, 19, 16, 24, 31, 33, 32, 32, 37, 31, 24, 32, 38, 38, 39, 32, 26, 34, 10, 34, 23, 13, 40, 28, 41, 2, 10, 42, 2, [0, 28]], [[0, 31], 7, 0, 0, 1, 12, 9, 19, 19, 10, 24, 17, 43, 24, 31, 44, 31, 38, [33, 4], 37, 37, 33, [39, 4], 33, 44, 19, 16, 31, 23, 27, 45, 17, 16, 14, 9, 6, [0, 28]], [[0, 27], 4, 0, 7, 0, 11, 21, 11, 11, 14, 43, 26, 17, 43, 38, 31, 31, 33, 46, [38, 7], 33, 38, [39, 3], 38, 39, 38, 47, 37, 17, 23, 31, 44, 27, 27, 9, 16, 15, 48, 0, 1, 1, [0, 25]], [[0, 27], 4, 11, 13, 8, 16, 9, 16, 18, 49, 26, 39, 16, 50, 46, 39, 38, 39, 51, 46, 52, 38, 52, 38, 38, 52, 38, 38, 39, 39, 46, 38, 47, 46, 47, 47, 33, 32, 37, 31, 17, 27, 23, 31, 31, 16, 53, 8, 1, [0, 25]], [[0, 25], 21, 11, 5, 8, 54, 27, 37, 27, 26, 31, 33, 49, 32, 55, 24, 38, 46, 47, 47, 51, 46, 38, [55, 3], 52, 52, 33, 56, 47, 39, [47, 3], 46, 47, 46, 47, 38, 33, 37, 31, 31, 32, 31, 26, 16, 16, 10, [0, 26]], [[0, 26], 14, 18, 14, 16, 37, 33, 38, 38, 24, 38, 24, 37, 38, 56, 52, 46, 57, 38, 46, 47, 31, 56, 37, 37, 55, 52, 55, 37, 52, [33, 3], 38, 39, 39, 46, 47, 46, 38, 55, 33, 32, 33, 24, 16, 32, 27, 34, 12, 5, 6, [0, 23]], [[0, 25], 28, 58, 26, 59, 43, 38, 33, 39, 60, 61, 38, 57, 24, 38, 55, 46, 55, 56, 37, 46, 33, 24, 56, 24, 38, 31, 37, 62, 55, 33, 55, 37, 31, 33, 47, 39, 33, 52, 46, 38, 55, 38, 33, 33, 31, 17, 23, 27, 27, 63, 14, 1, 0, 7, [0, 21]], [[0, 25], 1, 0, 64, 5, 49, 39, 38, 47, 65, 60, 38, 46, 66, 57, 52, 52, 67, 68, 69, 46, 55, 38, 56, 70, 62, 55, 56, 56, 31, 31, 37, 55, 55, 37, 39, 38, 38, 33, 52, 47, 38, 38, [33, 3], 44, 31, 26, 27, 8, 6, 13, 20, 13, [0, 21]], [[0, 23], 4, 6, 8, 1, 71, 34, 34, [46, 3], 60, 51, 46, 57, 66, 66, 55, 52, 62, 72, 66, 55, 55, 31, 55, 73, 74, 68, 68, 62, 62, 56, 37, 56, 33, 55, 37, 33, 52, 38, 33, 46, 38, 33, 37, 33, 33, 37, 37, 23, 44, 17, 27, 42, 34, 13, 1, [0, 20]], [[0, 24], 14, 5, 59, 23, 44, 19, 38, [46, 4], 52, 55, 55, 75, 55, 69, 76, 73, 56, 62, 77, 55, 55, 68, 74, 62, 76, 78, 74, 62, [56, 3], 55, 37, 31, 33, 55, 33, 47, 33, 33, 37, 39, 38, 37, 37, 32, 26, 34, 53, 27, 9, 7, [0, 21]], [[0, 21], 1, 2, 2, 8, 16, 42, 79, 37, 19, 17, 46, 57, 52, 52, 55, 56, 55, 75, 69, 75, 70, 76, 76, 62, 56, 38, 56, 56, 55, 56, 74, 80, 76, 70, 75, [62, 4], 24, 55, 56, 37, 31, 33, 55, 33, 33, 38, [37, 3], 19, 53, 43, 27, 63, 0, 4, [0, 20]], [[0, 22], 2, 13, 45, 43, 43, 37, 52, 31, 67, 81, [52, 3], 69, 69, 55, 81, 56, 56, 76, 68, 82, 83, 75, 55, 62, 56, 56, 75, 80, 84, 72, 83, 85, 78, 78, 72, 78, 24, 69, 78, 56, 62, 31, 24, [37, 5], 31, 17, 30, 62, 34, 0, 11, 4, 2, [0, 19]], [[0, 22], 86, 11, 42, 17, 37, 62, 55, 38, 56, 75, [55, 4], 67, 75, 81, 56, 75, 75, 87, 73, 73, 88, 69, 78, 70, 70, 62, 72, 84, 80, 75, 74, 85, 89, 90, 72, 85, 75, 85, [62, 3], 56, 37, 56, 37, 55, 37, 31, 17, 24, 44, 35, 5, 5, 36, 11, [0, 19]], [[0, 21], 4, 4, 91, 53, 17, 37, 55, 69, 52, 66, 75, 62, 81, 56, 81, 75, 68, 81, 69, 70, 78, 87, 92, 93, 94, 78, 83, 82, 82, 88, 82, 95, 96, 78, 82, 74, 97, 72, 97, 74, 89, 85, 85, 98, 62, 56, 62, 56, 56, 62, 56, 31, 44, 43, 44, 9, 16, 12, 8, 11, 21, 99, [0, 17]], [[0, 20], 7, 2, 40, 19, 37, 43, 100, 38, 66, 66, 101, 75, 78, 62, 68, 68, 87, 75, 78, 77, 74, 83, 76, 83, 102, 103, 102, 104, 102, 105, 95, 82, 95, 105, 100, 76, 106, 107, 96, 72, 80, 90, 72, 89, 85, 56, 43, 43, 62, 67, 62, 24, 37, 56, 24, 43, 108, 43, 26, 34, 8, 109, 1, [0, 17]], [[0, 20], 11, 11, 9, 45, 17, 69, 55, 85, 55, 55, 66, 75, 70, 83, 83, 110, 87, 87, 111, 87, 83, 82, 82, 111, 112, 113, 103, [102, 2], 84, 84, 73, 95, 88, 97, 88, 106, 96, 106, 88, 97, 97, 72, 72, 85, 62, 85, 85, 98, 98, 62, [24, 3], 56, 62, 62, 17, 18, 63, 4, 21, 6, [0, 17]], [[0, 21], 12, 53, 114, 107, 43, 66, 66, 52, 55, 81, 87, 83, 115, 116, [117, 3], [115, 2], 118, 119, 102, 120, 119, 121, 122, 113, 93, 123, 93, 84, 105, 73, [124, 4], 97, 106, [105, 2], 97, 80, 70, 76, 85, 85, 98, 17, 62, 62, 56, 44, 24, 56, 43, 19, 12, 22, 29, 8, 1, [0, 17]], [[0, 20], 58, 58, 34, 43, 56, 24, 56, 55, 81, 81, 75, 68, 110, 117, [125, 2], [126, 2], 117, [115, 2], 118, 115, 117, 118, 127, 121, 128, [122, 2], 129, 128, 94, 94, 105, 130, 84, [124, 3], [105, 2], 131, 73, 83, 72, 74, 70, [62, 3], 98, 24, 43, 43, 56, 62, 45, 19, 18, 5, 99, [0, 18]], [[0, 20], 8, 114, 40, 34, [55, 3], 66, 66, 56, 78, 76, 110, 126, 125, [132, 2], 133, 134, [135, 5], 133, 136, 127, 121, 137, 122, 138, 122, 103, 139, [123, 3], 95, 95, 84, 84, 124, 105, [82, 4], 72, 89, 62, 67, [62, 3], 43, 24, 62, 17, 19, 13, 1, [0, 19]], [[0, 20], 5, 50, 19, 43, 56, 55, [66, 3], 81, 75, 140, 133, [125, 2], [132, 2], 141, 142, 143, [101, 3], 142, 144, 126, 136, 145, 121, 146, 122, 138, [139, 3], 147, [148, 2], 123, 84, 84, 105, 88, [82, 3], 73, 88, 89, 85, 67, 56, [62, 3], 24, 24, 43, 17, 44, 40, [0, 19]], [[0, 20], 149, 42, 37, [107, 2], 85, 69, 66, 55, 56, 77, 150, 133, 125, 126, 132, 151, 135, 143, 152, [52, 3], 101, 144, 126, 136, 153, 127, 145, 121, 122, 137, 138, [139, 2], [123, 2], 84, 84, 130, 154, 74, 74, 155, 82, 73, 154, 89, 76, [85, 3], 62, 43, 24, 37, 56, 43, 45, 1, [0, 19]], [[0, 21], 109, 18, 69, 55, [66, 3], 69, 56, 81, 135, 125, [126, 3], 151, 142, 143, 156, 152, 101, 157, 158, 133, 126, 159, [153, 3], 145, 121, 146, 122, [137, 2], 113, 139, 113, 130, 154, 160, 74, 76, 83, 82, 73, 154, 82, 68, 56, 85, 43, 62, 44, 44, 56, 62, 114, 161, 2, 5, 6, [0, 17]], [[0, 20], 4, 29, 45, 90, 98, 69, 66, 55, 75, 56, 55, 135, 126, [162, 2], 163, 151, 164, 157, 152, 52, [157, 2], 164, 133, 126, 136, [153, 3], 127, [121, 2], 122, 137, 113, 139, [148, 2], 84, 154, 160, 165, 83, [155, 2], 73, 73, 72, 62, 33, 55, 31, 56, 37, 55, 55, 56, 43, 25, 27, 19, 11, [0, 17]], [[0, 19], 6, 58, 10, 166, 75, 81, 69, 69, 75, 77, 75, 142, 144, [162, 3], 163, 132, 167, 164, 158, 168, 143, 142, 144, 126, [136, 2], [153, 2], [127, 2], [121, 2], 128, 137, 113, 169, [148, 2], 170, 130, 154, 171, 82, 76, 155, 73, 73, 74, 85, 31, 33, 52, 38, 38, 46, 38, 38, 33, 24, 15, 10, 5, 6, [0, 16]], [[0, 19], 6, 10, 5, 42, 98, 81, 55, 55, 81, 75, 150, 172, 133, [162, 4], 163, 133, 135, 167, 164, 173, 144, 133, 126, [136, 2], 153, [127, 3], 121, [128, 3], 113, [148, 4], 170, 174, 154, 155, 76, 155, 93, 175, 74, 62, 62, 24, 55, [46, 3], 47, 39, 38, 37, 24, 27, 9, 6, 1, [0, 15]], [[0, 19], 6, 176, 17, 43, 67, 75, 75, 55, 81, 75, 77, 150, 125, [162, 4], 126, 125, 133, [135, 3], 133, 177, 178, [136, 2], 153, [127, 2], 119, 179, [128, 2], 93, 174, 84, [148, 2], 180, 95, 84, 93, 171, 155, 171, [105, 2], 88, 76, 62, 62, 24, 37, 55, 38, 33, 47, 33, 23, 17, 27, 34, 9, 6, [0, 15]], [[0, 19], 4, 6, 161, 43, 24, 75, 81, 52, 81, 77, 81, 150, 117, [162, 2], 181, 162, 126, 163, 151, 133, [144, 2], 133, 126, [136, 2], 118, 182, 127, [119, 3], 128, 93, 93, 174, 170, 148, 95, 180, 95, 95, 130, 154, [171, 2], 94, 105, 88, 76, [85, 3], [62, 3], 56, 31, 24, 37, 24, 62, 34, 6, [0, 16]], [[0, 18], 4, 6, 29, 40, 161, 98, 56, 66, 55, 55, 77, 150, 183, 184, 185, 162, 181, [163, 2], 126, 133, [135, 2], 144, 133, 177, 117, [136, 2], 118, 182, [119, 3], 128, 93, 174, 113, 170, 95, 180, [186, 2], 95, 84, 154, 73, 93, 93, 154, 74, 85, [62, 4], 98, 62, 24, 56, 56, 31, 43, 17, 9, 6, [0, 16]], [[0, 18], 99, 187, 114, 188, 45, 89, 69, 66, 55, 81, 87, 87, 183, 184, 159, 162, 163, [126, 2], 151, [135, 4], 133, 177, [136, 3], [118, 2], 127, [119, 2], [128, 2], 174, 113, 148, 95, 95, [186, 2], 95, 95, 130, 171, 103, [105, 2], 74, 56, 62, 17, 85, 85, 43, 62, 62, 24, 56, 37, 37, 43, 34, 161, 11, [0, 15]], [[0, 18], 1, 22, 35, 107, 43, 56, 37, 69, 69, 75, 87, 150, 183, 153, 189, [162, 2], 163, 132, 151, [167, 2], [135, 2], [133, 2], 117, [136, 2], [118, 2], [127, 2], 119, 179, 190, 113, [170, 2], 148, [95, 4], 84, 95, 95, 123, 84, 80, 89, 191, 43, 85, 89, [85, 3], 62, 24, 56, 37, 55, 24, 16, 59, 5, 2, [0, 14]], [[0, 20], 6, 161, 17, 43, 24, 56, 75, 87, [150, 2], 117, 184, 189, [162, 2], [163, 2], 151, [135, 3], [133, 2], 126, 117, 136, [118, 2], 136, 192, 127, 119, 179, 128, 113, 170, [148, 3], [95, 6], 193, 84, 80, 88, 89, 107, 89, 85, 17, 85, [62, 3], 55, 55, 56, 19, 9, 10, 11, [0, 15]], [[0, 21], 29, 194, 45, 67, 67, 68, 87, 83, 115, 184, [162, 4], [163, 2], 151, 195, [167, 2], 133, 126, 196, 136, 118, 127, [136, 2], 118, 127, 119, 179, 128, 113, 169, [148, 4], [95, 5], 197, 198, 124, 97, [107, 4], 19, 89, 85, 62, 56, [55, 3], 24, 42, 29, 4, [0, 15]], [[0, 20], 6, 40, 45, [98, 3], 78, 78, 83, 199, 153, [162, 3], 181, [163, 4], 151, 133, [126, 2], 117, 136, [127, 2], 118, 136, 118, 127, 119, 179, 128, 174, 200, [148, 5], [95, 4], [201, 2], 198, 106, 107, 188, 107, 202, 89, 85, 98, 56, 55, 52, 38, 24, 19, 29, 2, 1, [0, 15]], [[0, 21], 4, 29, 187, 58, 70, 70, 73, 92, 182, [162, 4], 181, [162, 4], [126, 2], 196, [136, 2], [127, 4], 136, 127, 119, [179, 2], 203, 174, 170, 148, [95, 7], 198, [201, 3], 204, 106, 107, [89, 3], 85, 85, 56, 37, 55, 55, 44, 45, 5, 6, [0, 16]], [[0, 23], 29, 161, 70, 70, 72, 102, 153, [162, 5], 126, 162, [159, 3], [136, 2], 205, [127, 2], 121, [179, 2], 127, 206, 179, 121, [128, 2], 84, 84, 170, [95, 4], 84, 84, 95, 197, [201, 5], 96, 97, 107, 19, 85, 85, 62, 56, 56, 24, 62, 16, 10, 6, [0, 16]], [[0, 23], 36, 42, 100, 78, 82, 118, 162, 189, 162, 153, 159, 162, [126, 2], 159, [136, 2], 127, [207, 2], 121, 208, 121, [128, 2], 127, 207, 128, 190, [174, 2], 130, 174, 84, 170, [84, 4], 130, 84, 197, 201, [209, 2], [201, 3], 210, 72, 107, 89, 85, 98, 56, 56, 24, 62, 19, 53, 11, 2, [0, 15]], [[0, 22], 1, 187, 12, 85, 78, 83, 184, 189, [153, 3], 146, 122, 119, 179, [128, 2], [113, 3], [137, 2], 138, [137, 3], 121, 208, 139, [148, 2], 170, 84, 84, [124, 2], 84, 84, 93, 93, 73, 93, 211, 201, [209, 3], [201, 2], 204, 106, 188, 107, 89, 98, 62, 24, 56, 24, 43, 9, 5, 7, [0, 15]], [[0, 22], 1, 161, 100, 78, 78, 82, 184, 136, [153, 2], 121, 137, 148, 186, 180, 197, 212, [213, 2], 214, [215, 2], 216, [137, 2], 113, 137, 138, 217, [186, 2], 212, [218, 2], 219, 197, 211, [198, 2], 124, 105, 93, 124, 201, [209, 3], [201, 2], 204, 106, 89, 202, 107, 89, 43, 62, 89, 161, 13, 11, 2, 2, [0, 15]], [[0, 22], 99, 220, 89, 75, 83, 111, 184, [153, 2], 145, 146, 139, 148, 186, 213, 221, 222, 223, 224, 225, [226, 2], 216, 138, 137, 113, 137, 169, 215, 214, 213, 221, 227, [228, 2], [229, 2], 230, [231, 2], 219, 84, 130, 197, [209, 4], 201, 198, 232, 188, 90, 89, 43, 56, 56, 15, 45, 19, 18, 53, 5, 2, [0, 14]], [[0, 23], 233, 90, 150, 83, 118, 162, 189, 153, 129, [122, 2], 113, [169, 3], 216, [234, 2], 235, [226, 2], 236, 237, [137, 2], 139, 215, 238, 213, 209, [213, 2], [209, 2], 212, [197, 2], 219, [209, 2], 219, 95, 198, [201, 2], 239, [197, 3], 106, 89, 89, 85, 85, 77, 240, 55, 62, 45, 29, 109, 11, [0, 15]], [[0, 23], 109, 241, 83, 111, 199, [162, 2], 153, 145, 146, 208, 237, 215, 186, 218, 230, 228, 221, 214, 234, [226, 2], 138, 129, 121, 113, 186, 239, 213, [209, 2], 221, 227, 229, [242, 2], 219, 243, 218, [209, 2], 197, 201, 209, 201, 197, 198, 95, 95, 105, 70, 62, 85, 62, 155, 179, 78, 62, 17, 6, 0, 4, [0, 15]], [[0, 23], 4, 244, 83, 111, 184, [162, 2], 153, 145, 146, 245, 225, 223, 218, 246, 2, 40, 247, 180, 215, 248, 234, 146, 184, 127, 113, 238, 239, [197, 2], 213, 224, 249, 250, 35, 21, 251, 246, 229, [209, 3], [201, 2], 239, 198, 95, [193, 2], 105, 72, 98, 62, 74, 252, 253, 111, 85, 27, 49, 13, 28, [0, 15]], [[0, 24], 58, 87, 111, 254, [189, 2], 162, 185, 145, 208, 121, 252, 170, 255, 227, 256, 180, 248, 169, 200, 217, 136, 133, 118, 137, 238, 239, [197, 3], 248, 170, 96, 228, [257, 2], 247, 230, 227, 230, 209, [201, 2], 239, 198, 95, 193, 84, 175, 72, 70, 85, 258, 259, 260, 102, 17, 16, 34, 12, [0, 16]], [[0, 22], 1, 6, 90, 87, 119, 153, [189, 2], 162, 126, 162, 125, 133, 117, 261, 203, [200, 4], 113, 200, 121, 125, 133, 118, 137, 186, [239, 2], 197, 95, [170, 2], 248, 180, [262, 2], 197, 212, [209, 2], 201, [239, 3], 95, 124, 95, 193, 73, 82, 70, 171, 223, 263, 260, 190, 58, 2, 2, 5, 11, [0, 15]], [[0, 22], 2, 1, 264, 265, 112, 153, [189, 2], 266, 151, 134, 162, [136, 2], 127, 121, 252, [237, 2], 169, 137, 121, 126, 167, 133, 127, 169, 215, [239, 2], 197, 186, [148, 3], [170, 2], [267, 2], 95, 197, 209, 201, [239, 2], 197, [95, 3], 268, 105, 82, 72, 130, 223, 269, 270, 171, 13, 6, [0, 18]], [[0, 24], 244, 92, 122, 153, 185, 162, 132, [125, 2], 126, 205, 271, 272, [237, 3], 137, 121, 127, 162, 133, 135, 117, 121, 169, 215, 238, [239, 2], 186, [170, 2], 148, 215, 180, 148, 95, 186, [239, 2], 197, 95, 95, 148, 170, 95, 95, 268, 84, 175, 82, 148, 214, 235, 273, 155, 19, 11, [0, 18]], [[0, 23], 1, 251, 124, 122, 153, 185, 162, 274, 132, 125, 126, 159, 205, 127, [207, 2], 127, 118, 136, [126, 2], 151, 135, 136, 121, 148, 215, 186, [239, 2], 238, [148, 2], 170, [148, 3], [186, 3], 95, 84, 93, [174, 2], 84, 95, [268, 2], 95, 84, 93, 214, 226, 275, 276, 85, 12, 48, [0, 18]], [[0, 25], 277, 145, 153, 185, 162, 181, 132, 133, 167, 151, [133, 4], [144, 2], 133, [163, 2], 195, 135, 136, 121, 215, [186, 2], 239, 213, 238, 215, [148, 3], 169, [148, 2], 169, [148, 4], 113, 93, 93, 84, 268, 239, 268, 130, 174, [226, 2], 216, 154, 19, 114, 6, [0, 18]], [[0, 25], 277, 205, 153, 185, 189, 181, 163, 132, [167, 6], 173, 167, 151, [126, 2], 167, 173, 196, 278, 215, 213, 186, [239, 2], 238, 148, [169, 7], 148, [215, 2], [148, 2], 113, 93, 84, 268, 197, 84, [203, 2], 226, 235, 216, 171, 34, 19, 233, [0, 18]], [[0, 25], 279, [153, 2], [185, 2], [181, 2], 132, 167, [173, 3], [167, 3], 151, 126, [162, 2], 151, 144, 136, 278, 186, 213, [239, 2], 238, 186, [200, 2], [137, 2], [169, 5], 148, 147, 268, 95, 84, 93, 93, 123, 84, 93, 111, 261, 280, 275, 281, 78, 62, 89, 11, 1, [0, 17]], [[0, 25], 277, 205, 153, [185, 2], 181, [163, 2], 133, 167, 164, 173, 195, 177, 126, 205, 282, 162, 125, 167, 144, 283, 137, 186, 209, 201, [239, 2], 148, 113, [137, 4], 138, 237, 137, [113, 2], 148, [268, 2], 148, 113, 93, 84, 84, 128, 102, 179, 284, 216, 237, 70, 45, 233, 11, 22, [0, 17]], [[0, 25], 211, 127, 153, [185, 2], 181, [163, 2], 126, 144, 135, [178, 2], 159, 205, 285, 153, [125, 2], 173, 133, 127, 252, 186, 213, [209, 2], 239, 95, 113, 137, [128, 2], [137, 4], 113, 93, 174, 148, 268, 84, 113, 93, 84, 84, 93, 102, 119, 286, 128, 190, 89, 45, 287, 2, [0, 18]], [[0, 25], 211, 127, 153, [185, 2], [181, 3], 126, 151, 126, 283, 205, 127, 207, 271, [126, 3], 177, 118, 179, 113, 186, 213, 209, 239, 201, 197, 169, 137, [128, 3], [137, 2], [113, 2], [93, 3], 84, 123, 93, 128, 84, 84, 103, 128, 261, 288, 118, 286, 75, 98, 13, [0, 19]], [[0, 25], 124, 127, 289, [185, 2], [159, 3], [126, 3], 136, 207, 146, 271, 208, [153, 3], 145, 208, 137, 148, 186, [213, 5], 215, [137, 2], [128, 3], 137, 169, 148, 113, [93, 3], 84, 103, 93, 103, 123, 84, 93, 203, 261, [140, 2], 89, 6, 11, 2, [0, 18]], [[0, 25], 211, 145, 289, [185, 5], [159, 2], 136, 127, 207, [208, 3], 272, 216, 146, 138, 217, 234, 238, 213, [209, 2], [213, 3], 214, 113, 137, [128, 3], 113, 148, 215, 148, 84, 84, [103, 3], 93, 103, [84, 3], 102, 288, 286, 155, 264, 22, [0, 20]], [[0, 25], 290, 145, 289, [185, 6], [205, 2], 127, 121, 137, 127, 177, 283, 275, [226, 2], 214, 213, 209, 221, 218, [221, 3], 213, 186, 148, [137, 3], 190, 113, 148, 248, 186, 268, [123, 2], 84, 113, 93, 103, 123, 84, 84, 93, 192, 133, 111, 287, [0, 21]], [[0, 25], 241, [145, 2], [153, 4], [205, 3], 145, 121, 137, 127, 177, 133, 144, 127, 137, 291, 224, [221, 2], [230, 2], [221, 3], 212, 180, 148, 113, [137, 2], 113, 200, [148, 2], 186, 197, 95, 95, 148, 123, 93, 103, [123, 2], 84, 103, 252, 208, 119, 175, 48, [0, 20]], [[0, 25], 73, [145, 2], [153, 2], [282, 4], 207, 121, 208, 121, 136, [126, 2], 177, 127, 128, 148, 213, 212, 221, 230, [221, 4], 212, 243, 170, 113, [169, 3], 148, 147, 268, [239, 3], 197, 186, 148, 113, 103, 123, 148, 123, 113, 248, 280, 80, [277, 2], [0, 20]], [[0, 25], 219, 292, [145, 2], [282, 3], 207, 285, [208, 2], 137, [121, 2], [127, 3], 128, 169, 215, 213, 243, 212, 209, 221, 209, 230, [221, 2], 243, 180, [148, 2], 169, [147, 2], 186, 238, 239, 213, [209, 2], 239, [268, 2], 103, 123, 84, 148, 139, 102, 130, 293, 294, 279, [0, 20]], [[0, 25], 209, 93, [145, 3], [285, 3], 271, [138, 3], 137, 139, [137, 2], 139, [147, 2], 238, 213, 197, 239, 209, 221, [230, 4], 221, 209, 213, 238, [215, 2], [238, 3], 239, 213, [209, 2], 239, [268, 2], 84, 123, [148, 2], 123, 261, 210, 294, 187, 244, [0, 20]], [[0, 25], 246, 139, [145, 2], [285, 2], 146, 271, 295, 236, [147, 3], 238, [123, 2], 139, 147, 238, 186, [209, 2], 239, 213, 209, [230, 2], [229, 3], [230, 2], 209, 213, [238, 3], [213, 3], [209, 3], 186, 268, 123, 268, [148, 2], 123, 119, 105, 210, 296, [0, 21]], [[0, 26], 277, 129, 121, 146, 297, 271, 298, 299, 234, [238, 2], [239, 2], 268, 147, 300, 147, [238, 2], [214, 2], 186, [213, 2], 221, [230, 2], 257, 228, 257, 228, 230, 221, 213, [238, 2], [213, 2], [209, 4], 239, [268, 5], 148, 113, 123, 277, 1, [0, 21]], [[0, 26], 294, 122, [146, 2], [138, 2], 295, 299, 217, 147, 239, 230, 221, 213, 224, 214, [225, 2], 284, [226, 3], 225, 224, 222, [227, 2], 228, 229, [257, 3], 229, 213, 238, 239, 213, [209, 4], 231, 209, [239, 4], 186, 148, 107, 301, [0, 23]], [[0, 27], 84, [146, 2], 138, [298, 2], [138, 2], 302, 239, 230, 224, 214, 226, 169, 137, 200, 169, 248, 215, [291, 2], 186, 291, 212, 213, 221, 230, 228, [246, 2], 228, 213, 238, 239, [209, 3], [231, 3], 209, 201, 239, [201, 2], 239, 95, 25, 8, 3, [0, 22]], [[0, 27], 277, 146, 208, 138, 298, [138, 3], 234, 209, 221, 215, 137, [121, 2], 129, 138, 139, [169, 2], [215, 2], 248, 95, 186, 213, 209, 213, 209, 229, 246, 257, 209, 213, 209, [231, 3], [209, 2], 231, [209, 5], 239, 267, 16, 13, 11, [0, 22]], [[0, 27], 294, 137, [138, 5], 217, 238, 221, 214, 137, 145, [127, 2], 122, 303, 139, 103, 147, [186, 2], 268, [239, 2], [213, 4], 209, 228, 257, 221, [209, 2], [231, 2], [209, 4], 230, [231, 3], 209, 239, 107, 59, 11, 59, 11, [0, 21]], [[0, 28], 95, [138, 4], 304, 302, 213, 230, 239, 139, 121, 127, 145, 292, [305, 2], 306, 268, 193, [268, 2], 239, 268, 238, [213, 2], 209, 230, 228, 257, 230, 209, 221, [231, 2], [209, 4], [230, 4], 209, 201, 27, 35, 21, 14, 20, [0, 21]], [[0, 28], 244, 139, 138, [298, 2], 217, 234, 213, 219, 239, 147, 121, 127, 145, 119, 182, 307, 308, 103, 308, 309, 123, [300, 2], 310, 238, 213, 209, 229, 257, 246, 229, 230, 221, [209, 6], [230, 2], 229, [231, 2], 250, 14, 2, 8, 311, 14, [0, 21]], [[0, 29], 95, 217, 295, [217, 2], 234, 238, 209, 239, 148, 121, 127, 118, [184, 2], 199, [112, 2], 120, 112, 103, 139, 300, 268, 239, 209, 230, 257, [246, 2], 229, 230, [209, 2], 201, [239, 2], [209, 2], 230, [229, 2], 230, 231, 9, 6, 6, 8, 312, 6, [0, 21]], [[0, 29], 293, [217, 3], 299, [302, 2], [239, 2], 148, 121, 127, 126, 117, 118, 119, 129, 122, 129, 92, 175, 148, 147, 268, 197, 209, 228, 246, [251, 2], 229, 231, [209, 2], [239, 3], 209, [230, 2], 229, 230, 229, 13, 5, 2, 11, 312, 8, 8, 1, [0, 20]], [[0, 30], 186, [217, 4], 302, 209, 239, 123, 129, 127, 136, 118, 127, [129, 2], 112, [139, 2], 103, 148, [239, 3], 231, 257, 246, 251, 246, 313, [209, 3], [239, 2], [209, 2], 230, [229, 3], 314, 8, 2, 7, 54, 54, 8, 315, 11, 2, 22, [0, 18]], [[0, 30], 293, [234, 2], [299, 2], 302, 209, 239, 123, 122, 207, 127, 128, 112, 137, [122, 2], 139, 234, 186, 95, 239, 197, 230, 229, 257, [251, 2], 294, [231, 2], 209, 201, 239, [209, 2], 230, [229, 3], 316, 13, 86, 4, 14, 311, 5, 317, 318, 319, 1, 6, 5, 6, [0, 16]], [[0, 30], 1, 95, [234, 2], 302, 234, 230, 231, 239, 139, 146, 121, 139, 122, 103, 175, 123, 139, 147, 238, 197, 213, 209, 229, 316, 246, [251, 2], 246, 231, [209, 5], [230, 2], 229, 313, 229, 5, 11, 1, 320, 14, 5, 8, 23, 16, 5, 1, 1, 6, 5, 5, 4, [0, 14]], [[0, 30], 11, 290, 234, 238, 234, 238, 213, 228, 231, 197, 148, 139, 147, 103, [175, 2], 123, 103, 268, [209, 2], 230, 229, 257, [246, 2], [251, 2], 246, 231, [209, 4], [230, 3], 229, 316, 6, 11, 1, 6, 321, 5, 320, 322, 54, 311, 319, 6, 2, 6, 11, 5, 8, 21, [0, 13]], [[0, 22], 260, [323, 11], 324, 213, 209, [229, 2], 230, 275, [323, 5], 325, 123, 326, 209, 229, 257, [246, 2], 251, 260, [323, 4], [231, 4], 260, [323, 4], 8, 1, 4, [11, 3], 14, 311, 8, 5, 8, 11, 4, 0, 1, 6, 8, 327, 8, 6, [0, 11]], [[0, 22], 260, [323, 11], 324, [209, 2], 231, [229, 2], 260, [323, 5], 324, 268, 198, 231, 257, 246, [251, 3], 260, [323, 4], [230, 4], 260, [323, 4], 2, 1, 21, 109, 7, 321, 8, 328, 14, 10, 2, 22, 1, 0, 2, 14, 5, 5, 8, 327, 8, 2, [0, 9]], [[0, 22], 260, [323, 11], 324, 201, 230, 229, 230, 221, 324, [323, 6], 329, 198, 231, 246, 251, 1, [251, 2], 260, [323, 4], [230, 4], 260, [323, 4], 0, 7, 2, 2, 11, 5, 11, 11, 54, 8, 2, 29, 6, 1, 6, 5, 59, 322, 315, 8, 322, 54, 8, 4, [0, 7]], [[0, 22], 260, [323, 4], 220, 330, [244, 2], 294, 331, 123, 231, [209, 2], 230, 228, 259, [323, 7], 332, 333, 231, [251, 5], 260, [323, 4], 229, [230, 2], 229, 260, [323, 4], 4, 2, 28, 6, 11, 11, 7, 322, 9, 5, 2, 14, 40, 1, 22, 8, 64, 26, 16, 315, 14, 26, 318, 322, 59, 11, [0, 5]], [[0, 22], 260, [323, 4], 244, 334, 244, 294, 246, 229, 122, 239, [221, 2], [227, 2], 335, [323, 3], 336, [323, 4], 302, 230, 246, 251, [246, 3], 260, [323, 4], 228, 229, 257, 246, 260, [323, 4], 0, 1, 7, 6, 6, 2, 8, 27, 10, 35, 5, 59, 40, 1, 6, 322, 337, 26, 59, 20, 14, 338, 14, 311, 59, 59, 14, 6, [0, 3]], [[0, 22], 260, [323, 4], 334, 187, 41, 316, 246, 257, 122, 137, 213, [221, 2], 339, [323, 4], 236, 336, [323, 3], 340, 229, [257, 2], [229, 2], 257, 260, [323, 4], 246, [251, 2], 6, 341, [323, 4], 0, 4, 7, [2, 3], 54, 9, 14, 58, 14, 9, 35, 1, 8, 312, 342, 343, 13, 58, 5, 8, [14, 3], 8, 321, 5, 344, 5, 2], [[0, 22], 260, [323, 4], [244, 2], 316, 257, 246, 345, [292, 2], 146, 238, 224, 260, [323, 3], 335, 238, 346, [323, 3], 324, 230, 228, [230, 3], 229, 260, [323, 4], 1, 1, 11, 11, 347, [323, 4], 1, 4, 4, [2, 3], 317, 311, 8, 13, 59, 10, 41, 2, 59, 322, 16, 10, 58, 58, 35, 35, 8, [311, 3], 59, 311, 14, 8, 14], [[0, 22], 260, [323, 11], 348, 292, 146, 234, 324, [323, 3], 253, 238, 122, 324, [323, 3], 263, [221, 2], 230, 231, 230, 260, [323, 4], 1, 6, 8, 14, 260, [323, 4], 1, 1, 2, 6, 1, 6, 54, 54, 13, 10, 311, 13, 251, 6, 343, 59, 13, 11, 58, 58, [233, 2], 5, 54, 322, 16, 311, 14, 315, 54, 59], [[0, 22], 260, [323, 11], 348, 146, 292, 349, [323, 3], 324, 284, 225, 147, 350, [323, 3], 260, [221, 2], [209, 3], 260, [323, 4], 109, 8, 34, 5, 260, [323, 4], 1, 1, 6, 2, 0, 320, 54, 54, 5, 319, 8, 11, 1, 5, 315, 13, 11, 40, 6, [233, 2], 6, 14, 343, 311, 20, 20, 54, [322, 2], 318], [[0, 20], 1, 2, 351, [323, 11], 352, 297, 146, 325, [323, 3], 335, [214, 3], 353, [323, 3], 324, 214, [213, 2], 221, 230, 260, [323, 4], 8, 5, 5, 1, 260, [323, 4], 1, 7, 22, 1, 1, 8, [315, 2], 20, 319, 29, 6, 2, 8, 10, 35, 5, 40, 6, [233, 2], 29, [8, 3], 311, 343, 318, 322, 16, 343], [[0, 15], 99, 2, 2, 22, 233, 109, 58, 341, [323, 4], 330, 313, 294, 175, 306, 122, [282, 2], 285, 271, 324, [323, 3], 340, [226, 4], 324, [323, 3], 273, 224, 221, 227, 228, 260, [323, 4], 14, 0, 1, 0, 260, [323, 4], 2, 7, 4, 0, 4, 14, 54, 54, 14, 13, 35, 251, 2, 11, 58, 11, 5, 40, [233, 2], 58, 29, 5, 5, 14, 315, 54, 59, 59, 34, 315], [[0, 12], 99, 22, 22, 6, [109, 3], [58, 3], 354, [323, 4], 293, 294, 355, 356, 210, 128, 357, [282, 2], 352, [323, 13], 335, [213, 3], 221, 260, [323, 4], 6, [0, 3], 260, [323, 4], 22, 2, 1, 0, 4, 327, 54, 54, 14, 358, 6, 1, 233, 58, 58, 5, 5, 58, [233, 2], 58, 58, 29, 8, 14, 14, 8, 20, 59, 311, 322], [[0, 9], 99, 7, 11, 5, 11, [109, 3], [58, 3], 359, 233, 260, [323, 4], 316, 294, 287, 360, 112, 145, [282, 3], 350, [323, 14], 236, 234, 214, 224, 260, [323, 4], [0, 4], 260, [323, 4], 22, 1, 0, 0, 7, 14, 59, 9, 8, 11, 2, 48, 6, 11, 11, 40, 13, 6, 233, 361, 58, 58, 5, 13, 8, 13, 13, 5, 5, 8, 322], [[0, 7], 4, 6, 36, 5, 5, 11, 58, [109, 2], 58, 11, 11, 29, 58, 251, 260, [323, 4], 251, 233, 114, 89, 112, 153, 289, 362, 363, [323, 15], 364, 234, 214, 224, 260, [323, 4], [0, 4], 260, [323, 4], 2, [0, 3], 21, 338, 8, 319, 5, 35, 48, 22, 11, 5, 11, 40, 40, [233, 2], 361, 58, 40, [5, 3], 29, 6, 6, 11, 14, 59], [[0, 6], 21, [5, 4], 36, 11, 58, 58, 11, 29, [58, 3], 48, 2, 260, [323, 4], 1, 279, 193, 105, 113, 162, 153, 145, 365, [323, 3], 366, 185, 153, 205, 145, [146, 2], 138, 367, [323, 3], 324, 234, 214, 221, 260, [323, 4], [0, 4], 260, [323, 4], 1, 0, 0, 1, 5, 8, 8, 5, 358, 6, 99, 6, 5, 319, 8, 5, [233, 2], 361, 58, 58, 29, 29, 11, 6, 233, 6, 11, 5, 20, 14], [[0, 4], 4, 11, 5, 8, 8, 5, 36, 5, 36, 11, 36, 29, 58, 58, 109, 48, 41, 41, 260, [323, 4], 233, 219, 368, 369, 137, [162, 2], 282, 370, [323, 3], 371, [153, 3], 145, 285, 146, 138, 329, [323, 4], 353, 213, 229, 354, [323, 4], [0, 4], 260, [323, 12], 372, 2, 48, 58, 13, 13, 319, 5, [233, 2], 58, 58, 29, 29, 11, 58, 22, 22, 11, 36, 5, 20, 14], [[0, 3], 2, 5, 63, 344, 5, 5, 36, 29, 63, 63, 29, 29, [58, 3], 233, 2, 48, 251, 260, [323, 4], 244, 290, 373, 124, 121, 162, 181, 185, [323, 4], 363, [282, 2], 145, 285, 146, 297, 271, 138, 370, [323, 3], 336, 230, 40, 351, [323, 4], [0, 4], 260, [323, 12], 258, 2, 233, 36, 8, 5, 5, 40, 233, 361, 58, 29, 29, 58, 11, 109, 22, 6, 36, 29, 8, 14, 8], [0, 0, 2, 29, 63, 344, 5, 5, 36, 36, [12, 3], 5, [58, 3], 6, [233, 2], 48, 251, 260, [323, 4], 187, 244, 72, 93, 207, [162, 2], 374, [323, 3], 370, [282, 2], [145, 3], [362, 2], 146, 271, 325, [323, 3], 324, 232, 58, 260, [323, 4], [0, 4], 260, [323, 12], 291, 1, 109, 5, 8, 13, 29, 58, 375, [58, 3], [22, 3], 2, 22, 11, 11, 36, 8, 8, 319], [0, 4, [5, 5], 29, 29, 12, 376, 12, 12, 11, 359, 36, 6, 109, 22, 233, 48, [251, 2], 233, 48, 1, 48, 293, 290, 106, 113, 153, 132, [181, 2], 163, 126, 153, 362, [282, 6], 145, 285, 146, 271, 377, 235, 284, 242, 58, 1, [0, 10], [1, 3], [0, 3], 22, 5, 5, 58, 5, 11, 2, 2, 58, 8, 8, 13, 29, 58, 58, 220, 35, 99, 4, 109, 6, 4, 6, 29, 29, 11, [5, 3]]]};

  // romejs/cli-diagnostics/src/DiagnosticsPrinter.ts

  const ___$$priv$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$path = require('path');
  const ___$$priv$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$fs = require('fs');
  function ___$$priv$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$equalPosition(a, b) {
    if (a === undefined || b === undefined) {
      return false;
    }

    if (a.line !== b.line || a.column !== b.column) {
      return false;
    }

    return true;
  }

  const ___$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS = {
    grep: '',
    inverseGrep: false,
    focus: '',
    showAllDiagnostics: true,
    fieri: false,
    verboseDiagnostics: false,
    maxDiagnostics: 100};

  class ___$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$default extends Error {
    constructor(opts) {
      super(
      'Diagnostics printer. If you\'re seeing this then it wasn\'t caught and printed correctly.');
      const {cwd: cwd, reporter: reporter, flags = ___$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS} = opts;

      this.reporter = reporter;
      this.flags = flags;
      this.cwd = cwd === undefined ? process.cwd() : cwd;
      this.processor = new ___$romejs$diagnostics$src$DiagnosticsProcessor_ts$default({
        origins: opts.origins});

      this.displayedCount = 0;
      this.problemCount = 0;
      this.filteredCount = 0;
      this.truncatedCount = 0;

      this.fileSources = new Map();
      this.beforeFooterPrint = [];
    }

    throwIfAny() {
      if (this.hasDiagnostics()) {
        throw this;
      }
    }

    hasDiagnostics() {
      return this.processor.hasDiagnostics();
    }

    getDisplayedProblemsCount() {
      return this.problemCount - this.filteredCount;
    }

    shouldTruncate() {
      if (!this.flags.showAllDiagnostics &&
      this.displayedCount > this.flags.maxDiagnostics) {
        return true;
      } else {
        return false;
      }
    }

    getDiagnostics() {
      return this.processor.getCompleteSortedDiagnostics(
      this.reporter.markupOptions);
    }

    isFocused(diag) {
      const focusFlag = this.flags.focus;
      const focusEnabled = focusFlag !== undefined && focusFlag !== '';

      const {filename: filename, start: start, end: end} = diag;

      if (focusEnabled && (filename === undefined || start === undefined)) {
        return true;
      }

      if (filename !== undefined && start !== undefined && end !== undefined) {
        const niceFilename = ___$romejs$string_markup$src$format_ts$humanizeMarkupFilename(
        [filename],
        this.reporter.markupOptions);
        const focusId = ___$romejs$diagnostics$src$derive_ts$getDiagnosticHeader({
          filename: filename,
          start: start,
          cwd: this.cwd});
        if (focusEnabled && focusId !== focusFlag && focusId !== niceFilename) {
          return true;
        }
      }

      return false;
    }

    shouldIgnore(diag) {
      const {focus: focus, grep: grep, inverseGrep: inverseGrep} = this.flags;
      const focusEnabled = focus !== undefined && focus !== '';

      if (focusEnabled && this.isFocused(diag) === false) {
        return true;
      }

      if (grep === undefined || grep === '') {
        return false;
      }

      let ignored = diag.message.toLowerCase().includes(grep) === false;
      if (inverseGrep) {
        ignored = !ignored;
      }
      return ignored;
    }

    addFileSource(filename, src) {
      this.fileSources.set(filename, ___$romejs$cli_diagnostics$src$utils_ts$toLines(src));
    }

    getFileSourcesFromDiagnostics(diagnostics) {
      const framedFiles = new Set();

      for (const {advice: advice, filename: filename} of diagnostics) {
        if (filename !== undefined) {
          framedFiles.add(filename);
        }

        for (const item of advice) {
          if (item.type === 'frame' &&
          item.filename !== undefined &&
          item.code === undefined) {
            framedFiles.add(item.filename);
          }
        }
      }

      for (const filename of framedFiles) {
        if (!___$$priv$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$path.isAbsolute(filename)) {
          framedFiles.delete(filename);
        }
      }

      return framedFiles;
    }

    async fetchFileSources(diagnostics) {
      for (const filename of this.getFileSourcesFromDiagnostics(diagnostics)) {
        const src = await ___$$priv$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$fs.promises.readFile(filename, 'utf8');
        this.addFileSource(filename, src);
      }
    }

    fetchFileSourcesSync(diagnostics) {
      for (const filename of this.getFileSourcesFromDiagnostics(diagnostics)) {
        if (!___$$priv$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$fs.existsSync(filename)) {
          continue;
        }

        const src = ___$$priv$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$fs.readFileSync(filename, 'utf8');
        this.addFileSource(filename, src);
      }
    }

    getLinesFromFilename(filename) {
      if (filename === undefined) {
        return [];
      }

      const lines = this.fileSources.get(filename);
      if (lines === undefined) {
        return [];
      } else {
        return lines;
      }
    }

    addDiagnostic(partialDiagnostic, origin) {
      this.addDiagnostics([partialDiagnostic], origin);
    }

    addDiagnostics(partials, origin) {
      if (partials.length === 0) {
        return undefined;
      }

      this.processor.addDiagnostics(partials, origin);

      const {reporter: reporter} = this;
      if (reporter.isJSON) {
        for (const diagnostic of this.processor.getCompleteDiagnostics(
        this.reporter.markupOptions)) {
          if (this.shouldIgnore(diagnostic)) {
            this.filteredCount++;
            continue;
          }

          reporter.json({type: 'DIAGNOSTIC', diagnostic: diagnostic});
        }

        this.processor.clear();
      }
    }

    async print() {
      const {reporter: reporter} = this;
      if (reporter.isJSON) {
        return undefined;
      }

      reporter.hr();

      const filteredDiagnostics = this.filterDiagnostics();
      await this.fetchFileSources(filteredDiagnostics);
      this.displayDiagnostics(filteredDiagnostics);
    }

    printSync() {
      const {reporter: reporter} = this;
      if (reporter.isJSON) {
        return undefined;
      }

      reporter.hr();

      const filteredDiagnostics = this.filterDiagnostics();
      this.fetchFileSourcesSync(filteredDiagnostics);
      this.displayDiagnostics(filteredDiagnostics);
    }

    displayDiagnostics(diagnostics) {
      for (const diag of diagnostics) {
        this.displayDiagnostic(diag);
      }
    }

    displayDiagnostic(diag) {
      const {reporter: reporter} = this;
      reporter.indent();

      const {start: start, end: end, filename: filename} = diag;

      let skipFrame = false;
      if (start !== undefined && end !== undefined) {
        adviceLoop: for (const item of diag.advice) {
          if (item.type === 'frame' &&
          item.filename === filename &&
          ___$$priv$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$equalPosition(item.start, start) &&
          ___$$priv$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$equalPosition(item.end, end)) {
            skipFrame = true;
            break;
          }

          if (item.type === 'stacktrace') {
            for (const frame of item.frames) {
              if (frame.filename === filename && ___$$priv$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$equalPosition(frame, start)) {
                skipFrame = true;
                break adviceLoop;
              }
            }
          }
        }
      }

      const advice = ___$romejs$diagnostics$src$derive_ts$deriveRootAdviceFromDiagnostic(
      diag,
      this.cwd,
      skipFrame).map(item => ___$romejs$diagnostics$src$normalize_ts$normalizeDiagnosticAdviceItem(item, this.reporter.markupOptions)).concat(diag.advice);

      const lastItem = advice[advice.length - 1];
      for (const item of advice) {
        const skipped = ___$romejs$cli_diagnostics$src$printAdvice_ts$default(item, {
          fileSources: this.fileSources,
          diagnostic: diag,
          cwd: this.cwd,
          reporter: reporter});
        if (item !== lastItem && skipped !== true) {
          reporter.spacer();
        }
      }

      if (this.flags.verboseDiagnostics) {
        const {origins: origins} = diag;

        if (origins.length > 0) {
          reporter.spacer();
          reporter.info('Why are you seeing this diagnostic?');
          reporter.spacer();
          reporter.orderedList(origins, true);
        }
      }

      reporter.dedent();
      reporter.hr();
    }

    filterDiagnostics() {
      const diagnostics = this.getDiagnostics();
      const filteredDiagnostics = [];

      for (const diag of diagnostics) {
        this.problemCount++;

        if (this.shouldIgnore(diag)) {
          this.filteredCount++;
        } else if (this.shouldTruncate()) {
          this.truncatedCount++;
        } else {
          this.displayedCount++;
          filteredDiagnostics.push(diag);
        }
      }

      return filteredDiagnostics;
    }

    onBeforeFooterPrint(fn) {
      this.beforeFooterPrint.push(fn);
    }

    footer() {
      const {reporter: reporter, problemCount: problemCount} = this;

      for (const handler of this.beforeFooterPrint) {
        handler(reporter);
      }

      if (problemCount > 0) {
        this.footerError();
      } else {
        this.footerSuccess();
      }
    }

    showBanner(banner) {
      const {stdout: stdout} = this.reporter;

      for (const row of banner.rows) {
        for (const field of row) {
          let palleteIndex;
          let times = 1;
          if (Array.isArray(field)) {
            [palleteIndex, times] = field;
          } else {
            palleteIndex = field;
          }

          const pallete = banner.palettes[palleteIndex];
          stdout.write(
          ___$romejs$string_ansi$src$format_ts$formatAnsi.bgRgb(' ', {r: pallete[0], g: pallete[1], b: pallete[2]}).repeat(times));
        }
        stdout.write('\n');
      }
    }

    footerSuccess() {
      const {reporter: reporter} = this;

      if (this.flags.fieri) {
        this.showBanner(___$romejs$cli_diagnostics$src$banners$success_json$default);
      }

      reporter.success('No known problems!');
    }

    footerError() {
      const {reporter: reporter, filteredCount: filteredCount} = this;

      if (this.flags.fieri) {
        this.showBanner(___$romejs$cli_diagnostics$src$banners$error_json$default);
      }

      const displayableProblems = this.getDisplayedProblemsCount();
      let str = `Found <emphasis><number>${displayableProblems}</number></emphasis> problem`;
      if (displayableProblems > 1 || displayableProblems == 0) {
        str += 's';
      }

      if (filteredCount > 0) {
        str += ___$romejs$string_ansi$src$format_ts$formatAnsi.brightBlack(` (${filteredCount} filtered)`);
      }

      reporter.error(str);

      if (this.truncatedCount > 0) {
        const {maxDiagnostics: maxDiagnostics} = this.flags;
        reporter.warn(
        `Only <number>${maxDiagnostics}</number> errors shown, add the <emphasis>--show-all-diagnostics</emphasis> flag to view the remaining <number>${displayableProblems -
        maxDiagnostics}</number> errors`);
      }
    }
  }

  // romejs/cli-diagnostics/src/index.ts

  const ___$$priv$romejs$cli_diagnostics$src$index_ts$stream = require('stream');
  async function ___$romejs$cli_diagnostics$src$index_ts$print(diagnostics, opts) {
    const printer = new ___$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$default(opts);
    printer.addDiagnostics(diagnostics);
    await printer.print();
    return printer;
  }

  function ___$romejs$cli_diagnostics$src$index_ts$printToString(diagnostics, opts) {
    let buff = '';

    const stdout = new ___$$priv$romejs$cli_diagnostics$src$index_ts$stream.Writable({
      write: (chunk, encoding, callback) => {
        buff += chunk.toString();
        callback();
      }});

    const reporter = new ___$romejs$cli_reporter$src$Reporter_ts$default({
      stdout: stdout,
      stderr: stdout});

    const printer = new ___$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$default(Object.assign({}, opts, {
      reporter: reporter}));
    printer.addDiagnostics(diagnostics);
    printer.printSync();
    return buff;
  }

  // romejs/core/src/common/types/api.ts

  const ___$romejs$core$src$common$types$api_ts = {
    get DEFAULT_API_REQUEST_FLAGS() {
      return ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS;
    }};
  const ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS = Object.assign({
    cwd: process.cwd(),
    color: process.stdout.isTTY === true,
    json: false,
    silent: false,
    verbose: false,
    watch: false,
    rage: false,
    ragePath: '',
    logs: false,
    logPath: '',
    logWorkers: false,
    profile: false,
    profilePath: '',
    profileTimeout: 0,
    bundlerMode: undefined,
    resolverPlatform: undefined,
    resolverScale: undefined,
    resolverMocks: false}, ___$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS);

  // romejs/codec-json/src/types.ts


  // romejs/codec-json/src/constants.ts

  const ___$romejs$codec_json$src$constants_ts$PRIORITIZE_KEYS = ['id', 'name', 'version'];

  const ___$romejs$codec_json$src$constants_ts$DAYS_IN_A_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  const ___$romejs$codec_json$src$constants_ts$MONTH_NAMES = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

  // romejs/js-parser-utils/src/identifier.ts

  const ___$romejs$js_parser_utils$src$identifier_ts = {
    get keywordRelationalOperator() {
      return ___$romejs$js_parser_utils$src$identifier_ts$keywordRelationalOperator;
    },
    isES2015ReservedWord: ___$romejs$js_parser_utils$src$identifier_ts$isES2015ReservedWord,
    isReservedWord: ___$romejs$js_parser_utils$src$identifier_ts$isReservedWord,
    isStrictReservedWord: ___$romejs$js_parser_utils$src$identifier_ts$isStrictReservedWord,
    isStrictBindReservedWord: ___$romejs$js_parser_utils$src$identifier_ts$isStrictBindReservedWord,
    isKeyword: ___$romejs$js_parser_utils$src$identifier_ts$isKeyword,
    getFullCharCodeAt: ___$romejs$js_parser_utils$src$identifier_ts$getFullCharCodeAt,
    isIdentifierStart: ___$romejs$js_parser_utils$src$identifier_ts$isIdentifierStart,
    isIdentifierChar: ___$romejs$js_parser_utils$src$identifier_ts$isIdentifierChar};
  const ___$romejs$js_parser_utils$src$identifier_ts$keywordRelationalOperator = /^in(stanceof)?$/;

  function ___$romejs$js_parser_utils$src$identifier_ts$isES2015ReservedWord(word) {
    return word === 'enum' || word === 'await';
  }

  function ___$romejs$js_parser_utils$src$identifier_ts$isReservedWord(word, inModule) {
    return inModule && word === 'await' || word === 'enum';
  }

  const ___$$priv$romejs$js_parser_utils$src$identifier_ts$reservedWordsStrict = new Set(['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield']);
  function ___$romejs$js_parser_utils$src$identifier_ts$isStrictReservedWord(word, inModule) {
    return ___$romejs$js_parser_utils$src$identifier_ts$isReservedWord(word, inModule) || ___$$priv$romejs$js_parser_utils$src$identifier_ts$reservedWordsStrict.has(word);
  }

  function ___$romejs$js_parser_utils$src$identifier_ts$isStrictBindReservedWord(word, inModule) {
    return ___$romejs$js_parser_utils$src$identifier_ts$isStrictReservedWord(word, inModule) ||
    word === 'eval' ||
    word === 'arguments';
  }

  const ___$$priv$romejs$js_parser_utils$src$identifier_ts$keywords = new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete']);

  function ___$romejs$js_parser_utils$src$identifier_ts$isKeyword(word) {
    return ___$$priv$romejs$js_parser_utils$src$identifier_ts$keywords.has(word);
  }

  let ___$$priv$romejs$js_parser_utils$src$identifier_ts$nonASCIIidentifierStartChars = '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312e\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fea\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc';

  let ___$$priv$romejs$js_parser_utils$src$identifier_ts$nonASCIIidentifierChars = '\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f';

  const ___$$priv$romejs$js_parser_utils$src$identifier_ts$nonASCIIidentifierStart = new RegExp('[' + ___$$priv$romejs$js_parser_utils$src$identifier_ts$nonASCIIidentifierStartChars + ']');
  const ___$$priv$romejs$js_parser_utils$src$identifier_ts$nonASCIIidentifier = new RegExp('[' + ___$$priv$romejs$js_parser_utils$src$identifier_ts$nonASCIIidentifierStartChars + ___$$priv$romejs$js_parser_utils$src$identifier_ts$nonASCIIidentifierChars + ']');

  const ___$$priv$romejs$js_parser_utils$src$identifier_ts$astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 55, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 698, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 1, 31, 6124, 20, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];

  const ___$$priv$romejs$js_parser_utils$src$identifier_ts$astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 19719, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];

  function ___$romejs$js_parser_utils$src$identifier_ts$getFullCharCodeAt(str, offset) {
    const code = str.charCodeAt(offset);
    if (code <= 55295 || code >= 57344) {
      return code;
    }

    const next = str.charCodeAt(offset + 1);
    return (code << 10) + next - 56613888;
  }

  function ___$$priv$romejs$js_parser_utils$src$identifier_ts$isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) {
        return false;
      }

      pos += set[i + 1];
      if (pos >= code) {
        return true;
      }
    }
    return false;
  }

  function ___$romejs$js_parser_utils$src$identifier_ts$isIdentifierStart(code) {
    if (code === undefined) {
      return false;
    }

    if (code < 65) {
      return code === 36;
    }

    if (code < 91) {
      return true;
    }

    if (code < 97) {
      return code === 95;
    }

    if (code < 123) {
      return true;
    }

    if (code <= 65535) {
      return code >= 170 && ___$$priv$romejs$js_parser_utils$src$identifier_ts$nonASCIIidentifierStart.test(String.fromCharCode(code));
    }

    return ___$$priv$romejs$js_parser_utils$src$identifier_ts$isInAstralSet(code, ___$$priv$romejs$js_parser_utils$src$identifier_ts$astralIdentifierStartCodes);
  }

  function ___$romejs$js_parser_utils$src$identifier_ts$isIdentifierChar(code) {
    if (code < 48) {
      return code === 36;
    }

    if (code < 58) {
      return true;
    }

    if (code < 65) {
      return false;
    }

    if (code < 91) {
      return true;
    }

    if (code < 97) {
      return code === 95;
    }

    if (code < 123) {
      return true;
    }

    if (code <= 65535) {
      return code >= 170 && ___$$priv$romejs$js_parser_utils$src$identifier_ts$nonASCIIidentifier.test(String.fromCharCode(code));
    }

    return ___$$priv$romejs$js_parser_utils$src$identifier_ts$isInAstralSet(code, ___$$priv$romejs$js_parser_utils$src$identifier_ts$astralIdentifierStartCodes) ||
    ___$$priv$romejs$js_parser_utils$src$identifier_ts$isInAstralSet(code, ___$$priv$romejs$js_parser_utils$src$identifier_ts$astralIdentifierCodes);
  }

  // romejs/js-parser-utils/src/location.ts

  const ___$romejs$js_parser_utils$src$location_ts = {};

  // romejs/messages/src/index.ts

  function ___$$priv$romejs$messages$src$index_ts$sprintf(msg, ...args) {
    return msg.replace(/\$(\d+)/g, (match, num) => {
      return String(args[num]);
    });
  }

  function ___$romejs$messages$src$index_ts$default(messages) {
    const obj = {};

    for (const key in messages) {
      const msg = messages[key];

      obj[key] = (...args) => {
        return ___$$priv$romejs$messages$src$index_ts$sprintf(msg, ...args);
      };
    }

    return obj;
  }

  // romejs/js-parser-utils/src/messages.ts

  const ___$romejs$js_parser_utils$src$messages_ts$default = ___$romejs$messages$src$index_ts$default({
    DUPLICATE_REGEX_FLAG: 'Duplicate regular expression flag',
    INVALID_REGEX_FLAG: 'Invalid regular expression flag'});

  // romejs/js-parser-utils/src/regex.ts

  const ___$romejs$js_parser_utils$src$regex_ts = {
    validateRegexFlags: ___$romejs$js_parser_utils$src$regex_ts$validateRegexFlags};
  const ___$$priv$romejs$js_parser_utils$src$regex_ts$VALID_REGEX_FLAGS = 'gmsiyu'.split('');

  function ___$romejs$js_parser_utils$src$regex_ts$validateRegexFlags(flags, onUnexpected) {
    const foundFlags = new Set();

    for (let i = 0; i < flags.length; i++) {
      const flag = flags[i];

      if (___$$priv$romejs$js_parser_utils$src$regex_ts$VALID_REGEX_FLAGS.includes(flag)) {
        if (foundFlags.has(flag)) {
          onUnexpected(___$romejs$js_parser_utils$src$messages_ts$default.DUPLICATE_REGEX_FLAG(), i);
        } else {
          foundFlags.add(flag);
        }
      } else {
        onUnexpected(___$romejs$js_parser_utils$src$messages_ts$default.INVALID_REGEX_FLAG(), i);
      }
    }

    return foundFlags;
  }

  // romejs/js-parser-utils/src/whitespace.ts

  const ___$romejs$js_parser_utils$src$whitespace_ts = {
    get lineBreak() {
      return ___$romejs$js_parser_utils$src$whitespace_ts$lineBreak;
    },
    get lineBreakG() {
      return ___$romejs$js_parser_utils$src$whitespace_ts$lineBreakG;
    },
    isNewLine: ___$romejs$js_parser_utils$src$whitespace_ts$isNewLine,
    get nonASCIIwhitespace() {
      return ___$romejs$js_parser_utils$src$whitespace_ts$nonASCIIwhitespace;
    },
    get skipWhiteSpace() {
      return ___$romejs$js_parser_utils$src$whitespace_ts$skipWhiteSpace;
    }};
  const ___$romejs$js_parser_utils$src$whitespace_ts$lineBreak = /\r\n?|\n|\u2028|\u2029/;
  const ___$romejs$js_parser_utils$src$whitespace_ts$lineBreakG = new RegExp(___$romejs$js_parser_utils$src$whitespace_ts$lineBreak.source, 'g');

  function ___$romejs$js_parser_utils$src$whitespace_ts$isNewLine(code) {
    return code === 10 || code === 13 || code === 8232 || code === 8233;
  }

  const ___$romejs$js_parser_utils$src$whitespace_ts$nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  const ___$romejs$js_parser_utils$src$whitespace_ts$skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  // romejs/js-parser-utils/src/index.ts


  // romejs/codec-json/src/messages.ts

  const ___$romejs$codec_json$src$messages_ts$default = ___$romejs$messages$src$index_ts$default({
    SINGLE_QUOTE_USAGE: 'You can only use double quoted strings',
    TRAILING_OBJECT_COMMA: 'A trailing comma is only allowed after an object property',
    TRAILING_ARRAY_COMMA: 'A trailing comma is only allowed after an array element',
    UNCLOSED_STRING: 'Unclosed string',
    MISTAKEN_ARRAY_IDENTITY: 'Trying to use an array element as an object property. Did you mean to make an object?',
    UNCLOSED_BLOCK_COMMENT: 'Unclosed block comment',
    UNCLOSED_REGEX: 'Regex wasn\'t closed',

    BIGINT_WITH_SCI_NOTATION: 'A bigint can\'t have a decimal',
    BIGINT_WITH_DECIMAL: 'A bigint can\'t have scientific notation',
    BIGINT_UNSUPPORTED_ENV: 'Current environment does not support bigint',

    EMPTY_INPUT_IN_JSON: 'Empty input',
    PROPERTY_KEY_UNQUOTED_IN_JSON: 'Property keys must be quoted in JSON',
    IMPLICIT_OBJECT_IN_JSON: 'Objects must be wrapped in curly braces in JSON',
    COMMENTS_IN_JSON: 'Comments aren\'t allowed in JSON',
    TRAILING_COMMA_IN_JSON: 'Trailing commas aren\'t allowed in JSON',
    REGEX_IN_JSON: 'Regular expressions aren\'t allowed in JSON',
    NUMERIC_WORD_IN_JSON: '$0 cannot be used or represented in JSON',
    NUMERIC_SEPARATORS_IN_JSON: 'Numeric separators are not allowed in JSON',
    STRING_NEWLINES_IN_JSON: 'Newlines aren\'t allowed in JSON, you insert a newline by escaping it like this "\\n"',
    UNQUOTED_PROPERTY_KEY_IN_JSON: 'Property keys must be wrapped in quotes in JSON',
    UNDEFINED_IN_JSON: 'undefined isn\'t allowed in JSON, you could use null instead'});

  // romejs/codec-json/src/Parser.ts

  function ___$$priv$romejs$codec_json$src$Parser_ts$isWordStartChar(char) {
    return ___$romejs$parser_core$src$index_ts$isAlpha(char) || char === '_' || char === '$';
  }

  function ___$$priv$romejs$codec_json$src$Parser_ts$isWordChar(char) {
    return ___$$priv$romejs$codec_json$src$Parser_ts$isWordStartChar(char) || ___$romejs$parser_core$src$index_ts$isDigit(char);
  }

  function ___$romejs$codec_json$src$Parser_ts$isValidWord(word) {
    if (word.length === 0 || ___$$priv$romejs$codec_json$src$Parser_ts$isWordStartChar(word[0]) === false) {
      return false;
    }

    for (const char of word) {
      if (___$$priv$romejs$codec_json$src$Parser_ts$isWordChar(char) === false) {
        return false;
      }
    }

    return true;
  }

  function ___$$priv$romejs$codec_json$src$Parser_ts$isNumberChar(char) {
    return ___$romejs$parser_core$src$index_ts$isDigit(char) || char === '_';
  }

  function ___$$priv$romejs$codec_json$src$Parser_ts$isValidNumberWord(word) {
    return word === 'NaN' || word === 'Infinity';
  }

  function ___$$priv$romejs$codec_json$src$Parser_ts$isRegexPatternChar(char, index, input) {
    if (char === '/' && !___$romejs$parser_core$src$index_ts$isEscaped(index, input)) {
      return false;
    } else {
      return true;
    }
  }

  function ___$$priv$romejs$codec_json$src$Parser_ts$isStringValueChar(char, index, input) {
    if (char === '\n') {
      return false;
    }

    if (char === '"' && !___$romejs$parser_core$src$index_ts$isEscaped(index, input)) {
      return false;
    }

    return true;
  }

  function ___$$priv$romejs$codec_json$src$Parser_ts$isntNewline(char) {
    return char !== '\n';
  }

  function ___$$priv$romejs$codec_json$src$Parser_ts$isntBlockCommentEnd(char, index, input) {
    const nextChar = input[index + 1];
    return char !== '*' && nextChar !== '/';
  }

  function ___$romejs$codec_json$src$Parser_ts$toPathKey(parts) {
    return parts.join('.');
  }

  class ___$romejs$codec_json$src$Parser_ts$default extends ___$romejs$parser_core$src$index_ts$ParserCore {
    constructor({mode: mode, locations: locations, ...opts}) {
      super(opts, '@romejs/codec-json');
      this.isRegularJSON = ___$romejs$codec_json$src$Parser_ts$default.isRegularJSON(mode, opts.filename);
      this.locations = locations === undefined ? true : false;
      this.contextStack = [];
    }

    static isRegularJSON(mode, filename) {
      if (mode === 'json') {
        return true;
      }

      if (mode === undefined && filename !== undefined) {
        return !filename.endsWith('.rjson');
      }

      return false;
    }

    tokenize(index, input) {
      const nextChar = input[index + 1];
      const char = input[index];

      if (char === '/' && nextChar === '/') {
        const commentValueIndex = index + 2;
        const value = this.readInputFrom(commentValueIndex, ___$$priv$romejs$codec_json$src$Parser_ts$isntNewline);

        return this.finishValueToken(
        'LineComment',
        value,
        commentValueIndex + value.length);
      }

      if (char === '/' && nextChar === '*') {
        const commentValueIndex = index + 2;
        const value = this.readInputFrom(commentValueIndex, ___$$priv$romejs$codec_json$src$Parser_ts$isntBlockCommentEnd);

        const endIndex = commentValueIndex + value.length + 2;

        if (this.input[endIndex - 2] !== '*' ||
        this.input[endIndex - 1] !== '/') {
          throw this.unexpected({
            message: ___$romejs$codec_json$src$messages_ts$default.UNCLOSED_BLOCK_COMMENT(),
            start: this.getPositionFromIndex(endIndex)});
        }

        return this.finishValueToken(
        'BlockComment',
        value,
        endIndex);
      }

      switch (char) {
        case '"':
          const value = this.readInputFrom(index + 1, ___$$priv$romejs$codec_json$src$Parser_ts$isStringValueChar);

          const end = index + value.length + 2;
          if (input[end - 1] !== '"') {
            throw this.unexpected({
              message: ___$romejs$codec_json$src$messages_ts$default.UNCLOSED_STRING(),
              start: this.getPositionFromIndex(end)});
          }

          if (this.isRegularJSON) {
            for (let strIndex = 0; strIndex < value.length; strIndex++) {
              const char = value[strIndex];

              if (char === '\n') {
                throw this.unexpected({
                  message: ___$romejs$codec_json$src$messages_ts$default.STRING_NEWLINES_IN_JSON(),
                  start: this.getPositionFromIndex(index + strIndex)});
              }
            }
          }

          const unescaped = ___$romejs$string_escape$src$unescapeString_ts$default(value, (message, strIndex) => {
            throw this.unexpected({
              message: message,
              start: this.getPositionFromIndex(index + strIndex)});
          });

          return this.finishValueToken('String', unescaped, end);

        case '\'':
          throw this.unexpected({
            message: ___$romejs$codec_json$src$messages_ts$default.SINGLE_QUOTE_USAGE(),
            start: this.getPositionFromIndex(index)});

        case ',':
          return this.finishToken('Comma');

        case '.':
          return this.finishToken('Dot');

        case '+':
          return this.finishToken('Plus');

        case '-':
          return this.finishToken('Minus');

        case ':':
          return this.finishToken('Colon');

        case '{':
          return this.finishToken('BraceOpen');

        case '}':
          return this.finishToken('BraceClose');

        case '[':
          return this.finishToken('BracketOpen');

        case ']':
          return this.finishToken('BracketClose');

        case '/':
          {
            const pattern = this.readInputFrom(index + 1, ___$$priv$romejs$codec_json$src$Parser_ts$isRegexPatternChar);

            const endIndex = index + pattern.length + 2;

            if (input[endIndex] !== '/') {
              throw this.unexpected({
                message: ___$romejs$codec_json$src$messages_ts$default.UNCLOSED_REGEX(),
                start: this.getPositionFromIndex(endIndex - 1)});
            }

            return this.finishValueToken('Regex', pattern, endIndex);
          }

        case ' ':
        case '\t':
        case '\r':
        case '\n':
          return this.lookaheadToken(index + 1);}

      if (___$romejs$parser_core$src$index_ts$isDigit(char)) {
        const value = this.removeUnderscores(
        index,
        this.readInputFrom(index, ___$$priv$romejs$codec_json$src$Parser_ts$isNumberChar));
        const num = Number(value);

        ___$romejs$invariant$src$index_ts$default(!isNaN(num), 'Invalid number, internal error');

        return this.finishValueToken(
        'Number',
        num,
        index + value.length);
      }

      if (___$$priv$romejs$codec_json$src$Parser_ts$isWordStartChar(char)) {
        const value = this.readInputFrom(index, ___$$priv$romejs$codec_json$src$Parser_ts$isWordChar);
        return this.finishValueToken(
        'Word',
        value,
        index + value.length);
      }

      return undefined;
    }

    removeUnderscores(index, raw) {
      let str = '';

      for (let i = 0; i < raw.length; i++) {
        const char = raw[i];

        if (char === '_') {
          if (this.isRegularJSON) {
            throw this.unexpected({
              message: ___$romejs$codec_json$src$messages_ts$default.NUMERIC_SEPARATORS_IN_JSON(),
              start: this.getPositionFromIndex(index + 1)});
          }
        } else {
          str += char;
        }
      }

      return str;
    }

    eatComments() {
      const comments = [];

      while (true) {
        const token = this.getToken();

        if (token.type === 'LineComment') {
          comments.push({
            type: 'LineComment',
            value: token.value});
        } else if (token.type === 'BlockComment') {
          comments.push({
            type: 'BlockComment',
            value: token.value});
        } else {
          break;
        }

        if (this.isRegularJSON) {
          throw this.unexpected({message: ___$romejs$codec_json$src$messages_ts$default.COMMENTS_IN_JSON()});
        }

        this.nextToken();
      }

      return comments;
    }

    getLastContext() {
      const {contextStack: contextStack} = this;

      const lastContext = contextStack[contextStack.length - 1];
      ___$romejs$invariant$src$index_ts$default(
      lastContext !== undefined,
      'Expected there to be a context but found none');
      return lastContext;
    }

    createContext(key) {
      const start = this.getPosition();
      const context = {
        originalValue: undefined,
        start: start,
        end: start,
        innerComments: [],
        comments: [],
        children: new Map()};

      if (key !== undefined) {
        const parentContext = this.getLastContext();
        parentContext.children.set(key, context);
      }

      this.contextStack.push(context);
    }

    provideContext(opts) {
      const lastContext = this.getLastContext();

      Object.assign(lastContext, {
        end: opts.end === undefined ? this.getPosition() : opts.end,
        originalValue: opts.originalValue,
        innerComments: opts.innerComments === undefined ? lastContext.innerComments : [...lastContext.innerComments, ...opts.innerComments],
        comments: opts.comments === undefined ? lastContext.comments : [...lastContext.comments, ...opts.comments]});

      return lastContext;
    }

    popContext() {
      return this.contextStack.pop();
    }

    parseObject(firstKey) {
      const obj = {};

      let innerComments = [];
      let isFirstProp = true;

      let nextLeadingComments;

      do {
        let leadingComments = this.eatComments();

        if (nextLeadingComments !== undefined) {
          leadingComments = [...nextLeadingComments, ...leadingComments];
          nextLeadingComments = undefined;
        }

        if (this.isRegularJSON && this.matchToken('Word')) {
          throw this.unexpected({
            message: ___$romejs$codec_json$src$messages_ts$default.UNQUOTED_PROPERTY_KEY_IN_JSON()});
        }

        if (this.matchToken('Comma')) {
          throw this.unexpected({
            message: ___$romejs$codec_json$src$messages_ts$default.TRAILING_OBJECT_COMMA()});
        }

        const hasKey = isFirstProp && firstKey !== undefined;
        if (!hasKey && !this.matchToken('String') && !this.matchToken('Word')) {
          innerComments = [...innerComments, ...leadingComments];
          break;
        }

        let key;
        if (isFirstProp && firstKey !== undefined) {
          key = firstKey;
        } else {
          key = this.parseStringOrWord();
        }
        this.expectToken('Colon');

        const leadingValueComments = this.eatComments();
        this.createContext(key);

        const value = this.parseExpression();
        const end = this.getPosition();

        let trailingValueComments = this.eatComments();

        if (!this.matchToken('Comma') && !this.matchToken('BraceClose')) {
          nextLeadingComments = trailingValueComments;
          trailingValueComments = [];
        }

        this.provideContext({
          end: end,
          originalValue: value,
          comments: [...leadingComments, ...leadingValueComments, ...trailingValueComments]});
        this.popContext();

        if (!this.isRegularJSON &&
        Object.prototype.hasOwnProperty.call(obj, key)) {
          throw this.unexpected({message: 'Duplicate property'});
        }

        if (key === '__proto__') {
          Object.defineProperty(obj, '__proto__', {
            value: value,
            configurable: true,
            writable: true,
            enumerable: true});
        } else {
          obj[key] = value;
        }

        isFirstProp = false;
      } while (this.isPropertySeparator());

      if (nextLeadingComments !== undefined) {
        innerComments = [...innerComments, ...nextLeadingComments];
      }

      this.provideContext({
        originalValue: obj,
        innerComments: innerComments});

      if (firstKey === undefined) {
        this.expectToken('BraceClose');
      }

      return obj;
    }

    parseRegExp() {
      if (this.isRegularJSON) {
        throw this.unexpected({
          message: ___$romejs$codec_json$src$messages_ts$default.REGEX_IN_JSON()});
      }

      const token = this.expectToken('Regex');
      if (token.type !== 'Regex') {
        throw new Error('Impossible');
      }

      const pattern = token.value;
      let flags = '';

      const nextToken = this.getToken();
      if (nextToken.type === 'Word') {
        this.nextToken();
        flags = nextToken.value;

        ___$romejs$js_parser_utils$src$regex_ts$validateRegexFlags(flags, (msg, index) => {
          throw this.unexpected({
            message: msg,
            start: this.getPositionFromIndex(nextToken.start + index)});
        });
      }

      return new RegExp(pattern, flags);
    }

    parseArray() {
      this.expectToken('BracketOpen');

      const arr = [];
      let innerComments = [];
      let i = 0;

      do {
        const leadingComments = this.eatComments();

        if (this.matchToken('Comma')) {
          throw this.unexpected({
            message: ___$romejs$codec_json$src$messages_ts$default.TRAILING_ARRAY_COMMA()});
        }

        if (this.matchToken('BracketClose')) {
          innerComments = [...innerComments, ...leadingComments];
          break;
        }

        this.createContext(i);
        i++;

        const item = this.parseExpression();
        arr.push(item);
        const end = this.getPosition();

        const trailingComments = this.eatComments();
        const comments = [...leadingComments, ...trailingComments];
        this.provideContext({originalValue: item, end: end, comments: comments});
        this.popContext();

        if (this.matchToken('Colon')) {
          throw this.unexpected({message: ___$romejs$codec_json$src$messages_ts$default.MISTAKEN_ARRAY_IDENTITY()});
        }
      } while (this.isPropertySeparator());

      this.expectToken('BracketClose');

      this.provideContext({
        originalValue: arr,
        innerComments: innerComments});

      return arr;
    }

    isPropertySeparator() {
      const token = this.getToken();

      if (this.isRegularJSON) {
        if (token.type !== 'Comma') {
          return false;
        }

        const lookahead = this.lookaheadToken();
        if (lookahead.type === 'BraceClose' ||
        lookahead.type === 'BracketClose') {
          throw this.unexpected({message: ___$romejs$codec_json$src$messages_ts$default.TRAILING_COMMA_IN_JSON()});
        }

        this.nextToken();
        return true;
      }

      if (token.type === 'Comma') {
        this.nextToken();
      }

      if (token.type === 'BraceClose' || token.type === 'BracketClose') {
        return false;
      }

      return true;
    }

    parseWord(isStart) {
      const token = this.expectToken('Word');
      if (token.type !== 'Word') {
        throw new Error('Impossible');
      }

      switch (token.value) {
        case 'true':
          return true;

        case 'false':
          return false;

        case 'null':
          return null;

        case 'undefined':
          if (this.isRegularJSON) {
            throw this.unexpected({message: ___$romejs$codec_json$src$messages_ts$default.UNDEFINED_IN_JSON()});
          } else {
            return undefined;
          }}

      if (this.isRegularJSON) {
        throw this.unexpected({
          message: ___$romejs$codec_json$src$messages_ts$default.NUMERIC_WORD_IN_JSON(token.value)});
      }

      switch (token.value) {
        case 'Infinity':
          return Infinity;

        case 'NaN':
          return NaN;

        default:
          if (isStart && this.matchToken('Colon')) {
            if (this.isRegularJSON) {
              throw this.unexpected({
                message: ___$romejs$codec_json$src$messages_ts$default.IMPLICIT_OBJECT_IN_JSON()});
            }

            return this.parseObject(token.value);
          } else {
            throw this.unexpected();
          }}
    }

    expectDateNumber(callback) {
      const token = this.getToken();
      if (token.type !== 'Number') {
        throw this.unexpected({message: 'Expected a date number'});
      }
      callback(token.value);
      this.nextToken();

      return token.value;
    }

    parseDateOnly(year) {
      if (year < 1 || year > 9999) {
        throw this.unexpected({
          message: 'Year must be between 1-9999'});
      }
      this.nextToken();

      const month = this.expectDateNumber(val => {
        if (val < 1 || val > 12) {
          throw this.unexpected({
            message: 'Month must be between 1-12'});
        }
      });
      const monthIndex = month - 1;
      this.expectToken('Minus');

      const isLeapYear = year % 4 === 0;
      const monthName = ___$romejs$codec_json$src$constants_ts$MONTH_NAMES[monthIndex];
      let totalDays = ___$romejs$codec_json$src$constants_ts$DAYS_IN_A_MONTH[monthIndex];

      if (month === 2 && isLeapYear) {
        totalDays++;
      }

      const day = this.expectDateNumber(val => {
        if (val === 0 || val > totalDays) {
          throw this.unexpected({
            message: `Day for ${monthName} must be between 1-${String(
            totalDays)}`});
        }
      });

      return {monthIndex: monthIndex, day: day};
    }

    parseTime() {
      const hour = this.expectDateNumber(val => {
        if (val > 24) {
          throw this.unexpected({
            message: 'Hour must be between 0-24'});
        }
      });
      this.expectToken('Colon');

      const minute = this.expectDateNumber(val => {
        if (val > 59) {
          throw this.unexpected({
            message: 'Hour must be between 0-59'});
        }
      });
      this.expectToken('Colon');

      const second = this.expectDateNumber(val => {
        if (val > 59) {
          throw this.unexpected({
            message: 'Seconds must be between 0-59'});
        }
      });

      let millisecond = 0;
      if (this.eatToken('Dot')) {
        millisecond = this.expectDateNumber(val => {
          if (val > 999) {
            throw this.unexpected({
              message: 'Milliseconds must only have 3 digits and be between 0-999'});
          }
        });
      }

      return {hour: hour, minute: minute, second: second, millisecond: millisecond};
    }

    eatDateEnd() {
      const token = this.getToken();
      if (token.type === 'Word' && token.value === 'Z') {
        this.nextToken();
      }
    }

    parseDate(year) {
      const {monthIndex: monthIndex, day: day} = this.parseDateOnly(year);

      const timeEndToken = this.getToken();
      if (timeEndToken.type === 'Word' && timeEndToken.value === 'T') {
        this.nextToken();
      } else {
        this.eatDateEnd();

        return new Date(year, monthIndex, day, 0, 0, 0, 0);
      }

      const {hour: hour, minute: minute, second: second, millisecond: millisecond} = this.parseTime();
      this.eatDateEnd();
      return new Date(year, monthIndex, day, hour, minute, second, millisecond);
    }

    parseNumber() {
      const isNegative = this.eatToken('Minus') !== undefined;
      let hasDecimal = false;
      let hasSciNotation = false;

      const token = this.getToken();
      if (token.type === 'Word' && ___$$priv$romejs$codec_json$src$Parser_ts$isValidNumberWord(token.value)) {
        const num = this.parseWord(false);
        if (typeof num !== 'number') {
          throw new Error('Impossible');
        }
        return num;
      }

      if (token.type !== 'Number') {
        throw new Error('Impossible');
      }
      let value = String(token.value);

      if (this.eatToken('Minus')) {
        return this.parseDate(token.value);
      }

      this.nextToken();

      if (this.eatToken('Dot')) {
        value += '.';

        const decimal = this.expectToken('Number');
        if (decimal.type !== 'Number') {
          throw new Error('Impossible');
        }
        value += String(decimal.value);
        hasDecimal = true;
      }

      const nextToken = this.getToken();
      if (nextToken.type === 'Word' &&
      (nextToken.value === 'e' || nextToken.value === 'E')) {
        value += 'e';

        const operator = this.nextToken();
        if (operator.type === 'Plus') {
          value += '+';
        } else if (operator.type === 'Minus') {
          value += '-';
        } else {
          throw this.unexpected();
        }

        this.nextToken();
        const factor = this.expectToken('Number');
        if (factor.type !== 'Number') {
          throw new Error('Impossible');
        }
        value += String(factor.value);

        hasSciNotation = true;
      }

      const nextToken2 = this.getToken();
      if (nextToken2.type === 'Word' && nextToken2.value === 'n') {
        this.nextToken();

        if (hasSciNotation) {
          throw this.unexpected({
            message: ___$romejs$codec_json$src$messages_ts$default.BIGINT_WITH_SCI_NOTATION()});
        }

        if (hasDecimal) {
          throw this.unexpected({
            message: ___$romejs$codec_json$src$messages_ts$default.BIGINT_WITH_DECIMAL()});
        }

        if (typeof BigInt === 'undefined') {
          throw this.unexpected({
            message: ___$romejs$codec_json$src$messages_ts$default.BIGINT_UNSUPPORTED_ENV()});
        }

        let num = BigInt(value);
        if (isNegative) {
          num = -num;
        }
        return num;
      }

      let num = Number(value);
      if (isNegative) {
        num = -num;
      }
      return num;
    }

    parseStringOrWord() {
      const token = this.getToken();

      switch (token.type) {
        case 'String':
          this.nextToken();
          return token.value;

        case 'Word':
          if (this.isRegularJSON) {
            throw this.unexpected({
              message: ___$romejs$codec_json$src$messages_ts$default.PROPERTY_KEY_UNQUOTED_IN_JSON()});
          } else {
            this.nextToken();
            return token.value;
          }

        default:
          throw this.unexpected();}
    }

    parseString(isStart) {
      const token = this.expectToken('String');
      if (token.type !== 'String') {
        throw new Error('Impossible');
      }

      if (isStart && this.nextToken().type === 'Colon') {
        if (this.isRegularJSON) {
          throw this.unexpected({message: ___$romejs$codec_json$src$messages_ts$default.IMPLICIT_OBJECT_IN_JSON()});
        }

        return this.parseObject(token.value);
      } else {
        return token.value;
      }
    }

    parseExpression(isStart = false) {
      const token = this.getToken();

      switch (token.type) {
        case 'String':
          return this.parseString(isStart);

        case 'Minus':
        case 'Number':
          return this.parseNumber();

        case 'Word':
          return this.parseWord(isStart);

        case 'Regex':
          return this.parseRegExp();

        case 'BracketOpen':
          return this.parseArray();

        case 'BraceOpen':
          {
            this.nextToken();
            return this.parseObject();
          }

        default:
          throw this.unexpected();}
    }

    parseEntry() {
      if (this.matchToken('EOF')) {
        if (this.isRegularJSON) {
          throw this.unexpected({message: ___$romejs$codec_json$src$messages_ts$default.EMPTY_INPUT_IN_JSON()});
        } else {
          return {};
        }
      } else {
        return this.parseExpression(true);
      }
    }

    parse() {
      if (this.isRegularJSON && this.locations === false) {
        try {
          const value = JSON.parse(this.input);

          this.createContext();
          const context = this.provideContext({
            originalValue: value});

          return {
            context: context,
            value: value};
        } catch (err) {
          if (!(err instanceof SyntaxError)) {
            throw err;
          }
        }
      }

      const leadingComments = this.eatComments();

      this.createContext();
      const expr = this.parseEntry();
      const end = this.getPosition();

      const trailingComments = this.eatComments();
      const context = this.provideContext({
        originalValue: expr,
        end: end,
        comments: [...leadingComments, ...trailingComments]});

      this.finalize();

      return {
        value: expr,
        context: context};
    }
  }

  // romejs/codec-json/src/stringify.ts

  function ___$$priv$romejs$codec_json$src$stringify_ts$joinList(open, close, indent, items) {
    if (items.length === 0) {
      return open + close;
    }

    if (items.length === 1) {
      const first = items[0].trim();

      if (first[0] !== '/') {
        return open + first + close;
      }
    }

    return [open, ...items, indent + close].join('\n');
  }

  function ___$$priv$romejs$codec_json$src$stringify_ts$stringifyKey(key) {
    if (___$romejs$codec_json$src$Parser_ts$isValidWord(key)) {
      return key;
    } else {
      return ___$romejs$string_escape$src$escapeString_ts$default(key, {
        ignoreWhitespaceEscapes: true,
        json: true});
    }
  }

  function ___$$priv$romejs$codec_json$src$stringify_ts$stringifyDate(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const day = date.getUTCDate();
    const hour = date.getUTCHours();
    const minute = date.getUTCMinutes();
    const second = date.getUTCSeconds();
    const ms = date.getUTCMilliseconds();

    const dateStr = [year, month, day].join('-');

    if (hour === 0 && minute === 0 && second === 0 && ms === 0) {
      return dateStr;
    }

    const secondStr = ms === 0 ? second : `${second}.${ms}`;
    const timeStr = [hour, minute, secondStr].join(':');
    return `${dateStr}T${timeStr}`;
  }

  function ___$romejs$codec_json$src$stringify_ts$stringifyComments(indent, comments) {
    return comments.map(node => {
      if (node.type === 'BlockComment') {
        return `${indent}/*${node.value}*/`;
      } else {
        return `${indent}//${node.value}`;
      }
    });
  }

  function ___$$priv$romejs$codec_json$src$stringify_ts$stringifyPrimitives(value) {
    if (value === null) {
      return 'null';
    }

    if (value instanceof RegExp) {
      return `/${value.source}/${value.flags}`;
    }

    if (value instanceof Date) {
      return ___$$priv$romejs$codec_json$src$stringify_ts$stringifyDate(value);
    }

    if (value instanceof Number ||
    value instanceof String ||
    value instanceof Boolean) {
      value = value.valueOf();
    }

    switch (typeof value) {
      case 'symbol':
      case 'function':
        return 'null';

      case 'undefined':
        return 'undefined';

      case 'boolean':
        return value ? 'true' : 'false';

      case 'string':
        return ___$romejs$string_escape$src$escapeString_ts$default(value, {json: true, ignoreWhitespaceEscapes: true});

      case 'bigint':
        return `${___$romejs$pretty_format$src$index_ts$formatNumber(value)}n`;

      case 'number':
        return ___$romejs$pretty_format$src$index_ts$formatNumber(value);}

    return undefined;
  }

  function ___$$priv$romejs$codec_json$src$stringify_ts$sortMapKeys(map) {
    return new Set(Array.from(map.keys()).sort(___$romejs$string_utils$src$naturalCompare_ts$naturalCompare));
  }

  function ___$$priv$romejs$codec_json$src$stringify_ts$sortMap(map) {
    const sortedMap = new Map();
    const sortedKeys = ___$$priv$romejs$codec_json$src$stringify_ts$sortMapKeys(map);

    for (const key of ___$romejs$codec_json$src$constants_ts$PRIORITIZE_KEYS) {
      if (sortedKeys.has(key)) {
        sortedKeys.delete(key);
        sortedMap.set(key, map.getStrict(key));
      }
    }

    for (const key of sortedKeys) {
      sortedMap.set(key, map.getStrict(key));
    }

    return sortedMap;
  }

  function ___$$priv$romejs$codec_json$src$stringify_ts$stringifyArray(consumer, info) {
    const {level: level, prevIndent: prevIndent, nextIndent: nextIndent, stack: stack} = info;

    let buff = [];

    const arr = consumer.asArray();
    for (const consumer of arr) {
      const comments = consumer.getComments().outer;
      buff = buff.concat(___$romejs$codec_json$src$stringify_ts$stringifyComments(nextIndent, comments));

      const element = ___$romejs$codec_json$src$stringify_ts$stringifyConsumer(consumer, {
        isTopLevel: false,
        level: level + 1,
        stack: stack});
      buff.push(`${nextIndent}${element}`);
    }

    const innerComments = consumer.getComments().inner;
    buff = buff.concat(___$romejs$codec_json$src$stringify_ts$stringifyComments(nextIndent, innerComments));

    return ___$$priv$romejs$codec_json$src$stringify_ts$joinList('[', ']', prevIndent, buff);
  }

  function ___$$priv$romejs$codec_json$src$stringify_ts$stringifyPlainObject(consumer, info) {
    const {level: level, prevIndent: prevIndent, stack: stack, isTopLevel: isTopLevel} = info;
    let {nextIndent: nextIndent} = info;

    let buff = [];
    const map = consumer.asMap();

    for (const [key, consumer] of map) {
      const value = consumer.asMixed();

      if (typeof value === 'function' ||
      typeof value === 'undefined' ||
      typeof value === 'symbol') {
        map.delete(key);
      }
    }

    let propLevel = level + 1;

    if (isTopLevel && level === 0) {
      propLevel = 0;
      nextIndent = '';
    }

    for (const [key, consumer] of ___$$priv$romejs$codec_json$src$stringify_ts$sortMap(map)) {
      const comments = consumer.getComments().outer;
      buff = buff.concat(___$romejs$codec_json$src$stringify_ts$stringifyComments(nextIndent, comments));

      const propKey = ___$$priv$romejs$codec_json$src$stringify_ts$stringifyKey(key);
      const propValue = ___$romejs$codec_json$src$stringify_ts$stringifyConsumer(consumer, {
        isTopLevel: false,
        level: propLevel,
        stack: stack});
      buff.push(`${nextIndent}${propKey}: ${propValue}`);
    }

    const hasProps = buff.length > 0;

    const innerComments = consumer.getComments().inner;
    buff = buff.concat(___$romejs$codec_json$src$stringify_ts$stringifyComments(nextIndent, innerComments));

    if (level === 0 && isTopLevel) {
      if (hasProps) {
        return buff.join('\n');
      } else if (buff.length > 0) {
        buff = buff.map(str => {
          return '  ' + str;
        });
      }
    }

    return ___$$priv$romejs$codec_json$src$stringify_ts$joinList('{', '}', prevIndent, buff);
  }

  function ___$$priv$romejs$codec_json$src$stringify_ts$stringifyObject(consumer, value, opts) {
    const {isTopLevel: isTopLevel, level: level, stack: stack} = opts;

    const info = {
      isTopLevel: isTopLevel,
      nextIndent: '  '.repeat(level + 1),
      prevIndent: level === 0 ? '' : '  '.repeat(level - 1),
      level: level,
      stack: stack};

    try {
      stack.add(value);

      if (Array.isArray(value) || value instanceof Set) {
        return ___$$priv$romejs$codec_json$src$stringify_ts$stringifyArray(consumer, info);
      }

      return ___$$priv$romejs$codec_json$src$stringify_ts$stringifyPlainObject(consumer, info);
    } finally {
      stack.delete(value);
    }
  }

  function ___$romejs$codec_json$src$stringify_ts$stringifyConsumer(consumer, opts) {
    const {isTopLevel: isTopLevel, level: level, stack: stack} = opts;
    let value = consumer.asMixed();

    if (typeof value === 'object' &&
    value != null &&
    consumer.hasProperty('toJSON')) {
      const toJSON = consumer.getProperty('toJSON').asMixed();
      if (typeof toJSON === 'function') {
        const consumer2 = new ___$romejs$codec_json$src$Consumer_ts$default({
          filename: consumer.filename,
          context: consumer.context,
          value: toJSON.call(value),
          parent: consumer.parent,
          key: consumer.key});
        return ___$romejs$codec_json$src$stringify_ts$stringifyConsumer(consumer2, {isTopLevel: isTopLevel, level: level, stack: stack});
      }
    }

    const asPrim = ___$$priv$romejs$codec_json$src$stringify_ts$stringifyPrimitives(value);
    if (asPrim !== undefined) {
      return asPrim;
    }

    if (stack.has(value)) {
      throw new TypeError('Recursive');
    }

    return ___$$priv$romejs$codec_json$src$stringify_ts$stringifyObject(consumer, value, opts);
  }

  // romejs/codec-json/src/Consumer.ts

  class ___$romejs$codec_json$src$Consumer_ts$ConsumerMap extends Map {
    getStrict(key) {
      const val = this.get(key);
      if (val === undefined) {
        throw new Error(`Expected property ${key}`);
      }
      return val;
    }
  }

  const ___$$priv$romejs$codec_json$src$Consumer_ts$EMPTY_POSITION = {
    line: 1,
    column: 0,
    index: 0};

  const ___$$priv$romejs$codec_json$src$Consumer_ts$EMPTY_CONTEXT = {
    start: ___$$priv$romejs$codec_json$src$Consumer_ts$EMPTY_POSITION,
    end: ___$$priv$romejs$codec_json$src$Consumer_ts$EMPTY_POSITION,
    comments: [],
    innerComments: [],
    originalValue: undefined,
    children: new Map()};

  class ___$romejs$codec_json$src$Consumer_ts$default {
    constructor(opts) {
      this.filename = opts.filename;
      this.value = opts.value;
      this.parent = opts.parent;
      this.key = opts.key;

      if (opts.context === undefined) {
        this.context = Object.assign({}, ___$$priv$romejs$codec_json$src$Consumer_ts$EMPTY_CONTEXT);
        this.fromSource = false;
      } else {
        this.context = opts.context;
        this.fromSource = true;
      }
    }

    getComments() {
      const {comments: comments, innerComments: innerComments} = this.context;
      return {
        outer: comments,
        inner: innerComments};
    }

    getInnerLocation() {
      const {originalValue: originalValue} = this.context;

      const loc = this.getLocation();

      if (typeof originalValue === 'string') {
        return Object.assign({}, loc, {
          start: {
            index: loc.start.index + 1,
            line: loc.start.line,
            column: loc.start.column + 1},
          end: {
            index: loc.end.index - 1,
            line: loc.end.line,
            column: loc.end.column - 1}});
      } else {
        return loc;
      }
    }

    getLocation() {
      const {start: start, end: end} = this.context;
      return {
        filename: this.filename,
        start: start,
        end: end};
    }

    getPath() {
      const keys = [];

      let consumer = this;
      do {
        if (consumer.key !== undefined) {
          keys.unshift(String(consumer.key));
        }
        consumer = consumer.parent;
      } while (consumer !== undefined);

      return keys.join('.');
    }

    unexpected(msg) {
      const {filename: filename, fromSource: fromSource, value: value, parent: parent, key: key} = this;
      const {originalValue: originalValue} = this.context;
      let {start: start, end: end} = this.context;

      if (typeof key === 'number' && parent !== undefined) {
        msg += ` as an item for <emphasis>${parent.getPath()}</emphasis>`;
      } else {
        msg += ` at <emphasis>${this.getPath()}</emphasis>`;
      }

      if (fromSource) {
        if (originalValue !== value) {
          msg += '. This value has been modified from the original source.';
        }
      } else {
        let consumer = this;
        do {
          if (consumer.fromSource) {
            ({start: start, end: end} = consumer.context);
            break;
          }
          consumer = consumer.parent;
        } while (consumer !== undefined);

        if (consumer === undefined && filename === undefined) {
          throw new Error(msg);
        }

        msg += `. This value was not found in the original source.`;
      }

      let locMsg = `(${start.line}: ${start.column})`;
      if (filename !== undefined) {
        locMsg = `at ${filename} ${locMsg}`;
      }

      const errMsg = `Error occured while consuming JSON ${locMsg}: ${msg}`;

      throw new ___$romejs$diagnostics$src$errors_ts$DiagnosticError(errMsg, {
        category: 'json',
        language: 'json',
        filename: filename,
        message: msg,
        start: start,
        end: end});
    }

    fork(key, value) {
      return new ___$romejs$codec_json$src$Consumer_ts$default({
        filename: this.filename,
        context: this.context.children.get(key),
        value: value,
        parent: this,
        key: key});
    }

    _normalizeValueForSet(value) {
      if (value instanceof Set) {
        return Array.from(value);
      }

      if (value instanceof Map) {
        const obj = {};
        for (const [key, val] of value) {
          obj[key] = val;
        }
        return obj;
      }

      return value;
    }

    getValue(def) {
      if (this.exists()) {
        return this.value;
      } else {
        return def;
      }
    }

    setValue(rawValue) {
      const value = this._normalizeValueForSet(rawValue);
      this.value = value;

      const {parent: parent, key: key} = this;
      if (parent === undefined || key === undefined) {
        return this;
      }

      const parentValue = parent.asMixed();
      if (parentValue === undefined || typeof parentValue !== 'object') {
        throw parent.unexpected('Attempted to set a property on a non-object');
      }

      const parentObj = parent.asUnknownObject();
      parentObj[String(key)] = value;
      parent.setValue(parentObj);

      return this;
    }

    renameProperty(before, after) {
      const object = this.asUnknownObject();

      const value = object[before];
      object[before] = undefined;
      object[after] = value;

      const {children: children} = this.context;
      const beforeContext = children.get(before);
      children.delete(before);
      children.delete(after);
      if (beforeContext !== undefined) {
        children.set(after, beforeContext);
      }

      this.setValue(object);

      return this;
    }

    hasProperty(key) {
      return this.getProperty(key).asMixed() !== undefined;
    }

    setProperty(key, value) {
      return this.getProperty(key).setValue(value);
    }

    getProperty(key) {
      const value = this.asUnknownObject();
      return this.fork(key, value[key]);
    }

    spliceArray(index, deleteCount, ...items) {
      const {children: children} = this.context;
      const arr = this.asPlainArray();

      for (let i = 0; i < deleteCount; i++) {
        children.delete(index + i);
      }

      arr.splice(index, deleteCount, ...items);

      for (let i = arr.length - 1; i >= index + deleteCount; i--) {
        const context = children.get(i);
        if (context !== undefined) {
          children.set(i - deleteCount + items.length, context);
          children.delete(i);
        }
      }

      this.setValue(arr);

      return this;
    }

    pushArray(item) {
      this.concatArray([item]);
      return this;
    }

    concatArray(items) {
      const arr = this.asPlainArray();
      this.setValue(arr.concat(items));
      return this;
    }

    exists() {
      return this.value !== undefined;
    }

    mergeObjects(...consumers) {
      const newValue = Object.assign({}, this.asUnknownObject());

      const newContext = Object.assign({}, this.context);

      let hadConsumers = false;
      for (const consumer of consumers) {
        if (consumer === undefined) {
          continue;
        }
        hadConsumers = true;

        const obj = consumer.asUnknownObject();
        Object.assign(newValue, obj);

        for (const [key, entry] of consumer.context.children) {
          newContext.children.set(key, entry);
        }
      }

      if (!hadConsumers) {
        return this;
      }

      return new ___$romejs$codec_json$src$Consumer_ts$default({
        filename: this.filename,
        context: newContext,
        value: newValue,
        parent: this.parent,
        key: this.key});
    }

    asUnknownObject(optional) {
      if (optional === true && !this.exists()) {
        return {};
      }

      const {value: value} = this;
      if (value == null || typeof value !== 'object') {
        throw this.unexpected('Expected object');
      }

      return Object.assign({}, value);
    }

    asMap(optional) {
      const value = this.asUnknownObject(optional);
      const map = new ___$romejs$codec_json$src$Consumer_ts$ConsumerMap();
      for (const key in value) {
        map.set(key, this.fork(key, value[key]));
      }
      return map;
    }

    asSet(optional) {
      const arr = this.asArray(optional);
      const setVals = new Set();
      const set = new Set();

      for (let i = 0; i < arr.length; i++) {
        const consumer = arr[i];
        const value = consumer.asMixed();
        if (setVals.has(value)) {
          continue;
        }

        setVals.add(value);
        set.add(consumer);
      }

      return set;
    }

    asPlainArray(optional) {
      if (optional === true && !this.exists()) {
        return [];
      }

      const {value: value} = this;

      if (!Array.isArray(value)) {
        throw this.unexpected('Expected array');
      }

      return [...value];
    }

    asArray(optional) {
      const arr = this.asPlainArray(optional);

      return arr.map((val, index) => {
        return this.fork(index, val);
      });
    }

    asDateOrVoid(def) {
      if (this.exists()) {
        return this.asDate(def);
      } else {
        return undefined;
      }
    }

    asDate(def) {
      const value = this.getValue(def);
      if (!(value instanceof Date)) {
        throw this.unexpected('Expected a date');
      }
      return value;
    }

    asBooleanOrVoid(def) {
      if (this.exists()) {
        return this.asBoolean(def);
      } else {
        return undefined;
      }
    }

    asBoolean(def) {
      const value = this.getValue(def);
      if (typeof value !== 'boolean') {
        throw this.unexpected('Expected a boolean');
      }
      return value;
    }

    asStringOrVoid(def) {
      if (this.exists()) {
        return this.asString(def);
      } else {
        return undefined;
      }
    }

    asString(def) {
      const value = this.getValue(def);
      if (typeof value !== 'string') {
        throw this.unexpected('Expected a string');
      }
      return value;
    }

    asBigIntOrVoid(def) {
      if (this.exists()) {
        return this.asBigInt(def);
      } else {
        return undefined;
      }
    }

    asBigInt(def) {
      const value = this.getValue(def);

      if (typeof value === 'number') {
        return BigInt(value);
      }

      if (typeof value === 'bigint') {
        return value;
      }

      throw this.unexpected('Expected a bigint');
    }

    asNumberOrVoid(def) {
      if (this.exists()) {
        return this.asNumber(def);
      } else {
        return undefined;
      }
    }

    asNumber(def) {
      const value = this.getValue(def);
      if (typeof value !== 'number') {
        throw this.unexpected('Expected a number');
      }
      return value;
    }

    asNull() {
      const {value: value} = this;
      if (value === null) {
        return value;
      } else {
        throw this.unexpected('Expected null');
      }
    }

    asMixed() {
      return this.value;
    }

    asAny() {
      return this.value;
    }

    stringify() {
      const val = ___$romejs$codec_json$src$stringify_ts$stringifyConsumer(this, {
        isTopLevel: true,
        level: 0,
        stack: new Set()});

      const {outer: comments} = this.getComments();
      if (comments.length > 0) {
        return ___$romejs$codec_json$src$stringify_ts$stringifyComments('', comments).join('\n') + '\n' + val;
      }

      return val;
    }
  }

  // romejs/codec-json/src/index.ts

  function ___$romejs$codec_json$src$index_ts$consumeMixed(value) {
    return new ___$romejs$codec_json$src$Consumer_ts$default({
      filename: undefined,
      context: undefined,
      key: undefined,
      value: value,
      parent: undefined});
  }

  function ___$romejs$codec_json$src$index_ts$consumeJSON(opts) {
    const parser = new ___$romejs$codec_json$src$Parser_ts$default(opts);
    const {value: value, context: context} = parser.parse();

    return new ___$romejs$codec_json$src$Consumer_ts$default({
      filename: parser.filename,
      context: context,
      key: undefined,
      value: value,
      parent: undefined});
  }

  function ___$romejs$codec_json$src$index_ts$stringifyJSON(value) {
    const consumer = new ___$romejs$codec_json$src$Consumer_ts$default({
      filename: undefined,
      context: undefined,
      key: undefined,
      value: value,
      parent: undefined});
    return consumer.stringify();
  }

  function ___$romejs$codec_json$src$index_ts$parseJSON(opts) {
    const parser = new ___$romejs$codec_json$src$Parser_ts$default(opts);
    return parser.parse().value;
  }

  // romejs/codec-tar/src/index.ts

  const ___$$priv$romejs$codec_tar$src$index_ts$stream = require('stream');
  const ___$$priv$romejs$codec_tar$src$index_ts$END_OF_TAR = Buffer.alloc(1024);
  const ___$$priv$romejs$codec_tar$src$index_ts$ZEROS = '0000000000000000000';
  const ___$$priv$romejs$codec_tar$src$index_ts$SEVENS = '7777777777777777777';
  const ___$$priv$romejs$codec_tar$src$index_ts$ZERO_OFFSET = '0'.charCodeAt(0);
  const ___$$priv$romejs$codec_tar$src$index_ts$USTAR = 'ustar\x0000';
  const ___$$priv$romejs$codec_tar$src$index_ts$MASK = 4095;
  const ___$$priv$romejs$codec_tar$src$index_ts$DMODE = 493;
  const ___$$priv$romejs$codec_tar$src$index_ts$FMODE = 420;

  function ___$$priv$romejs$codec_tar$src$index_ts$encodeOct(num, n) {
    const oct = num.toString(8);
    if (oct.length > n) {
      return ___$$priv$romejs$codec_tar$src$index_ts$SEVENS.slice(0, n) + ' ';
    } else {
      return ___$$priv$romejs$codec_tar$src$index_ts$ZEROS.slice(0, n - oct.length) + oct + ' ';
    }
  }

  function ___$$priv$romejs$codec_tar$src$index_ts$checksum(block) {
    let sum = 8 * 32;
    for (let i = 0; i < 148; i++) {
      sum += block[i];
    }
    for (let j = 156; j < 512; j++) {
      sum += block[j];
    }
    return sum;
  }

  function ___$$priv$romejs$codec_tar$src$index_ts$toTypeflag(type) {
    switch (type) {
      case 'file':
        return 0;
      case 'link':
        return 1;
      case 'symlink':
        return 2;
      case 'character-device':
        return 3;
      case 'block-device':
        return 4;
      case 'directory':
        return 5;
      case 'fifo':
        return 6;
      case 'contiguous-file':
        return 7;}

    return 0;
  }

  function ___$$priv$romejs$codec_tar$src$index_ts$encodeHeader(header) {
    const buf = Buffer.alloc(512);

    let name = header.name;
    let prefix = '';

    if (Buffer.byteLength(name) !== name.length) {
      throw new Error('utf-8 filename is only supported in PAX, we only support USTAR');
    }

    while (Buffer.byteLength(name) > 100) {
      const i = name.indexOf('/');
      if (i === -1) {
        throw new Error('filename is too long for USTAR and it was in no directory');
      }

      prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i);
      name = name.slice(i + 1);
    }

    if (Buffer.byteLength(name) > 100) {
      throw new Error('filename is too long for USTAR');
    }

    if (Buffer.byteLength(prefix) > 155) {
      throw new Error('prefix is too long for USTAR');
    }

    if (header.linkname !== undefined &&
    Buffer.byteLength(header.linkname) > 100) {
      throw new Error('linkname is too long for USTAR');
    }

    buf.write(name);
    buf.write(___$$priv$romejs$codec_tar$src$index_ts$encodeOct(header.mode & ___$$priv$romejs$codec_tar$src$index_ts$MASK, 6), 100);
    buf.write(___$$priv$romejs$codec_tar$src$index_ts$encodeOct(header.uid, 6), 108);
    buf.write(___$$priv$romejs$codec_tar$src$index_ts$encodeOct(header.gid, 6), 116);
    buf.write(___$$priv$romejs$codec_tar$src$index_ts$encodeOct(header.size, 11), 124);
    buf.write(___$$priv$romejs$codec_tar$src$index_ts$encodeOct(header.mtime.getTime() / 1000 | 0, 11), 136);

    buf[156] = ___$$priv$romejs$codec_tar$src$index_ts$ZERO_OFFSET + ___$$priv$romejs$codec_tar$src$index_ts$toTypeflag(header.type);

    if (header.linkname !== undefined) {
      buf.write(header.linkname, 157);
    }

    buf.write(___$$priv$romejs$codec_tar$src$index_ts$USTAR, 257);
    if (header.uname !== undefined) {
      buf.write(header.uname, 265);
    }
    if (header.gname !== undefined) {
      buf.write(header.gname, 297);
    }
    buf.write(___$$priv$romejs$codec_tar$src$index_ts$encodeOct(header.devmajor || 0, 6), 329);
    buf.write(___$$priv$romejs$codec_tar$src$index_ts$encodeOct(header.devminor || 0, 6), 337);

    if (prefix !== '') {
      buf.write(prefix, 345);
    }

    buf.write(___$$priv$romejs$codec_tar$src$index_ts$encodeOct(___$$priv$romejs$codec_tar$src$index_ts$checksum(buf), 6), 148);

    return buf;
  }

  class ___$romejs$codec_tar$src$index_ts$TarWriter {
    constructor(stream) {
      this.finalized = false;
      this.stream = stream;
    }

    static normalizeHeader(partial, size) {
      let mode = partial.mode;
      if (mode === undefined) {
        if (partial.type === 'directory') {
          mode = ___$$priv$romejs$codec_tar$src$index_ts$DMODE;
        } else {
          mode = ___$$priv$romejs$codec_tar$src$index_ts$FMODE;
        }
      }

      return {
        name: partial.name,
        size: size,
        mode: mode,
        mtime: partial.mtime === undefined ? new Date() : partial.mtime,
        type: partial.type === undefined ? 'file' : partial.type,
        linkname: partial.linkname,
        uid: partial.uid === undefined ? 0 : partial.uid,
        gid: partial.gid === undefined ? 0 : partial.gid,
        uname: partial.uname,
        gname: partial.gname,
        devmajor: partial.devmajor === undefined ? 0 : partial.devmajor,
        devminor: partial.devminor === undefined ? 0 : partial.devminor};
    }

    overflow(size) {
      size &= 511;
      if (size > 0) {
        this.stream.write(___$$priv$romejs$codec_tar$src$index_ts$END_OF_TAR.slice(0, 512 - size));
      }
    }

    append(rawHeader, rawBuffer) {
      if (this.finalized) {
        throw new Error('Already finalized file');
      }

      const buffer = rawBuffer instanceof Buffer ? rawBuffer : Buffer.from(rawBuffer);
      const header = ___$romejs$codec_tar$src$index_ts$TarWriter.normalizeHeader(rawHeader, buffer.length);

      this.stream.write(___$$priv$romejs$codec_tar$src$index_ts$encodeHeader(header));
      this.stream.write(buffer);
      this.overflow(header.size);
    }

    finalize() {
      this.finalized = true;

      return new Promise((resolve, reject) => {
        const {stream: stream} = this;

        stream.on('close', () => {
          resolve();
        });

        stream.on('error', err => {
          reject(err);
        });

        stream.write(___$$priv$romejs$codec_tar$src$index_ts$END_OF_TAR);
        stream.end();
      });
    }
  }

  // romejs/events/src/Event.ts

  class ___$romejs$events$src$Event_ts$default {
    constructor(opts) {
      this.subscriptions = new Set();
      this.rootSubscription = undefined;
      this.name = opts.name;
      this.options = opts;
    }

    onSubscriptionChange() {}

    clear() {
      this.subscriptions.clear();
    }

    hasSubscribers() {
      return this.hasSubscriptions();
    }

    hasSubscriptions() {
      return this.rootSubscription !== undefined;
    }

    send(param) {
      const {rootSubscription: rootSubscription} = this;
      if (rootSubscription === undefined) {
        return undefined;
      }

      rootSubscription(param);

      for (const callback of this.subscriptions) {
        callback(param);
      }
    }

    async call(param) {
      const {rootSubscription: rootSubscription, subscriptions: subscriptions} = this;
      if (rootSubscription === undefined) {
        throw new Error(`No subscription for event ${this.name}`);
      }

      if (this.options.serial === true) {
        const ret = await rootSubscription(param);
        for (const callback of subscriptions) {
          await callback(param);
        }
        return ret;
      } else {
        const res = await Promise.all([rootSubscription(param), ...Array.from(subscriptions, callback => callback(param))]);

        return res[0];
      }
    }

    wait(val, timeout) {
      return new Promise((resolve, reject) => {
        let timeoutId;
        let timedOut = false;

        if (timeout !== undefined) {
          timeoutId = setTimeout(() => {
            timedOut = true;
            listener.unsubscribe();
            reject(new Error('Timed out'));
          }, timeout);
        }

        const listener = this.subscribe(param => {
          if (timedOut) {
            return val;
          }

          if (timeoutId !== undefined) {
            clearTimeout(timeoutId);
          }

          listener.unsubscribe();
          resolve(param);
          return val;
        });
      });
    }

    async callOptional(param) {
      if (this.rootSubscription === undefined) {
        return undefined;
      } else {
        return this.call(param);
      }
    }

    subscribe(callback, makeRoot) {
      if (this.options.unique === true && this.subscriptions.size !== 0) {
        throw new Error(`Event ${this.name} only allows a single subscription`);
      }

      if (this.rootSubscription === callback ||
      this.subscriptions.has(callback)) {
        throw new Error('Cannot double subscribe a callback');
      }

      if (this.rootSubscription === undefined) {
        this.rootSubscription = callback;
      } else if (makeRoot === true) {
        this.subscriptions.add(this.rootSubscription);
        this.rootSubscription = callback;
      } else {
        this.subscriptions.add(callback);
      }

      this.onSubscriptionChange();

      return {
        unsubscribe: () => {
          this.unsubscribe(callback);
        }};
    }

    unsubscribe(callback) {
      if (this.subscriptions.has(callback)) {
        this.subscriptions.delete(callback);
        this.onSubscriptionChange();
        return undefined;
      }

      if (callback === this.rootSubscription) {
        this.rootSubscription = Array.from(this.subscriptions)[0];
        this.onSubscriptionChange();
        return undefined;
      }

      throw new Error('Not a current subscription');
    }
  }

  // romejs/events/src/BridgeError.ts

  class ___$romejs$events$src$BridgeError_ts$default extends Error {
    constructor(message) {
      super(message);
    }
  }

  // romejs/events/src/BridgeEvent.ts

  class ___$romejs$events$src$BridgeEvent_ts$default extends ___$romejs$events$src$Event_ts$default {
    constructor(opts, bridge) {
      super(opts);

      this.bridge = bridge;
      this.requestCallbacks = new Map();
    }

    clear() {
      super.clear();
      this.requestCallbacks.clear();
    }

    end(err) {
      for (const {reject: reject} of this.requestCallbacks.values()) {
        reject(err);
      }
    }

    onSubscriptionChange() {
      this.bridge.sendSubscriptions();
    }

    dispatchRequest(param) {
      return super.call(param);
    }

    dispatchResponse(id, data) {
      const callbacks = this.requestCallbacks.get(id);
      if (!callbacks) {
        return undefined;
      }

      this.requestCallbacks.delete(id);

      if (data.responseStatus === 'success') {
        callbacks.resolve(data.value);
      } else if (data.responseStatus === 'error') {
        callbacks.reject(this.bridge.buildError(data.value, data.metadata));
      } else {}

      if (callbacks.completed !== undefined) {
        callbacks.completed();
      }
    }

    hasSubscribers() {
      return this.bridge.listeners.has(this.name);
    }

    send(param) {
      if (!this.hasSubscribers()) {
        return undefined;
      }

      this.bridge.assertAlive();
      this.bridge.sendMessage({
        type: 'request',
        event: this.name,
        param: param});
    }

    async call(param, timeout) {
      return new Promise((resolve, reject) => {
        this.bridge.assertAlive();

        const id = this.bridge.getNextMessageId();

        let completed;
        if (timeout !== undefined) {
          const timeoutId = setTimeout(() => {
            this.requestCallbacks.delete(id);

            reject(
            new ___$romejs$events$src$BridgeError_ts$default(`Timeout of ${String(timeout)}ms for ${this.name}(${String(
            JSON.stringify(param))}) event exceeded`));
          }, timeout);

          completed = () => {
            clearTimeout(timeoutId);
          };
        }

        this.requestCallbacks.set(id, {
          completed: completed,
          reject: reject,
          resolve: resolve});

        this.bridge.sendMessage({
          id: id,
          event: this.name,
          param: param,
          type: 'request'});
      });
    }
  }

  // romejs/events/src/Bridge.ts

  class ___$$priv$romejs$events$src$Bridge_ts$RPCError extends Error {
    constructor(opts) {
      super(opts.message);

      this.stack = opts.stack;
      this.name = opts.name;
      this.__ROME_ERROR_ADVICE__ = opts.__ROME_ERROR_ADVICE__;
      this.__ROME_POP_FRAMES__ = opts.__ROME_POP_FRAMES__;
      this.__ROME_ERROR_FRAMES__ = opts.__ROME_ERROR_FRAMES__;
    }
  }

  class ___$romejs$events$src$Bridge_ts$default {
    constructor(opts) {
      this.errorTransports = new Map();

      this.alive = true;
      this.opts = opts;

      this.messageIdCounter = 0;
      this.events = new Map();

      this.hasHandshook = false;
      this.handshakeEvent = new ___$romejs$events$src$Event_ts$default({name: 'Bridge.handshake'});
      this.endEvent = new ___$romejs$events$src$Event_ts$default({name: 'Bridge.end'});

      this.listeners = new Set();

      this.heartbeatEvent = this.createEvent({name: 'Bridge.heartbeat'});
      this.heartbeatEvent.subscribe(() => {
        return undefined;
      });

      this.clear();
      this.init();
    }

    monitorHeartbeat(timeout, onExceeded) {
      this.heartbeatTimeout = setTimeout(async () => {
        try {
          await this.heartbeatEvent.call(undefined, timeout);
          this.monitorHeartbeat(timeout, onExceeded);
        } catch (err) {
          if (err instanceof ___$romejs$events$src$BridgeError_ts$default) {
            if (this.alive) {
              onExceeded();
            }
          } else {
            throw err;
          }
        }
      }, 1000);
    }

    async handshake(timeout) {
      if (this.hasHandshook) {
        throw new Error('Already performed handshake');
      }

      this.sendMessage({type: 'handshake', first: true});

      const res = await this.handshakeEvent.wait(undefined, timeout);

      if (res.first) {
        this.sendMessage({type: 'handshake', first: false});
      }

      this.hasHandshook = true;
      this.sendSubscriptions();
    }

    sendSubscriptions() {
      if (!this.hasHandshook) {
        return undefined;
      }

      const names = [];
      for (const event of this.events.values()) {
        if (event.hasSubscriptions()) {
          names.push(event.name);
        }
      }
      this.sendMessage({
        type: 'subscriptions',
        names: names});
    }

    receivedSubscriptions(names) {
      this.listeners = new Set(names);
    }

    init() {}

    clear() {
      for (const [, event] of this.events) {
        event.clear();
      }
    }

    getNextMessageId() {
      return ++this.messageIdCounter;
    }

    createEvent(opts) {
      if (this.events.has(opts.name)) {
        throw new Error('Duplicate event');
      }

      const event = new ___$romejs$events$src$BridgeEvent_ts$default(opts, this);
      this.events.set(opts.name, event);
      return event;
    }

    assertAlive() {
      if (this.alive === false) {
        throw new Error('Bridge is dead');
      }
    }

    endWithError(err) {
      if (this.alive === false) {
        return undefined;
      }

      this.alive = false;

      for (const [, event] of this.events) {
        event.end(err);
      }
      this.clear();

      if (this.heartbeatTimeout !== undefined) {
        clearTimeout(this.heartbeatTimeout);
      }

      this.endEvent.send(err);
    }

    end(message = 'Connection died') {
      this.endWithError(new ___$romejs$events$src$BridgeError_ts$default(message));
    }

    buildError(value, data) {
      const transport = this.errorTransports.get(value.name);
      if (transport === undefined) {
        return new ___$$priv$romejs$events$src$Bridge_ts$RPCError(value);
      } else {
        return transport.hydrate(value, data);
      }
    }

    buildErrorResponse(id, event, errRaw) {
      const err = errRaw instanceof Error ? errRaw : new Error(String(errRaw));

      const tranport = this.errorTransports.get(err.name);
      const metadata = tranport === undefined ? {} : tranport.serialize(err);

      const v8Err = ___$romejs$v8$src$index_ts$errors.toV8Error(err);
      return {
        id: id,
        event: event,
        type: 'response',
        responseStatus: 'error',
        value: {
          name: err.name,
          message: err.message,
          stack: err.stack,
          __ROME_ERROR_FRAMES__: v8Err.__ROME_ERROR_FRAMES__,
          __ROME_ERROR_ADVICE__: v8Err.__ROME_ERROR_ADVICE__,
          __ROME_POP_FRAMES__: v8Err.__ROME_POP_FRAMES__},
        metadata: metadata};
    }

    addErrorTransport(name, transport) {
      this.errorTransports.set(name, transport);
    }

    sendMessage(msg) {
      if (msg.type !== 'handshake' && !this.hasHandshook) {
        throw new Error(`Can't send a message before the handshake has been completed`);
      }

      this.assertAlive();

      const {opts: opts} = this;
      opts.sendMessage(msg);
      if (opts.onSendMessage !== undefined) {
        opts.onSendMessage(msg);
      }
    }

    handleJSONMessage(str) {
      try {
        const data = JSON.parse(str);
        this.handleMessage(data);
      } catch (err) {
        if (err instanceof SyntaxError) {
          this.endWithError(
          new ___$romejs$events$src$BridgeError_ts$default(`Error parsing message JSON: ${err.message}`));
        } else {
          this.endWithError(err);
        }
      }
    }

    handleMessage(msg) {
      try {
        this.assertAlive();

        if (msg.type === 'handshake') {
          this.handshakeEvent.send({first: msg.first});
        }

        if (msg.type === 'subscriptions') {
          this.receivedSubscriptions(msg.names);
        }

        if (msg.type === 'request') {
          this.handleMessageRequest(msg);
        }

        if (msg.type === 'response') {
          this.handleMessageResponse(msg);
        }
      } catch (err) {
        this.endWithError(err);
      }
    }

    handleMessageResponse(data) {
      const {id: id, event: event} = data;
      if (id === undefined) {
        throw new Error('Expected id');
      }
      if (event === undefined) {
        throw new Error('Expected event');
      }

      const eventHandler = this.events.get(event);
      if (eventHandler === undefined) {
        throw new Error('Unknown event');
      }

      eventHandler.dispatchResponse(id, data);
    }

    handleMessageRequest(data) {
      const {id: id, event: event, param: param} = data;
      if (event === undefined) {
        throw new Error('Expected event in message request but received none');
      }

      const eventHandler = this.events.get(event);
      if (eventHandler === undefined) {
        throw new Error(`Unknown event ${event}`);
      }

      if (id === undefined) {
        eventHandler.dispatchRequest(param);
      } else {
        eventHandler.dispatchRequest(param).then(value => {
          this.sendMessage({
            event: event,
            id: id,
            type: 'response',
            responseStatus: 'success',
            value: value});
        }).catch(err => {
          this.sendMessage(this.buildErrorResponse(id, event, err));
        }).catch(err => this.endWithError(err));
      }
    }
  }

  // romejs/events/src/bridgeCreators.ts

  const ___$romejs$events$src$bridgeCreators_ts = {
    createBridgeFromWebSocketInterface: ___$romejs$events$src$bridgeCreators_ts$createBridgeFromWebSocketInterface,
    createBridgeFromBrowserWebSocket: ___$romejs$events$src$bridgeCreators_ts$createBridgeFromBrowserWebSocket,
    createBridgeFromSocket: ___$romejs$events$src$bridgeCreators_ts$createBridgeFromSocket,
    createBridgeFromLocal: ___$romejs$events$src$bridgeCreators_ts$createBridgeFromLocal,
    createBridgeFromChildProcess: ___$romejs$events$src$bridgeCreators_ts$createBridgeFromChildProcess,
    createBridgeFromParentProcess: ___$romejs$events$src$bridgeCreators_ts$createBridgeFromParentProcess};
  const ___$$priv$romejs$events$src$bridgeCreators_ts$child = require('child_process');
  const ___$$priv$romejs$events$src$bridgeCreators_ts$net = require('net');
  const ___$$priv$romejs$events$src$bridgeCreators_ts$SOCKET_LENGTH = /^(\d+)\:/;

  function ___$romejs$events$src$bridgeCreators_ts$createBridgeFromWebSocketInterface(CustomBridge, inf, opts = {}) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: data => {
        inf.sendJSON(data);
      }}));

    const {socket: socket} = inf;

    bridge.endEvent.subscribe(() => {
      socket.end();
    });

    inf.messageEvent.subscribe(frame => {
      const json = frame.payload.toString();
      bridge.handleJSONMessage(json);
    });

    socket.on('error', err => {
      bridge.endWithError(err);
    });

    socket.on('end', () => {
      bridge.end('RPC WebSocket died');
    });

    return bridge;
  }

  function ___$romejs$events$src$bridgeCreators_ts$createBridgeFromBrowserWebSocket(CustomBridge, socket, opts = {}) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: data => {
        socket.send(JSON.stringify(data));
      }}));

    bridge.endEvent.subscribe(() => {
      socket.close();
    });

    socket.onmessage = function(event) {
      bridge.handleJSONMessage(String(event.data));
    };

    socket.onclose = () => {
      bridge.end('RPC WebSocket disconnected');
    };

    return bridge;
  }

  function ___$romejs$events$src$bridgeCreators_ts$createBridgeFromSocket(CustomBridge, socket, opts = {}) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: data => {
        const serialized = JSON.stringify(data);
        socket.write(`${serialized.length}:${serialized}`);
      }}));

    bridge.endEvent.subscribe(() => {
      socket.end();
    });

    let buff = '';
    let messageLength = 0;
    socket.setEncoding('utf8');
    function checkForPossibleMessage() {
      if (messageLength > 0 && buff.length >= messageLength) {
        const msg = buff.slice(0, messageLength);

        buff = buff.slice(messageLength);
        messageLength = 0;

        bridge.handleJSONMessage(msg);
      }

      if (messageLength === 0 && buff !== '') {
        const possibleLength = buff.match(___$$priv$romejs$events$src$bridgeCreators_ts$SOCKET_LENGTH);
        if (possibleLength != null) {
          messageLength = Number(possibleLength[1]);

          buff = buff.slice(possibleLength[0].length);

          checkForPossibleMessage();
        }
      }
    }

    socket.on('data', chunk => {
      buff += chunk;
      checkForPossibleMessage();
    });

    socket.on('error', err => {
      bridge.endWithError(err);
    });

    socket.on('end', () => {
      bridge.end('RPC socket disconnected');
    });

    return bridge;
  }

  function ___$romejs$events$src$bridgeCreators_ts$createBridgeFromLocal(CustomBridge, opts = {}) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: msg => {
        bridge.handleMessage(msg);
      }}));

    return bridge;
  }

  function ___$romejs$events$src$bridgeCreators_ts$createBridgeFromChildProcess(CustomBridge, proc, opts = {}) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: data => {
        proc.send(data);
      }}));

    bridge.endEvent.subscribe(() => {
      proc.kill();
    });

    proc.on('error', err => {
      bridge.endWithError(err);
    });

    proc.on('message', msg => {
      bridge.handleMessage(msg);
    });

    proc.on('close', () => {
      bridge.end('RPC child process died');
    });

    return bridge;
  }

  function ___$romejs$events$src$bridgeCreators_ts$createBridgeFromParentProcess(CustomBridge, opts = {}) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: data => {
        if (typeof process.send === 'function') {
          process.send(data);
        } else {
          throw new Error('No process.send found');
        }
      }}));

    process.on('message', data => {
      bridge.handleMessage(data);
    });

    process.on('exit', () => {
      bridge.end('RPC self process died');
    });

    return bridge;
  }

  // romejs/events/src/types.ts

  const ___$romejs$events$src$types_ts = {};

  // romejs/events/src/index.ts


  // romejs/core/src/commands.ts

  function ___$romejs$core$src$commands_ts$createMasterCommand(cmd) {
    return cmd;
  }

  const ___$romejs$core$src$commands_ts$commandCategories = {
    PROCESS_MANAGEMENT: 'Process Management',
    CODE_QUALITY: 'Code Quality',
    SOURCE_CODE: 'Source Code',
    PROJECT_MANAGEMENT: 'Project Management',
    SOURCE_CONTROL: 'Source Control',
    INTERNAL: 'Internal'};

  // romejs/core/src/common/utils/executeMain.ts

  const ___$$priv$romejs$core$src$common$utils$executeMain_ts$internalModule = require('module');
  const ___$$priv$romejs$core$src$common$utils$executeMain_ts$path = require('path');
  const ___$$priv$romejs$core$src$common$utils$executeMain_ts$vm = require('vm');
  async function ___$romejs$core$src$common$utils$executeMain_ts$default(opts) {
    const {filename: filename, code: code, sourceMap: sourceMap, globals: globals} = opts;

    const sandbox = Object.assign({}, globals, {
      process: {
        argv: [process.argv[0], filename],
        __proto__: process},

      Buffer: Buffer,
      clearImmediate: clearImmediate,
      clearInterval: clearInterval,
      clearTimeout: clearTimeout,
      setImmediate: setImmediate,
      setInterval: setInterval,
      setTimeout: setTimeout,
      require: ___$$priv$romejs$core$src$common$utils$executeMain_ts$internalModule.createRequireFromPath(filename),
      console: console,
      __dirname: ___$$priv$romejs$core$src$common$utils$executeMain_ts$path.dirname(filename),
      __filename: filename});
    sandbox.global = sandbox;
    const context = ___$$priv$romejs$core$src$common$utils$executeMain_ts$vm.createContext(sandbox);

    let script = undefined;
    let syntaxError = undefined;
    try {
      script = new ___$$priv$romejs$core$src$common$utils$executeMain_ts$vm.Script(code, {
        filename: filename});
    } catch (err) {
      if (err instanceof SyntaxError) {
        syntaxError = err;
      } else {
        throw err;
      }
    }

    if (script !== undefined) {
      ___$romejs$v8$src$index_ts$sourceMapManager.addSourceMap(filename, sourceMap);
      await script.runInContext(context);
    }

    return {syntaxError: syntaxError};
  }

  // romejs/core/src/api/commands.ts

  const ___$romejs$core$src$api$commands_ts$localCommands = new Map();

  ___$romejs$core$src$api$commands_ts$localCommands.set('start', {
    category: ___$romejs$core$src$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'start daemon (if none running)',
    async run(req) {
      const existingServer = await req.api.tryConnectToExistingDaemon();
      if (existingServer) {
        req.api.reporter.success('Already running server.');
        return true;
      }

      const bridge = await req.api.startDaemon();
      return bridge !== undefined;
    }});

  ___$romejs$core$src$api$commands_ts$localCommands.set('stop', {
    category: ___$romejs$core$src$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'stop a running daemon if one exists',
    async run(req) {
      const {reporter: reporter} = req.api;
      const bridge = await req.api.tryConnectToExistingDaemon();
      if (bridge) {
        const {killed: killed} = await req.api.query({
          command: 'stop',
          type: 'master'});
        if (killed === true) {
          reporter.success('Stopped server.');
        } else {
          reporter.error('Failed to stop server.');
          return false;
        }
      } else {
        reporter.warn('No running server to stop.');
      }
      return true;
    }});

  ___$romejs$core$src$api$commands_ts$localCommands.set('run', {
    category: ___$romejs$core$src$commands_ts$commandCategories.PROJECT_MANAGEMENT,
    description: 'TODO',
    async run(req) {
      const bridge = await req.api.findOrStartMaster();
      if (bridge === undefined) {
        return false;
      }

      process.on('unhandledRejection', error => {
        error;
      });

      const res = await req.api.query({
        command: 'run',
        type: 'master',
        args: req.args});
      const data = ___$romejs$codec_json$src$index_ts$consumeMixed(res.data);

      if (data.exists()) {
        const type = data.getProperty('type').asString();

        switch (type) {
          case 'executeCode':
            process.execArgv = [...process.execArgv, process.argv[1], 'run'];
            process.argv = [process.argv[0], String(data.filename), ...process.argv.slice(4)];
            const {syntaxError: syntaxError} = await ___$romejs$core$src$common$utils$executeMain_ts$default({
              filename: data.getProperty('filename').asString(),
              code: data.getProperty('code').asString(),
              sourceMap: data.getProperty('map').asAny()});
            if (syntaxError !== undefined) {
              throw syntaxError;
            }
            await new Promise(() => {});
            break;}
      }
      return data !== undefined;
    }});

  ___$romejs$core$src$api$commands_ts$localCommands.set('restart', {
    category: ___$romejs$core$src$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'restart daemon',
    async run(req) {
      const stopped = await req.api.query({
        command: 'stop'});

      if (stopped.data === true) {
        const started = await req.api.query({
          command: 'start'});
        return started.data === true;
      } else {
        return false;
      }
    }});

  ___$romejs$core$src$api$commands_ts$localCommands.set('status', {
    description: 'get the current daemon status',
    category: ___$romejs$core$src$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    async run(req) {
      const {reporter: reporter} = req.api;
      const bridge = await req.api.tryConnectToExistingDaemon();
      if (bridge) {
        const {data: data} = await req.api.query({
          type: 'master',
          command: 'status'});
        if (data !== undefined) {
          reporter.inspect(data);
        }
        return data !== undefined;
      } else {
        reporter.error('Server not running.');
        return false;
      }
    }});

  // romejs/core/src/api/APIRequest.ts

  const ___$$priv$romejs$core$src$api$APIRequest_ts$zlib = require('zlib');
  const ___$$priv$romejs$core$src$api$APIRequest_ts$path = require('path');
  const ___$$priv$romejs$core$src$api$APIRequest_ts$util = require('util');
  const ___$$priv$romejs$core$src$api$APIRequest_ts$fs = require('fs');
  const ___$$priv$romejs$core$src$api$APIRequest_ts$os = require('os');
  const ___$$priv$romejs$core$src$api$APIRequest_ts$writeFile = ___$$priv$romejs$core$src$api$APIRequest_ts$util.promisify(___$$priv$romejs$core$src$api$APIRequest_ts$fs.writeFile);

  function ___$$priv$romejs$core$src$api$APIRequest_ts$getTimestamp() {
    return new Date().toISOString().replace(/[^0-9a-zA-Z]/g, '');
  }

  class ___$romejs$core$src$api$APIRequest_ts$default {
    constructor(api, opts) {
      this.api = api;
      this.reporter = api.reporter;
      this.command = opts.command;
      this.commandFlags =
      opts.commandFlags === undefined ? {} : opts.commandFlags;
      this.flags = Object.assign({}, api.flags, opts.flags);
      this.args = opts.args === undefined ? [] : opts.args;
      this.type = opts.type === undefined ? 'local' : opts.type;
      this.noData = opts.noData === undefined ? false : opts.noData;
    }

    async init() {
      try {
        if (this.flags.rage) {
          return await this.initWithRage();
        } else if (this.flags.profile) {
          return await this.initWithCPUProfile(false);
        } else {
          return await this.initCommand();
        }
      } catch (err) {
        return {
          error: {
            handled: false,
            name: err.name,
            message: err.message,
            stack: err.stack}};
      }
    }

    async initCommand() {
      const localCommand = ___$romejs$core$src$api$commands_ts$localCommands.get(this.command);

      if (this.type === 'master' || localCommand === undefined) {
        return this.initFromMaster();
      } else {
        return this.initFromLocal(localCommand);
      }
    }

    async initWithRage() {
      const timestamp = ___$$priv$romejs$core$src$api$APIRequest_ts$getTimestamp();
      const tmpdir = ___$$priv$romejs$core$src$api$APIRequest_ts$os.tmpdir();
      const profilePath = ___$$priv$romejs$core$src$api$APIRequest_ts$path.join(tmpdir, `RomeRageProfile-${timestamp}.json`);
      const logPath = ___$$priv$romejs$core$src$api$APIRequest_ts$path.join(tmpdir, `RomeRageLog-${timestamp}.txt`);

      this.flags = Object.assign({}, this.flags, {
        profilePath: profilePath,
        logPath: logPath,
        logWorkers: true});

      let out = '';

      try {
        return await this.initWithCPUProfile(true);
      } finally {
        const {ragePath: ragePath, cwd: cwd} = this.flags;
        const filename = ___$$priv$romejs$core$src$api$APIRequest_ts$path.resolve(
        cwd,
        ragePath === '' ? `rome-rage-${___$$priv$romejs$core$src$api$APIRequest_ts$getTimestamp()}.tar.gz` : ragePath);
        const stream = ___$$priv$romejs$core$src$api$APIRequest_ts$zlib.createGzip();
        stream.pipe(___$$priv$romejs$core$src$api$APIRequest_ts$fs.createWriteStream(filename));

        const writer = new ___$romejs$codec_tar$src$index_ts$TarWriter(stream);

        writer.append({name: 'out-raw.txt'}, out);
        writer.append({name: 'out.txt'}, ___$romejs$string_ansi$src$format_ts$stripAnsi(out));

        const profile = await ___$$priv$romejs$core$src$api$APIRequest_ts$fs.promises.readFile(profilePath);
        writer.append({name: 'profile.json'}, profile);

        const log = await ___$$priv$romejs$core$src$api$APIRequest_ts$fs.promises.readFile(logPath);
        writer.append({name: 'log.txt'}, log);

        function indent(val) {
          const str = typeof val === 'string' ? val : ___$romejs$pretty_format$src$index_ts$default(val, {compact: true});
          const lines = str.trim().split('\n');
          const indented = lines.join('\n  ');
          return '\n  ' + indented;
        }
        const env = [];
        env.push(`Command: ${indent(this.command)}`);
        env.push(`Command Flags: ${indent(this.commandFlags)}`);
        env.push(`Flags: ${indent(this.flags)}`);
        env.push(`Args: ${indent(this.args)}`);
        env.push(`PATH: ${indent(process.env.PATH)}`);
        env.push(`Rome version: ${indent(___$romejs$core$src$common$constants_ts$VERSION)}`);
        env.push(`Node version: ${indent(process.versions.node)}`);
        env.push(`Platform: ${indent(process.platform + ' ' + process.arch)}`);
        writer.append({name: 'environment.txt'}, env.join('\n\n') + '\n');

        const bridgeStatus = this.api.getBridge();
        if (bridgeStatus !== undefined) {
          const status = await this.api.query({
            flags: {
              silent: true},
            command: 'status'});
          writer.append(
          {name: 'status.txt'},
          ___$romejs$pretty_format$src$index_ts$default(status.data, {compact: true}) + '\n');
        }

        await writer.finalize();
        this.reporter.success('Rage archive written to', filename);
      }
    }

    async initFromLocal(localCommand) {
      if (this.flags.silent !== true) {
        this.reporter.header(this.command);
      }

      const success = await localCommand.run(
      this,
      ___$romejs$codec_json$src$index_ts$consumeMixed(this.commandFlags));
      if (success) {
        if (this.flags.silent !== true) {
          this.reporter.footer();
        }
        return {};
      } else {
        return {
          error: {
            handled: true,
            name: 'Error',
            message: 'Command was not successful'}};
      }
    }

    async initFromMaster() {
      try {
        const bridge = await this.api.findOrStartMaster();

        const request = {
          args: this.args,
          flags: this.flags,
          commandFlags: this.commandFlags,
          hasClearScreen: this.reporter.hasClearScreen,
          columns: this.reporter.getColumns(),
          command: this.command,
          noData: this.noData};

        return await bridge.query.call(request);
      } catch (err) {
        if (err instanceof ___$romejs$events$src$BridgeError_ts$default) {
          return {
            killed: true,
            error: {
              handled: false,
              name: 'Error',
              message: 'Server died while processing command. Results may be incomplete.',
              stack: undefined}};
        } else {
          throw err;
        }
      }
    }

    async initWithCPUProfile(rage) {
      if (!rage) {
        this.reporter.info('Starting CPU profile...');
      }

      const bridge = await this.api.findOrStartMaster();
      await bridge.profilingStart.call();

      let cliProfiler;
      const bridgeStatus = this.api.getBridge();
      if (bridgeStatus === undefined || bridgeStatus.dedicated) {
        cliProfiler = new ___$romejs$v8$src$Profiler_ts$default();
        await cliProfiler.startProfiling();
      }

      const {profileTimeout: profileTimeout} = this.flags;

      let hasProfiled;
      let timeout;
      if (profileTimeout > 0) {
        timeout = setTimeout(() => {
          hasProfiled = stopProfile();
        }, profileTimeout);
      }

      const stopProfile = async () => {
        if (hasProfiled) {
          return hasProfiled;
        }

        if (timeout !== undefined) {
          clearTimeout(timeout);
        }

        this.reporter.info(
        rage ? 'Creating rage archive...' : 'Fetching profiles...');
        const trace = new ___$romejs$v8$src$Trace_ts$default();

        if (cliProfiler !== undefined) {
          const cliProfile = await cliProfiler.stopProfiling();
          trace.addProfile('CLI', cliProfile);
        }

        const {
          master: masterProfile,
          workers: workerProfiles} = await bridge.profilingStop.call();

        const masterProfileName = cliProfiler === undefined ? 'Master/CLI' : 'Master';
        trace.addProfile(masterProfileName, masterProfile);

        for (let i = 0; i < workerProfiles.length; i++) {
          trace.addProfile(`Worker ${String(i + 1)}`, workerProfiles[i]);
        }

        const {cwd: cwd, profilePath: profilePath} = this.flags;
        const filename = ___$$priv$romejs$core$src$api$APIRequest_ts$path.resolve(
        cwd,
        profilePath === '' ? `Profile-${___$$priv$romejs$core$src$api$APIRequest_ts$getTimestamp()}.json` : profilePath);

        const events = trace.build();
        await ___$$priv$romejs$core$src$api$APIRequest_ts$writeFile(filename, JSON.stringify(events, undefined, '  '));

        if (!rage) {
          this.reporter.success(`Wrote CPU profile to "${filename}"`);
        }
      };

      try {
        return await this.initCommand();
      } finally {
        await stopProfile();
      }
    }
  }

  // romejs/codec-semver/src/parse.ts

  class ___$$priv$romejs$codec_semver$src$parse_ts$Parser extends ___$romejs$parser_core$src$index_ts$ParserCore {
    constructor({loose: loose, ...opts}, mode) {
      super(opts, 'semver-parser');
      this.input = this.input.trimRight();
      this.mode = mode;
      this.loose = loose === undefined ? false : loose;
    }

    tokenize(index, input) {
      const char = input[index];
      const nextChar = input[index + 1];

      if (char === '<' && nextChar === '=' ||
      char === '>' && nextChar === '=' ||
      char === '~' && nextChar === '>') {
        const value = char + nextChar;
        return this.finishValueToken(
        'Operator',
        value,
        index + 2);
      }

      if (char === '^' ||
      char === '<' ||
      char === '>' ||
      char === '~' ||
      char === '=') {
        return this.finishValueToken('Operator', char);
      }

      if (char === '|' && nextChar === '|') {
        return this.finishToken('Pipe', index + 2);
      }

      if (char === '*') {
        return this.finishToken('Star');
      }

      if (input[index - 1] === ' ' && char === '-' && nextChar === ' ') {
        return this.finishToken('RangeDash');
      }

      if (char === '-') {
        return this.finishToken('Dash');
      }

      if (char === '+') {
        return this.finishToken('Plus');
      }

      if (char === '.') {
        return this.finishToken('Dot');
      }

      if (___$romejs$parser_core$src$index_ts$isDigit(char)) {
        const value = this.readInputFrom(index, ___$romejs$parser_core$src$index_ts$isDigit);
        return this.finishValueToken(
        'Number',
        Number(value),
        index + value.length);
      }

      if (___$romejs$parser_core$src$index_ts$isAlpha(char)) {
        const value = this.readInputFrom(index, ___$romejs$parser_core$src$index_ts$isAlpha);
        return this.finishValueToken(
        'Word',
        value,
        index + value.length);
      }

      if (char === ' ' || char === '\t') {
        return this.finishToken('Space');
      }

      return undefined;
    }

    eatSpaceToken() {
      while (this.eatToken('Space') !== undefined);
    }

    parseVersionOrWildcard() {
      const startPos = this.getPosition();
      const startToken = this.getToken();
      const version = this.parseVersion();

      if (this.isWildcardToken(startToken) &&
      version.minor === undefined &&
      version.patch === undefined &&
      version.prerelease.length === 0 &&
      version.build.length === 0) {
        return {
          type: 'Wildcard',
          loc: this.finishLoc(startPos)};
      }

      return version;
    }

    parseVersion() {
      const startPos = this.getPosition();
      const startToken = this.getToken();

      if (this.isVersionCharacter(startToken)) {
        this.nextToken();
      }

      const major = this.parseVersionNumber();
      let minor = undefined;
      let patch = undefined;

      if (this.eatToken('Dot')) {
        minor = this.parseVersionNumber();
      } else if (this.mode === 'version') {
        throw this.unexpected({
          message: 'A minor number is required for a version'});
      }

      if (this.eatToken('Dot')) {
        patch = this.parseVersionNumber();
      } else if (this.mode === 'version') {
        throw this.unexpected({
          message: 'A patch number is required for a version'});
      }

      if (this.matchToken('Dot')) {
        throw this.unexpected({message: 'Too many parts for version'});
      }

      let prerelease = [];
      if (this.eatToken('Dash') || this.loose && this.matchToken('Word')) {
        prerelease = this.parseVersionQualifierParts();
      }

      let build = [];
      if (this.eatToken('Plus')) {
        build = this.parseVersionQualifierParts();
      }

      if (major !== undefined && minor !== undefined && patch !== undefined) {
        return {
          type: 'AbsoluteVersion',
          loc: this.finishLoc(startPos),
          major: major,
          minor: minor,
          patch: patch,
          prerelease: prerelease,
          build: build};
      } else {
        return {
          type: 'WildcardVersion',
          loc: this.finishLoc(startPos),
          major: major,
          minor: minor,
          patch: patch,
          prerelease: prerelease,
          build: build};
      }
    }

    parseVersionQualifierParts() {
      const parts = [];
      do {
        parts.push(this.parseVersionQualifierPart());
      } while (this.eatToken('Dot') !== undefined);
      return parts;
    }

    parseVersionQualifierPart() {
      const parts = [];

      do {
        const token = this.getToken();

        if (token.type === 'Number' || token.type === 'Word') {
          this.nextToken();
          parts.push(token.value);
        } else if (token.type === 'Dash') {
          this.nextToken();
          parts.push('-');
        } else {
          throw this.unexpected({message: 'Invalid version qualifier part'});
        }
      } while (this.matchToken('Number') ||
      this.matchToken('Word') ||
      this.matchToken('Dash'));

      if (parts.length === 1 && typeof parts[0] === 'number') {
        return parts[0];
      } else {
        return parts.join('');
      }
    }

    isWildcardToken(token) {
      if (token.type === 'Star') {
        return true;
      }

      if (token.type === 'Word') {
        return token.value === 'x' || token.value === 'X';
      }

      return false;
    }

    parseVersionNumber() {
      const token = this.getToken();

      if (token.type === 'Number') {
        this.nextToken();
        return token.value;
      }

      if (this.isWildcardToken(token)) {
        if (this.mode === 'version') {
          throw this.unexpected({
            message: 'Wildcard aren\'t allowed in a hard version'});
        }

        this.nextToken();
      } else {
        throw this.unexpected({
          message: 'This isn\'t a valid version part, expected a number'});
      }

      return undefined;
    }

    parseLogicalOr(left) {
      this.nextToken();
      this.eatSpaceToken();

      const right = this.parseExpression();
      return {
        loc: this.finishLoc(this.getLoc(left).start),
        type: 'LogicalOr',
        left: left,
        right: right};
    }

    validateRangeSide(node) {
      if (node.type === 'WildcardVersion' || node.type === 'AbsoluteVersion') {
        return node;
      }

      if (node.type === 'Wildcard' && this.loose) {
        return node;
      }

      throw this.unexpected({
        message: 'A semver range can only be defined with versions',
        start: this.getLoc(node).start});
    }

    parseVersionRange(left) {
      this.nextToken();
      this.eatSpaceToken();

      const right = this.parseVersionOrWildcard();

      return {
        type: 'VersionRange',
        loc: this.finishLoc(this.getLoc(left).start),
        left: this.validateRangeSide(left),
        right: this.validateRangeSide(right)};
    }

    parseWildcard() {
      const startPos = this.getPosition();
      this.nextToken();
      return {type: 'Wildcard', loc: this.finishLoc(startPos)};
    }

    parseAtomOperator(token) {
      const startPos = this.getPosition();
      this.nextToken();
      this.eatSpaceToken();

      const version = this.parseVersionOrWildcard();

      return {
        type: 'Comparator',
        loc: this.finishLoc(startPos),
        operator: token.value,
        version: version};
    }

    isVersionCharacter(token) {
      if (this.loose && token.type === 'Word') {
        return token.value === 'v';
      }

      return false;
    }

    parseAtomStartPipe() {
      if (this.loose) {
        return this.parseWildcard();
      } else {
        throw this.unexpected({
          message: 'Bare pipes are only allowed in loose mode'});
      }
    }

    parseAtomStartWord(token) {
      if (this.isWildcardToken(token)) {
        return this.parseWildcard();
      } else if (this.isVersionCharacter(token)) {
        return this.parseVersion();
      } else {
        throw this.unexpected({
          message: ___$romejs$string_markup$src$escape_ts$markup`Unexpected word <emphasis>${token.value}</emphasis>`});
      }
    }

    parseAtom() {
      const token = this.getToken();

      switch (token.type) {
        case 'Number':
          return this.parseVersion();

        case 'Operator':
          return this.parseAtomOperator(token);

        case 'Star':
          return this.parseWildcard();

        case 'Pipe':
          return this.parseAtomStartPipe();

        case 'Word':
          return this.parseAtomStartWord(token);

        default:
          throw this.unexpected({message: 'Unknown start of atom'});}
    }

    parseLogicalAnd(left) {
      const right = this.parseExpression();

      return {
        type: 'LogicalAnd',
        left: left,
        right: right,
        loc: {
          filename: this.filename,
          start: this.getLoc(left).start,
          end: this.getLoc(right).end}};
    }

    parseExpression() {
      const left = this.parseAtom();
      this.eatSpaceToken();

      if (this.matchToken('RangeDash')) {
        return this.parseVersionRange(left);
      }

      if (this.matchToken('Pipe')) {
        return this.parseLogicalOr(left);
      }

      if (!this.matchToken('EOF')) {
        return this.parseLogicalAnd(left);
      }

      return left;
    }

    parseInitialRange() {
      this.eatSpaceToken();

      if (this.matchToken('EOF') && this.loose) {
        return this.parseWildcard();
      }

      const expr = this.parseExpression();
      this.finalize();

      return expr;
    }

    parseInitialVersion() {
      const node = this.parseInitialRange();

      if (node.type !== 'AbsoluteVersion') {
        throw this.unexpected({
          message: 'Unexpected value for version',
          start: this.getLoc(node).start});
      }

      return node;
    }
  }

  function ___$romejs$codec_semver$src$parse_ts$parseRange(opts) {
    const parser = new ___$$priv$romejs$codec_semver$src$parse_ts$Parser(opts, 'range');
    return parser.parseInitialRange();
  }

  function ___$romejs$codec_semver$src$parse_ts$parseVersion(opts) {
    const parser = new ___$$priv$romejs$codec_semver$src$parse_ts$Parser(opts, 'version');
    return parser.parseInitialVersion();
  }

  // romejs/codec-semver/src/compare.ts

  function ___$$priv$romejs$codec_semver$src$compare_ts$compareIdentifiers(a, b) {
    if (b === undefined) {
      return 0;
    }

    if (typeof a === 'string' || typeof b === 'string') {
      return String(a).localeCompare(String(b));
    }

    if (a < b) {
      return -1;
    }

    if (a > b) {
      return 1;
    }

    return 0;
  }
  function ___$$priv$romejs$codec_semver$src$compare_ts$compareMain(version, range) {
    return ___$$priv$romejs$codec_semver$src$compare_ts$compareIdentifiers(version.major, range.major) ||
    ___$$priv$romejs$codec_semver$src$compare_ts$compareIdentifiers(version.minor, range.minor) ||
    ___$$priv$romejs$codec_semver$src$compare_ts$compareIdentifiers(version.patch, range.patch);
  }

  function ___$$priv$romejs$codec_semver$src$compare_ts$comparePre(version, range) {
    if (version.prerelease.length > 0 && range.prerelease.length === 0) {
      return -1;
    } else if (version.prerelease.length === 0 && range.prerelease.length > 0) {
      return 1;
    } else if (version.prerelease.length === 0 && range.prerelease.length === 0) {
      return 0;
    }

    let i = 0;
    do {
      const a = version.prerelease[i];
      const b = range.prerelease[i];

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return ___$$priv$romejs$codec_semver$src$compare_ts$compareIdentifiers(a, b);
      }
    } while (++i);

    throw new Error('Unreachable');
  }

  function ___$romejs$codec_semver$src$compare_ts$default(version, range) {
    return ___$$priv$romejs$codec_semver$src$compare_ts$compareMain(version, range) || ___$$priv$romejs$codec_semver$src$compare_ts$comparePre(version, range);
  }

  // romejs/codec-semver/src/satisfies.ts

  function ___$$priv$romejs$codec_semver$src$satisfies_ts$buildVersion(major, minor, patch) {
    return {
      type: 'WildcardVersion',
      major: major,
      minor: minor,
      patch: patch,
      prerelease: [],
      build: []};
  }

  function ___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp(op, version, range) {
    if (range.type === 'Wildcard') {
      return true;
    }

    switch (op) {
      case '=':
        return ___$romejs$codec_semver$src$compare_ts$default(version, range) === 0;

      case '<':
        return ___$romejs$codec_semver$src$compare_ts$default(version, range) < 0;

      case '>':
        return ___$romejs$codec_semver$src$compare_ts$default(version, range) > 0;

      case '>=':
        return ___$romejs$codec_semver$src$compare_ts$default(version, range) >= 0;

      case '<=':
        return ___$romejs$codec_semver$src$compare_ts$default(version, range) <= 0;

      case '^':
        {
          if (___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp('>=', version, range) === false) {
            return false;
          }

          const {major: major, minor: minor, patch: patch} = range;

          if (major === 0) {
            if (minor === 0) {
              return ___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp('<', version, ___$$priv$romejs$codec_semver$src$satisfies_ts$buildVersion(0, 0, patch + 1));
            } else {
              return ___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp('<', version, ___$$priv$romejs$codec_semver$src$satisfies_ts$buildVersion(0, minor + 1, 0));
            }
          }

          return ___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp('<', version, ___$$priv$romejs$codec_semver$src$satisfies_ts$buildVersion(major + 1, 0, 0));
        }

      case '~>':
      case '~':
        {
          if (___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp('>=', version, range) === false) {
            return false;
          }

          const {major: major, minor: minor} = range;

          if (minor === undefined) {
            return ___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp('<', version, ___$$priv$romejs$codec_semver$src$satisfies_ts$buildVersion(major + 1, minor, 0));
          }

          return ___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp('<', version, ___$$priv$romejs$codec_semver$src$satisfies_ts$buildVersion(major, minor + 1, 0));
        }

      default:
        throw new Error('Unknown operator ' + op);}
  }

  function ___$$priv$romejs$codec_semver$src$satisfies_ts$inRange(version, left, right) {
    if (left.type === 'Wildcard' || right.type === 'Wildcard') {
      return true;
    }

    return ___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp('>=', version, left) && ___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp('<=', version, right);
  }

  function ___$$priv$romejs$codec_semver$src$satisfies_ts$collectVersions(range) {
    switch (range.type) {
      case 'AbsoluteVersion':
      case 'WildcardVersion':
        return [range];

      case 'Wildcard':
        return [];

      case 'Comparator':
        return ___$$priv$romejs$codec_semver$src$satisfies_ts$collectVersions(range.version);

      case 'LogicalAnd':
      case 'LogicalOr':
      case 'VersionRange':
        return [...___$$priv$romejs$codec_semver$src$satisfies_ts$collectVersions(range.left), ...___$$priv$romejs$codec_semver$src$satisfies_ts$collectVersions(range.right)];

      default:
        throw new Error('Unknown range type');}
  }

  function ___$romejs$codec_semver$src$satisfies_ts$default(version, range) {
    const res = ___$$priv$romejs$codec_semver$src$satisfies_ts$satisfiesSub(version, range);
    if (res === false) {
      return false;
    }

    if (version.prerelease.length > 0) {
      const versions = ___$$priv$romejs$codec_semver$src$satisfies_ts$collectVersions(range);

      for (const comparator of versions) {
        if (comparator.prerelease.length > 0) {
          if (comparator.major === version.major &&
          comparator.minor === version.minor &&
          comparator.patch === version.patch) {
            return true;
          }
        }
      }

      return false;
    }

    return true;
  }

  function ___$$priv$romejs$codec_semver$src$satisfies_ts$satisfiesSub(version, range) {
    switch (range.type) {
      case 'AbsoluteVersion':
      case 'WildcardVersion':
        return ___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp('=', version, range);

      case 'Wildcard':
        return true;

      case 'Comparator':
        return ___$$priv$romejs$codec_semver$src$satisfies_ts$compareOp(range.operator, version, range.version);

      case 'LogicalAnd':
        return ___$$priv$romejs$codec_semver$src$satisfies_ts$satisfiesSub(version, range.left) && ___$$priv$romejs$codec_semver$src$satisfies_ts$satisfiesSub(version, range.right);

      case 'LogicalOr':
        return ___$$priv$romejs$codec_semver$src$satisfies_ts$satisfiesSub(version, range.left) || ___$$priv$romejs$codec_semver$src$satisfies_ts$satisfiesSub(version, range.right);

      case 'VersionRange':
        return ___$$priv$romejs$codec_semver$src$satisfies_ts$inRange(version, range.left, range.right) ||
        ___$$priv$romejs$codec_semver$src$satisfies_ts$inRange(version, range.right, range.left);}
  }

  // romejs/codec-semver/src/utils.ts

  function ___$romejs$codec_semver$src$utils_ts$normalizeUserVersion(ver, opts) {
    if (typeof ver === 'string') {
      return ___$romejs$codec_semver$src$parse_ts$parseVersion(Object.assign({}, opts, {
        input: ver}));
    } else if (ver.type === 'AbsoluteVersion') {
      return ver;
    } else {
      throw new Error('Not a valid version: ' + ver.type);
    }
  }

  function ___$romejs$codec_semver$src$utils_ts$normalizeUserRange(range, opts) {
    if (typeof range === 'string') {
      return ___$romejs$codec_semver$src$parse_ts$parseRange(Object.assign({}, opts, {
        input: range}));
    } else {
      return range;
    }
  }

  // romejs/codec-semver/src/stringify.ts

  function ___$$priv$romejs$codec_semver$src$stringify_ts$compactRight(parts) {
    for (let i = parts.length - 1; i >= 0; i--) {
      const part = parts[i];
      if (part !== undefined) {
        return parts.slice(0, i + 1);
      }
    }

    return [];
  }

  const ___$$priv$romejs$codec_semver$src$stringify_ts$WILDCARD = '*';

  function ___$romejs$codec_semver$src$stringify_ts$default(node) {
    switch (node.type) {
      case 'WildcardVersion':
      case 'AbsoluteVersion':
        {
          let str = ___$$priv$romejs$codec_semver$src$stringify_ts$compactRight([node.major, node.minor, node.patch]).map(part => part === undefined ? ___$$priv$romejs$codec_semver$src$stringify_ts$WILDCARD : part).join('.');

          if (node.prerelease.length > 0) {
            str += '-' + node.prerelease.join('.');
          }
          if (node.build.length > 0) {
            str += '+' + node.build.join('.');
          }
          return str;
        }

      case 'Wildcard':
        return ___$$priv$romejs$codec_semver$src$stringify_ts$WILDCARD;

      case 'Comparator':
        return `${node.operator}${___$romejs$codec_semver$src$stringify_ts$default(node.version)}`;

      case 'LogicalAnd':
        return `${___$romejs$codec_semver$src$stringify_ts$default(node.left)} ${___$romejs$codec_semver$src$stringify_ts$default(node.right)}`;

      case 'LogicalOr':
        return `${___$romejs$codec_semver$src$stringify_ts$default(node.left)} || ${___$romejs$codec_semver$src$stringify_ts$default(node.right)}`;

      case 'VersionRange':
        return `${___$romejs$codec_semver$src$stringify_ts$default(node.left)} - ${___$romejs$codec_semver$src$stringify_ts$default(node.right)}`;}
  }

  // romejs/codec-semver/src/index.ts

  function ___$romejs$codec_semver$src$index_ts$sort(rawVersions, opts) {
    const versions = rawVersions.map(ver => ___$romejs$codec_semver$src$utils_ts$normalizeUserVersion(ver, opts));
    return versions.sort((a, b) => ___$romejs$codec_semver$src$compare_ts$default(a, b));
  }

  function ___$romejs$codec_semver$src$index_ts$maxSatisfying(rawVersions, rawRange, opts) {
    const versions = ___$romejs$codec_semver$src$index_ts$sort(rawVersions, opts).reverse();
    const range = ___$romejs$codec_semver$src$utils_ts$normalizeUserRange(rawRange, opts);

    for (const version of versions) {
      if (___$romejs$codec_semver$src$satisfies_ts$default(version, range)) {
        return version;
      }
    }

    return undefined;
  }

  function ___$romejs$codec_semver$src$index_ts$minSatisfying(rawVersions, rawRange, opts) {
    const versions = ___$romejs$codec_semver$src$index_ts$sort(rawVersions, opts);
    const range = ___$romejs$codec_semver$src$utils_ts$normalizeUserRange(rawRange, opts);

    for (const version of versions) {
      if (___$romejs$codec_semver$src$satisfies_ts$default(version, range)) {
        return version;
      }
    }

    return undefined;
  }

  function ___$romejs$codec_semver$src$index_ts$satisfies(rawVersion, rawRange, opts) {
    try {
      const version = ___$romejs$codec_semver$src$utils_ts$normalizeUserVersion(rawVersion, opts);
      const range = ___$romejs$codec_semver$src$utils_ts$normalizeUserRange(rawRange, opts);
      return ___$romejs$codec_semver$src$satisfies_ts$default(version, range);
    } catch (err) {
      if (err instanceof ___$romejs$parser_core$src$index_ts$ParserSyntaxError) {
        return false;
      } else {
        throw err;
      }
    }
  }

  // romejs/codec-spdx-license/src/data.ts

  const ___$romejs$codec_spdx_license$src$data_ts$default = {
    licenseListVersion: 'v3.4-22-g14c1a0e',
    licenses: [{
      reference: './0BSD.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/0BSD.json',
      referenceNumber: '311',
      name: 'BSD Zero Clause License',
      licenseId: '0BSD',
      seeAlso: ['http://landley.net/toybox/license.html'],
      isOsiApproved: true}, {
      reference: './AAL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AAL.json',
      referenceNumber: '20',
      name: 'Attribution Assurance License',
      licenseId: 'AAL',
      seeAlso: ['https://opensource.org/licenses/attribution'],
      isOsiApproved: true}, {
      reference: './ADSL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ADSL.json',
      referenceNumber: '18',
      name: 'Amazon Digital Services License',
      licenseId: 'ADSL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/AmazonDigitalServicesLicense'],
      isOsiApproved: false}, {
      reference: './AFL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AFL-1.1.json',
      referenceNumber: '112',
      name: 'Academic Free License v1.1',
      licenseId: 'AFL-1.1',
      seeAlso: ['http://opensource.linux-mirror.org/licenses/afl-1.1.txt', 'http://wayback.archive.org/web/20021004124254/http://www.opensource.org/licenses/academic.php'],
      isOsiApproved: true}, {
      reference: './AFL-1.2.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AFL-1.2.json',
      referenceNumber: '130',
      name: 'Academic Free License v1.2',
      licenseId: 'AFL-1.2',
      seeAlso: ['http://opensource.linux-mirror.org/licenses/afl-1.2.txt', 'http://wayback.archive.org/web/20021204204652/http://www.opensource.org/licenses/academic.php'],
      isOsiApproved: true}, {
      reference: './AFL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AFL-2.0.json',
      referenceNumber: '109',
      name: 'Academic Free License v2.0',
      licenseId: 'AFL-2.0',
      seeAlso: ['http://wayback.archive.org/web/20060924134533/http://www.opensource.org/licenses/afl-2.0.txt'],
      isOsiApproved: true}, {
      reference: './AFL-2.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AFL-2.1.json',
      referenceNumber: '245',
      name: 'Academic Free License v2.1',
      licenseId: 'AFL-2.1',
      seeAlso: ['http://opensource.linux-mirror.org/licenses/afl-2.1.txt'],
      isOsiApproved: true}, {
      reference: './AFL-3.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AFL-3.0.json',
      referenceNumber: '210',
      name: 'Academic Free License v3.0',
      licenseId: 'AFL-3.0',
      seeAlso: ['http://www.rosenlaw.com/AFL3.0.htm', 'https://opensource.org/licenses/afl-3.0'],
      isOsiApproved: true}, {
      reference: './AGPL-1.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AGPL-1.0.json',
      referenceNumber: '326',
      name: 'Affero General Public License v1.0',
      licenseId: 'AGPL-1.0',
      seeAlso: ['http://www.affero.org/oagpl.html'],
      isOsiApproved: false}, {
      reference: './AGPL-1.0-only.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AGPL-1.0-only.json',
      referenceNumber: '371',
      name: 'Affero General Public License v1.0 only',
      licenseId: 'AGPL-1.0-only',
      seeAlso: ['http://www.affero.org/oagpl.html'],
      isOsiApproved: false}, {
      reference: './AGPL-1.0-or-later.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AGPL-1.0-or-later.json',
      referenceNumber: '323',
      name: 'Affero General Public License v1.0 or later',
      licenseId: 'AGPL-1.0-or-later',
      seeAlso: ['http://www.affero.org/oagpl.html'],
      isOsiApproved: false}, {
      reference: './AGPL-3.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AGPL-3.0.json',
      referenceNumber: '223',
      name: 'GNU Affero General Public License v3.0',
      licenseId: 'AGPL-3.0',
      seeAlso: ['https://www.gnu.org/licenses/agpl.txt', 'https://opensource.org/licenses/AGPL-3.0'],
      isOsiApproved: true}, {
      reference: './AGPL-3.0-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AGPL-3.0-only.json',
      referenceNumber: '90',
      name: 'GNU Affero General Public License v3.0 only',
      licenseId: 'AGPL-3.0-only',
      seeAlso: ['https://www.gnu.org/licenses/agpl.txt', 'https://opensource.org/licenses/AGPL-3.0'],
      isOsiApproved: true}, {
      reference: './AGPL-3.0-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AGPL-3.0-or-later.json',
      referenceNumber: '149',
      name: 'GNU Affero General Public License v3.0 or later',
      licenseId: 'AGPL-3.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/agpl.txt', 'https://opensource.org/licenses/AGPL-3.0'],
      isOsiApproved: true}, {
      reference: './AMDPLPA.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AMDPLPA.json',
      referenceNumber: '31',
      name: 'AMD\'s plpa_map.c License',
      licenseId: 'AMDPLPA',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/AMD_plpa_map_License'],
      isOsiApproved: false}, {
      reference: './AML.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AML.json',
      referenceNumber: '142',
      name: 'Apple MIT License',
      licenseId: 'AML',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Apple_MIT_License'],
      isOsiApproved: false}, {
      reference: './AMPAS.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AMPAS.json',
      referenceNumber: '185',
      name: 'Academy of Motion Picture Arts and Sciences BSD',
      licenseId: 'AMPAS',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/BSD#AMPASBSD'],
      isOsiApproved: false}, {
      reference: './ANTLR-PD.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ANTLR-PD.json',
      referenceNumber: '382',
      name: 'ANTLR Software Rights Notice',
      licenseId: 'ANTLR-PD',
      seeAlso: ['http://www.antlr2.org/license.html'],
      isOsiApproved: false}, {
      reference: './APAFML.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/APAFML.json',
      referenceNumber: '189',
      name: 'Adobe Postscript AFM License',
      licenseId: 'APAFML',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/AdobePostscriptAFM'],
      isOsiApproved: false}, {
      reference: './APL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/APL-1.0.json',
      referenceNumber: '246',
      name: 'Adaptive Public License 1.0',
      licenseId: 'APL-1.0',
      seeAlso: ['https://opensource.org/licenses/APL-1.0'],
      isOsiApproved: true}, {
      reference: './APSL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/APSL-1.0.json',
      referenceNumber: '343',
      name: 'Apple Public Source License 1.0',
      licenseId: 'APSL-1.0',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Apple_Public_Source_License_1.0'],
      isOsiApproved: true}, {
      reference: './APSL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/APSL-1.1.json',
      referenceNumber: '316',
      name: 'Apple Public Source License 1.1',
      licenseId: 'APSL-1.1',
      seeAlso: ['http://www.opensource.apple.com/source/IOSerialFamily/IOSerialFamily-7/APPLE_LICENSE'],
      isOsiApproved: true}, {
      reference: './APSL-1.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/APSL-1.2.json',
      referenceNumber: '32',
      name: 'Apple Public Source License 1.2',
      licenseId: 'APSL-1.2',
      seeAlso: ['http://www.samurajdata.se/opensource/mirror/licenses/apsl.php'],
      isOsiApproved: true}, {
      reference: './APSL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/APSL-2.0.json',
      referenceNumber: '103',
      name: 'Apple Public Source License 2.0',
      licenseId: 'APSL-2.0',
      seeAlso: ['http://www.opensource.apple.com/license/apsl/'],
      isOsiApproved: true}, {
      reference: './Abstyles.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Abstyles.json',
      referenceNumber: '76',
      name: 'Abstyles License',
      licenseId: 'Abstyles',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Abstyles'],
      isOsiApproved: false}, {
      reference: './Adobe-2006.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Adobe-2006.json',
      referenceNumber: '278',
      name: 'Adobe Systems Incorporated Source Code License Agreement',
      licenseId: 'Adobe-2006',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/AdobeLicense'],
      isOsiApproved: false}, {
      reference: './Adobe-Glyph.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Adobe-Glyph.json',
      referenceNumber: '101',
      name: 'Adobe Glyph List License',
      licenseId: 'Adobe-Glyph',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT#AdobeGlyph'],
      isOsiApproved: false}, {
      reference: './Afmparse.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Afmparse.json',
      referenceNumber: '40',
      name: 'Afmparse License',
      licenseId: 'Afmparse',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Afmparse'],
      isOsiApproved: false}, {
      reference: './Aladdin.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Aladdin.json',
      referenceNumber: '252',
      name: 'Aladdin Free Public License',
      licenseId: 'Aladdin',
      seeAlso: ['http://pages.cs.wisc.edu/~ghost/doc/AFPL/6.01/Public.htm'],
      isOsiApproved: false}, {
      reference: './Apache-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Apache-1.0.json',
      referenceNumber: '231',
      name: 'Apache License 1.0',
      licenseId: 'Apache-1.0',
      seeAlso: ['http://www.apache.org/licenses/LICENSE-1.0'],
      isOsiApproved: false}, {
      reference: './Apache-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Apache-1.1.json',
      referenceNumber: '80',
      name: 'Apache License 1.1',
      licenseId: 'Apache-1.1',
      seeAlso: ['http://apache.org/licenses/LICENSE-1.1', 'https://opensource.org/licenses/Apache-1.1'],
      isOsiApproved: true}, {
      reference: './Apache-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Apache-2.0.json',
      referenceNumber: '24',
      name: 'Apache License 2.0',
      licenseId: 'Apache-2.0',
      seeAlso: ['http://www.apache.org/licenses/LICENSE-2.0', 'https://opensource.org/licenses/Apache-2.0'],
      isOsiApproved: true}, {
      reference: './Artistic-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Artistic-1.0.json',
      referenceNumber: '159',
      name: 'Artistic License 1.0',
      licenseId: 'Artistic-1.0',
      seeAlso: ['https://opensource.org/licenses/Artistic-1.0'],
      isOsiApproved: true}, {
      reference: './Artistic-1.0-Perl.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Artistic-1.0-Perl.json',
      referenceNumber: '364',
      name: 'Artistic License 1.0 (Perl)',
      licenseId: 'Artistic-1.0-Perl',
      seeAlso: ['http://dev.perl.org/licenses/artistic.html'],
      isOsiApproved: true}, {
      reference: './Artistic-1.0-cl8.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Artistic-1.0-cl8.json',
      referenceNumber: '12',
      name: 'Artistic License 1.0 w/clause 8',
      licenseId: 'Artistic-1.0-cl8',
      seeAlso: ['https://opensource.org/licenses/Artistic-1.0'],
      isOsiApproved: true}, {
      reference: './Artistic-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Artistic-2.0.json',
      referenceNumber: '183',
      name: 'Artistic License 2.0',
      licenseId: 'Artistic-2.0',
      seeAlso: ['http://www.perlfoundation.org/artistic_license_2_0', 'https://opensource.org/licenses/artistic-license-2.0'],
      isOsiApproved: true}, {
      reference: './BSD-1-Clause.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-1-Clause.json',
      referenceNumber: '346',
      name: 'BSD 1-Clause License',
      licenseId: 'BSD-1-Clause',
      seeAlso: ['https://svnweb.freebsd.org/base/head/include/ifaddrs.h?revision=326823'],
      isOsiApproved: false}, {
      reference: './BSD-2-Clause.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause.json',
      referenceNumber: '317',
      name: 'BSD 2-Clause "Simplified" License',
      licenseId: 'BSD-2-Clause',
      seeAlso: ['https://opensource.org/licenses/BSD-2-Clause'],
      isOsiApproved: true}, {
      reference: './BSD-2-Clause-FreeBSD.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause-FreeBSD.json',
      referenceNumber: '115',
      name: 'BSD 2-Clause FreeBSD License',
      licenseId: 'BSD-2-Clause-FreeBSD',
      seeAlso: ['http://www.freebsd.org/copyright/freebsd-license.html'],
      isOsiApproved: false}, {
      reference: './BSD-2-Clause-NetBSD.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause-NetBSD.json',
      referenceNumber: '368',
      name: 'BSD 2-Clause NetBSD License',
      licenseId: 'BSD-2-Clause-NetBSD',
      seeAlso: ['http://www.netbsd.org/about/redistribution.html#default'],
      isOsiApproved: false}, {
      reference: './BSD-2-Clause-Patent.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause-Patent.json',
      referenceNumber: '163',
      name: 'BSD-2-Clause Plus Patent License',
      licenseId: 'BSD-2-Clause-Patent',
      seeAlso: ['https://opensource.org/licenses/BSDplusPatent'],
      isOsiApproved: true}, {
      reference: './BSD-3-Clause.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause.json',
      referenceNumber: '263',
      name: 'BSD 3-Clause "New" or "Revised" License',
      licenseId: 'BSD-3-Clause',
      seeAlso: ['https://opensource.org/licenses/BSD-3-Clause'],
      isOsiApproved: true}, {
      reference: './BSD-3-Clause-Attribution.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-Attribution.json',
      referenceNumber: '37',
      name: 'BSD with attribution',
      licenseId: 'BSD-3-Clause-Attribution',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/BSD_with_Attribution'],
      isOsiApproved: false}, {
      reference: './BSD-3-Clause-Clear.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-Clear.json',
      referenceNumber: '206',
      name: 'BSD 3-Clause Clear License',
      licenseId: 'BSD-3-Clause-Clear',
      seeAlso: ['http://labs.metacarta.com/license-explanation.html#license'],
      isOsiApproved: false}, {
      reference: './BSD-3-Clause-LBNL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-LBNL.json',
      referenceNumber: '328',
      name: 'Lawrence Berkeley National Labs BSD variant license',
      licenseId: 'BSD-3-Clause-LBNL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/LBNLBSD'],
      isOsiApproved: false}, {
      reference: './BSD-3-Clause-No-Nuclear-License.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-License.json',
      referenceNumber: '11',
      name: 'BSD 3-Clause No Nuclear License',
      licenseId: 'BSD-3-Clause-No-Nuclear-License',
      seeAlso: ['http://download.oracle.com/otn-pub/java/licenses/bsd.txt?AuthParam=1467140197_43d516ce1776bd08a58235a7785be1cc'],
      isOsiApproved: false}, {
      reference: './BSD-3-Clause-No-Nuclear-License-2014.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-License-2014.json',
      referenceNumber: '131',
      name: 'BSD 3-Clause No Nuclear License 2014',
      licenseId: 'BSD-3-Clause-No-Nuclear-License-2014',
      seeAlso: ['https://java.net/projects/javaeetutorial/pages/BerkeleyLicense'],
      isOsiApproved: false}, {
      reference: './BSD-3-Clause-No-Nuclear-Warranty.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-Warranty.json',
      referenceNumber: '42',
      name: 'BSD 3-Clause No Nuclear Warranty',
      licenseId: 'BSD-3-Clause-No-Nuclear-Warranty',
      seeAlso: ['https://jogamp.org/git/?p=gluegen.git;a=blob_plain;f=LICENSE.txt'],
      isOsiApproved: false}, {
      reference: './BSD-4-Clause.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BSD-4-Clause.json',
      referenceNumber: '156',
      name: 'BSD 4-Clause "Original" or "Old" License',
      licenseId: 'BSD-4-Clause',
      seeAlso: ['http://directory.fsf.org/wiki/License:BSD_4Clause'],
      isOsiApproved: false}, {
      reference: './BSD-4-Clause-UC.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-4-Clause-UC.json',
      referenceNumber: '197',
      name: 'BSD-4-Clause (University of California-Specific)',
      licenseId: 'BSD-4-Clause-UC',
      seeAlso: ['http://www.freebsd.org/copyright/license.html'],
      isOsiApproved: false}, {
      reference: './BSD-Protection.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-Protection.json',
      referenceNumber: '113',
      name: 'BSD Protection License',
      licenseId: 'BSD-Protection',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/BSD_Protection_License'],
      isOsiApproved: false}, {
      reference: './BSD-Source-Code.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-Source-Code.json',
      referenceNumber: '301',
      name: 'BSD Source Code Attribution',
      licenseId: 'BSD-Source-Code',
      seeAlso: ['https://github.com/robbiehanson/CocoaHTTPServer/blob/master/LICENSE.txt'],
      isOsiApproved: false}, {
      reference: './BSL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BSL-1.0.json',
      referenceNumber: '218',
      name: 'Boost Software License 1.0',
      licenseId: 'BSL-1.0',
      seeAlso: ['http://www.boost.org/LICENSE_1_0.txt', 'https://opensource.org/licenses/BSL-1.0'],
      isOsiApproved: true}, {
      reference: './Bahyph.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Bahyph.json',
      referenceNumber: '354',
      name: 'Bahyph License',
      licenseId: 'Bahyph',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Bahyph'],
      isOsiApproved: false}, {
      reference: './Barr.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Barr.json',
      referenceNumber: '324',
      name: 'Barr License',
      licenseId: 'Barr',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Barr'],
      isOsiApproved: false}, {
      reference: './Beerware.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Beerware.json',
      referenceNumber: '16',
      name: 'Beerware License',
      licenseId: 'Beerware',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Beerware', 'https://people.freebsd.org/~phk/'],
      isOsiApproved: false}, {
      reference: './BitTorrent-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BitTorrent-1.0.json',
      referenceNumber: '212',
      name: 'BitTorrent Open Source License v1.0',
      licenseId: 'BitTorrent-1.0',
      seeAlso: ['http://sources.gentoo.org/cgi-bin/viewvc.cgi/gentoo-x86/licenses/BitTorrent?r1=1.1&r2=1.1.1.1&diff_format=s'],
      isOsiApproved: false}, {
      reference: './BitTorrent-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BitTorrent-1.1.json',
      referenceNumber: '173',
      name: 'BitTorrent Open Source License v1.1',
      licenseId: 'BitTorrent-1.1',
      seeAlso: ['http://directory.fsf.org/wiki/License:BitTorrentOSL1.1'],
      isOsiApproved: false}, {
      reference: './Borceux.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Borceux.json',
      referenceNumber: '304',
      name: 'Borceux license',
      licenseId: 'Borceux',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Borceux'],
      isOsiApproved: false}, {
      reference: './CATOSL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CATOSL-1.1.json',
      referenceNumber: '256',
      name: 'Computer Associates Trusted Open Source License 1.1',
      licenseId: 'CATOSL-1.1',
      seeAlso: ['https://opensource.org/licenses/CATOSL-1.1'],
      isOsiApproved: true}, {
      reference: './CC-BY-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-1.0.json',
      referenceNumber: '122',
      name: 'Creative Commons Attribution 1.0 Generic',
      licenseId: 'CC-BY-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-2.0.json',
      referenceNumber: '226',
      name: 'Creative Commons Attribution 2.0 Generic',
      licenseId: 'CC-BY-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-2.5.json',
      referenceNumber: '123',
      name: 'Creative Commons Attribution 2.5 Generic',
      licenseId: 'CC-BY-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-3.0.json',
      referenceNumber: '250',
      name: 'Creative Commons Attribution 3.0 Unported',
      licenseId: 'CC-BY-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-4.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-4.0.json',
      referenceNumber: '322',
      name: 'Creative Commons Attribution 4.0 International',
      licenseId: 'CC-BY-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-1.0.json',
      referenceNumber: '124',
      name: 'Creative Commons Attribution Non Commercial 1.0 Generic',
      licenseId: 'CC-BY-NC-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-2.0.json',
      referenceNumber: '238',
      name: 'Creative Commons Attribution Non Commercial 2.0 Generic',
      licenseId: 'CC-BY-NC-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-2.5.json',
      referenceNumber: '1',
      name: 'Creative Commons Attribution Non Commercial 2.5 Generic',
      licenseId: 'CC-BY-NC-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by-nc/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-3.0.json',
      referenceNumber: '249',
      name: 'Creative Commons Attribution Non Commercial 3.0 Unported',
      licenseId: 'CC-BY-NC-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-4.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-4.0.json',
      referenceNumber: '180',
      name: 'Creative Commons Attribution Non Commercial 4.0 International',
      licenseId: 'CC-BY-NC-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-ND-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-1.0.json',
      referenceNumber: '57',
      name: 'Creative Commons Attribution Non Commercial No Derivatives 1.0 Generic',
      licenseId: 'CC-BY-NC-ND-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nd-nc/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-ND-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-2.0.json',
      referenceNumber: '34',
      name: 'Creative Commons Attribution Non Commercial No Derivatives 2.0 Generic',
      licenseId: 'CC-BY-NC-ND-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-ND-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-2.5.json',
      referenceNumber: '152',
      name: 'Creative Commons Attribution Non Commercial No Derivatives 2.5 Generic',
      licenseId: 'CC-BY-NC-ND-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-ND-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-3.0.json',
      referenceNumber: '46',
      name: 'Creative Commons Attribution Non Commercial No Derivatives 3.0 Unported',
      licenseId: 'CC-BY-NC-ND-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-ND-4.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-4.0.json',
      referenceNumber: '274',
      name: 'Creative Commons Attribution Non Commercial No Derivatives 4.0 International',
      licenseId: 'CC-BY-NC-ND-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-SA-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-1.0.json',
      referenceNumber: '172',
      name: 'Creative Commons Attribution Non Commercial Share Alike 1.0 Generic',
      licenseId: 'CC-BY-NC-SA-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-SA-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-2.0.json',
      referenceNumber: '77',
      name: 'Creative Commons Attribution Non Commercial Share Alike 2.0 Generic',
      licenseId: 'CC-BY-NC-SA-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-SA-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-2.5.json',
      referenceNumber: '60',
      name: 'Creative Commons Attribution Non Commercial Share Alike 2.5 Generic',
      licenseId: 'CC-BY-NC-SA-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-SA-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-3.0.json',
      referenceNumber: '21',
      name: 'Creative Commons Attribution Non Commercial Share Alike 3.0 Unported',
      licenseId: 'CC-BY-NC-SA-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-SA-4.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-4.0.json',
      referenceNumber: '45',
      name: 'Creative Commons Attribution Non Commercial Share Alike 4.0 International',
      licenseId: 'CC-BY-NC-SA-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-ND-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-1.0.json',
      referenceNumber: '48',
      name: 'Creative Commons Attribution No Derivatives 1.0 Generic',
      licenseId: 'CC-BY-ND-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nd/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-ND-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-2.0.json',
      referenceNumber: '280',
      name: 'Creative Commons Attribution No Derivatives 2.0 Generic',
      licenseId: 'CC-BY-ND-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nd/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-ND-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-2.5.json',
      referenceNumber: '66',
      name: 'Creative Commons Attribution No Derivatives 2.5 Generic',
      licenseId: 'CC-BY-ND-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by-nd/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-ND-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-3.0.json',
      referenceNumber: '380',
      name: 'Creative Commons Attribution No Derivatives 3.0 Unported',
      licenseId: 'CC-BY-ND-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nd/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-ND-4.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-4.0.json',
      referenceNumber: '126',
      name: 'Creative Commons Attribution No Derivatives 4.0 International',
      licenseId: 'CC-BY-ND-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nd/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-SA-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-1.0.json',
      referenceNumber: '314',
      name: 'Creative Commons Attribution Share Alike 1.0 Generic',
      licenseId: 'CC-BY-SA-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by-sa/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-SA-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-2.0.json',
      referenceNumber: '136',
      name: 'Creative Commons Attribution Share Alike 2.0 Generic',
      licenseId: 'CC-BY-SA-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by-sa/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-SA-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-2.5.json',
      referenceNumber: '299',
      name: 'Creative Commons Attribution Share Alike 2.5 Generic',
      licenseId: 'CC-BY-SA-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by-sa/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-SA-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-3.0.json',
      referenceNumber: '381',
      name: 'Creative Commons Attribution Share Alike 3.0 Unported',
      licenseId: 'CC-BY-SA-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by-sa/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-SA-4.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-4.0.json',
      referenceNumber: '30',
      name: 'Creative Commons Attribution Share Alike 4.0 International',
      licenseId: 'CC-BY-SA-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by-sa/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC0-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CC0-1.0.json',
      referenceNumber: '207',
      name: 'Creative Commons Zero v1.0 Universal',
      licenseId: 'CC0-1.0',
      seeAlso: ['https://creativecommons.org/publicdomain/zero/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CDDL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CDDL-1.0.json',
      referenceNumber: '132',
      name: 'Common Development and Distribution License 1.0',
      licenseId: 'CDDL-1.0',
      seeAlso: ['https://opensource.org/licenses/cddl1'],
      isOsiApproved: true}, {
      reference: './CDDL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CDDL-1.1.json',
      referenceNumber: '363',
      name: 'Common Development and Distribution License 1.1',
      licenseId: 'CDDL-1.1',
      seeAlso: ['http://glassfish.java.net/public/CDDL+GPL_1_1.html', 'https://javaee.github.io/glassfish/LICENSE'],
      isOsiApproved: false}, {
      reference: './CDLA-Permissive-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CDLA-Permissive-1.0.json',
      referenceNumber: '244',
      name: 'Community Data License Agreement Permissive 1.0',
      licenseId: 'CDLA-Permissive-1.0',
      seeAlso: ['https://cdla.io/permissive-1-0'],
      isOsiApproved: false}, {
      reference: './CDLA-Sharing-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CDLA-Sharing-1.0.json',
      referenceNumber: '303',
      name: 'Community Data License Agreement Sharing 1.0',
      licenseId: 'CDLA-Sharing-1.0',
      seeAlso: ['https://cdla.io/sharing-1-0'],
      isOsiApproved: false}, {
      reference: './CECILL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CECILL-1.0.json',
      referenceNumber: '217',
      name: 'CeCILL Free Software License Agreement v1.0',
      licenseId: 'CECILL-1.0',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V1-fr.html'],
      isOsiApproved: false}, {
      reference: './CECILL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CECILL-1.1.json',
      referenceNumber: '293',
      name: 'CeCILL Free Software License Agreement v1.1',
      licenseId: 'CECILL-1.1',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V1.1-US.html'],
      isOsiApproved: false}, {
      reference: './CECILL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CECILL-2.0.json',
      referenceNumber: '341',
      name: 'CeCILL Free Software License Agreement v2.0',
      licenseId: 'CECILL-2.0',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V2-en.html'],
      isOsiApproved: false}, {
      reference: './CECILL-2.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CECILL-2.1.json',
      referenceNumber: '114',
      name: 'CeCILL Free Software License Agreement v2.1',
      licenseId: 'CECILL-2.1',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.html'],
      isOsiApproved: true}, {
      reference: './CECILL-B.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CECILL-B.json',
      referenceNumber: '331',
      name: 'CeCILL-B Free Software License Agreement',
      licenseId: 'CECILL-B',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html'],
      isOsiApproved: false}, {
      reference: './CECILL-C.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CECILL-C.json',
      referenceNumber: '73',
      name: 'CeCILL-C Free Software License Agreement',
      licenseId: 'CECILL-C',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html\n    '],
      isOsiApproved: false}, {
      reference: './CNRI-Jython.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CNRI-Jython.json',
      referenceNumber: '89',
      name: 'CNRI Jython License',
      licenseId: 'CNRI-Jython',
      seeAlso: ['http://www.jython.org/license.html'],
      isOsiApproved: false}, {
      reference: './CNRI-Python.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CNRI-Python.json',
      referenceNumber: '43',
      name: 'CNRI Python License',
      licenseId: 'CNRI-Python',
      seeAlso: ['https://opensource.org/licenses/CNRI-Python'],
      isOsiApproved: true}, {
      reference: './CNRI-Python-GPL-Compatible.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CNRI-Python-GPL-Compatible.json',
      referenceNumber: '196',
      name: 'CNRI Python Open Source GPL Compatible License Agreement',
      licenseId: 'CNRI-Python-GPL-Compatible',
      seeAlso: ['http://www.python.org/download/releases/1.6.1/download_win/'],
      isOsiApproved: false}, {
      reference: './CPAL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CPAL-1.0.json',
      referenceNumber: '164',
      name: 'Common Public Attribution License 1.0',
      licenseId: 'CPAL-1.0',
      seeAlso: ['https://opensource.org/licenses/CPAL-1.0'],
      isOsiApproved: true}, {
      reference: './CPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CPL-1.0.json',
      referenceNumber: '166',
      name: 'Common Public License 1.0',
      licenseId: 'CPL-1.0',
      seeAlso: ['https://opensource.org/licenses/CPL-1.0'],
      isOsiApproved: true}, {
      reference: './CPOL-1.02.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CPOL-1.02.json',
      referenceNumber: '26',
      name: 'Code Project Open License 1.02',
      licenseId: 'CPOL-1.02',
      seeAlso: ['http://www.codeproject.com/info/cpol10.aspx'],
      isOsiApproved: false}, {
      reference: './CUA-OPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CUA-OPL-1.0.json',
      referenceNumber: '353',
      name: 'CUA Office Public License v1.0',
      licenseId: 'CUA-OPL-1.0',
      seeAlso: ['https://opensource.org/licenses/CUA-OPL-1.0'],
      isOsiApproved: true}, {
      reference: './Caldera.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Caldera.json',
      referenceNumber: '102',
      name: 'Caldera License',
      licenseId: 'Caldera',
      seeAlso: ['http://www.lemis.com/grog/UNIX/ancient-source-all.pdf'],
      isOsiApproved: false}, {
      reference: './ClArtistic.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ClArtistic.json',
      referenceNumber: '264',
      name: 'Clarified Artistic License',
      licenseId: 'ClArtistic',
      seeAlso: ['http://gianluca.dellavedova.org/2011/01/03/clarified-artistic-license/', 'http://www.ncftp.com/ncftp/doc/LICENSE.txt'],
      isOsiApproved: false}, {
      reference: './Condor-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Condor-1.1.json',
      referenceNumber: '300',
      name: 'Condor Public License v1.1',
      licenseId: 'Condor-1.1',
      seeAlso: ['http://research.cs.wisc.edu/condor/license.html#condor', 'http://web.archive.org/web/20111123062036/http://research.cs.wisc.edu/condor/license.html#condor'],
      isOsiApproved: false}, {
      reference: './Crossword.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Crossword.json',
      referenceNumber: '351',
      name: 'Crossword License',
      licenseId: 'Crossword',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Crossword'],
      isOsiApproved: false}, {
      reference: './CrystalStacker.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CrystalStacker.json',
      referenceNumber: '162',
      name: 'CrystalStacker License',
      licenseId: 'CrystalStacker',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing:CrystalStacker?rd=Licensing/CrystalStacker'],
      isOsiApproved: false}, {
      reference: './Cube.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Cube.json',
      referenceNumber: '358',
      name: 'Cube License',
      licenseId: 'Cube',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Cube'],
      isOsiApproved: false}, {
      reference: './D-FSL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/D-FSL-1.0.json',
      referenceNumber: '176',
      name: 'Deutsche Freie Software Lizenz',
      licenseId: 'D-FSL-1.0',
      seeAlso: ['http://www.dipp.nrw.de/d-fsl/lizenzen/', 'http://www.dipp.nrw.de/d-fsl/index_html/lizenzen/de/D-FSL-1_0_de.txt', 'http://www.dipp.nrw.de/d-fsl/index_html/lizenzen/en/D-FSL-1_0_en.txt', 'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl', 'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/deutsche-freie-software-lizenz', 'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/german-free-software-license', 'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/D-FSL-1_0_de.txt/at_download/file', 'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/D-FSL-1_0_en.txt/at_download/file'],
      isOsiApproved: false}, {
      reference: './DOC.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/DOC.json',
      referenceNumber: '154',
      name: 'DOC License',
      licenseId: 'DOC',
      seeAlso: ['http://www.cs.wustl.edu/~schmidt/ACE-copying.html'],
      isOsiApproved: false}, {
      reference: './DSDP.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/DSDP.json',
      referenceNumber: '135',
      name: 'DSDP License',
      licenseId: 'DSDP',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/DSDP'],
      isOsiApproved: false}, {
      reference: './Dotseqn.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Dotseqn.json',
      referenceNumber: '377',
      name: 'Dotseqn License',
      licenseId: 'Dotseqn',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Dotseqn'],
      isOsiApproved: false}, {
      reference: './ECL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ECL-1.0.json',
      referenceNumber: '383',
      name: 'Educational Community License v1.0',
      licenseId: 'ECL-1.0',
      seeAlso: ['https://opensource.org/licenses/ECL-1.0'],
      isOsiApproved: true}, {
      reference: './ECL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ECL-2.0.json',
      referenceNumber: '291',
      name: 'Educational Community License v2.0',
      licenseId: 'ECL-2.0',
      seeAlso: ['https://opensource.org/licenses/ECL-2.0'],
      isOsiApproved: true}, {
      reference: './EFL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/EFL-1.0.json',
      referenceNumber: '144',
      name: 'Eiffel Forum License v1.0',
      licenseId: 'EFL-1.0',
      seeAlso: ['http://www.eiffel-nice.org/license/forum.txt', 'https://opensource.org/licenses/EFL-1.0'],
      isOsiApproved: true}, {
      reference: './EFL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EFL-2.0.json',
      referenceNumber: '155',
      name: 'Eiffel Forum License v2.0',
      licenseId: 'EFL-2.0',
      seeAlso: ['http://www.eiffel-nice.org/license/eiffel-forum-license-2.html', 'https://opensource.org/licenses/EFL-2.0'],
      isOsiApproved: true}, {
      reference: './EPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EPL-1.0.json',
      referenceNumber: '208',
      name: 'Eclipse Public License 1.0',
      licenseId: 'EPL-1.0',
      seeAlso: ['http://www.eclipse.org/legal/epl-v10.html', 'https://opensource.org/licenses/EPL-1.0'],
      isOsiApproved: true}, {
      reference: './EPL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EPL-2.0.json',
      referenceNumber: '128',
      name: 'Eclipse Public License 2.0',
      licenseId: 'EPL-2.0',
      seeAlso: ['https://www.eclipse.org/legal/epl-2.0', 'https://www.opensource.org/licenses/EPL-2.0'],
      isOsiApproved: true}, {
      reference: './EUDatagrid.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EUDatagrid.json',
      referenceNumber: '186',
      name: 'EU DataGrid Software License',
      licenseId: 'EUDatagrid',
      seeAlso: ['http://eu-datagrid.web.cern.ch/eu-datagrid/license.html', 'https://opensource.org/licenses/EUDatagrid'],
      isOsiApproved: true}, {
      reference: './EUPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/EUPL-1.0.json',
      referenceNumber: '167',
      name: 'European Union Public License 1.0',
      licenseId: 'EUPL-1.0',
      seeAlso: ['http://ec.europa.eu/idabc/en/document/7330.html', 'http://ec.europa.eu/idabc/servlets/Doc027f.pdf?id=31096'],
      isOsiApproved: false}, {
      reference: './EUPL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EUPL-1.1.json',
      referenceNumber: '87',
      name: 'European Union Public License 1.1',
      licenseId: 'EUPL-1.1',
      seeAlso: ['https://joinup.ec.europa.eu/software/page/eupl/licence-eupl', 'https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/eupl1.1.-licence-en_0.pdf', 'https://opensource.org/licenses/EUPL-1.1'],
      isOsiApproved: true}, {
      reference: './EUPL-1.2.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EUPL-1.2.json',
      referenceNumber: '374',
      name: 'European Union Public License 1.2',
      licenseId: 'EUPL-1.2',
      seeAlso: ['https://joinup.ec.europa.eu/page/eupl-text-11-12', 'https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/eupl_v1.2_en.pdf', 'https://joinup.ec.europa.eu/sites/default/files/inline-files/EUPL%20v1_2%20EN(1).txt', 'http://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:32017D0863', 'https://opensource.org/licenses/EUPL-1.1'],
      isOsiApproved: true}, {
      reference: './Entessa.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Entessa.json',
      referenceNumber: '94',
      name: 'Entessa Public License v1.0',
      licenseId: 'Entessa',
      seeAlso: ['https://opensource.org/licenses/Entessa'],
      isOsiApproved: true}, {
      reference: './ErlPL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ErlPL-1.1.json',
      referenceNumber: '151',
      name: 'Erlang Public License v1.1',
      licenseId: 'ErlPL-1.1',
      seeAlso: ['http://www.erlang.org/EPLICENSE'],
      isOsiApproved: false}, {
      reference: './Eurosym.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Eurosym.json',
      referenceNumber: '107',
      name: 'Eurosym License',
      licenseId: 'Eurosym',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Eurosym'],
      isOsiApproved: false}, {
      reference: './FSFAP.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/FSFAP.json',
      referenceNumber: '108',
      name: 'FSF All Permissive License',
      licenseId: 'FSFAP',
      seeAlso: ['https://www.gnu.org/prep/maintain/html_node/License-Notices-for-Other-Files.html'],
      isOsiApproved: false}, {
      reference: './FSFUL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/FSFUL.json',
      referenceNumber: '187',
      name: 'FSF Unlimited License',
      licenseId: 'FSFUL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/FSF_Unlimited_License'],
      isOsiApproved: false}, {
      reference: './FSFULLR.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/FSFULLR.json',
      referenceNumber: '41',
      name: 'FSF Unlimited License (with License Retention)',
      licenseId: 'FSFULLR',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/FSF_Unlimited_License#License_Retention_Variant'],
      isOsiApproved: false}, {
      reference: './FTL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/FTL.json',
      referenceNumber: '234',
      name: 'Freetype Project License',
      licenseId: 'FTL',
      seeAlso: ['http://freetype.fis.uniroma2.it/FTL.TXT', 'http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/docs/FTL.TXT'],
      isOsiApproved: false}, {
      reference: './Fair.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Fair.json',
      referenceNumber: '290',
      name: 'Fair License',
      licenseId: 'Fair',
      seeAlso: ['http://fairlicense.org/', 'https://opensource.org/licenses/Fair'],
      isOsiApproved: true}, {
      reference: './Frameworx-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Frameworx-1.0.json',
      referenceNumber: '376',
      name: 'Frameworx Open License 1.0',
      licenseId: 'Frameworx-1.0',
      seeAlso: ['https://opensource.org/licenses/Frameworx-1.0'],
      isOsiApproved: true}, {
      reference: './FreeImage.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/FreeImage.json',
      referenceNumber: '270',
      name: 'FreeImage Public License v1.0',
      licenseId: 'FreeImage',
      seeAlso: ['http://freeimage.sourceforge.net/freeimage-license.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.1.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.1.json',
      referenceNumber: '93',
      name: 'GNU Free Documentation License v1.1',
      licenseId: 'GFDL-1.1',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.1-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.1-only.json',
      referenceNumber: '97',
      name: 'GNU Free Documentation License v1.1 only',
      licenseId: 'GFDL-1.1-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.1-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.1-or-later.json',
      referenceNumber: '338',
      name: 'GNU Free Documentation License v1.1 or later',
      licenseId: 'GFDL-1.1-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.2.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.2.json',
      referenceNumber: '191',
      name: 'GNU Free Documentation License v1.2',
      licenseId: 'GFDL-1.2',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.2-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.2-only.json',
      referenceNumber: '230',
      name: 'GNU Free Documentation License v1.2 only',
      licenseId: 'GFDL-1.2-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.2-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.2-or-later.json',
      referenceNumber: '209',
      name: 'GNU Free Documentation License v1.2 or later',
      licenseId: 'GFDL-1.2-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.3.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.3.json',
      referenceNumber: '106',
      name: 'GNU Free Documentation License v1.3',
      licenseId: 'GFDL-1.3',
      seeAlso: ['https://www.gnu.org/licenses/fdl-1.3.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.3-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.3-only.json',
      referenceNumber: '67',
      name: 'GNU Free Documentation License v1.3 only',
      licenseId: 'GFDL-1.3-only',
      seeAlso: ['https://www.gnu.org/licenses/fdl-1.3.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.3-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.3-or-later.json',
      referenceNumber: '3',
      name: 'GNU Free Documentation License v1.3 or later',
      licenseId: 'GFDL-1.3-or-later',
      seeAlso: ['https://www.gnu.org/licenses/fdl-1.3.txt'],
      isOsiApproved: false}, {
      reference: './GL2PS.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/GL2PS.json',
      referenceNumber: '118',
      name: 'GL2PS License',
      licenseId: 'GL2PS',
      seeAlso: ['http://www.geuz.org/gl2ps/COPYING.GL2PS'],
      isOsiApproved: false}, {
      reference: './GPL-1.0.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-1.0.json',
      referenceNumber: '75',
      name: 'GNU General Public License v1.0 only',
      licenseId: 'GPL-1.0',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html'],
      isOsiApproved: false}, {
      reference: './GPL-1.0+.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-1.0+.json',
      referenceNumber: '169',
      name: 'GNU General Public License v1.0 or later',
      licenseId: 'GPL-1.0+',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html'],
      isOsiApproved: false}, {
      reference: './GPL-1.0-only.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/GPL-1.0-only.json',
      referenceNumber: '14',
      name: 'GNU General Public License v1.0 only',
      licenseId: 'GPL-1.0-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html'],
      isOsiApproved: false}, {
      reference: './GPL-1.0-or-later.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/GPL-1.0-or-later.json',
      referenceNumber: '345',
      name: 'GNU General Public License v1.0 or later',
      licenseId: 'GPL-1.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html'],
      isOsiApproved: false}, {
      reference: './GPL-2.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0.json',
      referenceNumber: '141',
      name: 'GNU General Public License v2.0 only',
      licenseId: 'GPL-2.0',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html', 'https://opensource.org/licenses/GPL-2.0'],
      isOsiApproved: true}, {
      reference: './GPL-2.0+.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0+.json',
      referenceNumber: '72',
      name: 'GNU General Public License v2.0 or later',
      licenseId: 'GPL-2.0+',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html', 'https://opensource.org/licenses/GPL-2.0'],
      isOsiApproved: true}, {
      reference: './GPL-2.0-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-only.json',
      referenceNumber: '227',
      name: 'GNU General Public License v2.0 only',
      licenseId: 'GPL-2.0-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html', 'https://opensource.org/licenses/GPL-2.0'],
      isOsiApproved: true}, {
      reference: './GPL-2.0-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-or-later.json',
      referenceNumber: '54',
      name: 'GNU General Public License v2.0 or later',
      licenseId: 'GPL-2.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html', 'https://opensource.org/licenses/GPL-2.0'],
      isOsiApproved: true}, {
      reference: './GPL-2.0-with-GCC-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-GCC-exception.json',
      referenceNumber: '111',
      name: 'GNU General Public License v2.0 w/GCC Runtime Library exception',
      licenseId: 'GPL-2.0-with-GCC-exception',
      seeAlso: ['https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/libgcc1.c;h=762f5143fc6eed57b6797c82710f3538aa52b40b;hb=cb143a3ce4fb417c68f5fa2691a1b1b1053dfba9#l10'],
      isOsiApproved: false}, {
      reference: './GPL-2.0-with-autoconf-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-autoconf-exception.json',
      referenceNumber: '344',
      name: 'GNU General Public License v2.0 w/Autoconf exception',
      licenseId: 'GPL-2.0-with-autoconf-exception',
      seeAlso: ['http://ac-archive.sourceforge.net/doc/copyright.html'],
      isOsiApproved: false}, {
      reference: './GPL-2.0-with-bison-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-bison-exception.json',
      referenceNumber: '365',
      name: 'GNU General Public License v2.0 w/Bison exception',
      licenseId: 'GPL-2.0-with-bison-exception',
      seeAlso: ['http://git.savannah.gnu.org/cgit/bison.git/tree/data/yacc.c?id=193d7c7054ba7197b0789e14965b739162319b5e#n141'],
      isOsiApproved: false}, {
      reference: './GPL-2.0-with-classpath-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-classpath-exception.json',
      referenceNumber: '58',
      name: 'GNU General Public License v2.0 w/Classpath exception',
      licenseId: 'GPL-2.0-with-classpath-exception',
      seeAlso: ['https://www.gnu.org/software/classpath/license.html'],
      isOsiApproved: false}, {
      reference: './GPL-2.0-with-font-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-font-exception.json',
      referenceNumber: '362',
      name: 'GNU General Public License v2.0 w/Font exception',
      licenseId: 'GPL-2.0-with-font-exception',
      seeAlso: ['https://www.gnu.org/licenses/gpl-faq.html#FontException'],
      isOsiApproved: false}, {
      reference: './GPL-3.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0.json',
      referenceNumber: '236',
      name: 'GNU General Public License v3.0 only',
      licenseId: 'GPL-3.0',
      seeAlso: ['https://www.gnu.org/licenses/gpl-3.0-standalone.html', 'https://opensource.org/licenses/GPL-3.0'],
      isOsiApproved: true}, {
      reference: './GPL-3.0+.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0+.json',
      referenceNumber: '70',
      name: 'GNU General Public License v3.0 or later',
      licenseId: 'GPL-3.0+',
      seeAlso: ['https://www.gnu.org/licenses/gpl-3.0-standalone.html', 'https://opensource.org/licenses/GPL-3.0'],
      isOsiApproved: true}, {
      reference: './GPL-3.0-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0-only.json',
      referenceNumber: '200',
      name: 'GNU General Public License v3.0 only',
      licenseId: 'GPL-3.0-only',
      seeAlso: ['https://www.gnu.org/licenses/gpl-3.0-standalone.html', 'https://opensource.org/licenses/GPL-3.0'],
      isOsiApproved: true}, {
      reference: './GPL-3.0-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0-or-later.json',
      referenceNumber: '190',
      name: 'GNU General Public License v3.0 or later',
      licenseId: 'GPL-3.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/gpl-3.0-standalone.html', 'https://opensource.org/licenses/GPL-3.0'],
      isOsiApproved: true}, {
      reference: './GPL-3.0-with-GCC-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0-with-GCC-exception.json',
      referenceNumber: '215',
      name: 'GNU General Public License v3.0 w/GCC Runtime Library exception',
      licenseId: 'GPL-3.0-with-GCC-exception',
      seeAlso: ['https://www.gnu.org/licenses/gcc-exception-3.1.html'],
      isOsiApproved: true}, {
      reference: './GPL-3.0-with-autoconf-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0-with-autoconf-exception.json',
      referenceNumber: '229',
      name: 'GNU General Public License v3.0 w/Autoconf exception',
      licenseId: 'GPL-3.0-with-autoconf-exception',
      seeAlso: ['https://www.gnu.org/licenses/autoconf-exception-3.0.html'],
      isOsiApproved: false}, {
      reference: './Giftware.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Giftware.json',
      referenceNumber: '357',
      name: 'Giftware License',
      licenseId: 'Giftware',
      seeAlso: ['http://liballeg.org/license.html#allegro-4-the-giftware-license'],
      isOsiApproved: false}, {
      reference: './Glide.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Glide.json',
      referenceNumber: '361',
      name: '3dfx Glide License',
      licenseId: 'Glide',
      seeAlso: ['http://www.users.on.net/~triforce/glidexp/COPYING.txt'],
      isOsiApproved: false}, {
      reference: './Glulxe.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Glulxe.json',
      referenceNumber: '88',
      name: 'Glulxe License',
      licenseId: 'Glulxe',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Glulxe'],
      isOsiApproved: false}, {
      reference: './HPND.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/HPND.json',
      referenceNumber: '258',
      name: 'Historical Permission Notice and Disclaimer',
      licenseId: 'HPND',
      seeAlso: ['https://opensource.org/licenses/HPND'],
      isOsiApproved: true}, {
      reference: './HPND-sell-variant.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/HPND-sell-variant.json',
      referenceNumber: '139',
      name: 'Historical Permission Notice and Disclaimer - sell variant',
      licenseId: 'HPND-sell-variant',
      seeAlso: ['https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/auth_gss/gss_generic_token.c?h=v4.19'],
      isOsiApproved: false}, {
      reference: './HaskellReport.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/HaskellReport.json',
      referenceNumber: '116',
      name: 'Haskell Language Report License',
      licenseId: 'HaskellReport',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Haskell_Language_Report_License'],
      isOsiApproved: false}, {
      reference: './IBM-pibs.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/IBM-pibs.json',
      referenceNumber: '201',
      name: 'IBM PowerPC Initialization and Boot Software',
      licenseId: 'IBM-pibs',
      seeAlso: ['http://git.denx.de/?p=u-boot.git;a=blob;f=arch/powerpc/cpu/ppc4xx/miiphy.c;h=297155fdafa064b955e53e9832de93bfb0cfb85b;hb=9fab4bf4cc077c21e43941866f3f2c196f28670d'],
      isOsiApproved: false}, {
      reference: './ICU.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ICU.json',
      referenceNumber: '188',
      name: 'ICU License',
      licenseId: 'ICU',
      seeAlso: ['http://source.icu-project.org/repos/icu/icu/trunk/license.html'],
      isOsiApproved: false}, {
      reference: './IJG.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/IJG.json',
      referenceNumber: '53',
      name: 'Independent JPEG Group License',
      licenseId: 'IJG',
      seeAlso: ['http://dev.w3.org/cvsweb/Amaya/libjpeg/Attic/README?rev=1.2'],
      isOsiApproved: false}, {
      reference: './IPA.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/IPA.json',
      referenceNumber: '305',
      name: 'IPA Font License',
      licenseId: 'IPA',
      seeAlso: ['https://opensource.org/licenses/IPA'],
      isOsiApproved: true}, {
      reference: './IPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/IPL-1.0.json',
      referenceNumber: '29',
      name: 'IBM Public License v1.0',
      licenseId: 'IPL-1.0',
      seeAlso: ['https://opensource.org/licenses/IPL-1.0'],
      isOsiApproved: true}, {
      reference: './ISC.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ISC.json',
      referenceNumber: '104',
      name: 'ISC License',
      licenseId: 'ISC',
      seeAlso: ['https://www.isc.org/downloads/software-support-policy/isc-license/', 'https://opensource.org/licenses/ISC'],
      isOsiApproved: true}, {
      reference: './ImageMagick.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ImageMagick.json',
      referenceNumber: '225',
      name: 'ImageMagick License',
      licenseId: 'ImageMagick',
      seeAlso: ['http://www.imagemagick.org/script/license.php'],
      isOsiApproved: false}, {
      reference: './Imlib2.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Imlib2.json',
      referenceNumber: '251',
      name: 'Imlib2 License',
      licenseId: 'Imlib2',
      seeAlso: ['http://trac.enlightenment.org/e/browser/trunk/imlib2/COPYING', 'https://git.enlightenment.org/legacy/imlib2.git/tree/COPYING'],
      isOsiApproved: false}, {
      reference: './Info-ZIP.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Info-ZIP.json',
      referenceNumber: '99',
      name: 'Info-ZIP License',
      licenseId: 'Info-ZIP',
      seeAlso: ['http://www.info-zip.org/license.html'],
      isOsiApproved: false}, {
      reference: './Intel.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Intel.json',
      referenceNumber: '161',
      name: 'Intel Open Source License',
      licenseId: 'Intel',
      seeAlso: ['https://opensource.org/licenses/Intel'],
      isOsiApproved: true}, {
      reference: './Intel-ACPI.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Intel-ACPI.json',
      referenceNumber: '84',
      name: 'Intel ACPI Software License Agreement',
      licenseId: 'Intel-ACPI',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Intel_ACPI_Software_License_Agreement'],
      isOsiApproved: false}, {
      reference: './Interbase-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Interbase-1.0.json',
      referenceNumber: '79',
      name: 'Interbase Public License v1.0',
      licenseId: 'Interbase-1.0',
      seeAlso: ['https://web.archive.org/web/20060319014854/http://info.borland.com/devsupport/interbase/opensource/IPL.html'],
      isOsiApproved: false}, {
      reference: './JSON.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/JSON.json',
      referenceNumber: '359',
      name: 'JSON License',
      licenseId: 'JSON',
      seeAlso: ['http://www.json.org/license.html'],
      isOsiApproved: false}, {
      reference: './JasPer-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/JasPer-2.0.json',
      referenceNumber: '233',
      name: 'JasPer License',
      licenseId: 'JasPer-2.0',
      seeAlso: ['http://www.ece.uvic.ca/~mdadams/jasper/LICENSE'],
      isOsiApproved: false}, {
      reference: './LAL-1.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LAL-1.2.json',
      referenceNumber: '367',
      name: 'Licence Art Libre 1.2',
      licenseId: 'LAL-1.2',
      seeAlso: ['http://artlibre.org/licence/lal/licence-art-libre-12/'],
      isOsiApproved: false}, {
      reference: './LAL-1.3.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LAL-1.3.json',
      referenceNumber: '150',
      name: 'Licence Art Libre 1.3',
      licenseId: 'LAL-1.3',
      seeAlso: ['http://artlibre.org/'],
      isOsiApproved: false}, {
      reference: './LGPL-2.0.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.0.json',
      referenceNumber: '261',
      name: 'GNU Library General Public License v2 only',
      licenseId: 'LGPL-2.0',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html'],
      isOsiApproved: true}, {
      reference: './LGPL-2.0+.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.0+.json',
      referenceNumber: '50',
      name: 'GNU Library General Public License v2 or later',
      licenseId: 'LGPL-2.0+',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html'],
      isOsiApproved: true}, {
      reference: './LGPL-2.0-only.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.0-only.json',
      referenceNumber: '269',
      name: 'GNU Library General Public License v2 only',
      licenseId: 'LGPL-2.0-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html'],
      isOsiApproved: true}, {
      reference: './LGPL-2.0-or-later.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.0-or-later.json',
      referenceNumber: '211',
      name: 'GNU Library General Public License v2 or later',
      licenseId: 'LGPL-2.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html'],
      isOsiApproved: true}, {
      reference: './LGPL-2.1.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.1.json',
      referenceNumber: '160',
      name: 'GNU Lesser General Public License v2.1 only',
      licenseId: 'LGPL-2.1',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html', 'https://opensource.org/licenses/LGPL-2.1'],
      isOsiApproved: true}, {
      reference: './LGPL-2.1+.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.1+.json',
      referenceNumber: '62',
      name: 'GNU Library General Public License v2.1 or later',
      licenseId: 'LGPL-2.1+',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html', 'https://opensource.org/licenses/LGPL-2.1'],
      isOsiApproved: true}, {
      reference: './LGPL-2.1-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.1-only.json',
      referenceNumber: '2',
      name: 'GNU Lesser General Public License v2.1 only',
      licenseId: 'LGPL-2.1-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html', 'https://opensource.org/licenses/LGPL-2.1'],
      isOsiApproved: true}, {
      reference: './LGPL-2.1-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.1-or-later.json',
      referenceNumber: '329',
      name: 'GNU Lesser General Public License v2.1 or later',
      licenseId: 'LGPL-2.1-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html', 'https://opensource.org/licenses/LGPL-2.1'],
      isOsiApproved: true}, {
      reference: './LGPL-3.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-3.0.json',
      referenceNumber: '204',
      name: 'GNU Lesser General Public License v3.0 only',
      licenseId: 'LGPL-3.0',
      seeAlso: ['https://www.gnu.org/licenses/lgpl-3.0-standalone.html', 'https://opensource.org/licenses/LGPL-3.0'],
      isOsiApproved: true}, {
      reference: './LGPL-3.0+.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-3.0+.json',
      referenceNumber: '146',
      name: 'GNU Lesser General Public License v3.0 or later',
      licenseId: 'LGPL-3.0+',
      seeAlso: ['https://www.gnu.org/licenses/lgpl-3.0-standalone.html', 'https://opensource.org/licenses/LGPL-3.0'],
      isOsiApproved: true}, {
      reference: './LGPL-3.0-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-3.0-only.json',
      referenceNumber: '248',
      name: 'GNU Lesser General Public License v3.0 only',
      licenseId: 'LGPL-3.0-only',
      seeAlso: ['https://www.gnu.org/licenses/lgpl-3.0-standalone.html', 'https://opensource.org/licenses/LGPL-3.0'],
      isOsiApproved: true}, {
      reference: './LGPL-3.0-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-3.0-or-later.json',
      referenceNumber: '294',
      name: 'GNU Lesser General Public License v3.0 or later',
      licenseId: 'LGPL-3.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/lgpl-3.0-standalone.html', 'https://opensource.org/licenses/LGPL-3.0'],
      isOsiApproved: true}, {
      reference: './LGPLLR.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LGPLLR.json',
      referenceNumber: '98',
      name: 'Lesser General Public License For Linguistic Resources',
      licenseId: 'LGPLLR',
      seeAlso: ['http://www-igm.univ-mlv.fr/~unitex/lgpllr.html'],
      isOsiApproved: false}, {
      reference: './LPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LPL-1.0.json',
      referenceNumber: '85',
      name: 'Lucent Public License Version 1.0',
      licenseId: 'LPL-1.0',
      seeAlso: ['https://opensource.org/licenses/LPL-1.0'],
      isOsiApproved: true}, {
      reference: './LPL-1.02.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LPL-1.02.json',
      referenceNumber: '125',
      name: 'Lucent Public License v1.02',
      licenseId: 'LPL-1.02',
      seeAlso: ['http://plan9.bell-labs.com/plan9/license.html', 'https://opensource.org/licenses/LPL-1.02'],
      isOsiApproved: true}, {
      reference: './LPPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LPPL-1.0.json',
      referenceNumber: '253',
      name: 'LaTeX Project Public License v1.0',
      licenseId: 'LPPL-1.0',
      seeAlso: ['http://www.latex-project.org/lppl/lppl-1-0.txt'],
      isOsiApproved: false}, {
      reference: './LPPL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LPPL-1.1.json',
      referenceNumber: '302',
      name: 'LaTeX Project Public License v1.1',
      licenseId: 'LPPL-1.1',
      seeAlso: ['http://www.latex-project.org/lppl/lppl-1-1.txt'],
      isOsiApproved: false}, {
      reference: './LPPL-1.2.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LPPL-1.2.json',
      referenceNumber: '379',
      name: 'LaTeX Project Public License v1.2',
      licenseId: 'LPPL-1.2',
      seeAlso: ['http://www.latex-project.org/lppl/lppl-1-2.txt'],
      isOsiApproved: false}, {
      reference: './LPPL-1.3a.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LPPL-1.3a.json',
      referenceNumber: '298',
      name: 'LaTeX Project Public License v1.3a',
      licenseId: 'LPPL-1.3a',
      seeAlso: ['http://www.latex-project.org/lppl/lppl-1-3a.txt'],
      isOsiApproved: false}, {
      reference: './LPPL-1.3c.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LPPL-1.3c.json',
      referenceNumber: '318',
      name: 'LaTeX Project Public License v1.3c',
      licenseId: 'LPPL-1.3c',
      seeAlso: ['http://www.latex-project.org/lppl/lppl-1-3c.txt', 'https://opensource.org/licenses/LPPL-1.3c'],
      isOsiApproved: true}, {
      reference: './Latex2e.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Latex2e.json',
      referenceNumber: '276',
      name: 'Latex2e License',
      licenseId: 'Latex2e',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Latex2e'],
      isOsiApproved: false}, {
      reference: './Leptonica.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Leptonica.json',
      referenceNumber: '153',
      name: 'Leptonica License',
      licenseId: 'Leptonica',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Leptonica'],
      isOsiApproved: false}, {
      reference: './LiLiQ-P-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LiLiQ-P-1.1.json',
      referenceNumber: '366',
      name: 'Licence Libre du Qu\xe9bec \u2013 Permissive version 1.1',
      licenseId: 'LiLiQ-P-1.1',
      seeAlso: ['https://forge.gouv.qc.ca/licence/fr/liliq-v1-1/', 'http://opensource.org/licenses/LiLiQ-P-1.1'],
      isOsiApproved: true}, {
      reference: './LiLiQ-R-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LiLiQ-R-1.1.json',
      referenceNumber: '279',
      name: 'Licence Libre du Qu\xe9bec \u2013 R\xe9ciprocit\xe9 version 1.1',
      licenseId: 'LiLiQ-R-1.1',
      seeAlso: ['https://www.forge.gouv.qc.ca/participez/licence-logicielle/licence-libre-du-quebec-liliq-en-francais/licence-libre-du-quebec-reciprocite-liliq-r-v1-1/', 'http://opensource.org/licenses/LiLiQ-R-1.1'],
      isOsiApproved: true}, {
      reference: './LiLiQ-Rplus-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LiLiQ-Rplus-1.1.json',
      referenceNumber: '133',
      name: 'Licence Libre du Qu\xe9bec \u2013 R\xe9ciprocit\xe9 forte version 1.1',
      licenseId: 'LiLiQ-Rplus-1.1',
      seeAlso: ['https://www.forge.gouv.qc.ca/participez/licence-logicielle/licence-libre-du-quebec-liliq-en-francais/licence-libre-du-quebec-reciprocite-forte-liliq-r-v1-1/', 'http://opensource.org/licenses/LiLiQ-Rplus-1.1'],
      isOsiApproved: true}, {
      reference: './Libpng.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Libpng.json',
      referenceNumber: '96',
      name: 'libpng License',
      licenseId: 'Libpng',
      seeAlso: ['http://www.libpng.org/pub/png/src/libpng-LICENSE.txt'],
      isOsiApproved: false}, {
      reference: './Linux-OpenIB.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Linux-OpenIB.json',
      referenceNumber: '4',
      name: 'Linux Kernel Variant of OpenIB.org license',
      licenseId: 'Linux-OpenIB',
      seeAlso: ['https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/infiniband/core/sa.h'],
      isOsiApproved: false}, {
      reference: './MIT.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/MIT.json',
      referenceNumber: '195',
      name: 'MIT License',
      licenseId: 'MIT',
      seeAlso: ['https://opensource.org/licenses/MIT'],
      isOsiApproved: true}, {
      reference: './MIT-0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MIT-0.json',
      referenceNumber: '5',
      name: 'MIT No Attribution',
      licenseId: 'MIT-0',
      seeAlso: ['https://github.com/aws/mit-0', 'https://romanrm.net/mit-zero', 'https://github.com/awsdocs/aws-cloud9-user-guide/blob/master/LICENSE-SAMPLECODE'],
      isOsiApproved: true}, {
      reference: './MIT-CMU.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MIT-CMU.json',
      referenceNumber: '8',
      name: 'CMU License',
      licenseId: 'MIT-CMU',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing:MIT?rd=Licensing/MIT#CMU_Style'],
      isOsiApproved: false}, {
      reference: './MIT-advertising.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MIT-advertising.json',
      referenceNumber: '7',
      name: 'Enlightenment License (e16)',
      licenseId: 'MIT-advertising',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT_With_Advertising'],
      isOsiApproved: false}, {
      reference: './MIT-enna.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MIT-enna.json',
      referenceNumber: '23',
      name: 'enna License',
      licenseId: 'MIT-enna',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT#enna'],
      isOsiApproved: false}, {
      reference: './MIT-feh.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MIT-feh.json',
      referenceNumber: '36',
      name: 'feh License',
      licenseId: 'MIT-feh',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT#feh'],
      isOsiApproved: false}, {
      reference: './MITNFA.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MITNFA.json',
      referenceNumber: '287',
      name: 'MIT +no-false-attribs license',
      licenseId: 'MITNFA',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MITNFA'],
      isOsiApproved: false}, {
      reference: './MPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MPL-1.0.json',
      referenceNumber: '47',
      name: 'Mozilla Public License 1.0',
      licenseId: 'MPL-1.0',
      seeAlso: ['http://www.mozilla.org/MPL/MPL-1.0.html', 'https://opensource.org/licenses/MPL-1.0'],
      isOsiApproved: true}, {
      reference: './MPL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/MPL-1.1.json',
      referenceNumber: '297',
      name: 'Mozilla Public License 1.1',
      licenseId: 'MPL-1.1',
      seeAlso: ['http://www.mozilla.org/MPL/MPL-1.1.html', 'https://opensource.org/licenses/MPL-1.1'],
      isOsiApproved: true}, {
      reference: './MPL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/MPL-2.0.json',
      referenceNumber: '228',
      name: 'Mozilla Public License 2.0',
      licenseId: 'MPL-2.0',
      seeAlso: ['http://www.mozilla.org/MPL/2.0/', 'https://opensource.org/licenses/MPL-2.0'],
      isOsiApproved: true}, {
      reference: './MPL-2.0-no-copyleft-exception.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MPL-2.0-no-copyleft-exception.json',
      referenceNumber: '296',
      name: 'Mozilla Public License 2.0 (no copyleft exception)',
      licenseId: 'MPL-2.0-no-copyleft-exception',
      seeAlso: ['http://www.mozilla.org/MPL/2.0/', 'https://opensource.org/licenses/MPL-2.0'],
      isOsiApproved: true}, {
      reference: './MS-PL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/MS-PL.json',
      referenceNumber: '327',
      name: 'Microsoft Public License',
      licenseId: 'MS-PL',
      seeAlso: ['http://www.microsoft.com/opensource/licenses.mspx', 'https://opensource.org/licenses/MS-PL'],
      isOsiApproved: true}, {
      reference: './MS-RL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/MS-RL.json',
      referenceNumber: '273',
      name: 'Microsoft Reciprocal License',
      licenseId: 'MS-RL',
      seeAlso: ['http://www.microsoft.com/opensource/licenses.mspx', 'https://opensource.org/licenses/MS-RL'],
      isOsiApproved: true}, {
      reference: './MTLL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MTLL.json',
      referenceNumber: '175',
      name: 'Matrix Template Library License',
      licenseId: 'MTLL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Matrix_Template_Library_License'],
      isOsiApproved: false}, {
      reference: './MakeIndex.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MakeIndex.json',
      referenceNumber: '181',
      name: 'MakeIndex License',
      licenseId: 'MakeIndex',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MakeIndex'],
      isOsiApproved: false}, {
      reference: './MirOS.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MirOS.json',
      referenceNumber: '292',
      name: 'MirOS License',
      licenseId: 'MirOS',
      seeAlso: ['https://opensource.org/licenses/MirOS'],
      isOsiApproved: true}, {
      reference: './Motosoto.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Motosoto.json',
      referenceNumber: '309',
      name: 'Motosoto License',
      licenseId: 'Motosoto',
      seeAlso: ['https://opensource.org/licenses/Motosoto'],
      isOsiApproved: true}, {
      reference: './Multics.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Multics.json',
      referenceNumber: '61',
      name: 'Multics License',
      licenseId: 'Multics',
      seeAlso: ['https://opensource.org/licenses/Multics'],
      isOsiApproved: true}, {
      reference: './Mup.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Mup.json',
      referenceNumber: '342',
      name: 'Mup License',
      licenseId: 'Mup',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Mup'],
      isOsiApproved: false}, {
      reference: './NASA-1.3.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NASA-1.3.json',
      referenceNumber: '83',
      name: 'NASA Open Source Agreement 1.3',
      licenseId: 'NASA-1.3',
      seeAlso: ['http://ti.arc.nasa.gov/opensource/nosa/', 'https://opensource.org/licenses/NASA-1.3'],
      isOsiApproved: true}, {
      reference: './NBPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NBPL-1.0.json',
      referenceNumber: '349',
      name: 'Net Boolean Public License v1',
      licenseId: 'NBPL-1.0',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=37b4b3f6cc4bf34e1d3dec61e69914b9819d8894'],
      isOsiApproved: false}, {
      reference: './NCSA.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/NCSA.json',
      referenceNumber: '56',
      name: 'University of Illinois/NCSA Open Source License',
      licenseId: 'NCSA',
      seeAlso: ['http://otm.illinois.edu/uiuc_openSource', 'https://opensource.org/licenses/NCSA'],
      isOsiApproved: true}, {
      reference: './NGPL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NGPL.json',
      referenceNumber: '69',
      name: 'Nethack General Public License',
      licenseId: 'NGPL',
      seeAlso: ['https://opensource.org/licenses/NGPL'],
      isOsiApproved: true}, {
      reference: './NLOD-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NLOD-1.0.json',
      referenceNumber: '203',
      name: 'Norwegian Licence for Open Government Data',
      licenseId: 'NLOD-1.0',
      seeAlso: ['http://data.norge.no/nlod/en/1.0'],
      isOsiApproved: false}, {
      reference: './NLPL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NLPL.json',
      referenceNumber: '334',
      name: 'No Limit Public License',
      licenseId: 'NLPL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/NLPL'],
      isOsiApproved: false}, {
      reference: './NOSL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/NOSL.json',
      referenceNumber: '370',
      name: 'Netizen Open Source License',
      licenseId: 'NOSL',
      seeAlso: ['http://bits.netizen.com.au/licenses/NOSL/nosl.txt'],
      isOsiApproved: false}, {
      reference: './NPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/NPL-1.0.json',
      referenceNumber: '320',
      name: 'Netscape Public License v1.0',
      licenseId: 'NPL-1.0',
      seeAlso: ['http://www.mozilla.org/MPL/NPL/1.0/'],
      isOsiApproved: false}, {
      reference: './NPL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/NPL-1.1.json',
      referenceNumber: '179',
      name: 'Netscape Public License v1.1',
      licenseId: 'NPL-1.1',
      seeAlso: ['http://www.mozilla.org/MPL/NPL/1.1/'],
      isOsiApproved: false}, {
      reference: './NPOSL-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NPOSL-3.0.json',
      referenceNumber: '216',
      name: 'Non-Profit Open Software License 3.0',
      licenseId: 'NPOSL-3.0',
      seeAlso: ['https://opensource.org/licenses/NOSL3.0'],
      isOsiApproved: true}, {
      reference: './NRL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NRL.json',
      referenceNumber: '51',
      name: 'NRL License',
      licenseId: 'NRL',
      seeAlso: ['http://web.mit.edu/network/isakmp/nrllicense.html'],
      isOsiApproved: false}, {
      reference: './NTP.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NTP.json',
      referenceNumber: '255',
      name: 'NTP License',
      licenseId: 'NTP',
      seeAlso: ['https://opensource.org/licenses/NTP'],
      isOsiApproved: true}, {
      reference: './Naumen.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Naumen.json',
      referenceNumber: '271',
      name: 'Naumen Public License',
      licenseId: 'Naumen',
      seeAlso: ['https://opensource.org/licenses/Naumen'],
      isOsiApproved: true}, {
      reference: './Net-SNMP.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Net-SNMP.json',
      referenceNumber: '277',
      name: 'Net-SNMP License',
      licenseId: 'Net-SNMP',
      seeAlso: ['http://net-snmp.sourceforge.net/about/license.html'],
      isOsiApproved: false}, {
      reference: './NetCDF.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NetCDF.json',
      referenceNumber: '44',
      name: 'NetCDF license',
      licenseId: 'NetCDF',
      seeAlso: ['http://www.unidata.ucar.edu/software/netcdf/copyright.html'],
      isOsiApproved: false}, {
      reference: './Newsletr.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Newsletr.json',
      referenceNumber: '272',
      name: 'Newsletr License',
      licenseId: 'Newsletr',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Newsletr'],
      isOsiApproved: false}, {
      reference: './Nokia.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Nokia.json',
      referenceNumber: '319',
      name: 'Nokia Open Source License',
      licenseId: 'Nokia',
      seeAlso: ['https://opensource.org/licenses/nokia'],
      isOsiApproved: true}, {
      reference: './Noweb.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Noweb.json',
      referenceNumber: '352',
      name: 'Noweb License',
      licenseId: 'Noweb',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Noweb'],
      isOsiApproved: false}, {
      reference: './Nunit.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Nunit.json',
      referenceNumber: '281',
      name: 'Nunit License',
      licenseId: 'Nunit',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Nunit'],
      isOsiApproved: false}, {
      reference: './OCCT-PL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OCCT-PL.json',
      referenceNumber: '275',
      name: 'Open CASCADE Technology Public License',
      licenseId: 'OCCT-PL',
      seeAlso: ['http://www.opencascade.com/content/occt-public-license'],
      isOsiApproved: false}, {
      reference: './OCLC-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OCLC-2.0.json',
      referenceNumber: '105',
      name: 'OCLC Research Public License 2.0',
      licenseId: 'OCLC-2.0',
      seeAlso: ['http://www.oclc.org/research/activities/software/license/v2final.htm', 'https://opensource.org/licenses/OCLC-2.0'],
      isOsiApproved: true}, {
      reference: './ODC-By-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ODC-By-1.0.json',
      referenceNumber: '138',
      name: 'Open Data Commons Attribution License v1.0',
      licenseId: 'ODC-By-1.0',
      seeAlso: ['https://opendatacommons.org/licenses/by/1.0/'],
      isOsiApproved: false}, {
      reference: './ODbL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ODbL-1.0.json',
      referenceNumber: '240',
      name: 'ODC Open Database License v1.0',
      licenseId: 'ODbL-1.0',
      seeAlso: ['http://www.opendatacommons.org/licenses/odbl/1.0/'],
      isOsiApproved: false}, {
      reference: './OFL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OFL-1.0.json',
      referenceNumber: '147',
      name: 'SIL Open Font License 1.0',
      licenseId: 'OFL-1.0',
      seeAlso: ['http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web'],
      isOsiApproved: false}, {
      reference: './OFL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OFL-1.1.json',
      referenceNumber: '307',
      name: 'SIL Open Font License 1.1',
      licenseId: 'OFL-1.1',
      seeAlso: ['http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web', 'https://opensource.org/licenses/OFL-1.1'],
      isOsiApproved: true}, {
      reference: './OGL-UK-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OGL-UK-1.0.json',
      referenceNumber: '110',
      name: 'Open Government Licence v1.0',
      licenseId: 'OGL-UK-1.0',
      seeAlso: ['http://www.nationalarchives.gov.uk/doc/open-government-licence/version/1/'],
      isOsiApproved: false}, {
      reference: './OGL-UK-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OGL-UK-2.0.json',
      referenceNumber: '282',
      name: 'Open Government Licence v2.0',
      licenseId: 'OGL-UK-2.0',
      seeAlso: ['http://www.nationalarchives.gov.uk/doc/open-government-licence/version/2/'],
      isOsiApproved: false}, {
      reference: './OGL-UK-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OGL-UK-3.0.json',
      referenceNumber: '220',
      name: 'Open Government Licence v3.0',
      licenseId: 'OGL-UK-3.0',
      seeAlso: ['http://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/'],
      isOsiApproved: false}, {
      reference: './OGTSL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OGTSL.json',
      referenceNumber: '119',
      name: 'Open Group Test Suite License',
      licenseId: 'OGTSL',
      seeAlso: ['http://www.opengroup.org/testing/downloads/The_Open_Group_TSL.txt', 'https://opensource.org/licenses/OGTSL'],
      isOsiApproved: true}, {
      reference: './OLDAP-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-1.1.json',
      referenceNumber: '92',
      name: 'Open LDAP Public License v1.1',
      licenseId: 'OLDAP-1.1',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=806557a5ad59804ef3a44d5abfbe91d706b0791f'],
      isOsiApproved: false}, {
      reference: './OLDAP-1.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-1.2.json',
      referenceNumber: '184',
      name: 'Open LDAP Public License v1.2',
      licenseId: 'OLDAP-1.2',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=42b0383c50c299977b5893ee695cf4e486fb0dc7'],
      isOsiApproved: false}, {
      reference: './OLDAP-1.3.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-1.3.json',
      referenceNumber: '100',
      name: 'Open LDAP Public License v1.3',
      licenseId: 'OLDAP-1.3',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=e5f8117f0ce088d0bd7a8e18ddf37eaa40eb09b1'],
      isOsiApproved: false}, {
      reference: './OLDAP-1.4.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-1.4.json',
      referenceNumber: '28',
      name: 'Open LDAP Public License v1.4',
      licenseId: 'OLDAP-1.4',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=c9f95c2f3f2ffb5e0ae55fe7388af75547660941'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.0.json',
      referenceNumber: '260',
      name: 'Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B)',
      licenseId: 'OLDAP-2.0',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=cbf50f4e1185a21abd4c0a54d3f4341fe28f36ea'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.0.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.0.1.json',
      referenceNumber: '339',
      name: 'Open LDAP Public License v2.0.1',
      licenseId: 'OLDAP-2.0.1',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=b6d68acd14e51ca3aab4428bf26522aa74873f0e'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.1.json',
      referenceNumber: '148',
      name: 'Open LDAP Public License v2.1',
      licenseId: 'OLDAP-2.1',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=b0d176738e96a0d3b9f85cb51e140a86f21be715'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.2.json',
      referenceNumber: '350',
      name: 'Open LDAP Public License v2.2',
      licenseId: 'OLDAP-2.2',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=470b0c18ec67621c85881b2733057fecf4a1acc3'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.2.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.2.1.json',
      referenceNumber: '330',
      name: 'Open LDAP Public License v2.2.1',
      licenseId: 'OLDAP-2.2.1',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=4bc786f34b50aa301be6f5600f58a980070f481e'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.2.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.2.2.json',
      referenceNumber: '193',
      name: 'Open LDAP Public License 2.2.2',
      licenseId: 'OLDAP-2.2.2',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=df2cc1e21eb7c160695f5b7cffd6296c151ba188'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.3.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.3.json',
      referenceNumber: '158',
      name: 'Open LDAP Public License v2.3',
      licenseId: 'OLDAP-2.3',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=d32cf54a32d581ab475d23c810b0a7fbaf8d63c3'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.4.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.4.json',
      referenceNumber: '64',
      name: 'Open LDAP Public License v2.4',
      licenseId: 'OLDAP-2.4',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=cd1284c4a91a8a380d904eee68d1583f989ed386'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.5.json',
      referenceNumber: '177',
      name: 'Open LDAP Public License v2.5',
      licenseId: 'OLDAP-2.5',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=6852b9d90022e8593c98205413380536b1b5a7cf'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.6.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.6.json',
      referenceNumber: '59',
      name: 'Open LDAP Public License v2.6',
      licenseId: 'OLDAP-2.6',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=1cae062821881f41b73012ba816434897abf4205'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.7.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.7.json',
      referenceNumber: '117',
      name: 'Open LDAP Public License v2.7',
      licenseId: 'OLDAP-2.7',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=47c2415c1df81556eeb39be6cad458ef87c534a2'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.8.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.8.json',
      referenceNumber: '35',
      name: 'Open LDAP Public License v2.8',
      licenseId: 'OLDAP-2.8',
      seeAlso: ['http://www.openldap.org/software/release/license.html'],
      isOsiApproved: false}, {
      reference: './OML.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OML.json',
      referenceNumber: '63',
      name: 'Open Market License',
      licenseId: 'OML',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Open_Market_License'],
      isOsiApproved: false}, {
      reference: './OPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OPL-1.0.json',
      referenceNumber: '333',
      name: 'Open Public License v1.0',
      licenseId: 'OPL-1.0',
      seeAlso: ['http://old.koalateam.com/jackaroo/OPL_1_0.TXT', 'https://fedoraproject.org/wiki/Licensing/Open_Public_License'],
      isOsiApproved: false}, {
      reference: './OSET-PL-2.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OSET-PL-2.1.json',
      referenceNumber: '284',
      name: 'OSET Public License version 2.1',
      licenseId: 'OSET-PL-2.1',
      seeAlso: ['http://www.osetfoundation.org/public-license', 'https://opensource.org/licenses/OPL-2.1'],
      isOsiApproved: true}, {
      reference: './OSL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OSL-1.0.json',
      referenceNumber: '81',
      name: 'Open Software License 1.0',
      licenseId: 'OSL-1.0',
      seeAlso: ['https://opensource.org/licenses/OSL-1.0'],
      isOsiApproved: true}, {
      reference: './OSL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OSL-1.1.json',
      referenceNumber: '325',
      name: 'Open Software License 1.1',
      licenseId: 'OSL-1.1',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/OSL1.1'],
      isOsiApproved: false}, {
      reference: './OSL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OSL-2.0.json',
      referenceNumber: '19',
      name: 'Open Software License 2.0',
      licenseId: 'OSL-2.0',
      seeAlso: ['http://web.archive.org/web/20041020171434/http://www.rosenlaw.com/osl2.0.html'],
      isOsiApproved: true}, {
      reference: './OSL-2.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OSL-2.1.json',
      referenceNumber: '22',
      name: 'Open Software License 2.1',
      licenseId: 'OSL-2.1',
      seeAlso: ['http://web.archive.org/web/20050212003940/http://www.rosenlaw.com/osl21.htm', 'https://opensource.org/licenses/OSL-2.1'],
      isOsiApproved: true}, {
      reference: './OSL-3.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OSL-3.0.json',
      referenceNumber: '95',
      name: 'Open Software License 3.0',
      licenseId: 'OSL-3.0',
      seeAlso: ['https://web.archive.org/web/20120101081418/http://rosenlaw.com:80/OSL3.0.htm', 'https://opensource.org/licenses/OSL-3.0'],
      isOsiApproved: true}, {
      reference: './OpenSSL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OpenSSL.json',
      referenceNumber: '243',
      name: 'OpenSSL License',
      licenseId: 'OpenSSL',
      seeAlso: ['http://www.openssl.org/source/license.html'],
      isOsiApproved: false}, {
      reference: './PDDL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/PDDL-1.0.json',
      referenceNumber: '13',
      name: 'ODC Public Domain Dedication & License 1.0',
      licenseId: 'PDDL-1.0',
      seeAlso: ['http://opendatacommons.org/licenses/pddl/1.0/'],
      isOsiApproved: false}, {
      reference: './PHP-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/PHP-3.0.json',
      referenceNumber: '372',
      name: 'PHP License v3.0',
      licenseId: 'PHP-3.0',
      seeAlso: ['http://www.php.net/license/3_0.txt', 'https://opensource.org/licenses/PHP-3.0'],
      isOsiApproved: true}, {
      reference: './PHP-3.01.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/PHP-3.01.json',
      referenceNumber: '308',
      name: 'PHP License v3.01',
      licenseId: 'PHP-3.01',
      seeAlso: ['http://www.php.net/license/3_01.txt'],
      isOsiApproved: false}, {
      reference: './Plexus.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Plexus.json',
      referenceNumber: '219',
      name: 'Plexus Classworlds License',
      licenseId: 'Plexus',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Plexus_Classworlds_License'],
      isOsiApproved: false}, {
      reference: './PostgreSQL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/PostgreSQL.json',
      referenceNumber: '241',
      name: 'PostgreSQL License',
      licenseId: 'PostgreSQL',
      seeAlso: ['http://www.postgresql.org/about/licence', 'https://opensource.org/licenses/PostgreSQL'],
      isOsiApproved: true}, {
      reference: './Python-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Python-2.0.json',
      referenceNumber: '33',
      name: 'Python License 2.0',
      licenseId: 'Python-2.0',
      seeAlso: ['https://opensource.org/licenses/Python-2.0'],
      isOsiApproved: true}, {
      reference: './QPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/QPL-1.0.json',
      referenceNumber: '25',
      name: 'Q Public License 1.0',
      licenseId: 'QPL-1.0',
      seeAlso: ['http://doc.qt.nokia.com/3.3/license.html', 'https://opensource.org/licenses/QPL-1.0'],
      isOsiApproved: true}, {
      reference: './Qhull.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Qhull.json',
      referenceNumber: '65',
      name: 'Qhull License',
      licenseId: 'Qhull',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Qhull'],
      isOsiApproved: false}, {
      reference: './RHeCos-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/RHeCos-1.1.json',
      referenceNumber: '143',
      name: 'Red Hat eCos Public License v1.1',
      licenseId: 'RHeCos-1.1',
      seeAlso: ['http://ecos.sourceware.org/old-license.html'],
      isOsiApproved: false}, {
      reference: './RPL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/RPL-1.1.json',
      referenceNumber: '262',
      name: 'Reciprocal Public License 1.1',
      licenseId: 'RPL-1.1',
      seeAlso: ['https://opensource.org/licenses/RPL-1.1'],
      isOsiApproved: true}, {
      reference: './RPL-1.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/RPL-1.5.json',
      referenceNumber: '221',
      name: 'Reciprocal Public License 1.5',
      licenseId: 'RPL-1.5',
      seeAlso: ['https://opensource.org/licenses/RPL-1.5'],
      isOsiApproved: true}, {
      reference: './RPSL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/RPSL-1.0.json',
      referenceNumber: '266',
      name: 'RealNetworks Public Source License v1.0',
      licenseId: 'RPSL-1.0',
      seeAlso: ['https://helixcommunity.org/content/rpsl', 'https://opensource.org/licenses/RPSL-1.0'],
      isOsiApproved: true}, {
      reference: './RSA-MD.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/RSA-MD.json',
      referenceNumber: '78',
      name: 'RSA Message-Digest License ',
      licenseId: 'RSA-MD',
      seeAlso: ['http://www.faqs.org/rfcs/rfc1321.html'],
      isOsiApproved: false}, {
      reference: './RSCPL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/RSCPL.json',
      referenceNumber: '205',
      name: 'Ricoh Source Code Public License',
      licenseId: 'RSCPL',
      seeAlso: ['http://wayback.archive.org/web/20060715140826/http://www.risource.org/RPL/RPL-1.0A.shtml', 'https://opensource.org/licenses/RSCPL'],
      isOsiApproved: true}, {
      reference: './Rdisc.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Rdisc.json',
      referenceNumber: '288',
      name: 'Rdisc License',
      licenseId: 'Rdisc',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Rdisc_License'],
      isOsiApproved: false}, {
      reference: './Ruby.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Ruby.json',
      referenceNumber: '257',
      name: 'Ruby License',
      licenseId: 'Ruby',
      seeAlso: ['http://www.ruby-lang.org/en/LICENSE.txt'],
      isOsiApproved: false}, {
      reference: './SAX-PD.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SAX-PD.json',
      referenceNumber: '134',
      name: 'Sax Public Domain Notice',
      licenseId: 'SAX-PD',
      seeAlso: ['http://www.saxproject.org/copying.html'],
      isOsiApproved: false}, {
      reference: './SCEA.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SCEA.json',
      referenceNumber: '15',
      name: 'SCEA Shared Source License',
      licenseId: 'SCEA',
      seeAlso: ['http://research.scea.com/scea_shared_source_license.html'],
      isOsiApproved: false}, {
      reference: './SGI-B-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SGI-B-1.0.json',
      referenceNumber: '86',
      name: 'SGI Free Software License B v1.0',
      licenseId: 'SGI-B-1.0',
      seeAlso: ['http://oss.sgi.com/projects/FreeB/SGIFreeSWLicB.1.0.html'],
      isOsiApproved: false}, {
      reference: './SGI-B-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SGI-B-1.1.json',
      referenceNumber: '235',
      name: 'SGI Free Software License B v1.1',
      licenseId: 'SGI-B-1.1',
      seeAlso: ['http://oss.sgi.com/projects/FreeB/'],
      isOsiApproved: false}, {
      reference: './SGI-B-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/SGI-B-2.0.json',
      referenceNumber: '265',
      name: 'SGI Free Software License B v2.0',
      licenseId: 'SGI-B-2.0',
      seeAlso: ['http://oss.sgi.com/projects/FreeB/SGIFreeSWLicB.2.0.pdf'],
      isOsiApproved: false}, {
      reference: './SISSL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/SISSL.json',
      referenceNumber: '71',
      name: 'Sun Industry Standards Source License v1.1',
      licenseId: 'SISSL',
      seeAlso: ['http://www.openoffice.org/licenses/sissl_license.html', 'https://opensource.org/licenses/SISSL'],
      isOsiApproved: true}, {
      reference: './SISSL-1.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SISSL-1.2.json',
      referenceNumber: '6',
      name: 'Sun Industry Standards Source License v1.2',
      licenseId: 'SISSL-1.2',
      seeAlso: ['http://gridscheduler.sourceforge.net/Gridengine_SISSL_license.html'],
      isOsiApproved: false}, {
      reference: './SMLNJ.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/SMLNJ.json',
      referenceNumber: '289',
      name: 'Standard ML of New Jersey License',
      licenseId: 'SMLNJ',
      seeAlso: ['https://www.smlnj.org/license.html'],
      isOsiApproved: false}, {
      reference: './SMPPL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SMPPL.json',
      referenceNumber: '121',
      name: 'Secure Messaging Protocol Public License',
      licenseId: 'SMPPL',
      seeAlso: ['https://github.com/dcblake/SMP/blob/master/Documentation/License.txt'],
      isOsiApproved: false}, {
      reference: './SNIA.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SNIA.json',
      referenceNumber: '224',
      name: 'SNIA Public License 1.1',
      licenseId: 'SNIA',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/SNIA_Public_License'],
      isOsiApproved: false}, {
      reference: './SPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/SPL-1.0.json',
      referenceNumber: '52',
      name: 'Sun Public License v1.0',
      licenseId: 'SPL-1.0',
      seeAlso: ['https://opensource.org/licenses/SPL-1.0'],
      isOsiApproved: true}, {
      reference: './SWL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SWL.json',
      referenceNumber: '202',
      name: 'Scheme Widget Library (SWL) Software License Agreement',
      licenseId: 'SWL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/SWL'],
      isOsiApproved: false}, {
      reference: './Saxpath.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Saxpath.json',
      referenceNumber: '17',
      name: 'Saxpath License',
      licenseId: 'Saxpath',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Saxpath_License'],
      isOsiApproved: false}, {
      reference: './Sendmail.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Sendmail.json',
      referenceNumber: '145',
      name: 'Sendmail License',
      licenseId: 'Sendmail',
      seeAlso: ['http://www.sendmail.com/pdfs/open_source/sendmail_license.pdf', 'https://web.archive.org/web/20160322142305/https://www.sendmail.com/pdfs/open_source/sendmail_license.pdf'],
      isOsiApproved: false}, {
      reference: './Sendmail-8.23.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Sendmail-8.23.json',
      referenceNumber: '39',
      name: 'Sendmail License 8.23',
      licenseId: 'Sendmail-8.23',
      seeAlso: ['https://www.proofpoint.com/sites/default/files/sendmail-license.pdf', 'https://web.archive.org/web/20181003101040/https://www.proofpoint.com/sites/default/files/sendmail-license.pdf'],
      isOsiApproved: false}, {
      reference: './SimPL-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SimPL-2.0.json',
      referenceNumber: '178',
      name: 'Simple Public License 2.0',
      licenseId: 'SimPL-2.0',
      seeAlso: ['https://opensource.org/licenses/SimPL-2.0'],
      isOsiApproved: true}, {
      reference: './Sleepycat.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Sleepycat.json',
      referenceNumber: '283',
      name: 'Sleepycat License',
      licenseId: 'Sleepycat',
      seeAlso: ['https://opensource.org/licenses/Sleepycat'],
      isOsiApproved: true}, {
      reference: './Spencer-86.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Spencer-86.json',
      referenceNumber: '306',
      name: 'Spencer License 86',
      licenseId: 'Spencer-86',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Henry_Spencer_Reg-Ex_Library_License'],
      isOsiApproved: false}, {
      reference: './Spencer-94.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Spencer-94.json',
      referenceNumber: '27',
      name: 'Spencer License 94',
      licenseId: 'Spencer-94',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Henry_Spencer_Reg-Ex_Library_License'],
      isOsiApproved: false}, {
      reference: './Spencer-99.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Spencer-99.json',
      referenceNumber: '373',
      name: 'Spencer License 99',
      licenseId: 'Spencer-99',
      seeAlso: ['http://www.opensource.apple.com/source/tcl/tcl-5/tcl/generic/regfronts.c'],
      isOsiApproved: false}, {
      reference: './StandardML-NJ.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/StandardML-NJ.json',
      referenceNumber: '213',
      name: 'Standard ML of New Jersey License',
      licenseId: 'StandardML-NJ',
      seeAlso: ['http://www.smlnj.org//license.html'],
      isOsiApproved: false}, {
      reference: './SugarCRM-1.1.3.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SugarCRM-1.1.3.json',
      referenceNumber: '285',
      name: 'SugarCRM Public License v1.1.3',
      licenseId: 'SugarCRM-1.1.3',
      seeAlso: ['http://www.sugarcrm.com/crm/SPL'],
      isOsiApproved: false}, {
      reference: './TCL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TCL.json',
      referenceNumber: '259',
      name: 'TCL/TK License',
      licenseId: 'TCL',
      seeAlso: ['http://www.tcl.tk/software/tcltk/license.html', 'https://fedoraproject.org/wiki/Licensing/TCL'],
      isOsiApproved: false}, {
      reference: './TCP-wrappers.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TCP-wrappers.json',
      referenceNumber: '267',
      name: 'TCP Wrappers License',
      licenseId: 'TCP-wrappers',
      seeAlso: ['http://rc.quest.com/topics/openssh/license.php#tcpwrappers'],
      isOsiApproved: false}, {
      reference: './TMate.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TMate.json',
      referenceNumber: '247',
      name: 'TMate Open Source License',
      licenseId: 'TMate',
      seeAlso: ['http://svnkit.com/license.html'],
      isOsiApproved: false}, {
      reference: './TORQUE-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TORQUE-1.1.json',
      referenceNumber: '165',
      name: 'TORQUE v2.5+ Software License v1.1',
      licenseId: 'TORQUE-1.1',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/TORQUEv1.1'],
      isOsiApproved: false}, {
      reference: './TOSL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TOSL.json',
      referenceNumber: '348',
      name: 'Trusster Open Source License',
      licenseId: 'TOSL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/TOSL'],
      isOsiApproved: false}, {
      reference: './TU-Berlin-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TU-Berlin-1.0.json',
      referenceNumber: '360',
      name: 'Technische Universitaet Berlin License 1.0',
      licenseId: 'TU-Berlin-1.0',
      seeAlso: ['https://github.com/swh/ladspa/blob/7bf6f3799fdba70fda297c2d8fd9f526803d9680/gsm/COPYRIGHT'],
      isOsiApproved: false}, {
      reference: './TU-Berlin-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TU-Berlin-2.0.json',
      referenceNumber: '378',
      name: 'Technische Universitaet Berlin License 2.0',
      licenseId: 'TU-Berlin-2.0',
      seeAlso: ['https://github.com/CorsixTH/deps/blob/fd339a9f526d1d9c9f01ccf39e438a015da50035/licences/libgsm.txt'],
      isOsiApproved: false}, {
      reference: './UPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/UPL-1.0.json',
      referenceNumber: '199',
      name: 'Universal Permissive License v1.0',
      licenseId: 'UPL-1.0',
      seeAlso: ['https://opensource.org/licenses/UPL'],
      isOsiApproved: true}, {
      reference: './Unicode-DFS-2015.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Unicode-DFS-2015.json',
      referenceNumber: '10',
      name: 'Unicode License Agreement - Data Files and Software (2015)',
      licenseId: 'Unicode-DFS-2015',
      seeAlso: ['https://web.archive.org/web/20151224134844/http://unicode.org/copyright.html'],
      isOsiApproved: false}, {
      reference: './Unicode-DFS-2016.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Unicode-DFS-2016.json',
      referenceNumber: '369',
      name: 'Unicode License Agreement - Data Files and Software (2016)',
      licenseId: 'Unicode-DFS-2016',
      seeAlso: ['http://www.unicode.org/copyright.html'],
      isOsiApproved: false}, {
      reference: './Unicode-TOU.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Unicode-TOU.json',
      referenceNumber: '68',
      name: 'Unicode Terms of Use',
      licenseId: 'Unicode-TOU',
      seeAlso: ['http://www.unicode.org/copyright.html'],
      isOsiApproved: false}, {
      reference: './Unlicense.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Unlicense.json',
      referenceNumber: '286',
      name: 'The Unlicense',
      licenseId: 'Unlicense',
      seeAlso: ['http://unlicense.org/'],
      isOsiApproved: false}, {
      reference: './VOSTROM.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/VOSTROM.json',
      referenceNumber: '222',
      name: 'VOSTROM Public License for Open Source',
      licenseId: 'VOSTROM',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/VOSTROM'],
      isOsiApproved: false}, {
      reference: './VSL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/VSL-1.0.json',
      referenceNumber: '174',
      name: 'Vovida Software License v1.0',
      licenseId: 'VSL-1.0',
      seeAlso: ['https://opensource.org/licenses/VSL-1.0'],
      isOsiApproved: true}, {
      reference: './Vim.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Vim.json',
      referenceNumber: '127',
      name: 'Vim License',
      licenseId: 'Vim',
      seeAlso: ['http://vimdoc.sourceforge.net/htmldoc/uganda.html'],
      isOsiApproved: false}, {
      reference: './W3C.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/W3C.json',
      referenceNumber: '340',
      name: 'W3C Software Notice and License (2002-12-31)',
      licenseId: 'W3C',
      seeAlso: ['http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231.html', 'https://opensource.org/licenses/W3C'],
      isOsiApproved: true}, {
      reference: './W3C-19980720.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/W3C-19980720.json',
      referenceNumber: '315',
      name: 'W3C Software Notice and License (1998-07-20)',
      licenseId: 'W3C-19980720',
      seeAlso: ['http://www.w3.org/Consortium/Legal/copyright-software-19980720.html'],
      isOsiApproved: false}, {
      reference: './W3C-20150513.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/W3C-20150513.json',
      referenceNumber: '49',
      name: 'W3C Software Notice and Document License (2015-05-13)',
      licenseId: 'W3C-20150513',
      seeAlso: ['https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document'],
      isOsiApproved: false}, {
      reference: './WTFPL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/WTFPL.json',
      referenceNumber: '356',
      name: 'Do What The F*ck You Want To Public License',
      licenseId: 'WTFPL',
      seeAlso: ['http://sam.zoy.org/wtfpl/COPYING'],
      isOsiApproved: false}, {
      reference: './Watcom-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Watcom-1.0.json',
      referenceNumber: '171',
      name: 'Sybase Open Watcom Public License 1.0',
      licenseId: 'Watcom-1.0',
      seeAlso: ['https://opensource.org/licenses/Watcom-1.0'],
      isOsiApproved: true}, {
      reference: './Wsuipa.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Wsuipa.json',
      referenceNumber: '129',
      name: 'Wsuipa License',
      licenseId: 'Wsuipa',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Wsuipa'],
      isOsiApproved: false}, {
      reference: './X11.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/X11.json',
      referenceNumber: '182',
      name: 'X11 License',
      licenseId: 'X11',
      seeAlso: ['http://www.xfree86.org/3.3.6/COPYRIGHT2.html#3'],
      isOsiApproved: false}, {
      reference: './XFree86-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/XFree86-1.1.json',
      referenceNumber: '237',
      name: 'XFree86 License 1.1',
      licenseId: 'XFree86-1.1',
      seeAlso: ['http://www.xfree86.org/current/LICENSE4.html'],
      isOsiApproved: false}, {
      reference: './XSkat.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/XSkat.json',
      referenceNumber: '91',
      name: 'XSkat License',
      licenseId: 'XSkat',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/XSkat_License'],
      isOsiApproved: false}, {
      reference: './Xerox.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Xerox.json',
      referenceNumber: '157',
      name: 'Xerox License',
      licenseId: 'Xerox',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Xerox'],
      isOsiApproved: false}, {
      reference: './Xnet.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Xnet.json',
      referenceNumber: '375',
      name: 'X.Net License',
      licenseId: 'Xnet',
      seeAlso: ['https://opensource.org/licenses/Xnet'],
      isOsiApproved: true}, {
      reference: './YPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/YPL-1.0.json',
      referenceNumber: '168',
      name: 'Yahoo! Public License v1.0',
      licenseId: 'YPL-1.0',
      seeAlso: ['http://www.zimbra.com/license/yahoo_public_license_1.0.html'],
      isOsiApproved: false}, {
      reference: './YPL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/YPL-1.1.json',
      referenceNumber: '55',
      name: 'Yahoo! Public License v1.1',
      licenseId: 'YPL-1.1',
      seeAlso: ['http://www.zimbra.com/license/yahoo_public_license_1.1.html'],
      isOsiApproved: false}, {
      reference: './ZPL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ZPL-1.1.json',
      referenceNumber: '347',
      name: 'Zope Public License 1.1',
      licenseId: 'ZPL-1.1',
      seeAlso: ['http://old.zope.org/Resources/License/ZPL-1.1'],
      isOsiApproved: false}, {
      reference: './ZPL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ZPL-2.0.json',
      referenceNumber: '74',
      name: 'Zope Public License 2.0',
      licenseId: 'ZPL-2.0',
      seeAlso: ['http://old.zope.org/Resources/License/ZPL-2.0', 'https://opensource.org/licenses/ZPL-2.0'],
      isOsiApproved: true}, {
      reference: './ZPL-2.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ZPL-2.1.json',
      referenceNumber: '335',
      name: 'Zope Public License 2.1',
      licenseId: 'ZPL-2.1',
      seeAlso: ['http://old.zope.org/Resources/ZPL/'],
      isOsiApproved: false}, {
      reference: './Zed.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Zed.json',
      referenceNumber: '242',
      name: 'Zed License',
      licenseId: 'Zed',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Zed'],
      isOsiApproved: false}, {
      reference: './Zend-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Zend-2.0.json',
      referenceNumber: '192',
      name: 'Zend License v2.0',
      licenseId: 'Zend-2.0',
      seeAlso: ['https://web.archive.org/web/20130517195954/http://www.zend.com/license/2_00.txt'],
      isOsiApproved: false}, {
      reference: './Zimbra-1.3.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Zimbra-1.3.json',
      referenceNumber: '38',
      name: 'Zimbra Public License v1.3',
      licenseId: 'Zimbra-1.3',
      seeAlso: ['http://web.archive.org/web/20100302225219/http://www.zimbra.com/license/zimbra-public-license-1-3.html'],
      isOsiApproved: false}, {
      reference: './Zimbra-1.4.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Zimbra-1.4.json',
      referenceNumber: '232',
      name: 'Zimbra Public License v1.4',
      licenseId: 'Zimbra-1.4',
      seeAlso: ['http://www.zimbra.com/legal/zimbra-public-license-1-4'],
      isOsiApproved: false}, {
      reference: './Zlib.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Zlib.json',
      referenceNumber: '312',
      name: 'zlib License',
      licenseId: 'Zlib',
      seeAlso: ['http://www.zlib.net/zlib_license.html', 'https://opensource.org/licenses/Zlib'],
      isOsiApproved: true}, {
      reference: './bzip2-1.0.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/bzip2-1.0.5.json',
      referenceNumber: '194',
      name: 'bzip2 and libbzip2 License v1.0.5',
      licenseId: 'bzip2-1.0.5',
      seeAlso: ['http://bzip.org/1.0.5/bzip2-manual-1.0.5.html'],
      isOsiApproved: false}, {
      reference: './bzip2-1.0.6.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/bzip2-1.0.6.json',
      referenceNumber: '295',
      name: 'bzip2 and libbzip2 License v1.0.6',
      licenseId: 'bzip2-1.0.6',
      seeAlso: ['https://github.com/asimonov-im/bzip2/blob/master/LICENSE'],
      isOsiApproved: false}, {
      reference: './copyleft-next-0.3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/copyleft-next-0.3.0.json',
      referenceNumber: '170',
      name: 'copyleft-next 0.3.0',
      licenseId: 'copyleft-next-0.3.0',
      seeAlso: ['https://github.com/copyleft-next/copyleft-next/blob/master/Releases/copyleft-next-0.3.0'],
      isOsiApproved: false}, {
      reference: './copyleft-next-0.3.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/copyleft-next-0.3.1.json',
      referenceNumber: '337',
      name: 'copyleft-next 0.3.1',
      licenseId: 'copyleft-next-0.3.1',
      seeAlso: ['https://github.com/copyleft-next/copyleft-next/blob/master/Releases/copyleft-next-0.3.1'],
      isOsiApproved: false}, {
      reference: './curl.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/curl.json',
      referenceNumber: '254',
      name: 'curl License',
      licenseId: 'curl',
      seeAlso: ['https://github.com/bagder/curl/blob/master/COPYING'],
      isOsiApproved: false}, {
      reference: './diffmark.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/diffmark.json',
      referenceNumber: '355',
      name: 'diffmark license',
      licenseId: 'diffmark',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/diffmark'],
      isOsiApproved: false}, {
      reference: './dvipdfm.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/dvipdfm.json',
      referenceNumber: '137',
      name: 'dvipdfm License',
      licenseId: 'dvipdfm',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/dvipdfm'],
      isOsiApproved: false}, {
      reference: './eCos-2.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/eCos-2.0.json',
      referenceNumber: '321',
      name: 'eCos license version 2.0',
      licenseId: 'eCos-2.0',
      seeAlso: ['https://www.gnu.org/licenses/ecos-license.html'],
      isOsiApproved: false}, {
      reference: './eGenix.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/eGenix.json',
      referenceNumber: '198',
      name: 'eGenix.com Public License 1.1.0',
      licenseId: 'eGenix',
      seeAlso: ['http://www.egenix.com/products/eGenix.com-Public-License-1.1.0.pdf', 'https://fedoraproject.org/wiki/Licensing/eGenix.com_Public_License_1.1.0'],
      isOsiApproved: false}, {
      reference: './gSOAP-1.3b.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/gSOAP-1.3b.json',
      referenceNumber: '336',
      name: 'gSOAP Public License v1.3b',
      licenseId: 'gSOAP-1.3b',
      seeAlso: ['http://www.cs.fsu.edu/~engelen/license.html'],
      isOsiApproved: false}, {
      reference: './gnuplot.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/gnuplot.json',
      referenceNumber: '9',
      name: 'gnuplot License',
      licenseId: 'gnuplot',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Gnuplot'],
      isOsiApproved: false}, {
      reference: './iMatix.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/iMatix.json',
      referenceNumber: '332',
      name: 'iMatix Standard Function Library Agreement',
      licenseId: 'iMatix',
      seeAlso: ['http://legacy.imatix.com/html/sfl/sfl4.htm#license'],
      isOsiApproved: false}, {
      reference: './libtiff.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/libtiff.json',
      referenceNumber: '214',
      name: 'libtiff License',
      licenseId: 'libtiff',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/libtiff'],
      isOsiApproved: false}, {
      reference: './mpich2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/mpich2.json',
      referenceNumber: '310',
      name: 'mpich2 License',
      licenseId: 'mpich2',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT'],
      isOsiApproved: false}, {
      reference: './psfrag.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/psfrag.json',
      referenceNumber: '239',
      name: 'psfrag License',
      licenseId: 'psfrag',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/psfrag'],
      isOsiApproved: false}, {
      reference: './psutils.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/psutils.json',
      referenceNumber: '120',
      name: 'psutils License',
      licenseId: 'psutils',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/psutils'],
      isOsiApproved: false}, {
      reference: './wxWindows.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/wxWindows.json',
      referenceNumber: '82',
      name: 'wxWindows Library License',
      licenseId: 'wxWindows',
      seeAlso: ['https://opensource.org/licenses/WXwindows'],
      isOsiApproved: false}, {
      reference: './xinetd.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/xinetd.json',
      referenceNumber: '140',
      name: 'xinetd License',
      licenseId: 'xinetd',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Xinetd_License'],
      isOsiApproved: false}, {
      reference: './xpp.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/xpp.json',
      referenceNumber: '268',
      name: 'XPP License',
      licenseId: 'xpp',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/xpp'],
      isOsiApproved: false}, {
      reference: './zlib-acknowledgement.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/zlib-acknowledgement.json',
      referenceNumber: '313',
      name: 'zlib/libpng License with Acknowledgement',
      licenseId: 'zlib-acknowledgement',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/ZlibWithAcknowledgement'],
      isOsiApproved: false}],
    releaseDate: '2019-03-11'};

  // romejs/codec-spdx-license/src/parse.ts

  function ___$$priv$romejs$codec_spdx_license$src$parse_ts$isWordChar(char) {
    return ___$romejs$parser_core$src$index_ts$isAlpha(char) || ___$romejs$parser_core$src$index_ts$isDigit(char) || char === '-' || char === '.';
  }

  class ___$$priv$romejs$codec_spdx_license$src$parse_ts$Parser extends ___$romejs$parser_core$src$index_ts$ParserCore {
    constructor(opts) {
      super(opts, 'spdx-license');
    }

    tokenize(index, input) {
      const char = input[index];

      if (char === '+') {
        return this.finishToken('Plus');
      }

      if (char === '(') {
        return this.finishToken('ParenOpen');
      }

      if (char === ')') {
        return this.finishToken('ParenClose');
      }

      if (char === ' ') {
        return this.lookaheadToken(index + 1);
      }

      if (___$romejs$parser_core$src$index_ts$isAlpha(char)) {
        const value = this.readInputFrom(index, ___$$priv$romejs$codec_spdx_license$src$parse_ts$isWordChar);
        const end = index + value.length;

        if (value === 'AND') {
          return this.finishToken('And', end);
        } else if (value === 'OR') {
          return this.finishToken('Or', end);
        } else if (value === 'WITH') {
          return this.finishToken('With', end);
        } else {
          return this.finishValueToken('Word', value, end);
        }
      }

      return undefined;
    }

    parseLicense(token) {
      const startPos = this.getPosition();

      const id = token.value;
      const licenseInfo = ___$romejs$codec_spdx_license$src$index_ts$getLicense(id);
      if (licenseInfo === undefined) {
        throw this.unexpected({
          message: `Unknown SPDX license <emphasis>${id}</emphasis>`,
          start: this.getPositionFromIndex(token.start),
          end: this.getPositionFromIndex(token.end),
          advice: [{
            type: 'log',
            category: 'info',
            message: `Did you mean <emphasis>${___$romejs$string_utils$src$orderBySimilarity_ts$orderBySimilarity(id, ___$romejs$codec_spdx_license$src$index_ts$licenseNames)[0].target}</emphasis>?`}]});
      }

      this.nextToken();

      const plus = this.eatToken('Plus') !== undefined;

      let exception;
      if (this.eatToken('With')) {
        const token = this.getToken();
        if (token.type === 'Word') {
          exception = token.value;
          this.nextToken();
        } else {
          throw this.unexpected({
            message: 'Only a license id can be on the right side of a WITH'});
        }
      }

      return {
        type: 'License',
        loc: this.finishLoc(startPos),
        id: id,
        exception: exception,
        plus: plus};
    }

    parseExpression() {
      const startPos = this.getPosition();
      const startToken = this.getToken();

      let value;

      switch (startToken.type) {
        case 'ParenOpen':
          this.nextToken();
          value = this.parseExpression();
          this.expectToken('ParenClose');
          break;

        case 'Word':
          value = this.parseLicense(startToken);
          break;

        case 'Or':
        case 'And':
          throw this.unexpected({
            message: 'Can only use AND/OR in between an expression'});

        case 'Plus':
          throw this.unexpected({
            message: 'A plus can only come after a license id'});

        case 'ParenClose':
          throw this.unexpected({message: 'Nothing open to close'});

        case 'EOF':
          throw this.unexpected({message: 'Unexpected end of file'});

        default:
          throw this.unexpected();}

      const nextToken = this.getToken();
      switch (nextToken.type) {
        case 'Or':
          this.nextToken();
          return {
            type: 'Or',
            loc: this.finishLoc(startPos),
            left: value,
            right: this.parseExpression()};

        case 'And':
          this.nextToken();
          return {
            type: 'And',
            loc: this.finishLoc(startPos),
            left: value,
            right: this.parseExpression()};

        default:
          return value;}
    }

    parse() {
      const expr = this.parseExpression();
      this.finalize();
      return expr;
    }
  }

  function ___$romejs$codec_spdx_license$src$parse_ts$default(opts) {
    const parser = new ___$$priv$romejs$codec_spdx_license$src$parse_ts$Parser(opts);
    return parser.parse();
  }

  // romejs/codec-spdx-license/src/stringify.ts

  function ___$romejs$codec_spdx_license$src$stringify_ts$default(node) {
    switch (node.type) {
      case 'Or':
        return `${___$romejs$codec_spdx_license$src$stringify_ts$default(node.left)} OR ${___$romejs$codec_spdx_license$src$stringify_ts$default(node.right)}`;

      case 'And':
        return `${___$romejs$codec_spdx_license$src$stringify_ts$default(node.left)} AND ${___$romejs$codec_spdx_license$src$stringify_ts$default(node.right)}`;

      case 'License':
        {
          let str = node.id;
          if (node.plus) {
            str += '+';
          }
          if (node.exception !== undefined) {
            str += ` WITH ${node.exception}`;
          }
          return str;
        }}
  }

  // romejs/codec-spdx-license/src/index.ts

  const ___$$priv$romejs$codec_spdx_license$src$index_ts$idToLicense = new Map();
  const ___$romejs$codec_spdx_license$src$index_ts$licenseNames = [];
  for (const license of ___$romejs$codec_spdx_license$src$data_ts$default.licenses) {
    ___$romejs$codec_spdx_license$src$index_ts$licenseNames.push(license.licenseId);
    ___$$priv$romejs$codec_spdx_license$src$index_ts$idToLicense.set(license.licenseId, license);
  }

  function ___$romejs$codec_spdx_license$src$index_ts$getLicense(licenseId) {
    return ___$$priv$romejs$codec_spdx_license$src$index_ts$idToLicense.get(licenseId);
  }

  // romejs/codec-js-manifest/src/dependencies.ts

  const ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$path = require('path');
  function ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$explodeHashUrl(pattern, consumer) {
    const parts = pattern.split('#');

    if (parts.length > 2) {
      throw consumer.unexpected('Too many hashes');
    }

    return {
      hash: parts[1],
      url: parts[0]};
  }

  function ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$removePrefix(prefix, value) {
    if (value.startsWith(prefix)) {
      return value.slice(prefix.length);
    } else {
      return value;
    }
  }

  const ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$GITHUB_SHORTHAND = /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/;

  const ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$HOSTED_GIT_PREFIXES = ['bitbucket', 'github', 'gist', 'gitlab'];

  function ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseHostedGit(host, pattern, consumer) {
    let commitish;
    if (pattern.includes('#')) {
      const hashIndex = pattern.indexOf('#');
      commitish = pattern.slice(hashIndex + 1);
      pattern = pattern.slice(0, hashIndex - 1);
    }

    const parts = pattern.split('/');
    if (parts.length > 2) {
      throw consumer.unexpected('Expected only 2 parts');
    }

    const user = parts[0];
    if (user === undefined) {
      throw consumer.unexpected('We are missing a user!');
    }

    const repo = parts[1];
    if (repo === undefined) {
      throw consumer.unexpected('We are missing a repo!');
    }

    return {
      type: 'hosted-git',
      host: host,
      user: user,
      repo: repo,
      commitish: commitish};
  }

  const ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$GIT_PATTERN_MATCHERS = [/^git:/, /^git\+.+:/, /^ssh:/, /^https?:.+\.git$/, /^https?:.+\.git#.+/];

  function ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseGit(pattern, consumer) {
    return Object.assign({
      type: 'git'}, ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$explodeHashUrl(pattern, consumer));
  }

  function ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseTarball(pattern, consumer) {
    return Object.assign({
      type: 'tarball'}, ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$explodeHashUrl(pattern, consumer));
  }

  function ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseSemver(pattern, consumer, loose) {
    const ast = ___$romejs$codec_semver$src$parse_ts$parseRange({
      loose: loose,
      filename: consumer.filename,
      input: pattern,
      offsetPosition: consumer.getInnerLocation().start});

    return {
      type: 'semver',
      range: ast};
  }

  const ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$FILE_PREFIX_REGEX = /^\.{1,2}\//;

  function ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseFile(pattern) {
    return {
      type: 'file',
      path: ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$removePrefix('file:', pattern)};
  }

  const ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$TAG_REGEX = /^[a-z]+$/g;

  function ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseTag(pattern) {
    return {
      type: 'tag',
      tag: pattern};
  }

  function ___$romejs$codec_js_manifest$src$dependencies_ts$parseDependencyPattern(consumer, loose) {
    const pattern = consumer.asString();

    for (const host of ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$HOSTED_GIT_PREFIXES) {
      const prefix = `${host}:`;
      if (pattern.startsWith(prefix)) {
        return ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseHostedGit(host, ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$removePrefix(prefix, pattern), consumer);
      }
    }

    for (const matcher of ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$GIT_PATTERN_MATCHERS) {
      if (matcher.test(pattern)) {
        return ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseGit(pattern, consumer);
      }
    }

    if (___$$priv$romejs$codec_js_manifest$src$dependencies_ts$GITHUB_SHORTHAND.test(pattern)) {
      return ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseHostedGit('github', pattern, consumer);
    }

    if (pattern.startsWith('http://') || pattern.startsWith('https://')) {
      return ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseTarball(pattern, consumer);
    }

    if (___$$priv$romejs$codec_js_manifest$src$dependencies_ts$FILE_PREFIX_REGEX.test(pattern) ||
    ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$path.isAbsolute(pattern) ||
    pattern.startsWith('file:')) {
      return ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseFile(pattern);
    }

    if (pattern.match(___$$priv$romejs$codec_js_manifest$src$dependencies_ts$TAG_REGEX)) {
      return ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseTag(pattern);
    }

    return ___$$priv$romejs$codec_js_manifest$src$dependencies_ts$parseSemver(pattern, consumer, loose);
  }

  function ___$romejs$codec_js_manifest$src$dependencies_ts$normalizeDependencies(consumer, key, loose) {
    const map = new Map();

    if (!consumer.hasProperty(key)) {
      return map;
    }

    for (const [name, value] of consumer.getProperty(key).asMap()) {
      map.set(name, ___$romejs$codec_js_manifest$src$dependencies_ts$parseDependencyPattern(value, loose));
    }

    return map;
  }

  // romejs/codec-js-manifest/src/types.ts

  const ___$romejs$codec_js_manifest$src$types_ts = {};

  // romejs/codec-js-manifest/src/index.ts

  function ___$romejs$codec_js_manifest$src$index_ts$getManifestKindFromBasename(filename) {
    if (filename === 'package.json') {
      return 'json';
    } else {
      return undefined;
    }
  }

  function ___$romejs$codec_js_manifest$src$index_ts$ifNamedManifest(manifest) {
    const {name: name} = manifest;
    if (name !== undefined) {
      return Object.assign({}, manifest, {
        name: name});
    } else {
      return undefined;
    }
  }

  function ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeBoolean(consumer, key) {
    if (consumer.hasProperty(key)) {
      return consumer.getProperty(key).asBoolean();
    } else {
      return undefined;
    }
  }

  function ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeString(consumer, key) {
    if (consumer.hasProperty(key)) {
      return consumer.getProperty(key).asString();
    } else {
      return undefined;
    }
  }

  function ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeStringArray(consumer, key) {
    const prop = consumer.getProperty(key);
    if (prop.exists()) {
      if (typeof prop.asMixed() === 'string') {
        return [prop.asString()];
      } else {
        return prop.asArray().map(item => item.asString());
      }
    } else {
      return undefined;
    }
  }

  function ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeStringMap(consumer, key) {
    const map = new Map();

    if (!consumer.hasProperty(key)) {
      return map;
    }

    for (const [name, value] of consumer.getProperty(key).asMap()) {
      map.set(name, value.asString());
    }

    return map;
  }

  function ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeBin(consumer, name) {
    const map = new Map();
    if (!consumer.hasProperty('bin')) {
      return map;
    }

    const obj = consumer.getProperty('bin');
    if (typeof obj.asMixed() === 'string') {
      if (name === undefined) {
        obj.unexpected(
        'A string bin is only allowed if the manifest has a name property');
      } else {
        map.set(name, obj.asString());
        return map;
      }
    }

    return ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeStringMap(consumer, 'bin');
  }

  function ___$$priv$romejs$codec_js_manifest$src$index_ts$extractLicenseFromObjectConsumer(consumer) {
    const prop = consumer.getProperty('type');
    const value = prop.asString();
    return [value, prop];
  }

  const ___$$priv$romejs$codec_js_manifest$src$index_ts$INVALID_IGNORE_LICENSES = ['UNLICENSED', 'none', 'Facebook Platform License', 'BSD', 'MIT/X11', 'Public Domain', 'MIT License', 'BSD-like'];

  function ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeLicense(consumer, loose) {
    if (!consumer.hasProperty('license')) {
      return undefined;
    }

    let licenseProp = consumer.getProperty('license');

    let licenseId;

    const raw = licenseProp.asMixed();
    if (loose && Array.isArray(raw)) {
      const licenseIds = licenseProp.asArray().map(consumer => ___$$priv$romejs$codec_js_manifest$src$index_ts$extractLicenseFromObjectConsumer(consumer)[0]);
      licenseId = `(${licenseIds.join(' OR ')})`;
    } else if (loose && typeof raw === 'object') {
      [licenseId, licenseProp] = ___$$priv$romejs$codec_js_manifest$src$index_ts$extractLicenseFromObjectConsumer(licenseProp);
    } else {
      licenseId = licenseProp.asString();
    }

    if (licenseId.startsWith('SEE LICENSE IN ')) {
      return undefined;
    }

    if (___$$priv$romejs$codec_js_manifest$src$index_ts$INVALID_IGNORE_LICENSES.includes(licenseId)) {
      return undefined;
    }

    return ___$romejs$codec_spdx_license$src$parse_ts$default({
      filename: consumer.filename,
      input: licenseId,
      offsetPosition: licenseProp.getInnerLocation().start});
  }

  function ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeVersion(consumer, loose) {
    if (!consumer.hasProperty('version')) {
      return undefined;
    }

    const prop = consumer.getProperty('version');
    const rawVersion = prop.asString();

    if (rawVersion === 'VERSION_STRING') {
      return undefined;
    }

    const ast = ___$romejs$codec_semver$src$parse_ts$parseVersion({
      filename: consumer.filename,
      input: rawVersion,
      offsetPosition: prop.getInnerLocation().start,

      loose: loose});
    return ast;
  }

  function ___$romejs$codec_js_manifest$src$index_ts$normalizeManifest(loc, consumer) {
    const loose = loc.includes('node_modules');

    if (!loose && consumer.hasProperty('bundleDependencies')) {
      consumer.getProperty('bundleDependencies').unexpected('bundleDependencies is a typo of bundledDependencies');
    }

    if (loc.includes('resolve/test/resolver/invalid_main')) {
      consumer.setValue({});
    }

    const name = ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeString(consumer, 'name');

    return Object.assign({}, consumer.asUnknownObject(), {
      name: name,
      version: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeVersion(consumer, loose),
      private: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeBoolean(consumer, 'private') === true,
      description: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeString(consumer, 'description'),
      license: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeLicense(consumer, loose),

      bin: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeBin(consumer, name),
      scripts: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeStringMap(consumer, 'scripts'),
      homepage: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeString(consumer, 'homepage'),
      engines: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeStringMap(consumer, 'engines'),

      files: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeStringArray(consumer, 'files'),
      keywords: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeStringArray(consumer, 'keywords'),
      cpu: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeStringArray(consumer, 'cpu'),
      os: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeStringArray(consumer, 'os'),

      browser: undefined,
      main: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeString(consumer, 'main'),
      'rome:main': ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeString(consumer, 'rome:main'),
      'jsnext:main': ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeString(consumer, 'jsnext:main'),

      dependencies: ___$romejs$codec_js_manifest$src$dependencies_ts$normalizeDependencies(consumer, 'dependencies', loose),
      devDependencies: ___$romejs$codec_js_manifest$src$dependencies_ts$normalizeDependencies(consumer, 'devDependencies', loose),
      optionalDependencies: ___$romejs$codec_js_manifest$src$dependencies_ts$normalizeDependencies(
      consumer,
      'optionalDependencies',
      loose),
      peerDependencies: ___$romejs$codec_js_manifest$src$dependencies_ts$normalizeDependencies(
      consumer,
      'peerDependencies',
      loose),
      bundledDependencies: ___$$priv$romejs$codec_js_manifest$src$index_ts$normalizeStringArray(consumer, 'bundledDependencies')});
  }

  // romejs/match-path/src/types.ts


  // romejs/match-path/src/parse.ts

  class ___$$priv$romejs$match_path$src$parse_ts$Parser extends ___$romejs$parser_core$src$index_ts$ParserCore {
    constructor(opts, mode) {
      super(opts, '@romejs/patch-match');
      this.mode = mode;
    }

    isWordCharacter(char, index, input) {
      const prevChar = input[index - 1];
      const nextChar = input[index + 1];

      if (char === '\\' && nextChar === '\\') {
        return false;
      }

      if (prevChar === '\\') {
        return true;
      }

      if (char === '/') {
        return false;
      }

      if (this.mode === 'pattern') {
        if (char === '*') {
          return false;
        }

        if (char === '#') {
          return false;
        }
      }

      return true;
    }

    tokenize(index, input) {
      const char = input[index];
      const nextChar = input[index + 1];

      if (this.mode === 'pattern') {
        if (char === '*') {
          if (nextChar === '*') {
            return this.finishToken('DoubleStar', index + 2);
          } else {
            return this.finishToken('Star');
          }
        } else if (index === 0 && char === '!') {
          return this.finishToken('Exclamation');
        } else if (char === '#') {
          return this.finishToken('Hash');
        }
      }

      if (char === '/') {
        return this.finishToken('Separator');
      } else if (char === '\\' && nextChar === '\\') {
        return this.finishToken('Separator', index + 2);
      }

      const value = this.readInputFrom(index, this.isWordCharacter.bind(this));
      return this.finishValueToken(
      'Word',
      value,
      index + value.length);
    }

    eatSeparators() {
      let ate = false;
      while (this.eatToken('Separator') !== undefined) {
        ate = true;
      }
      return ate;
    }

    parsePatternSegmentPart() {
      const startPos = this.getPosition();
      const token = this.getToken();
      this.nextToken();

      switch (token.type) {
        case 'Star':
          return {
            type: 'Wildcard',
            loc: this.finishLoc(startPos)};

        case 'Word':
          return {
            type: 'Word',
            loc: this.finishLoc(startPos),
            value: token.value};

        default:
          throw this.unexpected({
            start: startPos,
            message: 'Invalid pattern segment part'});}
    }

    parseSegment() {
      const startPos = this.getPosition();
      const parts = [];

      if (this.matchToken('DoubleStar')) {
        const lookahead = this.lookaheadToken();
        if (lookahead.type === 'Separator' || lookahead.type === 'EOF') {
          this.eatToken('DoubleStar');
          this.eatSeparators();
          return {
            type: 'WildcardSegment',
            loc: this.finishLoc(startPos)};
        }
      }

      while (!this.matchToken('Hash') &&
      !this.matchToken('EOF') &&
      !this.eatSeparators()) {
        parts.push(this.parsePatternSegmentPart());
      }

      return {
        loc: this.finishLoc(startPos),
        type: 'Segment',
        parts: parts};
    }

    isWildcardOnlySegment(segment) {
      if (segment === undefined) {
        return false;
      }

      if (segment.type === 'WildcardSegment') {
        return true;
      }

      if (segment.parts.length === 1 && segment.parts[0].type === 'Wildcard') {
        return true;
      }

      return false;
    }

    normalizePatternSegments(segments) {
      const normalized = [];

      if (segments.length === 1) {
        return segments;
      }

      for (const seg of segments) {
        if (normalized.length === 0 && this.isWildcardOnlySegment(seg)) {
          continue;
        }

        if (seg.type === 'Segment' && seg.parts.length === 0) {
          continue;
        }

        normalized.push(seg);
      }

      while (this.isWildcardOnlySegment(normalized[normalized.length - 1])) {
        normalized.pop();
      }

      return normalized;
    }

    parsePattern() {
      const startPos = this.getPosition();
      const segments = [];
      const negate = this.eatToken('Exclamation') !== undefined;

      while (!this.matchToken('Hash') && !this.matchToken('EOF')) {
        segments.push(this.parseSegment());
      }

      let comment = '';
      if (this.eatToken('Hash')) {
        comment = this.getRawInput(this.getToken().start, this.input.length);
      }

      let root = false;
      if (segments.length > 0) {
        const firstSeg = segments[0];
        root = firstSeg.type === 'Segment' && firstSeg.parts.length === 0;
      }

      return {
        type: 'Pattern',
        loc: this.finishLoc(startPos),
        root: root,
        comment: comment,
        negate: negate,
        segments: this.normalizePatternSegments(segments)};
    }

    parsePath() {
      const segments = [];

      this.eatSeparators();

      while (!this.matchToken('EOF')) {
        segments.push(this.parsePathSegment());
      }

      return segments;
    }

    parsePathSegment() {
      let segment = '';

      while (!this.eatSeparators() && !this.matchToken('EOF')) {
        segment += this.normalizePathSegmentToken();
      }

      return segment;
    }

    normalizePathSegmentToken() {
      const token = this.getToken();
      this.nextToken();

      if (token.type === 'Word') {
        return token.value;
      } else {
        throw this.unexpected({
          message: 'Invalid path segment'});
      }
    }
  }

  function ___$romejs$match_path$src$parse_ts$parsePattern(opts) {
    const parser = new ___$$priv$romejs$match_path$src$parse_ts$Parser(opts, 'pattern');
    return parser.parsePattern();
  }

  function ___$romejs$match_path$src$parse_ts$parsePath(opts) {
    const parser = new ___$$priv$romejs$match_path$src$parse_ts$Parser(opts, 'path');
    return parser.parsePath();
  }

  // romejs/match-path/src/match.ts

  function ___$$priv$romejs$match_path$src$match_ts$matchSegment(path, patternSeg) {
    if (patternSeg.type !== 'Segment') {
      throw new Error('Expected only plain segment');
    }

    const parts = [...patternSeg.parts];
    let buffer = path;

    function matchPart(part) {
      if (buffer.length === 0) {
        return false;
      }

      if (part.type === 'Word') {
        if (buffer.startsWith(part.value)) {
          buffer = buffer.slice(part.value.length);
        } else {
          return false;
        }
      } else if (part.type === 'Wildcard') {
        const nextPart = parts.shift();

        if (nextPart === undefined) {
          return buffer.length > 0;
        }

        while (buffer.length > 0) {
          if (matchPart(nextPart)) {
            return true;
          }

          buffer = buffer.slice(1);
        }

        return false;
      }

      return true;
    }

    while (parts.length > 0) {
      const part = parts.shift();
      if (part === undefined) {
        throw new Error('parts.length checked above');
      }

      if (matchPart(part) === false) {
        return false;
      }
    }

    return true;
  }

  function ___$romejs$match_path$src$match_ts$default(pathSegs, pattern, cwdSegs) {
    const patternSegs = [...pattern.segments];
    pathSegs = [...pathSegs];

    if (patternSegs.length === 0 || pathSegs.length === 0) {
      return false;
    }

    if (pattern.root && cwdSegs !== undefined) {
      cwdSegs = [...cwdSegs];

      for (const cwdSeg of cwdSegs) {
        const pathSeg = pathSegs.shift();
        if (cwdSeg === pathSeg) {
          continue;
        } else {
          return false;
        }
      }
    } else {
      const firstPatternSeg = patternSegs.shift();
      if (firstPatternSeg === undefined) {
        throw new Error('patternSegs.length already validated above');
      }

      while (pathSegs.length > 0) {
        const pathSeg = pathSegs.shift();
        if (pathSeg === undefined) {
          throw new Error('pathSegs.length already validated above');
        }

        if (___$$priv$romejs$match_path$src$match_ts$matchSegment(pathSeg, firstPatternSeg)) {
          if (pathSegs.length === 0 && patternSegs.length === 0) {
            return true;
          } else {
            break;
          }
        }
      }
    }

    if (pathSegs.length === 0) {
      return false;
    }

    for (let i = 0; i < patternSegs.length; i++) {
      const patternSeg = patternSegs[i];

      if (pathSegs.length === 0) {
        return false;
      }

      if (patternSeg.type === 'WildcardSegment') {
        const nextPattern = patternSegs[i + 1];
        while (!___$$priv$romejs$match_path$src$match_ts$matchSegment(pathSegs[0], nextPattern)) {
          pathSegs.shift();
        }
        continue;
      }

      const pathSeg = pathSegs.shift();
      if (pathSeg === undefined) {
        throw new Error('pathSegs.length already validated above');
      }
      if (___$$priv$romejs$match_path$src$match_ts$matchSegment(pathSeg, patternSeg)) {
        continue;
      } else {
        return false;
      }
    }

    return true;
  }

  // romejs/match-path/src/index.ts

  function ___$romejs$match_path$src$index_ts$matchPath(pathSegments, patternNode, cwdSegs) {
    const matches = ___$romejs$match_path$src$match_ts$default(pathSegments, patternNode, cwdSegs);

    if (patternNode.negate) {
      return !matches;
    } else {
      return matches;
    }
  }

  function ___$$priv$romejs$match_path$src$index_ts$getGreater(pattern, num) {
    if (pattern.segments.length > num) {
      return pattern.segments.length;
    } else {
      return num;
    }
  }

  function ___$romejs$match_path$src$index_ts$matchPathPatterns(pathSegments, patterns, cwdSegs) {
    if (patterns.length === 0) {
      return false;
    }

    let matches = 0;
    let notMatches = 0;

    for (const pattern of patterns) {
      if (pattern.segments.length === 0) {
        continue;
      }

      if (pattern.negate) {
        if (___$romejs$match_path$src$match_ts$default(pathSegments, Object.assign({}, pattern, {
          negate: false}), cwdSegs)) {
          notMatches = ___$$priv$romejs$match_path$src$index_ts$getGreater(pattern, notMatches);
        }
      } else {
        if (___$romejs$match_path$src$match_ts$default(pathSegments, pattern, cwdSegs)) {
          matches = ___$$priv$romejs$match_path$src$index_ts$getGreater(pattern, matches);
        }
      }
    }

    return matches > 0 && matches > notMatches;
  }

  // romejs/codec-watchman/src/index.ts

  const ___$$priv$romejs$codec_watchman$src$index_ts$child_process = require('child_process');
  const ___$$priv$romejs$codec_watchman$src$index_ts$util = require('util');
  const ___$$priv$romejs$codec_watchman$src$index_ts$net = require('net');
  const ___$$priv$romejs$codec_watchman$src$index_ts$exec = ___$$priv$romejs$codec_watchman$src$index_ts$util.promisify(___$$priv$romejs$codec_watchman$src$index_ts$child_process.exec);

  class ___$romejs$codec_watchman$src$index_ts$WatchmanClient {
    constructor(socket, reporter) {
      this.reporter = reporter;
      this.socket = socket;

      this.subscriptionCounter = 0;
      this.subscriptions = new Map();

      this.logEvent = new ___$romejs$events$src$Event_ts$default({name: 'WatchmanClient.log'});

      this.callbacks = [];
      this.listen();
    }

    listen() {
      const {socket: socket} = this;

      socket.on('error', function() {});

      let buf = '';

      const checkBuffer = offset => {
        for (let i = offset; i < buf.length; i++) {
          const char = buf[i];

          if (char === '\n') {
            const message = buf.slice(0, i);
            this.processResponse(message);

            buf = buf.slice(i + 1);
            checkBuffer(0);
          }
        }
      };

      socket.on('data', function(chunk) {
        const offset = buf.length;
        buf += chunk.toString();
        checkBuffer(offset);
      });

      socket.on('end', () => {
        this.end();
      });
    }

    processResponse(str) {
      const obj = JSON.parse(str);

      if (typeof obj.warn === 'string') {
        this.reporter.warn(obj.warn);
      }

      if (typeof obj.subscription === 'string') {
        const event = this.subscriptions.get(obj.subscription);
        if (event === undefined) {
          this.reporter.warn(
          'Received a watchman subscription event for %s that we aren\'t listening for',
          obj.subscription);
        } else {
          event.send(obj);
        }
        return undefined;
      }

      if (obj.log !== undefined) {
        return undefined;
      }

      if (obj.unilateral === true) {
        this.reporter.warn(
        'Received a watchman unilateral event that we don\'t support',
        obj);
        return undefined;
      }

      const callback = this.callbacks.shift();
      if (callback === undefined) {
        throw new Error('Received message but no callback');
      }

      if (typeof obj.error === 'string') {
        callback.reject(new Error(obj.error));
      } else {
        callback.resolve(obj);
      }
    }

    async createSubscription(dir, opts) {
      const name = `rome-${process.pid}.${String(this.subscriptionCounter++)}`;
      const event = new ___$romejs$events$src$Event_ts$default({
        name: name});
      this.subscriptions.set(name, event);

      const res = await this.command(['watch-project', dir]);

      if (res == null || typeof res !== 'object') {
        throw new Error('Malformed watchman watch-project response - not an object');
      }

      if (typeof res.watch !== 'string') {
        throw new Error('Malformed watchman watch-project response - non-string watch property');
      }

      if (typeof res.relative_path === 'string') {
        opts = Object.assign({}, opts, {
          expression: ['allof', ['dirname', res.relative_path]]});
      }

      const root = res.watch;
      await this.command(['subscribe', root, name, opts]);

      return {
        root: root,
        event: event};
    }

    async command(args) {
      return new Promise((resolve, reject) => {
        this.callbacks.push({resolve: resolve, reject: reject});
        this.socket.write(JSON.stringify(args) + '\n');
      });
    }

    end() {
      for (const {reject: reject} of this.callbacks) {
        reject(new Error('The watchman connection was closed'));
      }
      this.socket.end();
    }
  }

  async function ___$romejs$codec_watchman$src$index_ts$createWatchmanClient(reporter) {
    let sockname;

    if (typeof process.env.WATCHMAN_SOCK === 'string') {
      sockname = process.env.WATCHMAN_SOCK;
    } else {
      const {stdout: stdout} = await ___$$priv$romejs$codec_watchman$src$index_ts$exec('watchman --no-pretty get-sockname');
      ({sockname: sockname} = JSON.parse(stdout));
    }

    return new Promise((resolve, reject) => {
      if (sockname === undefined) {
        throw new Error('Failed to find watchman socket path');
      }

      const socket = ___$$priv$romejs$codec_watchman$src$index_ts$net.createConnection(sockname);

      socket.on('error', err => {
        reject(err);
      });

      socket.on('connect', () => {
        resolve(new ___$romejs$codec_watchman$src$index_ts$WatchmanClient(socket, reporter));
      });
    });
  }

  // romejs/core/src/common/utils/walkDirectoryPath.ts

  const ___$$priv$romejs$core$src$common$utils$walkDirectoryPath_ts$path = require('path');
  function ___$romejs$core$src$common$utils$walkDirectoryPath_ts$default(dir) {
    let nextDir = dir;

    const iterator = {
      next() {
        const currDir = nextDir;
        nextDir = ___$$priv$romejs$core$src$common$utils$walkDirectoryPath_ts$path.dirname(currDir);

        return {
          value: currDir,
          done: nextDir === currDir};
      }};

    return {
      [Symbol.iterator]() {
        return iterator;
      }};
  }

  // romejs/js-compiler/src/constants.ts

  const ___$romejs$js_compiler$src$constants_ts = {
    get SCOPE_PRIVATE_PREFIX() {
      return ___$romejs$js_compiler$src$constants_ts$SCOPE_PRIVATE_PREFIX;
    },
    get REDUCE_SKIP_SUBTREE() {
      return ___$romejs$js_compiler$src$constants_ts$REDUCE_SKIP_SUBTREE;
    }};
  const ___$romejs$js_compiler$src$constants_ts$SCOPE_PRIVATE_PREFIX = '___$';
  const ___$romejs$js_compiler$src$constants_ts$REDUCE_SKIP_SUBTREE = 'REDUCE_SKIP_SUBTREE';

  // romejs/js-ast-utils/src/assertMultipleNodes.ts

  function ___$romejs$js_ast_utils$src$assertMultipleNodes_ts$default(result) {
    if (Array.isArray(result)) {
      return result;
    } else if (result === undefined) {
      return [];
    } else {
      return [result];
    }
  }

  // romejs/js-ast-utils/src/assertSingleNode.ts

  function ___$romejs$js_ast_utils$src$assertSingleNode_ts$default(result) {
    if (Array.isArray(result)) {
      ___$romejs$invariant$src$index_ts$default(
      result.length === 1,
      `Expected node list length of 1 but got ${result.length}`);
      return result[0];
    } else if (result === undefined) {
      ___$romejs$invariant$src$index_ts$default(false, 'Expected node or node list but got null');
    } else {
      return result;
    }
  }

  // romejs/js-ast-utils/src/getNodeReferenceParts.ts

  function ___$romejs$js_ast_utils$src$getNodeReferenceParts_ts$default(node) {
    const parts = [];

    function add(node) {
      if (node.type === 'Identifier') {
        parts.push(node.name);
        return false;
      } else if (node.type === 'StringLiteral') {
        parts.push(node.value);
        return false;
      } else if (node.type === 'MemberExpression') {
        const stop = add(node.object);
        if (stop) {
          return true;
        }

        if (node.property.type === 'StringLiteral') {
          return add(node.property);
        } else if (node.computed === false) {
          return add(node.property);
        } else {
          return true;
        }
      } else {
        return true;
      }
    }

    add(node);

    return parts;
  }

  // romejs/js-ast-utils/src/doesNodeMatchPattern.ts

  function ___$romejs$js_ast_utils$src$doesNodeMatchPattern_ts$default(member, match, allowPartial = false) {
    if (member.type !== 'MemberExpression' && member.type !== 'Identifier') {
      return false;
    }

    const expectedParts = Array.isArray(match) ? match.slice() : match.split('.');
    const actualParts = ___$romejs$js_ast_utils$src$getNodeReferenceParts_ts$default(member);

    if (actualParts.length < expectedParts.length) {
      return false;
    }

    if (allowPartial === false && actualParts.length > expectedParts.length) {
      return false;
    }

    while (actualParts.length > 0) {
      if (expectedParts.length === 0) {
        return allowPartial;
      }

      const actual = actualParts.shift();
      const expected = expectedParts.shift();

      if (expected === '*') {
        continue;
      }

      if (expected === '**') {
        const next = expectedParts.shift();
        ___$romejs$invariant$src$index_ts$default(
        next !== '*' && next !== '**',
        'The next expected part was %s but this isn\'t allowed since we\'re processing a double star',
        next);

        let found = false;

        while (actualParts.length > 0) {
          const actual = actualParts.shift();
          if (actual === next) {
            found = true;
            break;
          }
        }

        if (found) {
          continue;
        } else {
          return false;
        }
      }

      if (expected !== actual) {
        return false;
      }
    }

    return true;
  }

  // romejs/js-ast-utils/src/getBindingIdentifiers.ts

  const ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$BINDING_IDENTIFIER_KEYS = new Map([['FlowDeclareClass', ['id']], ['FlowDeclareFunction', ['id']], ['FlowDeclareModule', ['id']], ['FlowDeclareVariable', ['id']], ['FlowDeclareInterface', ['id']], ['FlowDeclareTypeAlias', ['id']], ['FlowDeclareOpaqueType', ['id']], ['FlowInterfaceDeclaration', ['id']], ['FlowTypeAlias', ['id']], ['FlowTypeParameterDeclaration', ['params']], ['FlowOpaqueType', ['id']], ['TSImportEqualsDeclaration', ['id']], ['TSTypeAliasDeclaration', ['id']], ['CatchClause', ['param']], ['LabeledStatement', ['label']], ['UnaryExpression', ['argument']], ['AssignmentExpression', ['left']], ['ExportDefaultDeclaration', ['declaration']], ['ExportNamedDeclaration', ['declaration']], ['ImportSpecifier', ['local']], ['ImportNamespaceSpecifier', ['local']], ['ImportDefaultSpecifier', ['local']], ['ImportDeclaration', ['specifiers']], ['FunctionDeclaration', ['id']], ['FunctionExpression', ['id']], ['ForInStatement', ['left']], ['ForOfStatement', ['left']], ['ClassDeclaration', ['id']], ['ClassExpression', ['id']], ['RestProperty', ['argument']], ['RestElement', ['argument']], ['UpdateExpression', ['argument']], ['ObjectProperty', ['value']], ['AssignmentPattern', ['left']], ['ArrayPattern', ['elements']], ['ObjectPattern', ['properties']], ['VariableDeclaration', ['declarations']], ['VariableDeclarator', ['id']]]);

  function ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(node) {
    const ids = [];
    let queue = Array.isArray(node) ? node : [node];

    while (queue.length) {
      const node = queue.pop();
      if (node === undefined) {
        continue;
      }

      if (node.type === 'Identifier' || node.type === 'FlowTypeParameter') {
        ids.push(node);
        continue;
      }

      const keys = ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$BINDING_IDENTIFIER_KEYS.get(
      node.type);
      if (keys === undefined) {
        continue;
      }

      for (const key of keys) {
        const val = node[key];
        if (val === undefined) {
          continue;
        } else if (Array.isArray(val)) {
          queue = queue.concat(val);
        } else {
          queue.push(val);
        }
      }
    }

    return ids;
  }

  // romejs/js-ast-utils/src/hasPotentialSideEffects.ts

  function ___$romejs$js_ast_utils$src$hasPotentialSideEffects_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'ExportNamedDeclaration':
        if (node.source === undefined) {
          if (node.declaration === undefined) {
            return true;
          } else {
            return ___$romejs$js_ast_utils$src$hasPotentialSideEffects_ts$default(node.declaration);
          }
        } else {
          return true;
        }

      case 'FunctionDeclaration':
        return false;

      case 'ClassDeclaration':
        return node.superClass !== undefined;

      case 'Identifier':
        return false;

      case 'VariableDeclaration':
        for (const declarator of node.declarations) {
          if (___$romejs$js_ast_utils$src$hasPotentialSideEffects_ts$default(declarator)) {
            return true;
          }
        }
        return false;

      case 'VariableDeclarator':
        return ___$romejs$js_ast_utils$src$hasPotentialSideEffects_ts$default(node.id) || ___$romejs$js_ast_utils$src$hasPotentialSideEffects_ts$default(node.init);

      case 'AssignmentPattern':
        return ___$romejs$js_ast_utils$src$hasPotentialSideEffects_ts$default(node.right);

      case 'ObjectExpression':
      case 'ObjectPattern':
        for (const prop of node.properties) {
          if (___$romejs$js_ast_utils$src$hasPotentialSideEffects_ts$default(prop)) {
            return true;
          }
        }
        return false;

      case 'ObjectProperty':
        if (node.computed == true && ___$romejs$js_ast_utils$src$hasPotentialSideEffects_ts$default(node.key)) {
          return true;
        } else {
          return ___$romejs$js_ast_utils$src$hasPotentialSideEffects_ts$default(node.value);
        }

      case 'ArrayPattern':
      case 'ArrayExpression':
        for (const elem of node.elements) {
          if (___$romejs$js_ast_utils$src$hasPotentialSideEffects_ts$default(elem)) {
            return true;
          }
        }
        return false;

      case 'StringLiteral':
      case 'NumericLiteral':
      case 'BooleanLiteral':
      case 'NullLiteral':
        return false;}

    return true;
  }

  // romejs/js-ast-utils/src/isBinary.ts

  function ___$romejs$js_ast_utils$src$isBinary_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'BinaryExpression':
      case 'LogicalExpression':
        return true;

      default:
        return false;}
  }

  // romejs/js-ast-utils/src/isBinding.ts

  function ___$romejs$js_ast_utils$src$isBinding_ts$default(node, parent) {
    if (node === undefined || parent === undefined) {
      return false;
    }

    const keys = ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$BINDING_IDENTIFIER_KEYS.get(parent.type);
    if (keys === undefined) {
      return false;
    }

    for (const key of keys) {
      const val = parent[key];
      if (Array.isArray(val) && val.includes(node)) {
        return true;
      } else if (val === node) {
        return true;
      }
    }

    return false;
  }

  // romejs/js-ast-utils/src/isConditional.ts

  function ___$romejs$js_ast_utils$src$isConditional_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'ConditionalExpression':
      case 'IfStatement':
        return true;

      default:
        return false;}
  }

  // romejs/js-ast-utils/src/isTypeNode.ts

  function ___$romejs$js_ast_utils$src$isTypeNode_ts$default(node) {
    if (node.type.startsWith('Flow') || node.type.startsWith('TS')) {
      return true;
    } else if (node.type === 'ImportDeclaration') {
      return node.importKind === 'type' || node.importKind === 'typeof';
    } else if (node.type === 'ExportDefaultDeclaration' ||
    node.type === 'ExportNamedDeclaration' ||
    node.type === 'ExportAllDeclaration') {
      return node.exportKind === 'type';
    } else if (node.type === 'ImportSpecifier') {
      return node.importKind === 'type' || node.importKind === 'typeof';
    } else {
      return false;
    }
  }

  // romejs/js-ast-utils/src/isFor.ts

  function ___$romejs$js_ast_utils$src$isFor_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'ForStatement':
      case 'ForInStatement':
      case 'ForOfStatement':
        return true;

      default:
        return false;}
  }

  // romejs/js-ast-utils/src/isFunctionNode.ts

  function ___$romejs$js_ast_utils$src$isFunctionNode_ts$default(node) {
    return node.type === 'FunctionDeclaration' ||
    node.type === 'FunctionExpression' ||
    node.type === 'ObjectMethod' ||
    node.type === 'ArrowFunctionExpression' ||
    node.type === 'ClassMethod';
  }

  // romejs/js-ast-utils/src/isNodeLike.ts

  function ___$romejs$js_ast_utils$src$isNodeLike_ts$default(node) {
    if (node == null) {
      return false;
    } else {
      return typeof node === 'object' && typeof node.type === 'string';
    }
  }

  // romejs/js-ast-utils/src/isReferenced.ts

  function ___$romejs$js_ast_utils$src$isReferenced_ts$default(path) {
    const {node: node, parent: parent} = path;
    if (parent === undefined) {
      return false;
    }

    switch (parent.type) {
      case 'MemberExpression':
      case 'OptionalMemberExpression':
      case 'JSXMemberExpression':
        if (parent.property === node && parent.computed) {
          return true;
        } else if (parent.object === node) {
          return true;
        } else {
          return false;
        }

      case 'FlowQualifiedTypeIdentifier':
        return parent.qualification === node;

      case 'MetaProperty':
        return false;

      case 'ObjectProperty':
        if (parent.key === node) {
          return Boolean(parent.computed);
        } else {
          return true;
        }

      case 'FlowObjectTypeProperty':
        return parent.value === node;

      case 'VariableDeclarator':
        return parent.id !== node;

      case 'FlowFunctionTypeAnnotation':
        return parent.returnType === node;

      case 'ArrowFunctionExpression':
      case 'FunctionDeclaration':
      case 'FunctionExpression':
        return false;

      case 'ArrowFunctionExpression':
        return parent.body === node;

      case 'ExportSpecifier':
        {
          if (path.parentPath !== undefined) {
            const exportDeclaration = path.parentPath.parent;
            if (exportDeclaration !== undefined &&
            exportDeclaration.type === 'ExportNamedDeclaration' &&
            exportDeclaration.source === undefined) {
              return parent.local === node;
            }
          }

          return false;
        }

      case 'ExportNamespaceSpecifier':
      case 'ExportDefaultSpecifier':
        return false;

      case 'JSXAttribute':
        return parent.name !== node;

      case 'ClassProperty':
        if (parent.key === node) {
          return parent.computed;
        } else {
          return parent.value === node;
        }

      case 'ImportDefaultSpecifier':
      case 'ImportNamespaceSpecifier':
      case 'ImportSpecifier':
        return false;

      case 'ClassDeclaration':
      case 'ClassExpression':
        return parent.id !== node;

      case 'ClassMethod':
      case 'ObjectMethod':
        return parent.key === node && Boolean(parent.computed);

      case 'LabeledStatement':
        return false;

      case 'CatchClause':
        return parent.param !== node;

      case 'FlowFunctionTypeParam':
        return false;

      case 'RestElement':
        return false;

      case 'BreakStatement':
      case 'ContinueStatement':
        return false;

      case 'AssignmentPattern':
        return parent.right === node;

      case 'FlowObjectTypeIndexer':
        return parent.id !== node;

      case 'ObjectPattern':
      case 'ArrayPattern':
        return false;}

    return true;
  }

  // romejs/js-ast-utils/src/isStatement.ts

  function ___$romejs$js_ast_utils$src$isStatement_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'BlockStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
      case 'DebuggerStatement':
      case 'DoWhileStatement':
      case 'EmptyStatement':
      case 'ExpressionStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'FunctionDeclaration':
      case 'IfStatement':
      case 'LabeledStatement':
      case 'ReturnStatement':
      case 'SwitchStatement':
      case 'ThrowStatement':
      case 'TryStatement':
      case 'VariableDeclaration':
      case 'WhileStatement':
      case 'WithStatement':
      case 'ClassDeclaration':
      case 'ExportAllDeclaration':
      case 'ExportDefaultDeclaration':
      case 'ExportNamedDeclaration':
      case 'ForOfStatement':
      case 'ImportDeclaration':
      case 'FlowDeclareClass':
      case 'FlowDeclareFunction':
      case 'FlowDeclareInterface':
      case 'FlowDeclareModule':
      case 'FlowDeclareModuleExports':
      case 'FlowDeclareTypeAlias':
      case 'FlowDeclareOpaqueType':
      case 'FlowDeclareVariable':
      case 'FlowDeclareExportDeclaration':
      case 'FlowInterfaceDeclaration':
      case 'FlowTypeAlias':
      case 'FlowOpaqueType':
      case 'TSTypeAliasDeclaration':
      case 'ForAwaitStatement':
        return true;

      default:
        return false;}
  }

  // romejs/js-ast-utils/src/isUnaryLike.ts

  function ___$romejs$js_ast_utils$src$isUnaryLike_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'UnaryExpression':
      case 'SpreadElement':
      case 'RestProperty':
      case 'SpreadProperty':
        return true;

      default:
        return false;}
  }

  // romejs/js-ast-utils/src/isValidIdentifierName.ts

  function ___$romejs$js_ast_utils$src$isValidIdentifierName_ts$default(name) {
    if (name.length === 0) {
      return false;
    }

    if (___$romejs$js_parser_utils$src$identifier_ts$isStrictReservedWord(name, true)) {
      return false;
    }

    if (___$romejs$js_parser_utils$src$identifier_ts$isStrictBindReservedWord(name, true)) {
      return false;
    }

    if (___$romejs$js_parser_utils$src$identifier_ts$isES2015ReservedWord(name)) {
      return false;
    }

    if (___$romejs$js_parser_utils$src$identifier_ts$isKeyword(name)) {
      return false;
    }

    if (___$romejs$js_parser_utils$src$identifier_ts$isIdentifierStart(___$romejs$js_parser_utils$src$identifier_ts$getFullCharCodeAt(name, 0)) === false) {
      return false;
    }

    let i = 1;
    while (i < name.length) {
      const code = ___$romejs$js_parser_utils$src$identifier_ts$getFullCharCodeAt(name, 0);
      if (___$romejs$js_parser_utils$src$identifier_ts$isIdentifierChar(code)) {
        i += code <= 65535 ? 1 : 2;
      } else {
        return false;
      }
    }

    return true;
  }

  // romejs/js-ast/src/utils.ts

  const ___$romejs$js_ast$src$utils_ts$FUNCTION_VISITOR_KEYS = ['params', 'body', 'returnType', 'typeParameters', 'predicate', 'decorators'];
  const ___$romejs$js_ast$src$utils_ts$BOUND_FUNCTION_VISITOR_KEYS = ['id', ...___$romejs$js_ast$src$utils_ts$FUNCTION_VISITOR_KEYS];
  const ___$romejs$js_ast$src$utils_ts$METHOD_FUNCTION_VISITOR_KEYS = ['key', ...___$romejs$js_ast$src$utils_ts$FUNCTION_VISITOR_KEYS];

  const ___$romejs$js_ast$src$utils_ts$CLASS_VISITOR_KEYS = ['id', 'body', 'superClass', 'mixins', 'typeParameters', 'superTypeParameters', 'implements', 'decorators'];

  const ___$romejs$js_ast$src$utils_ts$visitorKeys = new Map();
  const ___$romejs$js_ast$src$utils_ts$nodeNames = new Set();

  function ___$romejs$js_ast$src$utils_ts$assertNodeTypeSet(names) {
    const set = new Set(names);

    const errors = [];

    for (const name of set) {
      if (name[0] === '_') {
        continue;
      }

      if (___$romejs$js_ast$src$utils_ts$nodeNames.has(name) === false) {
        errors.push(`${name} is not a valid node`);
      }
    }

    for (const name of ___$romejs$js_ast$src$utils_ts$nodeNames) {
      if (set.has(name) === false) {
        errors.push(`${name} does not appear`);
      }
    }

    if (errors.length > 0) {
      throw new Error(errors.join('\n'));
    }
  }

  function ___$romejs$js_ast$src$utils_ts$createBuilder(type, opts = {}) {
    ___$romejs$js_ast$src$utils_ts$nodeNames.add(type);

    if (opts.visitorKeys !== undefined) {
      ___$romejs$js_ast$src$utils_ts$visitorKeys.set(type, opts.visitorKeys);
    }

    return new ___$$priv$romejs$js_ast$src$utils_ts$Builder(type, opts.visitorKeys === undefined ? [] : opts.visitorKeys);
  }

  class ___$$priv$romejs$js_ast$src$utils_ts$Builder {
    constructor(type, visitorKeys) {
      this.type = type;
      this.visitorKeys = visitorKeys;
    }

    create(opts) {
      return Object.assign({}, opts, {
        type: this.type});
    }

    is(node) {
      return node !== undefined && node.type === this.type;
    }

    normalize(node) {
      if (this.is(node)) {
        return node;
      }
    }

    assert(node) {
      ___$romejs$invariant$src$index_ts$default(
      node !== undefined && node.type === this.type,
      `Expected ${this.type} Node`);
      return node;
    }
  }

  // romejs/js-ast/src/base.ts

  const ___$romejs$js_ast$src$base_ts = {};

  // romejs/js-ast/src/constants.ts

  const ___$romejs$js_ast$src$constants_ts = {};

  // romejs/js-ast/src/unions.ts

  const ___$romejs$js_ast$src$unions_ts = {};

  // romejs/js-ast/src/core/InterpreterDirective.ts

  const ___$romejs$js_ast$src$core$InterpreterDirective_ts = {
    get interpreterDirective() {
      return ___$romejs$js_ast$src$core$InterpreterDirective_ts$interpreterDirective;
    }};
  const ___$romejs$js_ast$src$core$InterpreterDirective_ts$interpreterDirective = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'InterpreterDirective');

  // romejs/js-ast/src/flow/FlowAnyTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowAnyTypeAnnotation_ts = {
    get flowAnyTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowAnyTypeAnnotation_ts$flowAnyTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowAnyTypeAnnotation_ts$flowAnyTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowAnyTypeAnnotation');

  // romejs/js-ast/src/core/ArrayExpression.ts

  const ___$romejs$js_ast$src$core$ArrayExpression_ts = {
    get arrayExpression() {
      return ___$romejs$js_ast$src$core$ArrayExpression_ts$arrayExpression;
    }};
  const ___$romejs$js_ast$src$core$ArrayExpression_ts$arrayExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ArrayExpression',
  {visitorKeys: ['elements']});

  // romejs/js-ast/src/core/ArrayPattern.ts

  const ___$romejs$js_ast$src$core$ArrayPattern_ts = {
    get arrayPattern() {
      return ___$romejs$js_ast$src$core$ArrayPattern_ts$arrayPattern;
    }};
  const ___$romejs$js_ast$src$core$ArrayPattern_ts$arrayPattern = ___$romejs$js_ast$src$utils_ts$createBuilder('ArrayPattern', {
    visitorKeys: ['elements', 'typeAnnotation']});

  // romejs/js-ast/src/flow/FlowArrayTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowArrayTypeAnnotation_ts = {
    get flowArrayTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowArrayTypeAnnotation_ts$flowArrayTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowArrayTypeAnnotation_ts$flowArrayTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowArrayTypeAnnotation',
  {visitorKeys: ['elementType']});

  // romejs/js-ast/src/core/ArrowFunctionExpression.ts

  const ___$romejs$js_ast$src$core$ArrowFunctionExpression_ts = {
    get arrowFunctionExpression() {
      return ___$romejs$js_ast$src$core$ArrowFunctionExpression_ts$arrowFunctionExpression;
    }};
  const ___$romejs$js_ast$src$core$ArrowFunctionExpression_ts$arrowFunctionExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ArrowFunctionExpression', {
    visitorKeys: ___$romejs$js_ast$src$utils_ts$FUNCTION_VISITOR_KEYS});

  // romejs/js-ast/src/core/AssignmentExpression.ts

  const ___$romejs$js_ast$src$core$AssignmentExpression_ts = {
    get assignmentExpression() {
      return ___$romejs$js_ast$src$core$AssignmentExpression_ts$assignmentExpression;
    }};
  const ___$romejs$js_ast$src$core$AssignmentExpression_ts$assignmentExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'AssignmentExpression',
  {visitorKeys: ['left', 'right']});

  // romejs/js-ast/src/core/AssignmentPattern.ts

  const ___$romejs$js_ast$src$core$AssignmentPattern_ts = {
    get assignmentPattern() {
      return ___$romejs$js_ast$src$core$AssignmentPattern_ts$assignmentPattern;
    }};
  const ___$romejs$js_ast$src$core$AssignmentPattern_ts$assignmentPattern = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'AssignmentPattern',
  {
    visitorKeys: ['left', 'right']});

  // romejs/js-ast/src/core/AwaitExpression.ts

  const ___$romejs$js_ast$src$core$AwaitExpression_ts = {
    get awaitExpression() {
      return ___$romejs$js_ast$src$core$AwaitExpression_ts$awaitExpression;
    }};
  const ___$romejs$js_ast$src$core$AwaitExpression_ts$awaitExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'AwaitExpression',
  {visitorKeys: ['argument']});

  // romejs/js-ast/src/flow/FlowBigIntTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowBigIntTypeAnnotation_ts = {
    get flowBigIntTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowBigIntTypeAnnotation_ts$flowBigIntTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowBigIntTypeAnnotation_ts$flowBigIntTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowBigIntTypeAnnotation');

  // romejs/js-ast/src/core/BinaryExpressionNode.ts

  const ___$romejs$js_ast$src$core$BinaryExpressionNode_ts = {
    get binaryExpression() {
      return ___$romejs$js_ast$src$core$BinaryExpressionNode_ts$binaryExpression;
    }};
  const ___$romejs$js_ast$src$core$BinaryExpressionNode_ts$binaryExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'BinaryExpression',
  {
    visitorKeys: ['left', 'right']});

  // romejs/js-ast/src/core/BlockStatement.ts

  const ___$romejs$js_ast$src$core$BlockStatement_ts = {
    get blockStatement() {
      return ___$romejs$js_ast$src$core$BlockStatement_ts$blockStatement;
    }};
  const ___$romejs$js_ast$src$core$BlockStatement_ts$blockStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'BlockStatement',
  {visitorKeys: ['body', 'directives']});

  // romejs/js-ast/src/core/BooleanLiteral.ts

  const ___$romejs$js_ast$src$core$BooleanLiteral_ts = {
    get booleanLiteral() {
      return ___$romejs$js_ast$src$core$BooleanLiteral_ts$booleanLiteral;
    }};
  const ___$romejs$js_ast$src$core$BooleanLiteral_ts$booleanLiteral = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'BooleanLiteral');

  // romejs/js-ast/src/flow/FlowBooleanLiteralTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowBooleanLiteralTypeAnnotation_ts = {
    get flowBooleanLiteralTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowBooleanLiteralTypeAnnotation_ts$flowBooleanLiteralTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowBooleanLiteralTypeAnnotation_ts$flowBooleanLiteralTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowBooleanLiteralTypeAnnotation');

  // romejs/js-ast/src/flow/FlowBooleanTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowBooleanTypeAnnotation_ts = {
    get flowBooleanTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowBooleanTypeAnnotation_ts$flowBooleanTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowBooleanTypeAnnotation_ts$flowBooleanTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowBooleanTypeAnnotation');

  // romejs/js-ast/src/core/BreakStatement.ts

  const ___$romejs$js_ast$src$core$BreakStatement_ts = {
    get breakStatement() {
      return ___$romejs$js_ast$src$core$BreakStatement_ts$breakStatement;
    }};
  const ___$romejs$js_ast$src$core$BreakStatement_ts$breakStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'BreakStatement',
  {visitorKeys: ['label']});

  // romejs/js-ast/src/core/CallExpression.ts

  const ___$romejs$js_ast$src$core$CallExpression_ts = {
    get callExpression() {
      return ___$romejs$js_ast$src$core$CallExpression_ts$callExpression;
    }};
  const ___$romejs$js_ast$src$core$CallExpression_ts$callExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'CallExpression',
  {
    visitorKeys: ['callee', 'arguments', 'typeArguments']});

  // romejs/js-ast/src/core/CatchClause.ts

  const ___$romejs$js_ast$src$core$CatchClause_ts = {
    get catchClause() {
      return ___$romejs$js_ast$src$core$CatchClause_ts$catchClause;
    }};
  const ___$romejs$js_ast$src$core$CatchClause_ts$catchClause = ___$romejs$js_ast$src$utils_ts$createBuilder('CatchClause', {
    visitorKeys: ['param', 'body']});

  // romejs/js-ast/src/core/ClassDeclaration.ts

  const ___$romejs$js_ast$src$core$ClassDeclaration_ts = {
    assertClass: ___$romejs$js_ast$src$core$ClassDeclaration_ts$assertClass,
    get classDeclaration() {
      return ___$romejs$js_ast$src$core$ClassDeclaration_ts$classDeclaration;
    }};
  function ___$romejs$js_ast$src$core$ClassDeclaration_ts$assertClass(node) {
    ___$romejs$invariant$src$index_ts$default(
    node.type === 'ClassExpression' || node.type === 'ClassDeclaration',
    'Expected ClassDeclaration or ClassExpression Node');
    return node;
  }

  const ___$romejs$js_ast$src$core$ClassDeclaration_ts$classDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ClassDeclaration',
  {
    visitorKeys: ___$romejs$js_ast$src$utils_ts$CLASS_VISITOR_KEYS});

  // romejs/js-ast/src/core/ClassExpression.ts

  const ___$romejs$js_ast$src$core$ClassExpression_ts = {
    get classExpression() {
      return ___$romejs$js_ast$src$core$ClassExpression_ts$classExpression;
    }};
  const ___$romejs$js_ast$src$core$ClassExpression_ts$classExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ClassExpression',
  {visitorKeys: ___$romejs$js_ast$src$utils_ts$CLASS_VISITOR_KEYS});

  // romejs/js-ast/src/flow/FlowClassImplements.ts

  const ___$romejs$js_ast$src$flow$FlowClassImplements_ts = {
    get flowClassImplements() {
      return ___$romejs$js_ast$src$flow$FlowClassImplements_ts$flowClassImplements;
    }};
  const ___$romejs$js_ast$src$flow$FlowClassImplements_ts$flowClassImplements = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowClassImplements',
  {visitorKeys: ['id', 'typeParameters']});

  // romejs/js-ast/src/core/ClassMethod.ts

  const ___$romejs$js_ast$src$core$ClassMethod_ts = {
    get classMethod() {
      return ___$romejs$js_ast$src$core$ClassMethod_ts$classMethod;
    }};
  const ___$romejs$js_ast$src$core$ClassMethod_ts$classMethod = ___$romejs$js_ast$src$utils_ts$createBuilder('ClassMethod', {
    visitorKeys: ___$romejs$js_ast$src$utils_ts$METHOD_FUNCTION_VISITOR_KEYS});

  // romejs/js-ast/src/core/ClassPrivateMethod.ts

  const ___$romejs$js_ast$src$core$ClassPrivateMethod_ts = {
    get classPrivateMethod() {
      return ___$romejs$js_ast$src$core$ClassPrivateMethod_ts$classPrivateMethod;
    }};
  const ___$romejs$js_ast$src$core$ClassPrivateMethod_ts$classPrivateMethod = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ClassPrivateMethod');

  // romejs/js-ast/src/core/ClassPrivateProperty.ts

  const ___$romejs$js_ast$src$core$ClassPrivateProperty_ts = {
    get classPrivateProperty() {
      return ___$romejs$js_ast$src$core$ClassPrivateProperty_ts$classPrivateProperty;
    }};
  const ___$romejs$js_ast$src$core$ClassPrivateProperty_ts$classPrivateProperty = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ClassPrivateProperty');

  // romejs/js-ast/src/core/ClassProperty.ts

  const ___$romejs$js_ast$src$core$ClassProperty_ts = {
    get classProperty() {
      return ___$romejs$js_ast$src$core$ClassProperty_ts$classProperty;
    }};
  const ___$romejs$js_ast$src$core$ClassProperty_ts$classProperty = ___$romejs$js_ast$src$utils_ts$createBuilder('ClassProperty', {
    visitorKeys: ['key', 'value', 'typeAnnotation', 'decorators']});

  // romejs/js-ast/src/core/ConditionalExpression.ts

  const ___$romejs$js_ast$src$core$ConditionalExpression_ts = {
    get conditionalExpression() {
      return ___$romejs$js_ast$src$core$ConditionalExpression_ts$conditionalExpression;
    }};
  const ___$romejs$js_ast$src$core$ConditionalExpression_ts$conditionalExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ConditionalExpression',
  {visitorKeys: ['test', 'consequent', 'alternate']});

  // romejs/js-ast/src/core/ContinueStatement.ts

  const ___$romejs$js_ast$src$core$ContinueStatement_ts = {
    get continueStatement() {
      return ___$romejs$js_ast$src$core$ContinueStatement_ts$continueStatement;
    }};
  const ___$romejs$js_ast$src$core$ContinueStatement_ts$continueStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ContinueStatement',
  {visitorKeys: ['label']});

  // romejs/js-ast/src/core/DebuggerStatement.ts

  const ___$romejs$js_ast$src$core$DebuggerStatement_ts = {
    get debuggerStatement() {
      return ___$romejs$js_ast$src$core$DebuggerStatement_ts$debuggerStatement;
    }};
  const ___$romejs$js_ast$src$core$DebuggerStatement_ts$debuggerStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'DebuggerStatement');

  // romejs/js-ast/src/flow/FlowDeclareClass.ts

  const ___$romejs$js_ast$src$flow$FlowDeclareClass_ts = {
    get flowDeclareClass() {
      return ___$romejs$js_ast$src$flow$FlowDeclareClass_ts$flowDeclareClass;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclareClass_ts$flowDeclareClass = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclareClass',
  {visitorKeys: ['id', 'typeParameters', 'extends', 'body']});

  // romejs/js-ast/src/flow/FlowDeclareExportDeclaration.ts

  const ___$romejs$js_ast$src$flow$FlowDeclareExportDeclaration_ts = {
    get flowDeclareExportDeclaration() {
      return ___$romejs$js_ast$src$flow$FlowDeclareExportDeclaration_ts$flowDeclareExportDeclaration;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclareExportDeclaration_ts$flowDeclareExportDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclareExportDeclaration', {
    visitorKeys: ['declaration', 'specifiers', 'source']});

  // romejs/js-ast/src/flow/FlowDeclareFunction.ts

  const ___$romejs$js_ast$src$flow$FlowDeclareFunction_ts = {
    get flowDeclareFunction() {
      return ___$romejs$js_ast$src$flow$FlowDeclareFunction_ts$flowDeclareFunction;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclareFunction_ts$flowDeclareFunction = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclareFunction',
  {visitorKeys: ['id']});

  // romejs/js-ast/src/flow/FlowDeclareInterface.ts

  const ___$romejs$js_ast$src$flow$FlowDeclareInterface_ts = {
    get flowDeclareInterface() {
      return ___$romejs$js_ast$src$flow$FlowDeclareInterface_ts$flowDeclareInterface;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclareInterface_ts$flowDeclareInterface = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclareInterface',
  {visitorKeys: ['id', 'typeParameters', 'extends', 'body']});

  // romejs/js-ast/src/flow/FlowDeclareModule.ts

  const ___$romejs$js_ast$src$flow$FlowDeclareModule_ts = {
    get flowDeclareModule() {
      return ___$romejs$js_ast$src$flow$FlowDeclareModule_ts$flowDeclareModule;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclareModule_ts$flowDeclareModule = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclareModule',
  {visitorKeys: ['id', 'body']});

  // romejs/js-ast/src/flow/FlowDeclareModuleExports.ts

  const ___$romejs$js_ast$src$flow$FlowDeclareModuleExports_ts = {
    get flowDeclareModuleExports() {
      return ___$romejs$js_ast$src$flow$FlowDeclareModuleExports_ts$flowDeclareModuleExports;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclareModuleExports_ts$flowDeclareModuleExports = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclareModuleExports',
  {visitorKeys: ['typeAnnotation']});

  // romejs/js-ast/src/flow/FlowDeclareOpaqueType.ts

  const ___$romejs$js_ast$src$flow$FlowDeclareOpaqueType_ts = {
    get flowDeclareOpaqueType() {
      return ___$romejs$js_ast$src$flow$FlowDeclareOpaqueType_ts$flowDeclareOpaqueType;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclareOpaqueType_ts$flowDeclareOpaqueType = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclareOpaqueType',
  {visitorKeys: ['id', 'typeParameters', 'supertype']});

  // romejs/js-ast/src/flow/FlowDeclareTypeAlias.ts

  const ___$romejs$js_ast$src$flow$FlowDeclareTypeAlias_ts = {
    get flowDeclareTypeAlias() {
      return ___$romejs$js_ast$src$flow$FlowDeclareTypeAlias_ts$flowDeclareTypeAlias;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclareTypeAlias_ts$flowDeclareTypeAlias = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclareTypeAlias',
  {visitorKeys: ['id', 'typeParameters', 'right']});

  // romejs/js-ast/src/flow/FlowDeclareVariable.ts

  const ___$romejs$js_ast$src$flow$FlowDeclareVariable_ts = {
    get flowDeclareVariable() {
      return ___$romejs$js_ast$src$flow$FlowDeclareVariable_ts$flowDeclareVariable;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclareVariable_ts$flowDeclareVariable = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclareVariable',
  {visitorKeys: ['id']});

  // romejs/js-ast/src/core/Directive.ts

  const ___$romejs$js_ast$src$core$Directive_ts = {
    get directive() {
      return ___$romejs$js_ast$src$core$Directive_ts$directive;
    }};
  const ___$romejs$js_ast$src$core$Directive_ts$directive = ___$romejs$js_ast$src$utils_ts$createBuilder('Directive', {
    visitorKeys: ['value']});

  // romejs/js-ast/src/core/DoWhileStatement.ts

  const ___$romejs$js_ast$src$core$DoWhileStatement_ts = {
    get doWhileStatement() {
      return ___$romejs$js_ast$src$core$DoWhileStatement_ts$doWhileStatement;
    }};
  const ___$romejs$js_ast$src$core$DoWhileStatement_ts$doWhileStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'DoWhileStatement',
  {visitorKeys: ['test', 'body']});

  // romejs/js-ast/src/core/EmptyStatement.ts

  const ___$romejs$js_ast$src$core$EmptyStatement_ts = {
    get emptyStatement() {
      return ___$romejs$js_ast$src$core$EmptyStatement_ts$emptyStatement;
    }};
  const ___$romejs$js_ast$src$core$EmptyStatement_ts$emptyStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'EmptyStatement');

  // romejs/js-ast/src/flow/FlowEmptyTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowEmptyTypeAnnotation_ts = {
    get flowEmptyTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowEmptyTypeAnnotation_ts$flowEmptyTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowEmptyTypeAnnotation_ts$flowEmptyTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowEmptyTypeAnnotation');

  // romejs/js-ast/src/flow/FlowExistsTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowExistsTypeAnnotation_ts = {
    get flowExistsTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowExistsTypeAnnotation_ts$flowExistsTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowExistsTypeAnnotation_ts$flowExistsTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowExistsTypeAnnotation');

  // romejs/js-ast/src/core/ExportAllDeclaration.ts

  const ___$romejs$js_ast$src$core$ExportAllDeclaration_ts = {
    get exportAllDeclaration() {
      return ___$romejs$js_ast$src$core$ExportAllDeclaration_ts$exportAllDeclaration;
    }};
  const ___$romejs$js_ast$src$core$ExportAllDeclaration_ts$exportAllDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ExportAllDeclaration',
  {visitorKeys: ['source']});

  // romejs/js-ast/src/core/ExportDefaultDeclaration.ts

  const ___$romejs$js_ast$src$core$ExportDefaultDeclaration_ts = {
    get exportDefaultDeclaration() {
      return ___$romejs$js_ast$src$core$ExportDefaultDeclaration_ts$exportDefaultDeclaration;
    }};
  const ___$romejs$js_ast$src$core$ExportDefaultDeclaration_ts$exportDefaultDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ExportDefaultDeclaration', {visitorKeys: ['declaration']});

  // romejs/js-ast/src/core/ExportDefaultSpecifier.ts

  const ___$romejs$js_ast$src$core$ExportDefaultSpecifier_ts = {
    get exportDefaultSpecifier() {
      return ___$romejs$js_ast$src$core$ExportDefaultSpecifier_ts$exportDefaultSpecifier;
    }};
  const ___$romejs$js_ast$src$core$ExportDefaultSpecifier_ts$exportDefaultSpecifier = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ExportDefaultSpecifier',
  {visitorKeys: ['exported']});

  // romejs/js-ast/src/core/ExportNamedDeclaration.ts

  const ___$romejs$js_ast$src$core$ExportNamedDeclaration_ts = {
    get exportNamedDeclaration() {
      return ___$romejs$js_ast$src$core$ExportNamedDeclaration_ts$exportNamedDeclaration;
    }};
  const ___$romejs$js_ast$src$core$ExportNamedDeclaration_ts$exportNamedDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ExportNamedDeclaration',
  {
    visitorKeys: ['declaration', 'specifiers', 'source']});

  // romejs/js-ast/src/core/ExportNamespaceSpecifier.ts

  const ___$romejs$js_ast$src$core$ExportNamespaceSpecifier_ts = {
    get exportNamespaceSpecifier() {
      return ___$romejs$js_ast$src$core$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier;
    }};
  const ___$romejs$js_ast$src$core$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ExportNamespaceSpecifier',
  {visitorKeys: ['exported']});

  // romejs/js-ast/src/core/ExportSpecifier.ts

  const ___$romejs$js_ast$src$core$ExportSpecifier_ts = {
    get exportSpecifier() {
      return ___$romejs$js_ast$src$core$ExportSpecifier_ts$exportSpecifier;
    }};
  const ___$romejs$js_ast$src$core$ExportSpecifier_ts$exportSpecifier = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ExportSpecifier',
  {visitorKeys: ['local', 'exported']});

  // romejs/js-ast/src/core/ExpressionStatement.ts

  const ___$romejs$js_ast$src$core$ExpressionStatement_ts = {
    get expressionStatement() {
      return ___$romejs$js_ast$src$core$ExpressionStatement_ts$expressionStatement;
    }};
  const ___$romejs$js_ast$src$core$ExpressionStatement_ts$expressionStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ExpressionStatement',
  {visitorKeys: ['expression']});

  // romejs/js-ast/src/core/ForStatement.ts

  const ___$romejs$js_ast$src$core$ForStatement_ts = {
    get forStatement() {
      return ___$romejs$js_ast$src$core$ForStatement_ts$forStatement;
    }};
  const ___$romejs$js_ast$src$core$ForStatement_ts$forStatement = ___$romejs$js_ast$src$utils_ts$createBuilder('ForStatement', {
    visitorKeys: ['init', 'test', 'update', 'body']});

  // romejs/js-ast/src/core/FunctionDeclaration.ts

  const ___$romejs$js_ast$src$core$FunctionDeclaration_ts = {
    get functionDeclaration() {
      return ___$romejs$js_ast$src$core$FunctionDeclaration_ts$functionDeclaration;
    }};
  const ___$romejs$js_ast$src$core$FunctionDeclaration_ts$functionDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FunctionDeclaration',
  {
    visitorKeys: ___$romejs$js_ast$src$utils_ts$BOUND_FUNCTION_VISITOR_KEYS});

  // romejs/js-ast/src/core/FunctionExpression.ts

  const ___$romejs$js_ast$src$core$FunctionExpression_ts = {
    get functionExpression() {
      return ___$romejs$js_ast$src$core$FunctionExpression_ts$functionExpression;
    }};
  const ___$romejs$js_ast$src$core$FunctionExpression_ts$functionExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FunctionExpression',
  {
    visitorKeys: ___$romejs$js_ast$src$utils_ts$BOUND_FUNCTION_VISITOR_KEYS});

  // romejs/js-ast/src/flow/FlowFunctionTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowFunctionTypeAnnotation_ts = {
    get flowFunctionTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowFunctionTypeAnnotation_ts$flowFunctionTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowFunctionTypeAnnotation_ts$flowFunctionTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowFunctionTypeAnnotation', {
    visitorKeys: ['typeParameters', 'params', 'rest', 'returnType']});

  // romejs/js-ast/src/flow/FlowFunctionTypeParam.ts

  const ___$romejs$js_ast$src$flow$FlowFunctionTypeParam_ts = {
    get flowFunctionTypeParam() {
      return ___$romejs$js_ast$src$flow$FlowFunctionTypeParam_ts$flowFunctionTypeParam;
    }};
  const ___$romejs$js_ast$src$flow$FlowFunctionTypeParam_ts$flowFunctionTypeParam = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowFunctionTypeParam',
  {visitorKeys: ['name', 'typeAnnotation']});

  // romejs/js-ast/src/flow/FlowGenericTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowGenericTypeAnnotation_ts = {
    get flowGenericTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowGenericTypeAnnotation_ts$flowGenericTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowGenericTypeAnnotation_ts$flowGenericTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowGenericTypeAnnotation',
  {visitorKeys: ['id', 'typeParameters']});

  // romejs/js-ast/src/core/Identifier.ts

  const ___$romejs$js_ast$src$core$Identifier_ts = {
    get identifier() {
      return ___$romejs$js_ast$src$core$Identifier_ts$identifier;
    }};
  const ___$romejs$js_ast$src$core$Identifier_ts$identifier = ___$romejs$js_ast$src$utils_ts$createBuilder('Identifier', {
    visitorKeys: ['typeAnnotation']});

  // romejs/js-ast/src/core/IfStatement.ts

  const ___$romejs$js_ast$src$core$IfStatement_ts = {
    get ifStatement() {
      return ___$romejs$js_ast$src$core$IfStatement_ts$ifStatement;
    }};
  const ___$romejs$js_ast$src$core$IfStatement_ts$ifStatement = ___$romejs$js_ast$src$utils_ts$createBuilder('IfStatement', {
    visitorKeys: ['test', 'consequent', 'alternate']});

  // romejs/js-ast/src/core/Import.ts

  const ___$romejs$js_ast$src$core$Import_ts = {
    get _import() {
      return ___$romejs$js_ast$src$core$Import_ts$_import;
    }};
  const ___$romejs$js_ast$src$core$Import_ts$_import = ___$romejs$js_ast$src$utils_ts$createBuilder('Import');

  // romejs/js-ast/src/core/ImportDeclaration.ts

  const ___$romejs$js_ast$src$core$ImportDeclaration_ts = {
    get importDeclaration() {
      return ___$romejs$js_ast$src$core$ImportDeclaration_ts$importDeclaration;
    }};
  const ___$romejs$js_ast$src$core$ImportDeclaration_ts$importDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ImportDeclaration',
  {visitorKeys: ['specifiers', 'source']});

  // romejs/js-ast/src/core/ImportSpecifier.ts

  const ___$romejs$js_ast$src$core$ImportSpecifier_ts = {
    get importSpecifier() {
      return ___$romejs$js_ast$src$core$ImportSpecifier_ts$importSpecifier;
    }};
  const ___$romejs$js_ast$src$core$ImportSpecifier_ts$importSpecifier = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ImportSpecifier',
  {visitorKeys: ['local', 'imported']});

  // romejs/js-ast/src/flow/FlowInterfaceExtends.ts

  const ___$romejs$js_ast$src$flow$FlowInterfaceExtends_ts = {
    get flowInterfaceExtends() {
      return ___$romejs$js_ast$src$flow$FlowInterfaceExtends_ts$flowInterfaceExtends;
    }};
  const ___$romejs$js_ast$src$flow$FlowInterfaceExtends_ts$flowInterfaceExtends = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowInterfaceExtends',
  {visitorKeys: ['id', 'typeParameters']});

  // romejs/js-ast/src/flow/FlowIntersectionTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowIntersectionTypeAnnotation_ts = {
    get flowIntersectionTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowIntersectionTypeAnnotation_ts$flowIntersectionTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowIntersectionTypeAnnotation_ts$flowIntersectionTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowIntersectionTypeAnnotation',
  {visitorKeys: ['types']});

  // romejs/js-ast/src/jsx/JSXAttribute.ts

  const ___$romejs$js_ast$src$jsx$JSXAttribute_ts = {
    get jsxAttribute() {
      return ___$romejs$js_ast$src$jsx$JSXAttribute_ts$jsxAttribute;
    }};
  const ___$romejs$js_ast$src$jsx$JSXAttribute_ts$jsxAttribute = ___$romejs$js_ast$src$utils_ts$createBuilder('JSXAttribute', {
    visitorKeys: ['name', 'value']});

  // romejs/js-ast/src/jsx/JSXClosingElement.ts

  const ___$romejs$js_ast$src$jsx$JSXClosingElement_ts = {
    get jsxClosingElement() {
      return ___$romejs$js_ast$src$jsx$JSXClosingElement_ts$jsxClosingElement;
    }};
  const ___$romejs$js_ast$src$jsx$JSXClosingElement_ts$jsxClosingElement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'JSXClosingElement',
  {visitorKeys: ['name']});

  // romejs/js-ast/src/jsx/JSXClosingFragment.ts

  const ___$romejs$js_ast$src$jsx$JSXClosingFragment_ts = {
    get jsxClosingFragment() {
      return ___$romejs$js_ast$src$jsx$JSXClosingFragment_ts$jsxClosingFragment;
    }};
  const ___$romejs$js_ast$src$jsx$JSXClosingFragment_ts$jsxClosingFragment = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'JSXClosingFragment');

  // romejs/js-ast/src/jsx/JSXElement.ts

  const ___$romejs$js_ast$src$jsx$JSXElement_ts = {
    get jsxElement() {
      return ___$romejs$js_ast$src$jsx$JSXElement_ts$jsxElement;
    }};
  const ___$romejs$js_ast$src$jsx$JSXElement_ts$jsxElement = ___$romejs$js_ast$src$utils_ts$createBuilder('JSXElement', {
    visitorKeys: ['openingElement', 'children', 'closingElement']});

  // romejs/js-ast/src/jsx/JSXEmptyExpression.ts

  const ___$romejs$js_ast$src$jsx$JSXEmptyExpression_ts = {
    get jsxEmptyExpression() {
      return ___$romejs$js_ast$src$jsx$JSXEmptyExpression_ts$jsxEmptyExpression;
    }};
  const ___$romejs$js_ast$src$jsx$JSXEmptyExpression_ts$jsxEmptyExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'JSXEmptyExpression');

  // romejs/js-ast/src/jsx/JSXExpressionContainer.ts

  const ___$romejs$js_ast$src$jsx$JSXExpressionContainer_ts = {
    get jsxExpressionContainer() {
      return ___$romejs$js_ast$src$jsx$JSXExpressionContainer_ts$jsxExpressionContainer;
    }};
  const ___$romejs$js_ast$src$jsx$JSXExpressionContainer_ts$jsxExpressionContainer = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'JSXExpressionContainer',
  {
    visitorKeys: ['expression']});

  // romejs/js-ast/src/jsx/JSXFragment.ts

  const ___$romejs$js_ast$src$jsx$JSXFragment_ts = {
    get jsxFragment() {
      return ___$romejs$js_ast$src$jsx$JSXFragment_ts$jsxFragment;
    }};
  const ___$romejs$js_ast$src$jsx$JSXFragment_ts$jsxFragment = ___$romejs$js_ast$src$utils_ts$createBuilder('JSXFragment');

  // romejs/js-ast/src/jsx/JSXIdentifier.ts

  const ___$romejs$js_ast$src$jsx$JSXIdentifier_ts = {
    get jsxIdentifier() {
      return ___$romejs$js_ast$src$jsx$JSXIdentifier_ts$jsxIdentifier;
    }};
  const ___$romejs$js_ast$src$jsx$JSXIdentifier_ts$jsxIdentifier = ___$romejs$js_ast$src$utils_ts$createBuilder('JSXIdentifier');

  // romejs/js-ast/src/jsx/JSXMemberExpression.ts

  const ___$romejs$js_ast$src$jsx$JSXMemberExpression_ts = {
    get jsxMemberExpression() {
      return ___$romejs$js_ast$src$jsx$JSXMemberExpression_ts$jsxMemberExpression;
    }};
  const ___$romejs$js_ast$src$jsx$JSXMemberExpression_ts$jsxMemberExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'JSXMemberExpression',
  {visitorKeys: ['object', 'property']});

  // romejs/js-ast/src/jsx/JSXNamespacedName.ts

  const ___$romejs$js_ast$src$jsx$JSXNamespacedName_ts = {
    get jsxNamespacedName() {
      return ___$romejs$js_ast$src$jsx$JSXNamespacedName_ts$jsxNamespacedName;
    }};
  const ___$romejs$js_ast$src$jsx$JSXNamespacedName_ts$jsxNamespacedName = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'JSXNamespacedName',
  {visitorKeys: ['namespace', 'name']});

  // romejs/js-ast/src/jsx/JSXOpeningElement.ts

  const ___$romejs$js_ast$src$jsx$JSXOpeningElement_ts = {
    get jsxOpeningElement() {
      return ___$romejs$js_ast$src$jsx$JSXOpeningElement_ts$jsxOpeningElement;
    }};
  const ___$romejs$js_ast$src$jsx$JSXOpeningElement_ts$jsxOpeningElement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'JSXOpeningElement',
  {
    visitorKeys: ['name', 'attributes', 'typeArguments']});

  // romejs/js-ast/src/jsx/JSXOpeningFragment.ts

  const ___$romejs$js_ast$src$jsx$JSXOpeningFragment_ts = {
    get jsxOpeningFragment() {
      return ___$romejs$js_ast$src$jsx$JSXOpeningFragment_ts$jsxOpeningFragment;
    }};
  const ___$romejs$js_ast$src$jsx$JSXOpeningFragment_ts$jsxOpeningFragment = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'JSXOpeningFragment',
  {visitorKeys: ['name', 'attributes']});

  // romejs/js-ast/src/jsx/JSXSpreadAttribute.ts

  const ___$romejs$js_ast$src$jsx$JSXSpreadAttribute_ts = {
    get jsxSpreadAttribute() {
      return ___$romejs$js_ast$src$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute;
    }};
  const ___$romejs$js_ast$src$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'JSXSpreadAttribute',
  {visitorKeys: ['argument']});

  // romejs/js-ast/src/jsx/JSXSpreadChild.ts

  const ___$romejs$js_ast$src$jsx$JSXSpreadChild_ts = {
    get jsxSpreadChild() {
      return ___$romejs$js_ast$src$jsx$JSXSpreadChild_ts$jsxSpreadChild;
    }};
  const ___$romejs$js_ast$src$jsx$JSXSpreadChild_ts$jsxSpreadChild = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'JSXSpreadChild',
  {visitorKeys: ['expression']});

  // romejs/js-ast/src/core/LabeledStatement.ts

  const ___$romejs$js_ast$src$core$LabeledStatement_ts = {
    get labeledStatement() {
      return ___$romejs$js_ast$src$core$LabeledStatement_ts$labeledStatement;
    }};
  const ___$romejs$js_ast$src$core$LabeledStatement_ts$labeledStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'LabeledStatement',
  {visitorKeys: ['label', 'body']});

  // romejs/js-ast/src/core/MemberExpression.ts

  const ___$romejs$js_ast$src$core$MemberExpression_ts = {
    get memberExpression() {
      return ___$romejs$js_ast$src$core$MemberExpression_ts$memberExpression;
    }};
  const ___$romejs$js_ast$src$core$MemberExpression_ts$memberExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'MemberExpression',
  {
    visitorKeys: ['object', 'property']});

  // romejs/js-ast/src/core/MetaProperty.ts

  const ___$romejs$js_ast$src$core$MetaProperty_ts = {
    get metaProperty() {
      return ___$romejs$js_ast$src$core$MetaProperty_ts$metaProperty;
    }};
  const ___$romejs$js_ast$src$core$MetaProperty_ts$metaProperty = ___$romejs$js_ast$src$utils_ts$createBuilder('MetaProperty', {
    visitorKeys: ['meta', 'property']});

  // romejs/js-ast/src/flow/FlowMixedTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowMixedTypeAnnotation_ts = {
    get flowMixedTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowMixedTypeAnnotation_ts$flowMixedTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowMixedTypeAnnotation_ts$flowMixedTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowMixedTypeAnnotation');

  // romejs/js-ast/src/core/NewExpression.ts

  const ___$romejs$js_ast$src$core$NewExpression_ts = {
    get newExpression() {
      return ___$romejs$js_ast$src$core$NewExpression_ts$newExpression;
    }};
  const ___$romejs$js_ast$src$core$NewExpression_ts$newExpression = ___$romejs$js_ast$src$utils_ts$createBuilder('NewExpression', {
    visitorKeys: ['callee', 'arguments']});

  // romejs/js-ast/src/core/NullLiteral.ts

  const ___$romejs$js_ast$src$core$NullLiteral_ts = {
    get nullLiteral() {
      return ___$romejs$js_ast$src$core$NullLiteral_ts$nullLiteral;
    }};
  const ___$romejs$js_ast$src$core$NullLiteral_ts$nullLiteral = ___$romejs$js_ast$src$utils_ts$createBuilder('NullLiteral');

  // romejs/js-ast/src/flow/FlowNullableTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowNullableTypeAnnotation_ts = {
    get flowNullableTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowNullableTypeAnnotation_ts$flowNullableTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowNullableTypeAnnotation_ts$flowNullableTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowNullableTypeAnnotation',
  {visitorKeys: ['typeAnnotation']});

  // romejs/js-ast/src/flow/FlowNumberTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowNumberTypeAnnotation_ts = {
    get flowNumberTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowNumberTypeAnnotation_ts$flowNumberTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowNumberTypeAnnotation_ts$flowNumberTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowNumberTypeAnnotation');

  // romejs/js-ast/src/core/NumericLiteral.ts

  const ___$romejs$js_ast$src$core$NumericLiteral_ts = {
    get numericLiteral() {
      return ___$romejs$js_ast$src$core$NumericLiteral_ts$numericLiteral;
    }};
  const ___$romejs$js_ast$src$core$NumericLiteral_ts$numericLiteral = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'NumericLiteral');

  // romejs/js-ast/src/flow/FlowNumericLiteral.ts

  const ___$romejs$js_ast$src$flow$FlowNumericLiteral_ts = {
    get flowNumericLiteral() {
      return ___$romejs$js_ast$src$flow$FlowNumericLiteral_ts$flowNumericLiteral;
    }};
  const ___$romejs$js_ast$src$flow$FlowNumericLiteral_ts$flowNumericLiteral = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowNumericLiteral');

  // romejs/js-ast/src/core/ObjectExpression.ts

  const ___$romejs$js_ast$src$core$ObjectExpression_ts = {
    get objectExpression() {
      return ___$romejs$js_ast$src$core$ObjectExpression_ts$objectExpression;
    }};
  const ___$romejs$js_ast$src$core$ObjectExpression_ts$objectExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ObjectExpression',
  {visitorKeys: ['properties']});

  // romejs/js-ast/src/core/ObjectMethod.ts

  const ___$romejs$js_ast$src$core$ObjectMethod_ts = {
    get objectMethod() {
      return ___$romejs$js_ast$src$core$ObjectMethod_ts$objectMethod;
    }};
  const ___$romejs$js_ast$src$core$ObjectMethod_ts$objectMethod = ___$romejs$js_ast$src$utils_ts$createBuilder('ObjectMethod', {
    visitorKeys: ___$romejs$js_ast$src$utils_ts$METHOD_FUNCTION_VISITOR_KEYS});

  // romejs/js-ast/src/core/ObjectPattern.ts

  const ___$romejs$js_ast$src$core$ObjectPattern_ts = {
    get objectPattern() {
      return ___$romejs$js_ast$src$core$ObjectPattern_ts$objectPattern;
    }};
  const ___$romejs$js_ast$src$core$ObjectPattern_ts$objectPattern = ___$romejs$js_ast$src$utils_ts$createBuilder('ObjectPattern', {
    visitorKeys: ['properties', 'typeAnnotation']});

  // romejs/js-ast/src/core/ObjectProperty.ts

  const ___$romejs$js_ast$src$core$ObjectProperty_ts = {
    get objectProperty() {
      return ___$romejs$js_ast$src$core$ObjectProperty_ts$objectProperty;
    }};
  const ___$romejs$js_ast$src$core$ObjectProperty_ts$objectProperty = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ObjectProperty',
  {
    visitorKeys: ['key', 'value', 'decorators']});

  // romejs/js-ast/src/flow/FlowObjectTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowObjectTypeAnnotation_ts = {
    get flowObjectTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowObjectTypeAnnotation_ts$flowObjectTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowObjectTypeAnnotation_ts$flowObjectTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowObjectTypeAnnotation', {
    visitorKeys: ['properties']});

  // romejs/js-ast/src/flow/FlowObjectTypeCallProperty.ts

  const ___$romejs$js_ast$src$flow$FlowObjectTypeCallProperty_ts = {
    get flowObjectTypeCallProperty() {
      return ___$romejs$js_ast$src$flow$FlowObjectTypeCallProperty_ts$flowObjectTypeCallProperty;
    }};
  const ___$romejs$js_ast$src$flow$FlowObjectTypeCallProperty_ts$flowObjectTypeCallProperty = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowObjectTypeCallProperty',
  {visitorKeys: ['value']});

  // romejs/js-ast/src/flow/FlowObjectTypeIndexer.ts

  const ___$romejs$js_ast$src$flow$FlowObjectTypeIndexer_ts = {
    get flowObjectTypeIndexer() {
      return ___$romejs$js_ast$src$flow$FlowObjectTypeIndexer_ts$flowObjectTypeIndexer;
    }};
  const ___$romejs$js_ast$src$flow$FlowObjectTypeIndexer_ts$flowObjectTypeIndexer = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowObjectTypeIndexer',
  {visitorKeys: ['id', 'key', 'value']});

  // romejs/js-ast/src/flow/FlowObjectTypeProperty.ts

  const ___$romejs$js_ast$src$flow$FlowObjectTypeProperty_ts = {
    get flowObjectTypeProperty() {
      return ___$romejs$js_ast$src$flow$FlowObjectTypeProperty_ts$flowObjectTypeProperty;
    }};
  const ___$romejs$js_ast$src$flow$FlowObjectTypeProperty_ts$flowObjectTypeProperty = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowObjectTypeProperty',
  {visitorKeys: ['key', 'value']});

  // romejs/js-ast/src/flow/FlowObjectTypeSpreadProperty.ts

  const ___$romejs$js_ast$src$flow$FlowObjectTypeSpreadProperty_ts = {
    get flowObjectTypeSpreadProperty() {
      return ___$romejs$js_ast$src$flow$FlowObjectTypeSpreadProperty_ts$flowObjectTypeSpreadProperty;
    }};
  const ___$romejs$js_ast$src$flow$FlowObjectTypeSpreadProperty_ts$flowObjectTypeSpreadProperty = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowObjectTypeSpreadProperty',
  {visitorKeys: ['argument']});

  // romejs/js-ast/src/flow/FlowOpaqueType.ts

  const ___$romejs$js_ast$src$flow$FlowOpaqueType_ts = {
    get flowOpaqueType() {
      return ___$romejs$js_ast$src$flow$FlowOpaqueType_ts$flowOpaqueType;
    }};
  const ___$romejs$js_ast$src$flow$FlowOpaqueType_ts$flowOpaqueType = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowOpaqueType',
  {visitorKeys: ['id', 'typeParameters', 'impltype', 'supertype']});

  // romejs/js-ast/src/core/PrivateName.ts

  const ___$romejs$js_ast$src$core$PrivateName_ts = {
    get privateName() {
      return ___$romejs$js_ast$src$core$PrivateName_ts$privateName;
    }};
  const ___$romejs$js_ast$src$core$PrivateName_ts$privateName = ___$romejs$js_ast$src$utils_ts$createBuilder('PrivateName', {
    visitorKeys: ['id']});

  // romejs/js-ast/src/core/Program.ts

  const ___$romejs$js_ast$src$core$Program_ts = {
    get program() {
      return ___$romejs$js_ast$src$core$Program_ts$program;
    }};
  const ___$romejs$js_ast$src$core$Program_ts$program = ___$romejs$js_ast$src$utils_ts$createBuilder('Program', {
    visitorKeys: ['directives', 'body']});

  // romejs/js-ast/src/flow/FlowQualifiedTypeIdentifier.ts

  const ___$romejs$js_ast$src$flow$FlowQualifiedTypeIdentifier_ts = {
    get flowQualifiedTypeIdentifier() {
      return ___$romejs$js_ast$src$flow$FlowQualifiedTypeIdentifier_ts$flowQualifiedTypeIdentifier;
    }};
  const ___$romejs$js_ast$src$flow$FlowQualifiedTypeIdentifier_ts$flowQualifiedTypeIdentifier = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowQualifiedTypeIdentifier',
  {visitorKeys: ['id', 'qualification']});

  // romejs/js-ast/src/core/RestElement.ts

  const ___$romejs$js_ast$src$core$RestElement_ts = {
    get restElement() {
      return ___$romejs$js_ast$src$core$RestElement_ts$restElement;
    }};
  const ___$romejs$js_ast$src$core$RestElement_ts$restElement = ___$romejs$js_ast$src$utils_ts$createBuilder('RestElement', {
    visitorKeys: ['argument', 'typeAnnotation']});

  // romejs/js-ast/src/core/ReturnStatement.ts

  const ___$romejs$js_ast$src$core$ReturnStatement_ts = {
    get returnStatement() {
      return ___$romejs$js_ast$src$core$ReturnStatement_ts$returnStatement;
    }};
  const ___$romejs$js_ast$src$core$ReturnStatement_ts$returnStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ReturnStatement',
  {visitorKeys: ['argument']});

  // romejs/js-ast/src/core/SequenceExpression.ts

  const ___$romejs$js_ast$src$core$SequenceExpression_ts = {
    get sequenceExpression() {
      return ___$romejs$js_ast$src$core$SequenceExpression_ts$sequenceExpression;
    }};
  const ___$romejs$js_ast$src$core$SequenceExpression_ts$sequenceExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'SequenceExpression',
  {visitorKeys: ['expressions']});

  // romejs/js-ast/src/core/SpreadElement.ts

  const ___$romejs$js_ast$src$core$SpreadElement_ts = {
    get spreadElement() {
      return ___$romejs$js_ast$src$core$SpreadElement_ts$spreadElement;
    }};
  const ___$romejs$js_ast$src$core$SpreadElement_ts$spreadElement = ___$romejs$js_ast$src$utils_ts$createBuilder('SpreadElement', {
    visitorKeys: ['argument']});

  // romejs/js-ast/src/core/SpreadProperty.ts

  const ___$romejs$js_ast$src$core$SpreadProperty_ts = {
    get spreadProperty() {
      return ___$romejs$js_ast$src$core$SpreadProperty_ts$spreadProperty;
    }};
  const ___$romejs$js_ast$src$core$SpreadProperty_ts$spreadProperty = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'SpreadProperty',
  {visitorKeys: ['argument']});

  // romejs/js-ast/src/core/StringLiteral.ts

  const ___$romejs$js_ast$src$core$StringLiteral_ts = {
    get stringLiteral() {
      return ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral;
    }};
  const ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral = ___$romejs$js_ast$src$utils_ts$createBuilder('StringLiteral');

  // romejs/js-ast/src/flow/FlowStringTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowStringTypeAnnotation_ts = {
    get flowStringTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowStringTypeAnnotation_ts$flowStringTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowStringTypeAnnotation_ts$flowStringTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowStringTypeAnnotation');

  // romejs/js-ast/src/core/Super.ts

  const ___$romejs$js_ast$src$core$Super_ts = {
    get _super() {
      return ___$romejs$js_ast$src$core$Super_ts$_super;
    }};
  const ___$romejs$js_ast$src$core$Super_ts$_super = ___$romejs$js_ast$src$utils_ts$createBuilder('Super');

  // romejs/js-ast/src/core/SwitchCase.ts

  const ___$romejs$js_ast$src$core$SwitchCase_ts = {
    get switchCase() {
      return ___$romejs$js_ast$src$core$SwitchCase_ts$switchCase;
    }};
  const ___$romejs$js_ast$src$core$SwitchCase_ts$switchCase = ___$romejs$js_ast$src$utils_ts$createBuilder('SwitchCase', {
    visitorKeys: ['test', 'consequent']});

  // romejs/js-ast/src/core/SwitchStatement.ts

  const ___$romejs$js_ast$src$core$SwitchStatement_ts = {
    get switchStatement() {
      return ___$romejs$js_ast$src$core$SwitchStatement_ts$switchStatement;
    }};
  const ___$romejs$js_ast$src$core$SwitchStatement_ts$switchStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'SwitchStatement',
  {visitorKeys: ['discriminant', 'cases']});

  // romejs/js-ast/src/core/TemplateElement.ts

  const ___$romejs$js_ast$src$core$TemplateElement_ts = {
    get templateElement() {
      return ___$romejs$js_ast$src$core$TemplateElement_ts$templateElement;
    }};
  const ___$romejs$js_ast$src$core$TemplateElement_ts$templateElement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TemplateElement');

  // romejs/js-ast/src/core/TemplateLiteral.ts

  const ___$romejs$js_ast$src$core$TemplateLiteral_ts = {
    get templateLiteral() {
      return ___$romejs$js_ast$src$core$TemplateLiteral_ts$templateLiteral;
    }};
  const ___$romejs$js_ast$src$core$TemplateLiteral_ts$templateLiteral = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TemplateLiteral',
  {visitorKeys: ['quasis', 'expressions']});

  // romejs/js-ast/src/core/ThisExpression.ts

  const ___$romejs$js_ast$src$core$ThisExpression_ts = {
    get thisExpression() {
      return ___$romejs$js_ast$src$core$ThisExpression_ts$thisExpression;
    }};
  const ___$romejs$js_ast$src$core$ThisExpression_ts$thisExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ThisExpression');

  // romejs/js-ast/src/flow/FlowThisTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowThisTypeAnnotation_ts = {
    get flowThisTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowThisTypeAnnotation_ts$flowThisTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowThisTypeAnnotation_ts$flowThisTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowThisTypeAnnotation');

  // romejs/js-ast/src/core/ThrowStatement.ts

  const ___$romejs$js_ast$src$core$ThrowStatement_ts = {
    get throwStatement() {
      return ___$romejs$js_ast$src$core$ThrowStatement_ts$throwStatement;
    }};
  const ___$romejs$js_ast$src$core$ThrowStatement_ts$throwStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ThrowStatement',
  {visitorKeys: ['argument']});

  // romejs/js-ast/src/core/TryStatement.ts

  const ___$romejs$js_ast$src$core$TryStatement_ts = {
    get tryStatement() {
      return ___$romejs$js_ast$src$core$TryStatement_ts$tryStatement;
    }};
  const ___$romejs$js_ast$src$core$TryStatement_ts$tryStatement = ___$romejs$js_ast$src$utils_ts$createBuilder('TryStatement', {
    visitorKeys: ['block', 'handler', 'finalizer']});

  // romejs/js-ast/src/flow/FlowTupleTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowTupleTypeAnnotation_ts = {
    get flowTupleTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowTupleTypeAnnotation_ts$flowTupleTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowTupleTypeAnnotation_ts$flowTupleTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowTupleTypeAnnotation',
  {visitorKeys: ['types']});

  // romejs/js-ast/src/flow/FlowTypeAlias.ts

  const ___$romejs$js_ast$src$flow$FlowTypeAlias_ts = {
    get flowTypeAlias() {
      return ___$romejs$js_ast$src$flow$FlowTypeAlias_ts$flowTypeAlias;
    }};
  const ___$romejs$js_ast$src$flow$FlowTypeAlias_ts$flowTypeAlias = ___$romejs$js_ast$src$utils_ts$createBuilder('FlowTypeAlias', {
    visitorKeys: ['id', 'typeParameters', 'right']});

  // romejs/js-ast/src/flow/FlowTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowTypeAnnotation_ts = {
    get flowTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowTypeAnnotation_ts$flowTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowTypeAnnotation_ts$flowTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowTypeAnnotation',
  {visitorKeys: ['typeAnnotation']});

  // romejs/js-ast/src/flow/FlowTypeParameter.ts

  const ___$romejs$js_ast$src$flow$FlowTypeParameter_ts = {
    get flowTypeParameter() {
      return ___$romejs$js_ast$src$flow$FlowTypeParameter_ts$flowTypeParameter;
    }};
  const ___$romejs$js_ast$src$flow$FlowTypeParameter_ts$flowTypeParameter = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowTypeParameter',
  {
    visitorKeys: ['bound', 'default', 'variance']});

  // romejs/js-ast/src/flow/FlowTypeParameterDeclaration.ts

  const ___$romejs$js_ast$src$flow$FlowTypeParameterDeclaration_ts = {
    get flowTypeParameterDeclaration() {
      return ___$romejs$js_ast$src$flow$FlowTypeParameterDeclaration_ts$flowTypeParameterDeclaration;
    }};
  const ___$romejs$js_ast$src$flow$FlowTypeParameterDeclaration_ts$flowTypeParameterDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowTypeParameterDeclaration',
  {visitorKeys: ['params']});

  // romejs/js-ast/src/flow/FlowTypeParameterInstantiation.ts

  const ___$romejs$js_ast$src$flow$FlowTypeParameterInstantiation_ts = {
    get flowTypeParameterInstantiation() {
      return ___$romejs$js_ast$src$flow$FlowTypeParameterInstantiation_ts$flowTypeParameterInstantiation;
    }};
  const ___$romejs$js_ast$src$flow$FlowTypeParameterInstantiation_ts$flowTypeParameterInstantiation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowTypeParameterInstantiation',
  {visitorKeys: ['params']});

  // romejs/js-ast/src/flow/FlowTypeofTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowTypeofTypeAnnotation_ts = {
    get flowTypeofTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowTypeofTypeAnnotation_ts$flowTypeofTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowTypeofTypeAnnotation_ts$flowTypeofTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowTypeofTypeAnnotation',
  {visitorKeys: ['argument']});

  // romejs/js-ast/src/flow/FlowUnionTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowUnionTypeAnnotation_ts = {
    get flowUnionTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowUnionTypeAnnotation_ts$flowUnionTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowUnionTypeAnnotation_ts$flowUnionTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowUnionTypeAnnotation',
  {visitorKeys: ['types']});

  // romejs/js-ast/src/core/UpdateExpression.ts

  const ___$romejs$js_ast$src$core$UpdateExpression_ts = {
    get updateExpression() {
      return ___$romejs$js_ast$src$core$UpdateExpression_ts$updateExpression;
    }};
  const ___$romejs$js_ast$src$core$UpdateExpression_ts$updateExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'UpdateExpression',
  {visitorKeys: ['argument']});

  // romejs/js-ast/src/core/VariableDeclaration.ts

  const ___$romejs$js_ast$src$core$VariableDeclaration_ts = {
    get variableDeclaration() {
      return ___$romejs$js_ast$src$core$VariableDeclaration_ts$variableDeclaration;
    }};
  const ___$romejs$js_ast$src$core$VariableDeclaration_ts$variableDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'VariableDeclaration',
  {visitorKeys: ['declarations']});

  // romejs/js-ast/src/core/VariableDeclarator.ts

  const ___$romejs$js_ast$src$core$VariableDeclarator_ts = {
    get variableDeclarator() {
      return ___$romejs$js_ast$src$core$VariableDeclarator_ts$variableDeclarator;
    }};
  const ___$romejs$js_ast$src$core$VariableDeclarator_ts$variableDeclarator = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'VariableDeclarator',
  {visitorKeys: ['id', 'init']});

  // romejs/js-ast/src/flow/FlowVariance.ts

  const ___$romejs$js_ast$src$flow$FlowVariance_ts = {
    get flowVariance() {
      return ___$romejs$js_ast$src$flow$FlowVariance_ts$flowVariance;
    }};
  const ___$romejs$js_ast$src$flow$FlowVariance_ts$flowVariance = ___$romejs$js_ast$src$utils_ts$createBuilder('FlowVariance');

  // romejs/js-ast/src/flow/FlowVoidTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowVoidTypeAnnotation_ts = {
    get flowVoidTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowVoidTypeAnnotation_ts$flowVoidTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowVoidTypeAnnotation_ts$flowVoidTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowVoidTypeAnnotation');

  // romejs/js-ast/src/core/WhileStatement.ts

  const ___$romejs$js_ast$src$core$WhileStatement_ts = {
    get whileStatement() {
      return ___$romejs$js_ast$src$core$WhileStatement_ts$whileStatement;
    }};
  const ___$romejs$js_ast$src$core$WhileStatement_ts$whileStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'WhileStatement',
  {visitorKeys: ['test', 'body']});

  // romejs/js-ast/src/core/WithStatement.ts

  const ___$romejs$js_ast$src$core$WithStatement_ts = {
    get withStatement() {
      return ___$romejs$js_ast$src$core$WithStatement_ts$withStatement;
    }};
  const ___$romejs$js_ast$src$core$WithStatement_ts$withStatement = ___$romejs$js_ast$src$utils_ts$createBuilder('WithStatement', {
    visitorKeys: ['object', 'body']});

  // romejs/js-ast/src/core/YieldExpression.ts

  const ___$romejs$js_ast$src$core$YieldExpression_ts = {
    get yieldExpression() {
      return ___$romejs$js_ast$src$core$YieldExpression_ts$yieldExpression;
    }};
  const ___$romejs$js_ast$src$core$YieldExpression_ts$yieldExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'YieldExpression',
  {visitorKeys: ['argument']});

  // romejs/js-ast/src/jsx/JSXText.ts

  const ___$romejs$js_ast$src$jsx$JSXText_ts = {
    get jsxText() {
      return ___$romejs$js_ast$src$jsx$JSXText_ts$jsxText;
    }};
  const ___$romejs$js_ast$src$jsx$JSXText_ts$jsxText = ___$romejs$js_ast$src$utils_ts$createBuilder('JSXText');

  // romejs/js-ast/src/core/ImportDefaultSpecifier.ts

  const ___$romejs$js_ast$src$core$ImportDefaultSpecifier_ts = {
    get importDefaultSpecifier() {
      return ___$romejs$js_ast$src$core$ImportDefaultSpecifier_ts$importDefaultSpecifier;
    }};
  const ___$romejs$js_ast$src$core$ImportDefaultSpecifier_ts$importDefaultSpecifier = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ImportDefaultSpecifier',
  {visitorKeys: ['local']});

  // romejs/js-ast/src/core/ImportNamespaceSpecifier.ts

  const ___$romejs$js_ast$src$core$ImportNamespaceSpecifier_ts = {
    get importNamespaceSpecifier() {
      return ___$romejs$js_ast$src$core$ImportNamespaceSpecifier_ts$importNamespaceSpecifier;
    }};
  const ___$romejs$js_ast$src$core$ImportNamespaceSpecifier_ts$importNamespaceSpecifier = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ImportNamespaceSpecifier',
  {visitorKeys: ['local']});

  // romejs/js-ast/src/core/DirectiveLiteral.ts

  const ___$romejs$js_ast$src$core$DirectiveLiteral_ts = {
    get directiveLiteral() {
      return ___$romejs$js_ast$src$core$DirectiveLiteral_ts$directiveLiteral;
    }};
  const ___$romejs$js_ast$src$core$DirectiveLiteral_ts$directiveLiteral = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'DirectiveLiteral');

  // romejs/js-ast/src/core/UnaryExpression.ts

  const ___$romejs$js_ast$src$core$UnaryExpression_ts = {
    get unaryExpression() {
      return ___$romejs$js_ast$src$core$UnaryExpression_ts$unaryExpression;
    }};
  const ___$romejs$js_ast$src$core$UnaryExpression_ts$unaryExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'UnaryExpression',
  {visitorKeys: ['argument']});

  // romejs/js-ast/src/core/LogicalExpression.ts

  const ___$romejs$js_ast$src$core$LogicalExpression_ts = {
    get logicalExpression() {
      return ___$romejs$js_ast$src$core$LogicalExpression_ts$logicalExpression;
    }};
  const ___$romejs$js_ast$src$core$LogicalExpression_ts$logicalExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'LogicalExpression',
  {visitorKeys: ['left', 'right']});

  // romejs/js-ast/src/core/RegExpLiteral.ts

  const ___$romejs$js_ast$src$core$RegExpLiteral_ts = {
    get regExpLiteral() {
      return ___$romejs$js_ast$src$core$RegExpLiteral_ts$regExpLiteral;
    }};
  const ___$romejs$js_ast$src$core$RegExpLiteral_ts$regExpLiteral = ___$romejs$js_ast$src$utils_ts$createBuilder('RegExpLiteral');

  // romejs/js-ast/src/core/BigIntLiteral.ts

  const ___$romejs$js_ast$src$core$BigIntLiteral_ts = {
    get bigIntLiteral() {
      return ___$romejs$js_ast$src$core$BigIntLiteral_ts$bigIntLiteral;
    }};
  const ___$romejs$js_ast$src$core$BigIntLiteral_ts$bigIntLiteral = ___$romejs$js_ast$src$utils_ts$createBuilder('BigIntLiteral');

  // romejs/js-ast/src/core/ForOfStatement.ts

  const ___$romejs$js_ast$src$core$ForOfStatement_ts = {
    get forOfStatement() {
      return ___$romejs$js_ast$src$core$ForOfStatement_ts$forOfStatement;
    }};
  const ___$romejs$js_ast$src$core$ForOfStatement_ts$forOfStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ForOfStatement',
  {visitorKeys: ['left', 'right', 'body']});

  // romejs/js-ast/src/core/ForInStatement.ts

  const ___$romejs$js_ast$src$core$ForInStatement_ts = {
    get forInStatement() {
      return ___$romejs$js_ast$src$core$ForInStatement_ts$forInStatement;
    }};
  const ___$romejs$js_ast$src$core$ForInStatement_ts$forInStatement = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'ForInStatement',
  {visitorKeys: ['left', 'right', 'body']});

  // romejs/js-ast/src/core/RestProperty.ts

  const ___$romejs$js_ast$src$core$RestProperty_ts = {
    get restProperty() {
      return ___$romejs$js_ast$src$core$RestProperty_ts$restProperty;
    }};
  const ___$romejs$js_ast$src$core$RestProperty_ts$restProperty = ___$romejs$js_ast$src$utils_ts$createBuilder('RestProperty', {
    visitorKeys: ['argument']});

  // romejs/js-ast/src/flow/FlowInterfaceDeclaration.ts

  const ___$romejs$js_ast$src$flow$FlowInterfaceDeclaration_ts = {
    get flowInterfaceDeclaration() {
      return ___$romejs$js_ast$src$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration;
    }};
  const ___$romejs$js_ast$src$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowInterfaceDeclaration',
  {visitorKeys: ['id', 'typeParameters', 'extends', 'body']});

  // romejs/js-ast/src/flow/FlowInterface.ts

  const ___$romejs$js_ast$src$flow$FlowInterface_ts = {
    get flowInterface() {
      return ___$romejs$js_ast$src$flow$FlowInterface_ts$flowInterface;
    }};
  const ___$romejs$js_ast$src$flow$FlowInterface_ts$flowInterface = ___$romejs$js_ast$src$utils_ts$createBuilder('FlowInterface');

  // romejs/js-ast/src/flow/FlowNullLiteralTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowNullLiteralTypeAnnotation_ts = {
    get flowNullLiteralTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowNullLiteralTypeAnnotation_ts$flowNullLiteralTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowNullLiteralTypeAnnotation_ts$flowNullLiteralTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowNullLiteralTypeAnnotation');

  // romejs/js-ast/src/flow/FlowNumericLiteralTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowNumericLiteralTypeAnnotation_ts = {
    get flowNumericLiteralTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowNumericLiteralTypeAnnotation_ts$flowNumericLiteralTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowNumericLiteralTypeAnnotation_ts$flowNumericLiteralTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowNumericLiteralTypeAnnotation');

  // romejs/js-ast/src/flow/FlowStringLiteralTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowStringLiteralTypeAnnotation_ts = {
    get flowStringLiteralTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowStringLiteralTypeAnnotation_ts$flowStringLiteralTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowStringLiteralTypeAnnotation_ts$flowStringLiteralTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowStringLiteralTypeAnnotation');

  // romejs/js-ast/src/flow/FlowTypeCastExpression.ts

  const ___$romejs$js_ast$src$flow$FlowTypeCastExpression_ts = {
    get flowTypeCastExpression() {
      return ___$romejs$js_ast$src$flow$FlowTypeCastExpression_ts$flowTypeCastExpression;
    }};
  const ___$romejs$js_ast$src$flow$FlowTypeCastExpression_ts$flowTypeCastExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowTypeCastExpression',
  {visitorKeys: ['expression', 'typeAnnotation']});

  // romejs/js-ast/src/flow/FlowInferredPredicate.ts

  const ___$romejs$js_ast$src$flow$FlowInferredPredicate_ts = {
    get flowInferredPredicate() {
      return ___$romejs$js_ast$src$flow$FlowInferredPredicate_ts$flowInferredPredicate;
    }};
  const ___$romejs$js_ast$src$flow$FlowInferredPredicate_ts$flowInferredPredicate = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowInferredPredicate');

  // romejs/js-ast/src/flow/FlowDeclaredPredicate.ts

  const ___$romejs$js_ast$src$flow$FlowDeclaredPredicate_ts = {
    get flowDeclaredPredicate() {
      return ___$romejs$js_ast$src$flow$FlowDeclaredPredicate_ts$flowDeclaredPredicate;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclaredPredicate_ts$flowDeclaredPredicate = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclaredPredicate');

  // romejs/js-ast/src/core/TaggedTemplateExpression.ts

  const ___$romejs$js_ast$src$core$TaggedTemplateExpression_ts = {
    get taggedTemplateExpression() {
      return ___$romejs$js_ast$src$core$TaggedTemplateExpression_ts$taggedTemplateExpression;
    }};
  const ___$romejs$js_ast$src$core$TaggedTemplateExpression_ts$taggedTemplateExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TaggedTemplateExpression',
  {
    visitorKeys: ['tag', 'quasi']});

  // romejs/js-ast/src/flow/FlowDeclareExportAllDeclaration.ts

  const ___$romejs$js_ast$src$flow$FlowDeclareExportAllDeclaration_ts = {
    get flowDeclareExportAllDeclaration() {
      return ___$romejs$js_ast$src$flow$FlowDeclareExportAllDeclaration_ts$flowDeclareExportAllDeclaration;
    }};
  const ___$romejs$js_ast$src$flow$FlowDeclareExportAllDeclaration_ts$flowDeclareExportAllDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowDeclareExportAllDeclaration',
  {visitorKeys: ['source']});

  // romejs/js-ast/src/core/DoExpression.ts

  const ___$romejs$js_ast$src$core$DoExpression_ts = {
    get doExpression() {
      return ___$romejs$js_ast$src$core$DoExpression_ts$doExpression;
    }};
  const ___$romejs$js_ast$src$core$DoExpression_ts$doExpression = ___$romejs$js_ast$src$utils_ts$createBuilder('DoExpression', {
    visitorKeys: ['body']});

  // romejs/js-ast/src/flow/FlowInterfaceTypeAnnotation.ts

  const ___$romejs$js_ast$src$flow$FlowInterfaceTypeAnnotation_ts = {
    get flowInterfaceTypeAnnotation() {
      return ___$romejs$js_ast$src$flow$FlowInterfaceTypeAnnotation_ts$flowInterfaceTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$flow$FlowInterfaceTypeAnnotation_ts$flowInterfaceTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowInterfaceTypeAnnotation', {
    visitorKeys: ['body', 'extends']});

  // romejs/js-ast/src/flow/FlowObjectTypeInternalSlot.ts

  const ___$romejs$js_ast$src$flow$FlowObjectTypeInternalSlot_ts = {
    get flowObjectTypeInternalSlot() {
      return ___$romejs$js_ast$src$flow$FlowObjectTypeInternalSlot_ts$flowObjectTypeInternalSlot;
    }};
  const ___$romejs$js_ast$src$flow$FlowObjectTypeInternalSlot_ts$flowObjectTypeInternalSlot = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowObjectTypeInternalSlot', {
    visitorKeys: ['id', 'value']});

  // romejs/js-ast/src/flow/FlowFunctionTypeParamRest.ts

  const ___$romejs$js_ast$src$flow$FlowFunctionTypeParamRest_ts = {
    get flowFunctionTypeRestParam() {
      return ___$romejs$js_ast$src$flow$FlowFunctionTypeParamRest_ts$flowFunctionTypeRestParam;
    }};
  const ___$romejs$js_ast$src$flow$FlowFunctionTypeParamRest_ts$flowFunctionTypeRestParam = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'FlowFunctionTypeParamRest', {
    visitorKeys: ['param']});

  // romejs/js-ast/src/typescript/TSUnknownKeyword.ts

  const ___$romejs$js_ast$src$typescript$TSUnknownKeyword_ts = {
    get tsUnknownKeyword() {
      return ___$romejs$js_ast$src$typescript$TSUnknownKeyword_ts$tsUnknownKeyword;
    }};
  const ___$romejs$js_ast$src$typescript$TSUnknownKeyword_ts$tsUnknownKeyword = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSUnknownKeyword');

  // romejs/js-ast/src/typescript/TSAnyKeyword.ts

  const ___$romejs$js_ast$src$typescript$TSAnyKeyword_ts = {
    get tsAnyKeyword() {
      return ___$romejs$js_ast$src$typescript$TSAnyKeyword_ts$tsAnyKeyword;
    }};
  const ___$romejs$js_ast$src$typescript$TSAnyKeyword_ts$tsAnyKeyword = ___$romejs$js_ast$src$utils_ts$createBuilder('TSAnyKeyword');

  // romejs/js-ast/src/typescript/TSBooleanKeyword.ts

  const ___$romejs$js_ast$src$typescript$TSBooleanKeyword_ts = {
    get tsBooleanKeyword() {
      return ___$romejs$js_ast$src$typescript$TSBooleanKeyword_ts$tsBooleanKeyword;
    }};
  const ___$romejs$js_ast$src$typescript$TSBooleanKeyword_ts$tsBooleanKeyword = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSBooleanKeyword');

  // romejs/js-ast/src/typescript/TSBigIntKeyword.ts

  const ___$romejs$js_ast$src$typescript$TSBigIntKeyword_ts = {
    get tsBigIntKeyword() {
      return ___$romejs$js_ast$src$typescript$TSBigIntKeyword_ts$tsBigIntKeyword;
    }};
  const ___$romejs$js_ast$src$typescript$TSBigIntKeyword_ts$tsBigIntKeyword = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSBigIntKeyword');

  // romejs/js-ast/src/typescript/TSNeverKeyword.ts

  const ___$romejs$js_ast$src$typescript$TSNeverKeyword_ts = {
    get tsNeverKeyword() {
      return ___$romejs$js_ast$src$typescript$TSNeverKeyword_ts$tsNeverKeyword;
    }};
  const ___$romejs$js_ast$src$typescript$TSNeverKeyword_ts$tsNeverKeyword = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSNeverKeyword');

  // romejs/js-ast/src/typescript/TSNumberKeyword.ts

  const ___$romejs$js_ast$src$typescript$TSNumberKeyword_ts = {
    get tsNumberKeyword() {
      return ___$romejs$js_ast$src$typescript$TSNumberKeyword_ts$tsNumberKeyword;
    }};
  const ___$romejs$js_ast$src$typescript$TSNumberKeyword_ts$tsNumberKeyword = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSNumberKeyword');

  // romejs/js-ast/src/typescript/TSObjectKeyword.ts

  const ___$romejs$js_ast$src$typescript$TSObjectKeyword_ts = {
    get tsObjectKeyword() {
      return ___$romejs$js_ast$src$typescript$TSObjectKeyword_ts$tsObjectKeyword;
    }};
  const ___$romejs$js_ast$src$typescript$TSObjectKeyword_ts$tsObjectKeyword = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSObjectKeyword');

  // romejs/js-ast/src/typescript/TSStringKeyword.ts

  const ___$romejs$js_ast$src$typescript$TSStringKeyword_ts = {
    get tsStringKeyword() {
      return ___$romejs$js_ast$src$typescript$TSStringKeyword_ts$tsStringKeyword;
    }};
  const ___$romejs$js_ast$src$typescript$TSStringKeyword_ts$tsStringKeyword = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSStringKeyword');

  // romejs/js-ast/src/typescript/TSSymbolKeyword.ts

  const ___$romejs$js_ast$src$typescript$TSSymbolKeyword_ts = {
    get tsSymbolKeyword() {
      return ___$romejs$js_ast$src$typescript$TSSymbolKeyword_ts$tsSymbolKeyword;
    }};
  const ___$romejs$js_ast$src$typescript$TSSymbolKeyword_ts$tsSymbolKeyword = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSSymbolKeyword');

  // romejs/js-ast/src/typescript/TSUndefinedKeyword.ts

  const ___$romejs$js_ast$src$typescript$TSUndefinedKeyword_ts = {
    get tsUndefinedKeyword() {
      return ___$romejs$js_ast$src$typescript$TSUndefinedKeyword_ts$tsUndefinedKeyword;
    }};
  const ___$romejs$js_ast$src$typescript$TSUndefinedKeyword_ts$tsUndefinedKeyword = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSUndefinedKeyword');

  // romejs/js-ast/src/typescript/TSImportType.ts

  const ___$romejs$js_ast$src$typescript$TSImportType_ts = {
    get tsImportType() {
      return ___$romejs$js_ast$src$typescript$TSImportType_ts$tsImportType;
    }};
  const ___$romejs$js_ast$src$typescript$TSImportType_ts$tsImportType = ___$romejs$js_ast$src$utils_ts$createBuilder('TSImportType', {
    visitorKeys: ['argument', 'typeParameters', 'qualifier']});

  // romejs/js-ast/src/typescript/TSQualifiedName.ts

  const ___$romejs$js_ast$src$typescript$TSQualifiedName_ts = {
    get tsQualifiedName() {
      return ___$romejs$js_ast$src$typescript$TSQualifiedName_ts$tsQualifiedName;
    }};
  const ___$romejs$js_ast$src$typescript$TSQualifiedName_ts$tsQualifiedName = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSQualifiedName',
  {visitorKeys: ['left', 'right']});

  // romejs/js-ast/src/typescript/TSTypeReference.ts

  const ___$romejs$js_ast$src$typescript$TSTypeReference_ts = {
    get tsTypeReference() {
      return ___$romejs$js_ast$src$typescript$TSTypeReference_ts$tsTypeReference;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypeReference_ts$tsTypeReference = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSTypeReference',
  {visitorKeys: ['typeName', 'typeParameters']});

  // romejs/js-ast/src/typescript/TSTypePredicate.ts

  const ___$romejs$js_ast$src$typescript$TSTypePredicate_ts = {
    get tsTypePredicate() {
      return ___$romejs$js_ast$src$typescript$TSTypePredicate_ts$tsTypePredicate;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypePredicate_ts$tsTypePredicate = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSTypePredicate',
  {visitorKeys: ['parameterName', 'typeAnnotation']});

  // romejs/js-ast/src/typescript/TSThisType.ts

  const ___$romejs$js_ast$src$typescript$TSThisType_ts = {
    get tsThisType() {
      return ___$romejs$js_ast$src$typescript$TSThisType_ts$tsThisType;
    }};
  const ___$romejs$js_ast$src$typescript$TSThisType_ts$tsThisType = ___$romejs$js_ast$src$utils_ts$createBuilder('TSThisType');

  // romejs/js-ast/src/typescript/TSTypeQuery.ts

  const ___$romejs$js_ast$src$typescript$TSTypeQuery_ts = {
    get tsTypeQuery() {
      return ___$romejs$js_ast$src$typescript$TSTypeQuery_ts$tsTypeQuery;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypeQuery_ts$tsTypeQuery = ___$romejs$js_ast$src$utils_ts$createBuilder('TSTypeQuery', {
    visitorKeys: ['exprName']});

  // romejs/js-ast/src/typescript/TSTypeParameter.ts

  const ___$romejs$js_ast$src$typescript$TSTypeParameter_ts = {
    get tsTypeParameter() {
      return ___$romejs$js_ast$src$typescript$TSTypeParameter_ts$tsTypeParameter;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypeParameter_ts$tsTypeParameter = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSTypeParameter',
  {visitorKeys: ['default', 'constraint']});

  // romejs/js-ast/src/typescript/TSTypeParameterDeclaration.ts

  const ___$romejs$js_ast$src$typescript$TSTypeParameterDeclaration_ts = {
    get tsTypeParameterDeclaration() {
      return ___$romejs$js_ast$src$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSTypeParameterDeclaration');

  // romejs/js-ast/src/typescript/TSIndexSignature.ts

  const ___$romejs$js_ast$src$typescript$TSIndexSignature_ts = {
    get tsIndexSignature() {
      return ___$romejs$js_ast$src$typescript$TSIndexSignature_ts$tsIndexSignature;
    }};
  const ___$romejs$js_ast$src$typescript$TSIndexSignature_ts$tsIndexSignature = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSIndexSignature',
  {visitorKeys: ['typeAnnotation', 'parameters']});

  // romejs/js-ast/src/typescript/TSMethodSignature.ts

  const ___$romejs$js_ast$src$typescript$TSMethodSignature_ts = {
    get tsMethodSignature() {
      return ___$romejs$js_ast$src$typescript$TSMethodSignature_ts$tsMethodSignature;
    }};
  const ___$romejs$js_ast$src$typescript$TSMethodSignature_ts$tsMethodSignature = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSMethodSignature',
  {
    visitorKeys: ['key', 'variance', 'typeAnnotation', 'parameters', 'typeParameters']});

  // romejs/js-ast/src/typescript/TSPropertySignature.ts

  const ___$romejs$js_ast$src$typescript$TSPropertySignature_ts = {
    get tsPropertySignature() {
      return ___$romejs$js_ast$src$typescript$TSPropertySignature_ts$tsPropertySignature;
    }};
  const ___$romejs$js_ast$src$typescript$TSPropertySignature_ts$tsPropertySignature = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSPropertySignature',
  {
    visitorKeys: ['key', 'variance', 'typeAnnotation']});

  // romejs/js-ast/src/typescript/TSTypeLiteral.ts

  const ___$romejs$js_ast$src$typescript$TSTypeLiteral_ts = {
    get tsTypeLiteral() {
      return ___$romejs$js_ast$src$typescript$TSTypeLiteral_ts$tsTypeLiteral;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypeLiteral_ts$tsTypeLiteral = ___$romejs$js_ast$src$utils_ts$createBuilder('TSTypeLiteral', {
    visitorKeys: ['members']});

  // romejs/js-ast/src/typescript/TSMappedType.ts

  const ___$romejs$js_ast$src$typescript$TSMappedType_ts = {
    get tsMappedType() {
      return ___$romejs$js_ast$src$typescript$TSMappedType_ts$tsMappedType;
    }};
  const ___$romejs$js_ast$src$typescript$TSMappedType_ts$tsMappedType = ___$romejs$js_ast$src$utils_ts$createBuilder('TSMappedType', {
    visitorKeys: ['typeParameter', 'typeAnnotation']});

  // romejs/js-ast/src/typescript/TSTupleType.ts

  const ___$romejs$js_ast$src$typescript$TSTupleType_ts = {
    get tsTupleType() {
      return ___$romejs$js_ast$src$typescript$TSTupleType_ts$tsTupleType;
    }};
  const ___$romejs$js_ast$src$typescript$TSTupleType_ts$tsTupleType = ___$romejs$js_ast$src$utils_ts$createBuilder('TSTupleType', {
    visitorKeys: ['elementTypes']});

  // romejs/js-ast/src/typescript/TSRestType.ts

  const ___$romejs$js_ast$src$typescript$TSRestType_ts = {
    get tsRestType() {
      return ___$romejs$js_ast$src$typescript$TSRestType_ts$tsRestType;
    }};
  const ___$romejs$js_ast$src$typescript$TSRestType_ts$tsRestType = ___$romejs$js_ast$src$utils_ts$createBuilder('TSRestType');

  // romejs/js-ast/src/typescript/TSOptionalType.ts

  const ___$romejs$js_ast$src$typescript$TSOptionalType_ts = {
    get tsOptionalType() {
      return ___$romejs$js_ast$src$typescript$TSOptionalType_ts$tsOptionalType;
    }};
  const ___$romejs$js_ast$src$typescript$TSOptionalType_ts$tsOptionalType = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSOptionalType');

  // romejs/js-ast/src/typescript/TSParenthesizedType.ts

  const ___$romejs$js_ast$src$typescript$TSParenthesizedType_ts = {
    get tsParenthesizedType() {
      return ___$romejs$js_ast$src$typescript$TSParenthesizedType_ts$tsParenthesizedType;
    }};
  const ___$romejs$js_ast$src$typescript$TSParenthesizedType_ts$tsParenthesizedType = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSParenthesizedType',
  {visitorKeys: ['typeAnnotation']});

  // romejs/js-ast/src/typescript/TSFunctionType.ts

  const ___$romejs$js_ast$src$typescript$TSFunctionType_ts = {
    get tsFunctionType() {
      return ___$romejs$js_ast$src$typescript$TSFunctionType_ts$tsFunctionType;
    }};
  const ___$romejs$js_ast$src$typescript$TSFunctionType_ts$tsFunctionType = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSFunctionType',
  {visitorKeys: ['typeAnnotation', 'parameters', 'typeParameters']});

  // romejs/js-ast/src/typescript/TSConstructorType.ts

  const ___$romejs$js_ast$src$typescript$TSConstructorType_ts = {
    get tsConstructorType() {
      return ___$romejs$js_ast$src$typescript$TSConstructorType_ts$tsConstructorType;
    }};
  const ___$romejs$js_ast$src$typescript$TSConstructorType_ts$tsConstructorType = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSConstructorType',
  {visitorKeys: ['typeAnnotation', 'parameters', 'typeParameters']});

  // romejs/js-ast/src/typescript/TSLiteralType.ts

  const ___$romejs$js_ast$src$typescript$TSLiteralType_ts = {
    get tsLiteralType() {
      return ___$romejs$js_ast$src$typescript$TSLiteralType_ts$tsLiteralType;
    }};
  const ___$romejs$js_ast$src$typescript$TSLiteralType_ts$tsLiteralType = ___$romejs$js_ast$src$utils_ts$createBuilder('TSLiteralType', {
    visitorKeys: ['literal']});

  // romejs/js-ast/src/typescript/TSArrayType.ts

  const ___$romejs$js_ast$src$typescript$TSArrayType_ts = {
    get tsArrayType() {
      return ___$romejs$js_ast$src$typescript$TSArrayType_ts$tsArrayType;
    }};
  const ___$romejs$js_ast$src$typescript$TSArrayType_ts$tsArrayType = ___$romejs$js_ast$src$utils_ts$createBuilder('TSArrayType');

  // romejs/js-ast/src/typescript/TSIndexedAccessType.ts

  const ___$romejs$js_ast$src$typescript$TSIndexedAccessType_ts = {
    get tsIndexedAccessType() {
      return ___$romejs$js_ast$src$typescript$TSIndexedAccessType_ts$tsIndexedAccessType;
    }};
  const ___$romejs$js_ast$src$typescript$TSIndexedAccessType_ts$tsIndexedAccessType = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSIndexedAccessType');

  // romejs/js-ast/src/typescript/TSTypeOperator.ts

  const ___$romejs$js_ast$src$typescript$TSTypeOperator_ts = {
    get tsTypeOperator() {
      return ___$romejs$js_ast$src$typescript$TSTypeOperator_ts$tsTypeOperator;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypeOperator_ts$tsTypeOperator = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSTypeOperator',
  {visitorKeys: ['typeAnnotation']});

  // romejs/js-ast/src/typescript/TSInferType.ts

  const ___$romejs$js_ast$src$typescript$TSInferType_ts = {
    get tsInferType() {
      return ___$romejs$js_ast$src$typescript$TSInferType_ts$tsInferType;
    }};
  const ___$romejs$js_ast$src$typescript$TSInferType_ts$tsInferType = ___$romejs$js_ast$src$utils_ts$createBuilder('TSInferType', {
    visitorKeys: ['typeParameter']});

  // romejs/js-ast/src/typescript/TSTypeAnnotation.ts

  const ___$romejs$js_ast$src$typescript$TSTypeAnnotation_ts = {
    get tsTypeAnnotation() {
      return ___$romejs$js_ast$src$typescript$TSTypeAnnotation_ts$tsTypeAnnotation;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypeAnnotation_ts$tsTypeAnnotation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSTypeAnnotation',
  {visitorKeys: ['typeAnnotation']});

  // romejs/js-ast/src/typescript/TSConditionalType.ts

  const ___$romejs$js_ast$src$typescript$TSConditionalType_ts = {
    get tsConditionalType() {
      return ___$romejs$js_ast$src$typescript$TSConditionalType_ts$tsConditionalType;
    }};
  const ___$romejs$js_ast$src$typescript$TSConditionalType_ts$tsConditionalType = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSConditionalType');

  // romejs/js-ast/src/typescript/TSTypeAssertion.ts

  const ___$romejs$js_ast$src$typescript$TSTypeAssertion_ts = {
    get tsTypeAssertion() {
      return ___$romejs$js_ast$src$typescript$TSTypeAssertion_ts$tsTypeAssertion;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypeAssertion_ts$tsTypeAssertion = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSTypeAssertion',
  {visitorKeys: ['expression', 'typeAnnotation']});

  // romejs/js-ast/src/typescript/TSExpressionWithTypeArguments.ts

  const ___$romejs$js_ast$src$typescript$TSExpressionWithTypeArguments_ts = {
    get tsExpressionWithTypeArguments() {
      return ___$romejs$js_ast$src$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments;
    }};
  const ___$romejs$js_ast$src$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSExpressionWithTypeArguments', {
    visitorKeys: ['expression', 'typeParameters']});

  // romejs/js-ast/src/typescript/TSInterfaceBody.ts

  const ___$romejs$js_ast$src$typescript$TSInterfaceBody_ts = {
    get tsInterfaceBody() {
      return ___$romejs$js_ast$src$typescript$TSInterfaceBody_ts$tsInterfaceBody;
    }};
  const ___$romejs$js_ast$src$typescript$TSInterfaceBody_ts$tsInterfaceBody = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSInterfaceBody',
  {visitorKeys: ['body']});

  // romejs/js-ast/src/typescript/TSInterfaceDeclaration.ts

  const ___$romejs$js_ast$src$typescript$TSInterfaceDeclaration_ts = {
    get tsInterfaceDeclaration() {
      return ___$romejs$js_ast$src$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration;
    }};
  const ___$romejs$js_ast$src$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSInterfaceDeclaration',
  {visitorKeys: ['id', 'body', 'typeParameters', 'extends']});

  // romejs/js-ast/src/typescript/TSTypeAliasDeclaration.ts

  const ___$romejs$js_ast$src$typescript$TSTypeAliasDeclaration_ts = {
    get tsTypeAliasDeclaration() {
      return ___$romejs$js_ast$src$typescript$TSTypeAliasDeclaration_ts$tsTypeAliasDeclaration;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypeAliasDeclaration_ts$tsTypeAliasDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSTypeAliasDeclaration',
  {visitorKeys: ['id', 'typeParameters', 'typeAnnotation']});

  // romejs/js-ast/src/typescript/TSEnumMember.ts

  const ___$romejs$js_ast$src$typescript$TSEnumMember_ts = {
    get tsEnumMember() {
      return ___$romejs$js_ast$src$typescript$TSEnumMember_ts$tsEnumMember;
    }};
  const ___$romejs$js_ast$src$typescript$TSEnumMember_ts$tsEnumMember = ___$romejs$js_ast$src$utils_ts$createBuilder('TSEnumMember', {
    visitorKeys: ['id', 'initializer']});

  // romejs/js-ast/src/typescript/TSEnumDeclaration.ts

  const ___$romejs$js_ast$src$typescript$TSEnumDeclaration_ts = {
    get tsEnumDeclaration() {
      return ___$romejs$js_ast$src$typescript$TSEnumDeclaration_ts$tsEnumDeclaration;
    }};
  const ___$romejs$js_ast$src$typescript$TSEnumDeclaration_ts$tsEnumDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSEnumDeclaration',
  {visitorKeys: ['id', 'members']});

  // romejs/js-ast/src/typescript/TSModuleBlock.ts

  const ___$romejs$js_ast$src$typescript$TSModuleBlock_ts = {
    get tsModuleBlock() {
      return ___$romejs$js_ast$src$typescript$TSModuleBlock_ts$tsModuleBlock;
    }};
  const ___$romejs$js_ast$src$typescript$TSModuleBlock_ts$tsModuleBlock = ___$romejs$js_ast$src$utils_ts$createBuilder('TSModuleBlock', {
    visitorKeys: ['body']});

  // romejs/js-ast/src/typescript/TSModuleDeclaration.ts

  const ___$romejs$js_ast$src$typescript$TSModuleDeclaration_ts = {
    get tsModuleDeclaration() {
      return ___$romejs$js_ast$src$typescript$TSModuleDeclaration_ts$tsModuleDeclaration;
    }};
  const ___$romejs$js_ast$src$typescript$TSModuleDeclaration_ts$tsModuleDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSModuleDeclaration',
  {visitorKeys: ['id', 'body']});

  // romejs/js-ast/src/typescript/TSImportEqualsDeclaration.ts

  const ___$romejs$js_ast$src$typescript$TSImportEqualsDeclaration_ts = {
    get tsImportEqualsDeclaration() {
      return ___$romejs$js_ast$src$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration;
    }};
  const ___$romejs$js_ast$src$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSImportEqualsDeclaration', {visitorKeys: ['id', 'moduleReference']});

  // romejs/js-ast/src/typescript/TSExternalModuleReference.ts

  const ___$romejs$js_ast$src$typescript$TSExternalModuleReference_ts = {
    get tsExternalModuleReference() {
      return ___$romejs$js_ast$src$typescript$TSExternalModuleReference_ts$tsExternalModuleReference;
    }};
  const ___$romejs$js_ast$src$typescript$TSExternalModuleReference_ts$tsExternalModuleReference = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSExternalModuleReference', {
    visitorKeys: ['expression']});

  // romejs/js-ast/src/typescript/TSTypeParameterInstantiation.ts

  const ___$romejs$js_ast$src$typescript$TSTypeParameterInstantiation_ts = {
    get tsTypeParameterInstantiation() {
      return ___$romejs$js_ast$src$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation;
    }};
  const ___$romejs$js_ast$src$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSTypeParameterInstantiation',
  {
    visitorKeys: ['params']});

  // romejs/js-ast/src/typescript/TSExportAssignment.ts

  const ___$romejs$js_ast$src$typescript$TSExportAssignment_ts = {
    get tsExportAssignment() {
      return ___$romejs$js_ast$src$typescript$TSExportAssignment_ts$tsExportAssignment;
    }};
  const ___$romejs$js_ast$src$typescript$TSExportAssignment_ts$tsExportAssignment = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSExportAssignment',
  {visitorKeys: ['expression']});

  // romejs/js-ast/src/typescript/TSNamespaceExportDeclaration.ts

  const ___$romejs$js_ast$src$typescript$TSNamespaceExportDeclaration_ts = {
    get tsNamespaceExportDeclaration() {
      return ___$romejs$js_ast$src$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration;
    }};
  const ___$romejs$js_ast$src$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSNamespaceExportDeclaration', {visitorKeys: ['id']});

  // romejs/js-ast/src/typescript/TSDeclareFunction.ts

  const ___$romejs$js_ast$src$typescript$TSDeclareFunction_ts = {
    get tsDeclareFunction() {
      return ___$romejs$js_ast$src$typescript$TSDeclareFunction_ts$tsDeclareFunction;
    }};
  const ___$romejs$js_ast$src$typescript$TSDeclareFunction_ts$tsDeclareFunction = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSDeclareFunction',
  {
    visitorKeys: ['id', 'params', 'typeParameters', 'returnType', 'predicate']});

  // romejs/js-ast/src/typescript/TSDeclareMethod.ts

  const ___$romejs$js_ast$src$typescript$TSDeclareMethod_ts = {
    get tsDeclareMethod() {
      return ___$romejs$js_ast$src$typescript$TSDeclareMethod_ts$tsDeclareMethod;
    }};
  const ___$romejs$js_ast$src$typescript$TSDeclareMethod_ts$tsDeclareMethod = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSDeclareMethod',
  {
    visitorKeys: ['key', 'params', 'body', 'typeParameters', 'returnType', 'predicate']});

  // romejs/js-ast/src/typescript/TSCallSignatureDeclaration.ts

  const ___$romejs$js_ast$src$typescript$TSCallSignatureDeclaration_ts = {
    get tsCallSignatureDeclaration() {
      return ___$romejs$js_ast$src$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration;
    }};
  const ___$romejs$js_ast$src$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSCallSignatureDeclaration', {
    visitorKeys: ['typeAnnotation', 'parameters', 'typeParameters']});

  // romejs/js-ast/src/typescript/TSConstructSignatureDeclaration.ts

  const ___$romejs$js_ast$src$typescript$TSConstructSignatureDeclaration_ts = {
    get tsConstructSignatureDeclaration() {
      return ___$romejs$js_ast$src$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration;
    }};
  const ___$romejs$js_ast$src$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSConstructSignatureDeclaration', {
    visitorKeys: ['typeAnnotation', 'parameters', 'typeParameters']});

  // romejs/js-ast/src/core/Unknown.ts

  const ___$romejs$js_ast$src$core$Unknown_ts = {
    get unknown() {
      return ___$romejs$js_ast$src$core$Unknown_ts$unknown;
    }};
  const ___$romejs$js_ast$src$core$Unknown_ts$unknown = ___$romejs$js_ast$src$utils_ts$createBuilder('Unknown');

  // romejs/js-ast/src/core/OptionalMemberExpression.ts

  const ___$romejs$js_ast$src$core$OptionalMemberExpression_ts = {
    get optionalMemberExpression() {
      return ___$romejs$js_ast$src$core$OptionalMemberExpression_ts$optionalMemberExpression;
    }};
  const ___$romejs$js_ast$src$core$OptionalMemberExpression_ts$optionalMemberExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'OptionalMemberExpression', {
    visitorKeys: ['object', 'property']});

  // romejs/js-ast/src/core/OptionalCallExpression.ts

  const ___$romejs$js_ast$src$core$OptionalCallExpression_ts = {
    get optionalCallExpression() {
      return ___$romejs$js_ast$src$core$OptionalCallExpression_ts$optionalCallExpression;
    }};
  const ___$romejs$js_ast$src$core$OptionalCallExpression_ts$optionalCallExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'OptionalCallExpression',
  {
    visitorKeys: ['callee', 'arguments']});

  // romejs/js-ast/src/typescript/TSNonNullExpression.ts

  const ___$romejs$js_ast$src$typescript$TSNonNullExpression_ts = {
    get tsNonNullExpression() {
      return ___$romejs$js_ast$src$typescript$TSNonNullExpression_ts$tsNonNullExpression;
    }};
  const ___$romejs$js_ast$src$typescript$TSNonNullExpression_ts$tsNonNullExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSNonNullExpression',
  {visitorKeys: ['expression']});

  // romejs/js-ast/src/typescript/TSAsExpression.ts

  const ___$romejs$js_ast$src$typescript$TSAsExpression_ts = {
    get tsAsExpression() {
      return ___$romejs$js_ast$src$typescript$TSAsExpression_ts$tsAsExpression;
    }};
  const ___$romejs$js_ast$src$typescript$TSAsExpression_ts$tsAsExpression = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSAsExpression',
  {visitorKeys: ['expression', 'typeAnnotation']});

  // romejs/js-ast/src/typescript/TSUnionType.ts

  const ___$romejs$js_ast$src$typescript$TSUnionType_ts = {
    get tsUnionType() {
      return ___$romejs$js_ast$src$typescript$TSUnionType_ts$tsUnionType;
    }};
  const ___$romejs$js_ast$src$typescript$TSUnionType_ts$tsUnionType = ___$romejs$js_ast$src$utils_ts$createBuilder('TSUnionType', {
    visitorKeys: ['types']});

  // romejs/js-ast/src/typescript/TSIntersectionType.ts

  const ___$romejs$js_ast$src$typescript$TSIntersectionType_ts = {
    get tsIntersectionType() {
      return ___$romejs$js_ast$src$typescript$TSIntersectionType_ts$tsIntersectionType;
    }};
  const ___$romejs$js_ast$src$typescript$TSIntersectionType_ts$tsIntersectionType = ___$romejs$js_ast$src$utils_ts$createBuilder(
  'TSIntersectionType',
  {
    visitorKeys: ['types']});

  // romejs/js-ast/src/index.ts

  const ___$romejs$js_ast$src$index_ts = {
    get visitorKeys() {
      return ___$romejs$js_ast$src$utils_ts$visitorKeys;
    },
    get nodeNames() {
      return ___$romejs$js_ast$src$utils_ts$nodeNames;
    },
    get assertNodeTypeSet() {
      return ___$romejs$js_ast$src$utils_ts$assertNodeTypeSet;
    }};
  Object.keys(___$romejs$js_ast$src$base_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$base_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$constants_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$constants_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$unions_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$unions_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$InterpreterDirective_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$InterpreterDirective_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowAnyTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowAnyTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ArrayExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ArrayExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ArrayPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ArrayPattern_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowArrayTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowArrayTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ArrowFunctionExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ArrowFunctionExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$AssignmentExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$AssignmentExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$AssignmentPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$AssignmentPattern_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$AwaitExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$AwaitExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowBigIntTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowBigIntTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$BinaryExpressionNode_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$BinaryExpressionNode_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$BlockStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$BlockStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$BooleanLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$BooleanLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowBooleanLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowBooleanLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowBooleanTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowBooleanTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$BreakStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$BreakStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$CallExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$CallExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$CatchClause_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$CatchClause_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ClassDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ClassDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ClassExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ClassExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowClassImplements_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowClassImplements_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ClassMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ClassMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ClassPrivateMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ClassPrivateMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ClassPrivateProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ClassPrivateProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ClassProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ClassProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ConditionalExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ConditionalExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ContinueStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ContinueStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$DebuggerStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$DebuggerStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclareClass_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclareClass_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclareExportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclareExportDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclareFunction_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclareFunction_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclareInterface_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclareInterface_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclareModule_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclareModule_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclareModuleExports_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclareModuleExports_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclareOpaqueType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclareOpaqueType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclareTypeAlias_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclareTypeAlias_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclareVariable_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclareVariable_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$Directive_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$Directive_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$DoWhileStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$DoWhileStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$EmptyStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$EmptyStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowEmptyTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowEmptyTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowExistsTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowExistsTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ExportAllDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ExportAllDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ExportDefaultDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ExportDefaultDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ExportDefaultSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ExportDefaultSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ExportNamedDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ExportNamedDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ExportNamespaceSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ExportNamespaceSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ExportSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ExportSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ExpressionStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ExpressionStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ForStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ForStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$FunctionDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$FunctionDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$FunctionExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$FunctionExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowFunctionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowFunctionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowFunctionTypeParam_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowFunctionTypeParam_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowGenericTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowGenericTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$Identifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$Identifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$IfStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$IfStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$Import_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$Import_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ImportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ImportDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ImportSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ImportSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowInterfaceExtends_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowInterfaceExtends_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowIntersectionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowIntersectionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXAttribute_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXAttribute_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXClosingElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXClosingElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXClosingFragment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXClosingFragment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXEmptyExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXEmptyExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXExpressionContainer_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXExpressionContainer_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXFragment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXFragment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXIdentifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXMemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXMemberExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXNamespacedName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXNamespacedName_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXOpeningElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXOpeningElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXOpeningFragment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXOpeningFragment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXSpreadAttribute_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXSpreadAttribute_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXSpreadChild_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXSpreadChild_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$LabeledStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$LabeledStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$MemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$MemberExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$MetaProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$MetaProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowMixedTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowMixedTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$NewExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$NewExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$NullLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$NullLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowNullableTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowNullableTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowNumberTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowNumberTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$NumericLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$NumericLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowNumericLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowNumericLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ObjectExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ObjectExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ObjectMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ObjectMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ObjectPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ObjectPattern_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ObjectProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ObjectProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowObjectTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowObjectTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowObjectTypeCallProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowObjectTypeCallProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowObjectTypeIndexer_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowObjectTypeIndexer_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowObjectTypeProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowObjectTypeProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowObjectTypeSpreadProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowObjectTypeSpreadProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowOpaqueType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowOpaqueType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$PrivateName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$PrivateName_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$Program_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$Program_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowQualifiedTypeIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowQualifiedTypeIdentifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$RestElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$RestElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ReturnStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ReturnStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$SequenceExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$SequenceExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$SpreadElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$SpreadElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$SpreadProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$SpreadProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$StringLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$StringLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowStringTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowStringTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$Super_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$Super_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$SwitchCase_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$SwitchCase_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$SwitchStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$SwitchStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$TemplateElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$TemplateElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$TemplateLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$TemplateLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ThisExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ThisExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowThisTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowThisTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ThrowStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ThrowStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$TryStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$TryStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowTupleTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowTupleTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowTypeAlias_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowTypeAlias_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowTypeParameter_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowTypeParameter_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowTypeParameterDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowTypeParameterDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowTypeParameterInstantiation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowTypeParameterInstantiation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowTypeofTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowTypeofTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowUnionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowUnionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$UpdateExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$UpdateExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$VariableDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$VariableDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$VariableDeclarator_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$VariableDeclarator_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowVariance_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowVariance_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowVoidTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowVoidTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$WhileStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$WhileStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$WithStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$WithStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$YieldExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$YieldExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$jsx$JSXText_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$jsx$JSXText_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ImportDefaultSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ImportDefaultSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ImportNamespaceSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ImportNamespaceSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$DirectiveLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$DirectiveLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$UnaryExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$UnaryExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$LogicalExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$LogicalExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$RegExpLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$RegExpLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$BigIntLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$BigIntLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ForOfStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ForOfStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$ForInStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$ForInStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$RestProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$RestProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowInterfaceDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowInterfaceDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowInterface_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowInterface_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowNullLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowNullLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowNumericLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowNumericLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowStringLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowStringLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowTypeCastExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowTypeCastExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowInferredPredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowInferredPredicate_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclaredPredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclaredPredicate_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$TaggedTemplateExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$TaggedTemplateExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowDeclareExportAllDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowDeclareExportAllDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$DoExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$DoExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowInterfaceTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowInterfaceTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowObjectTypeInternalSlot_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowObjectTypeInternalSlot_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$flow$FlowFunctionTypeParamRest_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$flow$FlowFunctionTypeParamRest_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSUnknownKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSUnknownKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSAnyKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSAnyKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSBooleanKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSBooleanKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSBigIntKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSBigIntKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSNeverKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSNeverKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSNumberKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSNumberKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSObjectKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSObjectKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSStringKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSStringKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSSymbolKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSSymbolKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSUndefinedKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSUndefinedKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSImportType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSImportType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSQualifiedName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSQualifiedName_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypeReference_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypeReference_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypePredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypePredicate_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSThisType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSThisType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypeQuery_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypeQuery_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypeParameter_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypeParameter_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypeParameterDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypeParameterDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSIndexSignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSIndexSignature_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSMethodSignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSMethodSignature_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSPropertySignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSPropertySignature_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypeLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypeLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSMappedType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSMappedType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTupleType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTupleType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSRestType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSRestType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSOptionalType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSOptionalType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSParenthesizedType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSParenthesizedType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSFunctionType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSFunctionType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSConstructorType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSConstructorType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSLiteralType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSLiteralType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSArrayType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSArrayType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSIndexedAccessType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSIndexedAccessType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypeOperator_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypeOperator_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSInferType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSInferType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSConditionalType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSConditionalType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypeAssertion_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypeAssertion_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSExpressionWithTypeArguments_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSExpressionWithTypeArguments_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSInterfaceBody_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSInterfaceBody_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSInterfaceDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSInterfaceDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypeAliasDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypeAliasDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSEnumMember_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSEnumMember_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSEnumDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSEnumDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSModuleBlock_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSModuleBlock_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSModuleDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSModuleDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSImportEqualsDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSImportEqualsDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSExternalModuleReference_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSExternalModuleReference_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSTypeParameterInstantiation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSTypeParameterInstantiation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSExportAssignment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSExportAssignment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSNamespaceExportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSNamespaceExportDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSDeclareFunction_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSDeclareFunction_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSDeclareMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSDeclareMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSCallSignatureDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSCallSignatureDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSConstructSignatureDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSConstructSignatureDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$Unknown_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$Unknown_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$OptionalMemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$OptionalMemberExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$core$OptionalCallExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$core$OptionalCallExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSNonNullExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSNonNullExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSAsExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSAsExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSUnionType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSUnionType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_ast$src$typescript$TSIntersectionType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_ast$src$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_ast$src$typescript$TSIntersectionType_ts[key];
      }});
  });

  // romejs/js-ast-utils/src/inheritLoc.ts

  function ___$romejs$js_ast_utils$src$inheritLoc_ts$default(node, name) {
    const {loc: loc} = node;
    if (loc === undefined) {
      return undefined;
    }

    if (name !== undefined) {
      return Object.assign({}, loc, {
        identifierName: name});
    }

    if (loc.identifierName !== undefined) {
      return loc;
    }

    if (node.type === 'Identifier') {
      return Object.assign({}, loc, {
        identifierName: node.name});
    }

    return loc;
  }

  // romejs/js-ast-utils/src/renameBindings.ts

  function ___$romejs$js_ast_utils$src$renameBindings_ts$default(path, mapping) {
    if (mapping.size === 0) {
      return path.node;
    }

    const currBindings = new Map();
    for (const [oldName] of mapping) {
      const binding = path.scope.getBinding(oldName);
      currBindings.set(oldName, binding);
    }

    const replaceNodes = new Set();
    path.traverse('renameBindingsCollector', path => {
      const {node: node, scope: scope} = path;
      if (node.type !== 'Identifier') {
        return;
      }

      const isRefId = ___$romejs$js_ast_utils$src$isReferenced_ts$default(path);
      const isBindingId = ___$romejs$js_ast_utils$src$isBinding_ts$default(node, path.parent);
      if (!isRefId && !isBindingId) {
        return;
      }

      const hasMatch = mapping.has(node.name) &&
      scope.getBinding(node.name) === currBindings.get(node.name);
      if (hasMatch) {
        replaceNodes.add(node);
      }
    });
    if (replaceNodes.size === 0) {
      return path.node;
    }

    const replaced = new Set();

    const renamedNode = path.reduce({
      name: 'renameBindings',
      enter(path) {
        const {node: node} = path;

        if (node.type === 'ExportNamedDeclaration' &&
        node.declaration !== undefined &&
        replaceNodes.has(node.declaration.id)) {
          replaced.add(node.declaration.id);

          const oldName = node.declaration.id.name;
          const newName = mapping.get(oldName);
          if (newName === undefined) {
            throw new Error('Expected new name');
          }

          return [node.declaration, ___$romejs$js_ast$src$core$ExportNamedDeclaration_ts$exportNamedDeclaration.create({
            specifiers: [___$romejs$js_ast$src$core$ExportSpecifier_ts$exportSpecifier.create({
              local: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: newName}),
              exported: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: oldName})})]})];
        }

        if (node.type === 'ExportNamedDeclaration' &&
        node.declaration !== undefined) {
          const bindings = ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(node.declaration);
          let includesAny = false;
          for (const node of bindings) {
            if (replaceNodes.has(node)) {
              includesAny = true;
              break;
            }
          }

          if (includesAny) {
            return [node.declaration, ___$romejs$js_ast$src$core$ExportNamedDeclaration_ts$exportNamedDeclaration.create({
              specifiers: bindings.map(node => {
                let local = node.name;
                if (replaceNodes.has(node)) {
                  local = mapping.get(local);
                  if (local === undefined) {
                    throw new Error('Expected local');
                  }
                  replaced.add(node);
                }
                return ___$romejs$js_ast$src$core$ExportSpecifier_ts$exportSpecifier.create({
                  local: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: local}),
                  exported: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: node.name})});
              })})];
          }
        }

        if (node.type === 'Identifier' && replaceNodes.has(node)) {
          const name = mapping.get(node.name);
          if (name === undefined) {
            throw new Error('Expected name');
          }
          replaced.add(node);
          return ___$romejs$js_ast$src$core$Identifier_ts$identifier.create(Object.assign({}, node, {
            name: name,
            loc: ___$romejs$js_ast_utils$src$inheritLoc_ts$default(node, node.name)}));
        }

        return node;
      }});

    if (replaced.size !== replaceNodes.size) {
      throw new Error('Missed some bindings');
    }

    return renamedNode;
  }

  // romejs/js-ast-utils/src/removeLoc.ts

  const ___$$priv$romejs$js_ast_utils$src$removeLoc_ts$removeLocTransform = [{
    name: 'removeLocTransform',
    enter(path) {
      const {node: node} = path;
      if (node.loc === undefined) {
        return node;
      } else {
        const newNode = Object.assign({}, node);
        delete newNode.loc;

        for (const key in newNode) {
          if (newNode[key] === undefined) {
            delete newNode[key];
          }
        }

        return newNode;
      }
    }}];

  function ___$romejs$js_ast_utils$src$removeLoc_ts$default(ast) {
    const context = new ___$romejs$js_compiler$src$lib$Context_ts$default({ast: ast, projectConfig: ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG});
    return context.reduce(ast, ___$$priv$romejs$js_ast_utils$src$removeLoc_ts$removeLocTransform);
  }

  // romejs/js-parser/src/options.ts

  const ___$$priv$romejs$js_parser$src$options_ts$path = require('path');
  function ___$romejs$js_parser$src$options_ts$deriveSyntaxFromFilename(filename) {
    switch (___$$priv$romejs$js_parser$src$options_ts$path.extname(filename)) {
      case '.ts':
        return ['ts'];

      case '.tsx':
        return ['jsx', 'ts'];

      case '.jsx':
        return ['jsx', 'flow'];

      case '.rjs':
        return ['jsx', 'flow', 'ts'];

      default:
        return ['jsx', 'flow'];}
  }

  function ___$romejs$js_parser$src$options_ts$normalizeOptions(opts) {
    return Object.assign({
      allowReturnOutsideFunction: false,

      sourceType: 'script',

      tokens: false}, opts, {
      syntax: opts.syntax === undefined ? ___$romejs$js_parser$src$options_ts$deriveSyntaxFromFilename(opts.filename) : opts.syntax});
  }

  // romejs/js-parser/src/xhtmlEntities.ts

  const ___$$priv$romejs$js_parser$src$xhtmlEntities_ts$entities = {
    quot: '"',
    amp: '&',
    apos: '\'',
    lt: '<',
    gt: '>',
    nbsp: '\xa0',
    iexcl: '\xa1',
    cent: '\xa2',
    pound: '\xa3',
    curren: '\xa4',
    yen: '\xa5',
    brvbar: '\xa6',
    sect: '\xa7',
    uml: '\xa8',
    copy: '\xa9',
    ordf: '\xaa',
    laquo: '\xab',
    not: '\xac',
    shy: '\xad',
    reg: '\xae',
    macr: '\xaf',
    deg: '\xb0',
    plusmn: '\xb1',
    sup2: '\xb2',
    sup3: '\xb3',
    acute: '\xb4',
    micro: '\xb5',
    para: '\xb6',
    middot: '\xb7',
    cedil: '\xb8',
    sup1: '\xb9',
    ordm: '\xba',
    raquo: '\xbb',
    frac14: '\xbc',
    frac12: '\xbd',
    frac34: '\xbe',
    iquest: '\xbf',
    Agrave: '\xc0',
    Aacute: '\xc1',
    Acirc: '\xc2',
    Atilde: '\xc3',
    Auml: '\xc4',
    Aring: '\xc5',
    AElig: '\xc6',
    Ccedil: '\xc7',
    Egrave: '\xc8',
    Eacute: '\xc9',
    Ecirc: '\xca',
    Euml: '\xcb',
    Igrave: '\xcc',
    Iacute: '\xcd',
    Icirc: '\xce',
    Iuml: '\xcf',
    ETH: '\xd0',
    Ntilde: '\xd1',
    Ograve: '\xd2',
    Oacute: '\xd3',
    Ocirc: '\xd4',
    Otilde: '\xd5',
    Ouml: '\xd6',
    times: '\xd7',
    Oslash: '\xd8',
    Ugrave: '\xd9',
    Uacute: '\xda',
    Ucirc: '\xdb',
    Uuml: '\xdc',
    Yacute: '\xdd',
    THORN: '\xde',
    szlig: '\xdf',
    agrave: '\xe0',
    aacute: '\xe1',
    acirc: '\xe2',
    atilde: '\xe3',
    auml: '\xe4',
    aring: '\xe5',
    aelig: '\xe6',
    ccedil: '\xe7',
    egrave: '\xe8',
    eacute: '\xe9',
    ecirc: '\xea',
    euml: '\xeb',
    igrave: '\xec',
    iacute: '\xed',
    icirc: '\xee',
    iuml: '\xef',
    eth: '\xf0',
    ntilde: '\xf1',
    ograve: '\xf2',
    oacute: '\xf3',
    ocirc: '\xf4',
    otilde: '\xf5',
    ouml: '\xf6',
    divide: '\xf7',
    oslash: '\xf8',
    ugrave: '\xf9',
    uacute: '\xfa',
    ucirc: '\xfb',
    uuml: '\xfc',
    yacute: '\xfd',
    thorn: '\xfe',
    yuml: '\xff',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02c6',
    tilde: '\u02dc',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039a',
    Lambda: '\u039b',
    Mu: '\u039c',
    Nu: '\u039d',
    Xi: '\u039e',
    Omicron: '\u039f',
    Pi: '\u03a0',
    Rho: '\u03a1',
    Sigma: '\u03a3',
    Tau: '\u03a4',
    Upsilon: '\u03a5',
    Phi: '\u03a6',
    Chi: '\u03a7',
    Psi: '\u03a8',
    Omega: '\u03a9',
    alpha: '\u03b1',
    beta: '\u03b2',
    gamma: '\u03b3',
    delta: '\u03b4',
    epsilon: '\u03b5',
    zeta: '\u03b6',
    eta: '\u03b7',
    theta: '\u03b8',
    iota: '\u03b9',
    kappa: '\u03ba',
    lambda: '\u03bb',
    mu: '\u03bc',
    nu: '\u03bd',
    xi: '\u03be',
    omicron: '\u03bf',
    pi: '\u03c0',
    rho: '\u03c1',
    sigmaf: '\u03c2',
    sigma: '\u03c3',
    tau: '\u03c4',
    upsilon: '\u03c5',
    phi: '\u03c6',
    chi: '\u03c7',
    psi: '\u03c8',
    omega: '\u03c9',
    thetasym: '\u03d1',
    upsih: '\u03d2',
    piv: '\u03d6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200c',
    zwj: '\u200d',
    lrm: '\u200e',
    rlm: '\u200f',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201a',
    ldquo: '\u201c',
    rdquo: '\u201d',
    bdquo: '\u201e',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203a',
    oline: '\u203e',
    frasl: '\u2044',
    euro: '\u20ac',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211c',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21b5',
    lArr: '\u21d0',
    uArr: '\u21d1',
    rArr: '\u21d2',
    dArr: '\u21d3',
    hArr: '\u21d4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220b',
    prod: '\u220f',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221a',
    prop: '\u221d',
    infin: '\u221e',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222a',
    int: '\u222b',
    there4: '\u2234',
    sim: '\u223c',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22a5',
    sdot: '\u22c5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230a',
    rfloor: '\u230b',
    lang: '\u2329',
    rang: '\u232a',
    loz: '\u25ca',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666'};
  const ___$romejs$js_parser$src$xhtmlEntities_ts$default = ___$$priv$romejs$js_parser$src$xhtmlEntities_ts$entities;

  // romejs/js-parser/src/tokenizer/types.ts

  const ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr = true;
  const ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr = true;
  const ___$$priv$romejs$js_parser$src$tokenizer$types_ts$isLoop = true;
  const ___$$priv$romejs$js_parser$src$tokenizer$types_ts$isAssign = true;
  const ___$$priv$romejs$js_parser$src$tokenizer$types_ts$prefix = true;
  const ___$$priv$romejs$js_parser$src$tokenizer$types_ts$postfix = true;

  class ___$romejs$js_parser$src$tokenizer$types_ts$TokenType {
    constructor(label, conf = {}) {
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = typeof conf.binop === 'number' ? conf.binop : undefined;
      this.updateContext = undefined;
    }

    getBinop() {
      const {binop: binop} = this;
      if (binop === undefined) {
        throw new Error(`Token ${this.label} doesn't have a binop`);
      }
      return binop;
    }
  }

  const ___$romejs$js_parser$src$tokenizer$types_ts$keywords = new Map();

  class ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType extends ___$romejs$js_parser$src$tokenizer$types_ts$TokenType {
    constructor(name, options = {}) {
      options.keyword = name;

      super(name, options);

      ___$romejs$js_parser$src$tokenizer$types_ts$keywords.set(name, this);
    }
  }

  class ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType extends ___$romejs$js_parser$src$tokenizer$types_ts$TokenType {
    constructor(name, prec) {
      super(name, {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, binop: prec});
    }
  }

  const ___$romejs$js_parser$src$tokenizer$types_ts$types = {
    num: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('num', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    bigint: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('bigint', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    regexp: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('regexp', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    string: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('string', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    name: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('name', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    eof: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('eof'),
    invalid: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('invalid'),
    comment: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('comment'),

    bracketL: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('[', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    bracketR: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType(']'),
    braceL: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('{', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    braceBarL: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    braceR: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('}'),
    braceBarR: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('|}'),
    parenL: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('(', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    parenR: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType(')'),
    comma: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType(',', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    semi: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType(';', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    colon: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType(':', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    doubleColon: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('::', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    dot: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('.'),
    question: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('?', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    questionDot: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('?.'),
    arrow: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('=>', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    template: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('template'),
    ellipsis: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('...', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    backQuote: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('`', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    dollarBraceL: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('${', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    at: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('@'),
    hash: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('#'),

    eq: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('=', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, isAssign: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$isAssign}),
    assign: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('_=', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, isAssign: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$isAssign}),
    incDec: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('++/--', {prefix: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$prefix, postfix: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$postfix, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    bang: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('!', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, prefix: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$prefix, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    tilde: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('~', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, prefix: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$prefix, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    nullishCoalescing: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('??', 1),
    logicalOR: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('||', 1),
    logicalAND: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('&&', 2),
    bitwiseOR: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('|', 3),
    bitwiseXOR: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('^', 4),
    bitwiseAND: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('&', 5),
    equality: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('==/!=', 6),
    relational: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('</>', 7),
    bitShift: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('<</>>', 8),
    plusMin: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('+/-', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, binop: 9, prefix: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$prefix, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    modulo: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('%', 10),
    star: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('*', 10),
    slash: new ___$romejs$js_parser$src$tokenizer$types_ts$BinopTokenType('/', 10),
    exponent: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('**', {
      beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr,
      binop: 11,
      rightAssociative: true}),

    jsxName: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('jsxName'),
    jsxText: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('jsxText', {beforeExpr: true}),
    jsxTagStart: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('jsxTagStart', {startsExpr: true}),
    jsxTagEnd: new ___$romejs$js_parser$src$tokenizer$types_ts$TokenType('jsxTagEnd'),

    _break: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('break'),
    _case: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('case', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    _catch: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('catch'),
    _continue: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('continue'),
    _debugger: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('debugger'),
    _default: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('default', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    _do: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('do', {isLoop: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$isLoop, beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    _else: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('else', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    _finally: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('finally'),
    _for: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('for', {isLoop: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$isLoop}),
    _function: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('function', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _if: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('if'),
    _return: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('return', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    _switch: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('switch'),
    _throw: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('throw', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, prefix: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$prefix, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _try: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('try'),
    _var: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('var'),
    _const: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('const'),
    _while: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('while', {isLoop: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$isLoop}),
    _with: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('with'),
    _new: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('new', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _this: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('this', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _super: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('super', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _class: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('class', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _extends: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('extends', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr}),
    _export: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('export'),
    _import: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('import', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _null: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('null', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _true: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('true', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _false: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('false', {startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _in: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('in', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, binop: 7}),
    _instanceof: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('instanceof', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, binop: 7}),
    _typeof: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('typeof', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, prefix: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$prefix, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _void: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('void', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, prefix: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$prefix, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr}),
    _delete: new ___$romejs$js_parser$src$tokenizer$types_ts$KeywordTokenType('delete', {beforeExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$beforeExpr, prefix: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$prefix, startsExpr: ___$$priv$romejs$js_parser$src$tokenizer$types_ts$startsExpr})};

  // romejs/js-parser/src/tokenizer/context.ts

  class ___$romejs$js_parser$src$tokenizer$context_ts$TokContext {
    constructor(token, isExpr, preserveSpace, override) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
    }
  }

  const ___$romejs$js_parser$src$tokenizer$context_ts$types = {
    braceStatement: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('{', false),
    braceExpression: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('{', true),
    templateQuasi: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('${', false),
    parenStatement: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('(', false),
    parenExpression: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('(', true),
    template: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('`', true, true, p => ___$romejs$js_parser$src$tokenizer$index_ts$readTemplateToken(p)),
    functionExpression: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('function', true),
    functionStatement: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('function', false),

    jsxOpenTag: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('<tag', false),
    jsxCloseTag: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('</tag', false),
    jsxInner: new ___$romejs$js_parser$src$tokenizer$context_ts$TokContext('<tag>...</tag>', true, true)};

  ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR.updateContext = ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR.updateContext = function(parser) {
    if (parser.state.context.length === 1) {
      parser.state.exprAllowed = true;
      return undefined;
    }

    let out = parser.state.context.pop();
    if (out === ___$romejs$js_parser$src$tokenizer$context_ts$types.braceStatement &&
    ___$romejs$js_parser$src$tokenizer$index_ts$getCurContext(parser).token === 'function') {
      out = parser.state.context.pop();
    }

    if (out === undefined) {
      throw new Error('No context found');
    }

    parser.state.exprAllowed = !out.isExpr;
  };

  ___$romejs$js_parser$src$tokenizer$types_ts$types.name.updateContext = function(parser, prevType) {
    let allowed = false;
    if (prevType !== ___$romejs$js_parser$src$tokenizer$types_ts$types.dot) {
      if (parser.state.tokenValue === 'of' && !parser.state.exprAllowed ||
      parser.state.tokenValue === 'yield' && parser.inScope('GENERATOR')) {
        allowed = true;
      }
    }

    parser.state.exprAllowed = allowed;

    if (parser.state.isIterator) {
      parser.state.isIterator = false;
    }
  };

  ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL.updateContext = function(parser, prevType) {
    parser.state.context.push(
    ___$romejs$js_parser$src$tokenizer$index_ts$isBraceBlock(parser, prevType) ? ___$romejs$js_parser$src$tokenizer$context_ts$types.braceStatement : ___$romejs$js_parser$src$tokenizer$context_ts$types.braceExpression);
    parser.state.exprAllowed = true;
  };

  ___$romejs$js_parser$src$tokenizer$types_ts$types.dollarBraceL.updateContext = function(parser) {
    parser.state.context.push(___$romejs$js_parser$src$tokenizer$context_ts$types.templateQuasi);
    parser.state.exprAllowed = true;
  };

  ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL.updateContext = function(parser, prevType) {
    const statementParens = prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types._if ||
    prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types._for ||
    prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types._with ||
    prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types._while;
    parser.state.context.push(
    statementParens ? ___$romejs$js_parser$src$tokenizer$context_ts$types.parenStatement : ___$romejs$js_parser$src$tokenizer$context_ts$types.parenExpression);
    parser.state.exprAllowed = true;
  };

  ___$romejs$js_parser$src$tokenizer$types_ts$types.incDec.updateContext = function() {};

  ___$romejs$js_parser$src$tokenizer$types_ts$types._function.updateContext = function(parser, prevType) {
    if (prevType.beforeExpr &&
    prevType !== ___$romejs$js_parser$src$tokenizer$types_ts$types.semi &&
    prevType !== ___$romejs$js_parser$src$tokenizer$types_ts$types._else &&
    !(prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types._return &&
    ___$romejs$js_parser_utils$src$whitespace_ts$lineBreak.test(
    parser.getRawInput(
    parser.state.lastEndPos.index,
    parser.state.startPos.index))) &&
    !((prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.colon || prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL) &&
    ___$romejs$js_parser$src$tokenizer$index_ts$getCurContext(parser) === ___$romejs$js_parser$src$tokenizer$context_ts$types.b_stat)) {
      parser.state.context.push(___$romejs$js_parser$src$tokenizer$context_ts$types.functionExpression);
    } else {
      parser.state.context.push(___$romejs$js_parser$src$tokenizer$context_ts$types.functionStatement);
    }

    parser.state.exprAllowed = false;
  };

  ___$romejs$js_parser$src$tokenizer$types_ts$types._class.updateContext = ___$romejs$js_parser$src$tokenizer$types_ts$types._function.updateContext;

  ___$romejs$js_parser$src$tokenizer$types_ts$types.backQuote.updateContext = function(parser) {
    if (___$romejs$js_parser$src$tokenizer$index_ts$getCurContext(parser) === ___$romejs$js_parser$src$tokenizer$context_ts$types.template) {
      parser.state.context.pop();
    } else {
      parser.state.context.push(___$romejs$js_parser$src$tokenizer$context_ts$types.template);
    }
    parser.state.exprAllowed = false;
  };

  ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagStart.updateContext = function(parser) {
    parser.state.context.push(___$romejs$js_parser$src$tokenizer$context_ts$types.jsxInner);
    parser.state.context.push(___$romejs$js_parser$src$tokenizer$context_ts$types.jsxOpenTag);
    parser.state.exprAllowed = false;
  };

  ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagEnd.updateContext = function(parser, prevType) {
    const out = parser.state.context.pop();
    if (out === ___$romejs$js_parser$src$tokenizer$context_ts$types.jsxOpenTag && prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.slash ||
    out === ___$romejs$js_parser$src$tokenizer$context_ts$types.jsxCloseTag) {
      parser.state.context.pop();
      parser.state.exprAllowed = ___$romejs$js_parser$src$tokenizer$index_ts$getCurContext(parser) === ___$romejs$js_parser$src$tokenizer$context_ts$types.jsxInner;
    } else {
      parser.state.exprAllowed = true;
    }
  };

  // romejs/js-parser/src/parser/comments.ts

  const ___$romejs$js_parser$src$parser$comments_ts = {
    addComment: ___$romejs$js_parser$src$parser$comments_ts$addComment,
    processComment: ___$romejs$js_parser$src$parser$comments_ts$processComment};
  function ___$$priv$romejs$js_parser$src$parser$comments_ts$last(stack) {
    return stack[stack.length - 1];
  }

  function ___$romejs$js_parser$src$parser$comments_ts$addComment(parser, comment) {
    parser.state.trailingComments.push(comment);
    parser.state.leadingComments.push(comment);
  }

  function ___$romejs$js_parser$src$parser$comments_ts$processComment(parser, node) {
    if (node.type === 'Program' && node.body.length > 0) {
      return undefined;
    }

    const stack = parser.state.commentStack;

    let firstChild, lastChild, trailingComments, i, j;

    if (parser.state.trailingComments.length > 0) {
      if (parser.getLoc(parser.state.trailingComments[0]).start.index >=
      parser.getLoc(node).end.index) {
        trailingComments = parser.state.trailingComments;
        parser.state.trailingComments = [];
      } else {
        parser.state.trailingComments.length = 0;
      }
    } else {
      if (stack.length > 0) {
        const lastInStack = ___$$priv$romejs$js_parser$src$parser$comments_ts$last(stack);
        if (lastInStack.trailingComments &&
        parser.getLoc(lastInStack.trailingComments[0]).start.index >=
        parser.getLoc(node).end.index) {
          trailingComments = lastInStack.trailingComments;
          lastInStack.trailingComments = undefined;
        }
      }
    }

    if (stack.length > 0 &&
    parser.getLoc(___$$priv$romejs$js_parser$src$parser$comments_ts$last(stack)).start.index >= parser.getLoc(node).start.index) {
      firstChild = stack.pop();
    }

    while (stack.length > 0 &&
    parser.getLoc(___$$priv$romejs$js_parser$src$parser$comments_ts$last(stack)).start.index >= parser.getLoc(node).start.index) {
      lastChild = stack.pop();
    }

    if (!lastChild && firstChild) {
      lastChild = firstChild;
    }

    if (firstChild && parser.state.leadingComments.length > 0) {
      const lastComment = ___$$priv$romejs$js_parser$src$parser$comments_ts$last(parser.state.leadingComments);

      if (firstChild.type === 'ObjectProperty') {
        if (parser.getLoc(lastComment).start.index >=
        parser.getLoc(node).start.index) {
          if (parser.state.commentPreviousNode) {
            for (j = 0; j < parser.state.leadingComments.length; j++) {
              if (parser.getLoc(parser.state.leadingComments[j]).end.index <
              parser.getLoc(parser.state.commentPreviousNode).end.index) {
                parser.state.leadingComments.splice(j, 1);
                j--;
              }
            }

            if (parser.state.leadingComments.length > 0) {
              firstChild.trailingComments = parser.state.leadingComments;
              parser.state.leadingComments = [];
            }
          }
        }
      } else if (node.type === 'CallExpression' &&
      node.arguments &&
      node.arguments.length) {
        const lastArg = ___$$priv$romejs$js_parser$src$parser$comments_ts$last(node.arguments);

        if (lastArg !== undefined &&
        parser.getLoc(lastComment).start.index >=
        parser.getLoc(lastArg).start.index &&
        parser.getLoc(lastComment).end.index <= parser.getLoc(node).end.index) {
          if (parser.state.commentPreviousNode) {
            if (parser.state.leadingComments.length > 0) {
              lastArg.trailingComments = parser.state.leadingComments;
              parser.state.leadingComments = [];
            }
          }
        }
      }
    }

    if (lastChild) {
      const lastLeadingComments = lastChild.leadingComments;
      if (lastLeadingComments !== undefined) {
        if (lastChild !== node &&
        lastLeadingComments.length > 0 &&
        parser.getLoc(___$$priv$romejs$js_parser$src$parser$comments_ts$last(lastLeadingComments)).end.index <=
        parser.getLoc(node).start.index) {
          node.leadingComments = lastLeadingComments;
          lastChild.leadingComments = undefined;
        } else {
          for (i = lastLeadingComments.length - 2; i >= 0; --i) {
            if (parser.getLoc(lastLeadingComments[i]).end.index <=
            parser.getLoc(node).start.index) {
              node.leadingComments = lastLeadingComments.splice(0, i + 1);
              break;
            }
          }
        }
      }
    } else if (parser.state.leadingComments.length > 0) {
      if (parser.getLoc(___$$priv$romejs$js_parser$src$parser$comments_ts$last(parser.state.leadingComments)).end.index <=
      parser.getLoc(node).start.index) {
        if (parser.state.commentPreviousNode) {
          for (j = 0; j < parser.state.leadingComments.length; j++) {
            if (parser.getLoc(parser.state.leadingComments[j]).end.index <
            parser.getLoc(parser.state.commentPreviousNode).end.index) {
              parser.state.leadingComments.splice(j, 1);
              j--;
            }
          }
        }
        if (parser.state.leadingComments.length > 0) {
          node.leadingComments = parser.state.leadingComments;
          parser.state.leadingComments = [];
        }
      } else {
        for (i = 0; i < parser.state.leadingComments.length; i++) {
          if (parser.getLoc(parser.state.leadingComments[i]).end.index >
          parser.getLoc(node).start.index) {
            break;
          }
        }

        const leadingComments = parser.state.leadingComments.slice(0, i);
        node.leadingComments =
        leadingComments.length === 0 ? null : leadingComments;

        trailingComments = parser.state.leadingComments.slice(i);
        if (trailingComments.length === 0) {
          trailingComments = undefined;
        }
      }
    }

    parser.state.commentPreviousNode = node;

    if (trailingComments) {
      if (trailingComments.length > 0 &&
      parser.getLoc(trailingComments[0]).start.index >=
      parser.getLoc(node).start.index &&
      parser.getLoc(___$$priv$romejs$js_parser$src$parser$comments_ts$last(trailingComments)).end.index <=
      parser.getLoc(node).end.index) {
        node.innerComments = trailingComments;
      } else {
        node.trailingComments = trailingComments;
      }
    }

    stack.push(node);
  }

  // romejs/js-parser/src/parser/expression.ts

  const ___$romejs$js_parser$src$parser$expression_ts = {
    checkPropClash: ___$romejs$js_parser$src$parser$expression_ts$checkPropClash,
    parseExpression: ___$romejs$js_parser$src$parser$expression_ts$parseExpression,
    parseMaybeAssign: ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign,
    parseMaybeConditional: ___$romejs$js_parser$src$parser$expression_ts$parseMaybeConditional,
    tryParseConditionalConsequent: ___$romejs$js_parser$src$parser$expression_ts$tryParseConditionalConsequent,
    parseConditional: ___$romejs$js_parser$src$parser$expression_ts$parseConditional,
    forwardNoArrowParamsConversionAt: ___$romejs$js_parser$src$parser$expression_ts$forwardNoArrowParamsConversionAt,
    parseExpressionOps: ___$romejs$js_parser$src$parser$expression_ts$parseExpressionOps,
    parseExpressionOp: ___$romejs$js_parser$src$parser$expression_ts$parseExpressionOp,
    parseMaybeUnary: ___$romejs$js_parser$src$parser$expression_ts$parseMaybeUnary,
    parseExpressionWithPossibleSubscripts: ___$romejs$js_parser$src$parser$expression_ts$parseExpressionWithPossibleSubscripts,
    parseSubscripts: ___$romejs$js_parser$src$parser$expression_ts$parseSubscripts,
    parseExpressionSubscript: ___$romejs$js_parser$src$parser$expression_ts$parseExpressionSubscript,
    parseTaggedTemplateExpression: ___$romejs$js_parser$src$parser$expression_ts$parseTaggedTemplateExpression,
    checkYieldAwaitInDefaultParams: ___$romejs$js_parser$src$parser$expression_ts$checkYieldAwaitInDefaultParams,
    atPossibleAsync: ___$romejs$js_parser$src$parser$expression_ts$atPossibleAsync,
    validateCallExpression: ___$romejs$js_parser$src$parser$expression_ts$validateCallExpression,
    parseCallExpressionArguments: ___$romejs$js_parser$src$parser$expression_ts$parseCallExpressionArguments,
    shouldParseAsyncArrow: ___$romejs$js_parser$src$parser$expression_ts$shouldParseAsyncArrow,
    parseAsyncArrowFromCallExpression: ___$romejs$js_parser$src$parser$expression_ts$parseAsyncArrowFromCallExpression,
    parseNoCallExpr: ___$romejs$js_parser$src$parser$expression_ts$parseNoCallExpr,
    parseExpressionAtom: ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom,
    parseBooleanLiteral: ___$romejs$js_parser$src$parser$expression_ts$parseBooleanLiteral,
    parseMaybePrivateName: ___$romejs$js_parser$src$parser$expression_ts$parseMaybePrivateName,
    parseFunctionExpressionOrMetaProperty: ___$romejs$js_parser$src$parser$expression_ts$parseFunctionExpressionOrMetaProperty,
    parseMetaProperty: ___$romejs$js_parser$src$parser$expression_ts$parseMetaProperty,
    parseImportMetaProperty: ___$romejs$js_parser$src$parser$expression_ts$parseImportMetaProperty,
    parseParenExpression: ___$romejs$js_parser$src$parser$expression_ts$parseParenExpression,
    parseParenAndDistinguishExpression: ___$romejs$js_parser$src$parser$expression_ts$parseParenAndDistinguishExpression,
    shouldParseArrow: ___$romejs$js_parser$src$parser$expression_ts$shouldParseArrow,
    parseArrowHead: ___$romejs$js_parser$src$parser$expression_ts$parseArrowHead,
    parseParenItem: ___$romejs$js_parser$src$parser$expression_ts$parseParenItem,
    parseNew: ___$romejs$js_parser$src$parser$expression_ts$parseNew,
    parseTemplateElement: ___$romejs$js_parser$src$parser$expression_ts$parseTemplateElement,
    parseTemplate: ___$romejs$js_parser$src$parser$expression_ts$parseTemplate,
    parseObjectExpression: ___$romejs$js_parser$src$parser$expression_ts$parseObjectExpression,
    parseObjectPattern: ___$romejs$js_parser$src$parser$expression_ts$parseObjectPattern,
    isGetterOrSetterMethod: ___$romejs$js_parser$src$parser$expression_ts$isGetterOrSetterMethod,
    checkGetterSetterParamCount: ___$romejs$js_parser$src$parser$expression_ts$checkGetterSetterParamCount,
    getGetterSetterExpectedParamCount: ___$romejs$js_parser$src$parser$expression_ts$getGetterSetterExpectedParamCount,
    parseObjectMethod: ___$romejs$js_parser$src$parser$expression_ts$parseObjectMethod,
    parseObjectProperty: ___$romejs$js_parser$src$parser$expression_ts$parseObjectProperty,
    parseObjectPropertyValue: ___$romejs$js_parser$src$parser$expression_ts$parseObjectPropertyValue,
    parsePropertyName: ___$romejs$js_parser$src$parser$expression_ts$parsePropertyName,
    parseMethod: ___$romejs$js_parser$src$parser$expression_ts$parseMethod,
    parseArrowExpression: ___$romejs$js_parser$src$parser$expression_ts$parseArrowExpression,
    normalizeArrowFunctionParameters: ___$romejs$js_parser$src$parser$expression_ts$normalizeArrowFunctionParameters,
    isStrictBody: ___$romejs$js_parser$src$parser$expression_ts$isStrictBody,
    parseFunctionBodyAndFinish: ___$romejs$js_parser$src$parser$expression_ts$parseFunctionBodyAndFinish,
    parseFunctionBody: ___$romejs$js_parser$src$parser$expression_ts$parseFunctionBody,
    checkFunctionNameAndParams: ___$romejs$js_parser$src$parser$expression_ts$checkFunctionNameAndParams,
    parseExpressionList: ___$romejs$js_parser$src$parser$expression_ts$parseExpressionList,
    parseExpressionListItem: ___$romejs$js_parser$src$parser$expression_ts$parseExpressionListItem,
    parseIdentifier: ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier,
    createIdentifier: ___$romejs$js_parser$src$parser$expression_ts$createIdentifier,
    parseIdentifierName: ___$romejs$js_parser$src$parser$expression_ts$parseIdentifierName,
    checkReservedWord: ___$romejs$js_parser$src$parser$expression_ts$checkReservedWord,
    parseAwait: ___$romejs$js_parser$src$parser$expression_ts$parseAwait,
    parseYield: ___$romejs$js_parser$src$parser$expression_ts$parseYield,
    parseStringLiteral: ___$romejs$js_parser$src$parser$expression_ts$parseStringLiteral};
  function ___$$priv$romejs$js_parser$src$parser$expression_ts$partition(list, test) {
    const accepted = [];
    const rejected = [];
    for (let i = 0; i < list.length; i++) {
      const item = list[i];
      if (test(item, i, list)) {
        accepted.push(item);
      } else {
        rejected.push(item);
      }
    }
    return [accepted, rejected];
  }

  function ___$romejs$js_parser$src$parser$expression_ts$checkPropClash(parser, prop, props) {
    if (prop.computed || prop.kind || parser.getExtra(prop, 'shorthand')) {
      return undefined;
    }

    const key = prop.key;

    const name = key.type === 'Identifier' ? key.name : String(key.value);

    if (name === '__proto__') {
      if (props.has('proto')) {
        parser.addDiagnostic({
          message: 'Redefinition of __proto__ property',
          loc: key.loc});
      } else {
        props.add('proto');
      }
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, context, noIn, refShorthandDefaultPos) {
    const startPos = parser.state.startPos;
    const expr = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, context, noIn, refShorthandDefaultPos);
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
      const expressions = [expr];
      while (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        expressions.push(
        ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, context, noIn, refShorthandDefaultPos));
      }
      ___$romejs$js_parser$src$parser$lval_ts$toReferencedList(parser, expressions);
      return {
        loc: parser.finishLoc(startPos),
        type: 'SequenceExpression',
        expressions: expressions};
    }
    return expr;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, context, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
    const branches = parser.createBranch();

    if ((parser.isRelational('<') || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagStart)) &&
    parser.shouldTokenizeJSX()) {
      branches.add(
      () => {
        return ___$$priv$romejs$js_parser$src$parser$expression_ts$_parseMaybeAssign(
        parser,
        context,
        noIn,
        refShorthandDefaultPos,
        afterLeftParse,
        refNeedsArrowPos);
      },
      {diagnosticsPriority: 1});

      const cLength = parser.state.context.length;
      if (parser.state.context[cLength - 1] === ___$romejs$js_parser$src$tokenizer$context_ts$types.jsxOpenTag) {
        parser.state.context.length -= 2;
      }
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.relational, '<');
    }

    if (parser.isRelational('<')) {
      branches.add(() => {
        const start = parser.getPosition();
        const typeParameters = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeParameters(parser);
        const arrowExpression = ___$romejs$js_parser$src$parser$expression_ts$forwardNoArrowParamsConversionAt(
        parser,
        start,
        () => ___$$priv$romejs$js_parser$src$parser$expression_ts$_parseMaybeAssign(
        parser,
        context,
        noIn,
        refShorthandDefaultPos,
        afterLeftParse,
        refNeedsArrowPos));
        parser.resetStartLocationFromNode(arrowExpression, typeParameters);

        if (arrowExpression.type === 'ArrowFunctionExpression') {
          return Object.assign({}, arrowExpression, {
            typeParameters: typeParameters});
        } else {
          parser.addDiagnostic({
            loc: typeParameters.loc,
            message: 'Expected an arrow function after this type parameter declaration'});
          return parser.createUnknownNode('type params without arrow function');
        }
      });
    }

    branches.add(() => {
      return ___$$priv$romejs$js_parser$src$parser$expression_ts$_parseMaybeAssign(
      parser,
      context,
      noIn,
      refShorthandDefaultPos,
      afterLeftParse,
      refNeedsArrowPos);
    });

    return branches.pick();
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$_parseMaybeAssign(parser, context, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
    const startPos = parser.state.startPos;

    if (parser.isContextual('yield')) {
      if (parser.inScope('GENERATOR')) {
        let left = ___$romejs$js_parser$src$parser$expression_ts$parseYield(parser, noIn);
        if (afterLeftParse) {
          left = afterLeftParse(parser, left, startPos);
        }
        return left;
      } else {
        parser.state.exprAllowed = false;
      }
    }

    const oldCommaAfterSpreadAt = parser.state.commaAfterSpreadAt;
    parser.state.commaAfterSpreadAt = -1;

    let failOnShorthandAssign;
    if (refShorthandDefaultPos) {
      failOnShorthandAssign = false;
    } else {
      refShorthandDefaultPos = {index: 0};
      failOnShorthandAssign = true;
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
      parser.state.potentialArrowAt = parser.state.startPos.index;
    }

    let left = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeConditional(
    parser,
    context,
    noIn,
    refShorthandDefaultPos,
    refNeedsArrowPos);
    if (afterLeftParse) {
      left = afterLeftParse(parser, left, startPos);
    }

    if (parser.state.tokenType.isAssign) {
      const operator = String(parser.state.tokenValue);
      left = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eq) ? ___$romejs$js_parser$src$parser$lval_ts$toAssignable(parser, left, undefined, 'assignment expression') : left;

      refShorthandDefaultPos.index = 0;

      ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, left, undefined, undefined, 'assignment expression');

      if (left.type === 'ArrayPattern' || left.type === 'ObjectPattern') {
        ___$romejs$js_parser$src$parser$lval_ts$checkCommaAfterRestFromSpread(parser);
      }

      parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

      parser.next();
      const right = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'assignment right', noIn);
      return {
        loc: parser.finishLoc(startPos),
        type: 'AssignmentExpression',

        operator: operator,
        left: left,
        right: right};
    } else if (failOnShorthandAssign && refShorthandDefaultPos.index > 0) {
      parser.unexpectedToken(
      parser.getPositionFromIndex(refShorthandDefaultPos.index));
    }

    parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

    return left;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseMaybeConditional(parser, context, noIn, refShorthandDefaultPos, refNeedsArrowPos) {
    const startPos = parser.state.startPos;
    const potentialArrowAt = parser.state.potentialArrowAt;
    const expr = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionOps(
    parser,
    context,
    noIn,
    refShorthandDefaultPos);

    if (expr.type === 'ArrowFunctionExpression' &&
    parser.getLoc(expr).start.index === potentialArrowAt) {
      return expr;
    }

    if (refShorthandDefaultPos && refShorthandDefaultPos.index > 0) {
      return expr;
    }

    return ___$romejs$js_parser$src$parser$expression_ts$parseConditional(parser, expr, noIn, startPos, refNeedsArrowPos);
  }

  function ___$romejs$js_parser$src$parser$expression_ts$tryParseConditionalConsequent(parser) {
    const brancher = parser.createBranch();

    brancher.add(() => {
      parser.state.noArrowParamsConversionAt.push(parser.state.startPos.index);
      const consequent = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'conditional consequent');
      parser.state.noArrowParamsConversionAt.pop();
      return {
        consequent: consequent,
        failed: !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)};
    });

    return brancher.pick();
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$getArrowLikeExpressions(parser, node, disallowInvalid = false) {
    const stack = [node];
    const arrows = [];

    while (stack.length > 0) {
      const node = stack.pop();
      if (node.type === 'ArrowFunctionExpression') {
        if (node.typeParameters || !node.returnType) {
          ___$romejs$js_parser$src$parser$lval_ts$toAssignableList(
          parser,

          node.params,
          true,
          'arrow function parameters');

          ___$romejs$js_parser$src$parser$expression_ts$checkFunctionNameAndParams(parser, node, true, true);
        } else {
          arrows.push(node);
        }
        stack.push(node.body);
      } else if (node.type === 'ConditionalExpression') {
        stack.push(node.consequent);
        stack.push(node.alternate);
      }
    }

    if (disallowInvalid) {
      for (let i = 0; i < arrows.length; i++) {
        ___$romejs$js_parser$src$parser$lval_ts$toAssignableList(parser, node.params, true, 'arrow function parameters');
      }
      return [arrows, []];
    }

    return ___$$priv$romejs$js_parser$src$parser$expression_ts$partition(arrows, node => {
      const branches = parser.createBranch();

      branches.add(
      () => {
        ___$romejs$js_parser$src$parser$lval_ts$toAssignableList(
        parser,
        node.params,
        true,
        'arrow function parameters');
      },
      {maxNewDiagnostics: 0});

      return branches.hasBranch();
    });
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseConditional(parser, expr, noIn, startPos, refNeedsArrowPos) {
    if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.question)) {
      return expr;
    }

    if (refNeedsArrowPos) {
      const branch = parser.createBranch();

      branch.add(() => ___$$priv$romejs$js_parser$src$parser$expression_ts$_parseConditional(parser, expr, noIn, startPos), {
        maxNewDiagnostics: 0});

      if (branch.hasBranch()) {
        return branch.pick();
      } else {
        refNeedsArrowPos.index = parser.state.startPos.index;
        return expr;
      }
    }

    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.question);
    const originalNoArrowAt = parser.state.noArrowAt;
    const origState = parser.cloneState();
    let {consequent: consequent, failed: failed} = ___$romejs$js_parser$src$parser$expression_ts$tryParseConditionalConsequent(parser);
    let [valid, invalid] = ___$$priv$romejs$js_parser$src$parser$expression_ts$getArrowLikeExpressions(parser, consequent);

    if (failed || invalid.length > 0) {
      const noArrowAt = [...originalNoArrowAt];

      if (invalid.length > 0) {
        parser.state = origState;
        parser.state.noArrowAt = noArrowAt;

        for (let i = 0; i < invalid.length; i++) {
          noArrowAt.push(parser.getLoc(invalid[i]).start.index);
        }

        ({consequent: consequent, failed: failed} = ___$romejs$js_parser$src$parser$expression_ts$tryParseConditionalConsequent(parser));
        [valid, invalid] = ___$$priv$romejs$js_parser$src$parser$expression_ts$getArrowLikeExpressions(parser, consequent);
      }

      if (failed && valid.length > 1) {
        parser.addDiagnostic({
          message: 'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.'});
      }

      if (failed && valid.length === 1) {
        parser.state = origState;
        parser.state.noArrowAt = noArrowAt.concat(
        parser.getLoc(valid[0]).start.index);
        ({consequent: consequent, failed: failed} = ___$romejs$js_parser$src$parser$expression_ts$tryParseConditionalConsequent(parser));
      }

      ___$$priv$romejs$js_parser$src$parser$expression_ts$getArrowLikeExpressions(parser, consequent, true);
    }

    parser.state.noArrowAt = originalNoArrowAt;

    if (!parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      parser.addDiagnostic({
        message: 'Missing conditional expression consequent separator'});
    }

    const alternate = ___$romejs$js_parser$src$parser$expression_ts$forwardNoArrowParamsConversionAt(parser, startPos, () => ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(
    parser,
    'conditional alternate',
    noIn,
    undefined,
    undefined,
    undefined));

    return {
      loc: parser.finishLoc(startPos),
      type: 'ConditionalExpression',
      test: expr,
      consequent: consequent,
      alternate: alternate};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$forwardNoArrowParamsConversionAt(parser, start, parse) {
    if (parser.state.noArrowParamsConversionAt.indexOf(start.index) !== -1) {
      let result;
      parser.state.noArrowParamsConversionAt.push(parser.state.startPos.index);
      result = parse();
      parser.state.noArrowParamsConversionAt.pop();
      return result;
    } else {
      return parse();
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$_parseConditional(parser, expr, noIn, startPos) {
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.question)) {
      const test = expr;
      const consequent = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'conditional consequent');
      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
      const alternate = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'conditional alternate', noIn);
      return {
        loc: parser.finishLoc(startPos),
        type: 'ConditionalExpression',
        test: test,
        consequent: consequent,
        alternate: alternate};
    }
    return expr;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseExpressionOps(parser, context, noIn, refShorthandDefaultPos) {
    const startPos = parser.state.startPos;
    const potentialArrowAt = parser.state.potentialArrowAt;
    const expr = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeUnary(parser, context, refShorthandDefaultPos);

    if (expr.type === 'ArrowFunctionExpression' &&
    parser.getLoc(expr).start.index === potentialArrowAt) {
      return expr;
    }
    if (refShorthandDefaultPos && refShorthandDefaultPos.index > 0) {
      return expr;
    }

    return ___$romejs$js_parser$src$parser$expression_ts$parseExpressionOp(parser, context, expr, startPos, -1, noIn);
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseExpressionOp(parser, context, left, leftStartPos, minPrec, noIn = false) {
    if (___$romejs$js_parser$src$tokenizer$types_ts$types._in.getBinop() > minPrec &&
    !parser.hasPrecedingLineBreak() &&
    parser.isContextual('as')) {
      const _const = ___$romejs$js_parser$src$parser$typescript_ts$tryTSNextParseConstantContext(parser);

      let typeAnnotation;
      if (_const) {
        ___$romejs$js_parser$src$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, left);
        typeAnnotation = _const;
      } else {
        typeAnnotation = ___$romejs$js_parser$src$parser$typescript_ts$tsNextThenParseType(parser);
      }

      const node = {
        type: 'TSAsExpression',
        loc: parser.finishLoc(leftStartPos),
        typeAnnotation: typeAnnotation,
        expression: left};

      return ___$romejs$js_parser$src$parser$expression_ts$parseExpressionOp(
      parser,
      context,
      node,
      leftStartPos,
      minPrec,
      noIn);
    }

    const prec = parser.state.tokenType.binop;
    if (prec !== undefined && (!noIn || !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._in))) {
      if (prec > minPrec) {
        const operator = String(parser.state.tokenValue);

        if (operator === '**' &&
        left.type === 'UnaryExpression' &&
        !parser.isParenthesized(left)) {
          parser.addDiagnostic({
            loc: left.argument.loc,
            message: 'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.'});
        }

        const op = parser.state.tokenType;
        parser.next();

        const startPos = parser.state.startPos;

        const right = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionOp(
        parser,
        context,
        ___$romejs$js_parser$src$parser$expression_ts$parseMaybeUnary(parser, context),
        startPos,
        op.rightAssociative ? prec - 1 : prec,
        noIn);

        let node;
        if (operator === '||' || operator === '&&' || operator === '??') {
          node = {
            loc: parser.finishLoc(leftStartPos),
            type: 'LogicalExpression',
            left: left,
            right: right,
            operator: operator};
        } else {
          node = {
            loc: parser.finishLoc(leftStartPos),
            type: 'BinaryExpression',
            left: left,
            right: right,
            operator: operator};
        }

        return ___$romejs$js_parser$src$parser$expression_ts$parseExpressionOp(
        parser,
        context,
        node,
        leftStartPos,
        minPrec,
        noIn);
      }
    }

    return left;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseMaybeUnary(parser, context, refShorthandDefaultPos) {
    if (parser.isSyntaxEnabled('ts') &&
    !parser.isSyntaxEnabled('jsx') &&
    parser.isRelational('<')) {
      return ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAssertion(parser);
    }

    if (parser.isContextual('await') && parser.inScope('ASYNC')) {
      return ___$romejs$js_parser$src$parser$expression_ts$parseAwait(parser);
    }

    if (parser.state.tokenType.prefix) {
      const start = parser.getPosition();
      const update = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.incDec);
      const operator = String(parser.state.tokenValue);
      const prefix = true;

      parser.next();

      const argument = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeUnary(parser, context);

      if (refShorthandDefaultPos && refShorthandDefaultPos.index > 0) {
        parser.unexpectedToken(
        parser.getPositionFromIndex(refShorthandDefaultPos.index));
      }

      if (update) {
        ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, argument, undefined, undefined, 'prefix operation');
      } else if (parser.inScope('STRICT') && operator === 'delete') {
        if (argument.type === 'Identifier') {
          parser.addDiagnostic({
            loc: argument.loc,
            message: 'Deleting local variable in strict mode'});
        } else if (argument.type === 'MemberExpression' &&
        argument.property.type === 'PrivateName') {
          parser.addDiagnostic({
            loc: argument.property.loc,
            message: 'Deleting a private field is not allowed'});
        }
      }

      let node;
      if (update) {
        ___$romejs$invariant$src$index_ts$default(
        operator === '++' || operator === '--',
        'Expected ++/-- operator only for UpdateExpression');
        node = {
          loc: parser.finishLoc(start),
          type: 'UpdateExpression',
          argument: argument,
          operator: operator,
          prefix: prefix};
      } else {
        ___$romejs$invariant$src$index_ts$default(
        operator !== '++' && operator !== '--',
        'BinaryExpression cannot have ++/-- operator');
        node = {
          loc: parser.finishLoc(start),
          type: 'UnaryExpression',
          argument: argument,

          operator: operator,
          prefix: prefix};
      }

      return node;
    }

    const startPos = parser.state.startPos;

    let expr = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionWithPossibleSubscripts(
    parser,
    context,
    refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.index > 0) {
      return expr;
    }

    while (parser.state.tokenType.postfix && !parser.canInsertSemicolon()) {
      const operator = parser.state.tokenValue;
      ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, expr, undefined, undefined, 'postfix operation');
      parser.next();
      expr = {
        loc: parser.finishLoc(startPos),
        type: 'UpdateExpression',
        operator: operator,
        prefix: false,
        argument: expr};
    }

    return expr;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseExpressionWithPossibleSubscripts(parser, context, refShorthandDefaultPos) {
    const startPos = parser.state.startPos;
    const potentialArrowAt = parser.state.potentialArrowAt;
    const expr = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, context, refShorthandDefaultPos);

    if (expr.type === 'ArrowFunctionExpression' &&
    parser.getLoc(expr).start.index === potentialArrowAt) {
      return expr;
    }

    if (refShorthandDefaultPos && refShorthandDefaultPos.index > 0) {
      return expr;
    }

    return ___$romejs$js_parser$src$parser$expression_ts$parseSubscripts(parser, expr, startPos);
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseSubscripts(parser, base, startPos, noCalls) {
    const maybeAsyncArrow = ___$romejs$js_parser$src$parser$expression_ts$atPossibleAsync(parser, base);

    if (base.type === 'Identifier' &&
    base.name === 'async' &&
    parser.state.noArrowAt.includes(startPos.index)) {
      const openContext = parser.expectOpening(
      ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
      ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
      'call arguments');
      const callee = base;
      const args = ___$romejs$js_parser$src$parser$expression_ts$parseCallExpressionArguments(
      parser,
      callee,
      openContext,
      false);
      base = {
        type: 'CallExpression',
        loc: parser.finishLoc(startPos),
        callee: callee,
        arguments: args};
    } else if (base.type === 'Identifier' &&
    base.name === 'async' &&
    parser.isRelational('<')) {
      const branch = parser.createBranch();
      branch.add(() => ___$romejs$js_parser$src$parser$flow_ts$parseAsyncArrowWithFlowTypeParameters(parser, startPos));
      branch.add(() => ___$$priv$romejs$js_parser$src$parser$expression_ts$parseExpressionSubscriptsRecursively(
      parser,
      base,
      startPos,
      noCalls,
      maybeAsyncArrow));
      return branch.pick();
    }

    return ___$$priv$romejs$js_parser$src$parser$expression_ts$parseExpressionSubscriptsRecursively(
    parser,
    base,
    startPos,
    noCalls,
    maybeAsyncArrow);
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$parseExpressionSubscriptsRecursively(parser, base, startPos, noCalls, maybeAsyncArrow) {
    const state = {
      optionalChainMember: false,
      stop: false};
    do {
      base = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionSubscript(
      parser,
      base,
      startPos,
      noCalls,
      state,
      maybeAsyncArrow);
    } while (!state.stop);
    return base;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseExpressionSubscript(parser, base, startPos, noCalls = false, state, maybeAsyncArrow) {
    if (!parser.hasPrecedingLineBreak() && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bang)) {
      parser.state.exprAllowed = false;
      parser.next();

      return {
        type: 'TSNonNullExpression',
        loc: parser.finishLoc(startPos),
        expression: base};
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.questionDot)) {
      state.optionalChainMember = true;

      if (noCalls && parser.lookaheadState().tokenType == ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) {
        state.stop = true;
        return base;
      }

      parser.next();

      if (parser.isRelational('<')) {
        if (noCalls) {
          state.stop = true;
          return base;
        }

        const callee = base;
        const typeArguments = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeCallArguments(parser);
        const openContext = parser.expectOpening(
        ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
        ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
        'call arguments');
        const args = ___$romejs$js_parser$src$parser$expression_ts$parseCallExpressionArguments(
        parser,
        callee,
        openContext,
        false);
        return {
          loc: parser.finishLoc(startPos),
          type: 'OptionalCallExpression',
          arguments: args,
          callee: callee,
          typeArguments: typeArguments};
      }

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL)) {
        const openContext = parser.expectOpening(
        ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL,
        ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR,
        'computed property');
        const object = base;
        const property = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(
        parser,
        'optional member expression property');
        const computed = true;
        parser.expectClosing(openContext);
        return {
          loc: parser.finishLoc(startPos),
          type: 'OptionalMemberExpression',
          object: object,
          property: property,
          computed: computed};
      }

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
        const openContext = parser.expectOpening(
        ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
        ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
        'call arguments');
        const callee = base;
        const args = ___$romejs$js_parser$src$parser$expression_ts$parseCallExpressionArguments(
        parser,
        callee,
        openContext,
        maybeAsyncArrow);

        return {
          loc: parser.finishLoc(startPos),
          type: 'OptionalCallExpression',
          callee: callee,
          arguments: args};
      }

      const object = base;
      const property = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);
      const computed = false;
      return {
        loc: parser.finishLoc(startPos),
        type: 'OptionalMemberExpression',
        object: object,
        property: property,
        computed: computed};
    }

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.dot)) {
      const object = base;
      const property = ___$romejs$js_parser$src$parser$expression_ts$parseMaybePrivateName(parser);
      const computed = false;

      return {
        loc: parser.finishLoc(startPos),
        type: 'MemberExpression',
        object: object,
        property: property,
        computed: computed};
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL)) {
      const openContext = parser.expectOpening(
      ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL,
      ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR,
      'computed property');
      const object = base;
      const property = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(
      parser,
      'member expression computed property');
      const computed = true;
      parser.expectClosing(openContext);

      return {
        loc: parser.finishLoc(startPos),
        type: 'MemberExpression',
        object: object,
        property: property,
        computed: computed};
    }

    if (parser.isRelational('<') && ___$romejs$js_parser$src$parser$type_systems_ts$isTypeSystemEnabled(parser)) {
      const possibleCallExpression = parser.tryBranch(() => {
        const typeArguments = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeCallArguments(parser);

        if (!noCalls && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
          const openContext = parser.expectOpening(
          ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
          ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
          'call arguments');
          const args = ___$romejs$js_parser$src$parser$expression_ts$parseCallExpressionArguments(
          parser,
          base,
          openContext,
          false);
          return {
            loc: parser.finishLoc(startPos),
            type: 'CallExpression',
            arguments: args,
            callee: base,
            typeArguments: typeArguments};
        }

        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.backQuote)) {
          return ___$romejs$js_parser$src$parser$expression_ts$parseTaggedTemplateExpression(
          parser,
          startPos,
          base,
          state,
          typeArguments);
        }
      });

      if (possibleCallExpression !== undefined) {
        return possibleCallExpression;
      }
    }

    if (!noCalls && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
      const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
      const oldYieldPos = parser.state.yieldPos;
      const oldAwaitPos = parser.state.awaitPos;
      parser.state.maybeInArrowParameters = true;
      parser.state.yieldPos = 0;
      parser.state.awaitPos = 0;

      const openContext = parser.expectOpening(
      ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
      ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
      'call arguments');
      const callee = base;

      const oldCommaAfterSpreadAt = parser.state.commaAfterSpreadAt;
      parser.state.commaAfterSpreadAt = -1;

      const args = ___$romejs$js_parser$src$parser$expression_ts$parseCallExpressionArguments(
      parser,
      callee,
      openContext,
      maybeAsyncArrow);

      if (maybeAsyncArrow && ___$romejs$js_parser$src$parser$expression_ts$shouldParseAsyncArrow(parser)) {
        state.stop = true;

        ___$romejs$js_parser$src$parser$lval_ts$checkCommaAfterRestFromSpread(parser);

        const node = ___$romejs$js_parser$src$parser$expression_ts$parseAsyncArrowFromCallExpression(parser, startPos, args);
        ___$romejs$js_parser$src$parser$expression_ts$checkYieldAwaitInDefaultParams(parser);
        parser.state.yieldPos = oldYieldPos;
        parser.state.awaitPos = oldAwaitPos;
        return node;
      } else {
        ___$romejs$js_parser$src$parser$lval_ts$toReferencedListDeep(parser, args);

        parser.state.yieldPos = oldYieldPos || parser.state.yieldPos;
        parser.state.awaitPos = oldAwaitPos || parser.state.awaitPos;
      }

      parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

      ___$romejs$js_parser$src$parser$expression_ts$validateCallExpression(parser, callee, args);

      return {
        type: 'CallExpression',
        loc: parser.finishLoc(startPos),
        callee: callee,
        arguments: args};
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.backQuote)) {
      return ___$romejs$js_parser$src$parser$expression_ts$parseTaggedTemplateExpression(parser, startPos, base, state);
    }

    state.stop = true;
    return base;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseTaggedTemplateExpression(parser, startPos, tag, state, typeArguments) {
    if (state.optionalChainMember) {
      parser.addDiagnostic({
        message: 'Tagged Template Literals are not allowed in optionalChain'});
    }

    const quasi = ___$romejs$js_parser$src$parser$expression_ts$parseTemplate(parser, true);
    return {
      loc: parser.finishLoc(startPos),
      type: 'TaggedTemplateExpression',
      tag: tag,
      quasi: quasi,
      typeArguments: typeArguments};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$checkYieldAwaitInDefaultParams(parser) {
    if (parser.state.yieldPos > 0 &&
    (parser.state.awaitPos === 0 ||
    parser.state.yieldPos < parser.state.awaitPos)) {
      parser.addDiagnostic({
        index: parser.state.yieldPos,
        message: 'Yield cannot be used as name inside a generator function'});
    }

    if (parser.state.awaitPos > 0) {
      parser.addDiagnostic({
        index: parser.state.awaitPos,
        message: 'Await cannot be used as name inside an async function'});
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$atPossibleAsync(parser, base) {
    const loc = parser.getLoc(base);
    return base.type === 'Identifier' &&
    base.name === 'async' &&
    parser.state.lastEndPos.index === loc.end.index &&
    !parser.canInsertSemicolon() &&
    parser.getRawInput(loc.start.index, loc.end.index) === 'async';
  }

  function ___$romejs$js_parser$src$parser$expression_ts$validateCallExpression(parser, callee, args) {
    if (callee.type === 'Import') {
      if (args.length !== 1) {
        parser.addDiagnostic({
          loc: callee.loc,
          message: 'import() requires exactly one argument'});
      }

      const importArg = args[0];
      if (importArg && importArg.type === 'SpreadElement') {
        parser.addDiagnostic({
          loc: importArg.loc,
          message: 'Spread is not allowed in import()'});
      }
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseCallExpressionArguments(parser, callee, openContext, possibleAsyncArrow, refTrailingCommaPos) {
    const elts = [];
    let innerParenStart;
    let first = true;

    while (true) {
      if (parser.match(openContext.close) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (!parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
          break;
        }

        if (parser.eat(openContext.close)) {
          if (callee.type === 'Import') {
            parser.addDiagnostic({
              start: parser.state.lastStartPos,
              end: parser.state.lastEndPos,
              message: 'Trailing comma is disallowed inside import(...) arguments'});
          }

          break;
        }
      }

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) && !innerParenStart) {
        innerParenStart = parser.state.startPos;
      }

      const elt = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionListItem(
      parser,
      'call expression argument',
      false,
      possibleAsyncArrow ? {index: 0} : undefined,
      possibleAsyncArrow ? {index: 0} : undefined,
      possibleAsyncArrow ? refTrailingCommaPos : undefined);
      ___$romejs$invariant$src$index_ts$default(elt !== undefined, 'expected element');
      elts.push(elt);
    }

    if (possibleAsyncArrow &&
    innerParenStart !== undefined &&
    ___$romejs$js_parser$src$parser$expression_ts$shouldParseAsyncArrow(parser)) {
      parser.addDiagnostic({
        start: innerParenStart,
        message: 'Inner paren inside of an async arrow function params'});
    }

    return elts;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$shouldParseAsyncArrow(parser) {
    return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon) ||
    parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.arrow) && !parser.canInsertSemicolon();
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseAsyncArrowFromCallExpression(parser, start, args) {
    let returnType;

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
      parser.state.noAnonFunctionType = true;
      returnType = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotation(parser);
      parser.state.noAnonFunctionType = oldNoAnonFunctionType;
    }

    const oldYield = parser.state.yieldInPossibleArrowParameters;
    parser.state.yieldInPossibleArrowParameters = undefined;
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.arrow);
    const node = ___$romejs$js_parser$src$parser$expression_ts$parseArrowExpression(parser, start, args, true);
    parser.state.yieldInPossibleArrowParameters = oldYield;
    return Object.assign({}, node, {
      returnType: returnType});
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseNoCallExpr(parser, context) {
    const startPos = parser.state.startPos;
    return ___$romejs$js_parser$src$parser$expression_ts$parseSubscripts(
    parser,
    ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, context),
    startPos,
    true);
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, context, refShorthandDefaultPos) {
    if (parser.state.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.slash) {
      ___$romejs$js_parser$src$tokenizer$index_ts$readRegexp(parser);
    }

    const canBeArrow = parser.state.potentialArrowAt === parser.state.startPos.index;

    if (parser.isRelational('<') &&
    parser.input.charCodeAt(parser.state.index) !== ___$romejs$string_charcodes$src$index_ts$exclamationMark) {
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagStart);
      return ___$romejs$js_parser$src$parser$jsx_ts$parseJSXElement(parser);
    }

    switch (parser.state.tokenType) {
      case ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxText:
        return ___$romejs$js_parser$src$parser$jsx_ts$parseJSXText(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagStart:
        return ___$romejs$js_parser$src$parser$jsx_ts$parseJSXElement(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._super:
        return ___$$priv$romejs$js_parser$src$parser$expression_ts$parseSuper(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._import:
        return ___$$priv$romejs$js_parser$src$parser$expression_ts$parseImportOrMetaProperty(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._this:
        {
          const start = parser.getPosition();
          parser.next();
          return {
            type: 'ThisExpression',
            loc: parser.finishLoc(start)};
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.name:
        {
          const start = parser.getPosition();
          const containsEsc = parser.state.escapePosition !== undefined;
          const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);

          if (!containsEsc &&
          id.name === 'async' &&
          parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._function) &&
          !parser.canInsertSemicolon()) {
            parser.next();
            return ___$romejs$js_parser$src$parser$statement_ts$parseFunction(parser, {
              start: start,
              isStatement: false,
              isAsync: true});
          }

          if (canBeArrow &&
          !containsEsc &&
          id.name === 'async' &&
          parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
            const oldYield = parser.state.yieldInPossibleArrowParameters;
            parser.state.yieldInPossibleArrowParameters = undefined;
            const params = [___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser)];
            parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.arrow);

            const node = ___$romejs$js_parser$src$parser$expression_ts$parseArrowExpression(parser, start, params, true);
            parser.state.yieldInPossibleArrowParameters = oldYield;
            return node;
          }

          if (canBeArrow && !parser.canInsertSemicolon() && parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.arrow)) {
            const oldYield = parser.state.yieldInPossibleArrowParameters;
            parser.state.yieldInPossibleArrowParameters = undefined;
            const node = ___$romejs$js_parser$src$parser$expression_ts$parseArrowExpression(parser, start, [id]);
            parser.state.yieldInPossibleArrowParameters = oldYield;
            return node;
          }

          return id;
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._do:
        return ___$$priv$romejs$js_parser$src$parser$expression_ts$parseDoExpression(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.regexp:
        return ___$$priv$romejs$js_parser$src$parser$expression_ts$parseRegExpLiteral(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.num:
        return ___$$priv$romejs$js_parser$src$parser$expression_ts$parseNumericLiteral(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.bigint:
        return ___$$priv$romejs$js_parser$src$parser$expression_ts$parseBigIntLiteral(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.string:
        return ___$romejs$js_parser$src$parser$expression_ts$parseStringLiteral(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._null:
        return ___$$priv$romejs$js_parser$src$parser$expression_ts$parseNullLiteral(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._true:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._false:
        return ___$romejs$js_parser$src$parser$expression_ts$parseBooleanLiteral(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL:
        return ___$romejs$js_parser$src$parser$expression_ts$parseParenAndDistinguishExpression(parser, context, canBeArrow);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL:
        return ___$$priv$romejs$js_parser$src$parser$expression_ts$parseArrayExpression(parser, refShorthandDefaultPos);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL:
        return ___$romejs$js_parser$src$parser$expression_ts$parseObjectExpression(parser, refShorthandDefaultPos);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._function:
        return ___$romejs$js_parser$src$parser$expression_ts$parseFunctionExpressionOrMetaProperty(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._class:
        {
          const start = parser.getPosition();
          return ___$romejs$js_parser$src$parser$classes_ts$parseClass(parser, start, false);
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._new:
        return ___$romejs$js_parser$src$parser$expression_ts$parseNew(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.backQuote:
        return ___$romejs$js_parser$src$parser$expression_ts$parseTemplate(parser, false);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.doubleColon:
        {
          const start = parser.getPosition();
          parser.next();
          const object = undefined;
          const callee = ___$romejs$js_parser$src$parser$expression_ts$parseNoCallExpr(parser, context);

          if (callee.type === 'MemberExpression') {
            return {
              loc: parser.finishLoc(start),
              type: 'BindExpression',
              object: object,
              callee: callee};
          } else {
            parser.addDiagnostic({
              loc: callee.loc,
              message: 'Binding should be performed on object property.'});
            return parser.createUnknownNode(
            'bind expression non-member callee',
            start);
          }
        }

      default:
        {
          const start = parser.getPosition();
          parser.addDiagnostic({
            message: `Unknown start to an ${context}`});
          parser.next();
          return parser.createUnknownNode(context, start);
        }}
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseBooleanLiteral(parser) {
    const start = parser.getPosition();
    const value = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._true);
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'BooleanLiteral',
      value: value};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseMaybePrivateName(parser) {
    const isPrivate = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.hash);

    if (isPrivate) {
      const start = parser.getPosition();
      parser.next();
      parser.assertNoSpace('Unexpected space between # and identifier');
      const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);
      return {
        loc: parser.finishLoc(start),
        type: 'PrivateName',
        id: id};
    } else {
      return ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseFunctionExpressionOrMetaProperty(parser) {
    const start = parser.getPosition();
    parser.next();

    const meta = ___$romejs$js_parser$src$parser$expression_ts$createIdentifier(parser, start, 'function');

    if (parser.inScope('GENERATOR') && parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.dot)) {
      return ___$romejs$js_parser$src$parser$expression_ts$parseMetaProperty(parser, start, meta, 'sent');
    }

    const node = ___$romejs$js_parser$src$parser$statement_ts$parseFunction(parser, {
      start: start,
      isStatement: false});

    if (node.type !== 'FunctionExpression') {
      throw new Error('Expected parseFunction to return a FunctionExpression');
    }

    return node;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseMetaProperty(parser, start, meta, propertyName) {
    if (meta.name === 'function' &&
    propertyName === 'sent' &&
    !parser.isContextual(propertyName)) {
      parser.unexpectedToken();
    }

    const escapePosition = parser.state.escapePosition;
    const property = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);

    if (property.name === propertyName) {
      parser.banUnicodeEscape(escapePosition, propertyName);
    } else {
      parser.addDiagnostic({
        loc: property.loc,
        message: `The only valid meta property for ${meta.name} is ${meta.name}.${propertyName}`});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'MetaProperty',
      meta: meta,
      property: property};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseImportMetaProperty(parser) {
    const start = parser.getPosition();
    const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.dot);
    const node = ___$romejs$js_parser$src$parser$expression_ts$parseMetaProperty(parser, start, id, 'meta');

    if (!parser.inModule) {
      parser.addDiagnostic({
        loc: node.loc,
        message: `import.meta may appear only with 'sourceType: "module"'`});
    }

    return node;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseParenExpression(parser, context) {
    const openContext = parser.expectOpening(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL, ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR, context);
    const val = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, context);
    parser.expectClosing(openContext);
    return val;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseParenAndDistinguishExpression(parser, context, canBeArrow) {
    if (parser.state.noArrowAt.includes(parser.state.startPos.index)) {
      canBeArrow = false;
    }

    const startPos = parser.state.startPos;

    let val;
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
    'paren expression');

    const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    const oldYield = parser.state.yieldInPossibleArrowParameters;
    parser.state.maybeInArrowParameters = true;
    parser.state.yieldInPossibleArrowParameters = undefined;
    parser.state.yieldPos = 0;
    parser.state.awaitPos = 0;

    const innerStart = parser.getPosition();
    let exprList = [];
    const refShorthandDefaultPos = {index: 0};
    const refNeedsArrowPos = {index: 0};
    let first = true;
    let spreadStart;
    let optionalCommaStart;

    while (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenR)) {
      if (first) {
        first = false;
      } else {
        if (!parser.expect(
        ___$romejs$js_parser$src$tokenizer$types_ts$types.comma,
        refNeedsArrowPos.index === 0 ? undefined : parser.getPositionFromIndex(refNeedsArrowPos.index))) {
          break;
        }

        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenR)) {
          optionalCommaStart = parser.state.startPos;
          break;
        }
      }

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
        const spreadNodeStartPos = parser.state.startPos;
        spreadStart = parser.state.startPos;
        exprList.push(
        ___$romejs$js_parser$src$parser$expression_ts$parseParenItem(parser, ___$romejs$js_parser$src$parser$lval_ts$parseRest(parser), spreadNodeStartPos));

        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma) &&
        parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR) {
          ___$romejs$js_parser$src$parser$lval_ts$raiseRestNotLast(parser);
          parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma);
        }
      } else {
        exprList.push(
        ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(
        parser,
        context,
        false,
        refShorthandDefaultPos,
        ___$romejs$js_parser$src$parser$expression_ts$parseParenItem,
        refNeedsArrowPos));
      }
    }

    const innerEnd = parser.getPosition();
    parser.expectClosing(openContext);

    parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;

    const arrowStart = startPos;
    if (canBeArrow && ___$romejs$js_parser$src$parser$expression_ts$shouldParseArrow(parser)) {
      const {valid: valid, returnType: returnType, predicate: predicate} = ___$romejs$js_parser$src$parser$expression_ts$parseArrowHead(parser);

      if (valid) {
        ___$romejs$js_parser$src$parser$expression_ts$checkYieldAwaitInDefaultParams(parser);
        parser.state.yieldPos = oldYieldPos;
        parser.state.awaitPos = oldAwaitPos;

        for (const param of exprList) {
          if (parser.isParenthesized(param)) {
            parser.addDiagnostic({
              loc: param.loc,
              message: 'Function parameters can\'t be parenthesized'});
          }
        }

        const arrow = ___$romejs$js_parser$src$parser$expression_ts$parseArrowExpression(parser, arrowStart, exprList);
        parser.state.yieldInPossibleArrowParameters = oldYield;
        return Object.assign({}, arrow, {
          predicate: predicate,
          returnType: returnType});
      }
    }

    parser.state.yieldInPossibleArrowParameters = oldYield;

    parser.state.yieldPos = oldYieldPos || parser.state.yieldPos;
    parser.state.awaitPos = oldAwaitPos || parser.state.awaitPos;

    if (exprList.length === 0) {
      parser.addDiagnostic({
        start: innerStart,
        end: innerEnd,
        message: 'Parenthesized expression didnt contain anything'});

      exprList.push({
        type: 'Noop',
        loc: parser.finishLocAt(innerStart, innerEnd)});
    }

    if (optionalCommaStart !== undefined) {
      parser.unexpectedToken(optionalCommaStart);
    }

    if (spreadStart !== undefined) {
      parser.unexpectedToken(spreadStart);
    }

    if (refShorthandDefaultPos.index > 0) {
      parser.unexpectedToken(
      parser.getPositionFromIndex(refShorthandDefaultPos.index));
    }

    if (refNeedsArrowPos.index > 0) {
      parser.unexpectedToken(parser.getPositionFromIndex(refNeedsArrowPos.index));
    }

    exprList = ___$romejs$js_parser$src$parser$lval_ts$toReferencedListDeep(
    parser,
    exprList,
    true);

    if (exprList.length > 1) {
      const expressions = ___$romejs$js_parser$src$parser$lval_ts$toReferencedList(parser, exprList);
      val = {
        loc: parser.finishLocAt(innerStart, innerEnd),
        type: 'SequenceExpression',
        expressions: expressions};
    } else {
      val = exprList[0];
    }

    parser.addParenthesized(val);

    return val;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$shouldParseArrow(parser) {
    return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon) || !parser.canInsertSemicolon();
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseArrowHead(parser) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
      parser.state.noAnonFunctionType = true;

      const branch = parser.createBranch();

      branch.add(() => {
        const res = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotationAndPredicate(parser);

        if (parser.canInsertSemicolon()) {
          parser.addDiagnostic({
            message: 'No semicolon insertion expected'});
        }

        if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.arrow)) {
          return res;
        }
      });

      if (branch.hasBranchResult()) {
        const typeInfo = branch.pick();
        parser.state.noAnonFunctionType = oldNoAnonFunctionType;

        if (typeInfo === undefined) {
          throw new Error('hasBranchResult call above should have refined this condition');
        }

        return {
          valid: true,
          predicate: typeInfo[1],
          returnType: typeInfo[0]};
      } else {
        parser.state.noAnonFunctionType = oldNoAnonFunctionType;
        return {
          valid: false,
          predicate: undefined,
          returnType: undefined};
      }
    } else {
      return {
        valid: parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.arrow),
        predicate: undefined,
        returnType: undefined};
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseParenItem(parser, node, startPos) {
    let optional = undefined;
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.question)) {
      optional = true;
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      const typeAnnotation = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotation(parser);
      return {
        loc: parser.finishLoc(startPos),
        type: 'FlowTypeCastExpression',
        expression: node,
        typeAnnotation: typeAnnotation,
        optional: optional};
    }

    if (optional) {
      return Object.assign({}, node, {
        optional: optional});
    } else {
      return node;
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseNew(parser) {
    const start = parser.getPosition();
    const meta = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.dot)) {
      const metaProp = ___$romejs$js_parser$src$parser$expression_ts$parseMetaProperty(parser, start, meta, 'target');

      if (!parser.inScope('NON_ARROW_FUNCTION') &&
      !parser.inScope('CLASS_PROPERTY')) {
        parser.addDiagnostic({
          loc: metaProp.loc,
          message: 'new.target can only be used in functions or class properties'});
      }

      return metaProp;
    }

    const callee = ___$romejs$js_parser$src$parser$expression_ts$parseNoCallExpr(parser, 'new callee');

    if (callee.type === 'Import') {
      parser.addDiagnostic({
        loc: callee.loc,
        message: 'Cannot use new with import(...)'});
    }

    const optionalMember = ___$$priv$romejs$js_parser$src$parser$expression_ts$getFirstOptionalChainMember(callee);
    if (optionalMember !== undefined) {
      const memberLoc = parser.getLoc(optionalMember);

      parser.addDiagnostic({
        message: 'constructors in/after an Optional Chain are not allowed',
        advice: [{
          type: 'log',
          category: 'info',
          message: 'Optional chain member responsible'}, {
          type: 'frame',
          filename: parser.filename,
          start: memberLoc.start,
          end: memberLoc.end}]});
    }

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.questionDot)) {
      parser.addDiagnostic({
        message: 'constructors in/after an Optional Chain are not allowed'});
    }

    let optional = undefined;
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.questionDot)) {
      optional = true;
    }

    let typeArguments = undefined;
    if (___$romejs$js_parser$src$parser$type_systems_ts$isTypeSystemEnabled(parser) && parser.isRelational('<')) {
      typeArguments = parser.tryBranch(___$romejs$js_parser$src$parser$type_systems_ts$parseTypeCallArguments);
    }

    let args = [];
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
      const openContext = parser.expectOpening(
      ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
      ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
      'new argument');
      args = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionList(parser, 'new expression argument', openContext);
      ___$romejs$js_parser$src$parser$lval_ts$toReferencedList(parser, args);
    } else if (parser.isSyntaxEnabled('ts') && typeArguments !== undefined) {
      parser.addDiagnostic({
        message: 'In TypeScript, a new expression with type arguments must have parens'});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'NewExpression',
      callee: callee,
      typeArguments: typeArguments,
      arguments: args,
      optional: optional};
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$getFirstOptionalChainMember(node) {
    if (node.type === 'OptionalMemberExpression' ||
    node.type === 'OptionalCallExpression') {
      return node;
    }

    if (node.type === 'MemberExpression' && node.computed !== true) {
      return ___$$priv$romejs$js_parser$src$parser$expression_ts$getFirstOptionalChainMember(node.object);
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseTemplateElement(parser, isTagged) {
    const start = parser.getPosition();
    const tokenValue = parser.state.tokenValue;

    if (tokenValue === undefined) {
      if (isTagged) {
        parser.state.invalidTemplateEscapePosition = undefined;
      } else {
        parser.addDiagnostic({
          index: parser.state.invalidTemplateEscapePosition || 0,
          message: 'Invalid escape sequence in template'});
      }
    }

    const raw = parser.getRawInput(parser.state.startPos.index, parser.state.endPos.index).replace(/\r\n?/g, '\n');
    const cooked = tokenValue === undefined ? raw : String(tokenValue);

    parser.next();
    const tail = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.backQuote);
    return {
      loc: parser.finishLoc(start),
      type: 'TemplateElement',
      raw: raw,
      cooked: cooked,
      tail: tail};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseTemplate(parser, isTagged) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.backQuote,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.backQuote,
    'template literal');
    const expressions = [];
    let curElt = ___$romejs$js_parser$src$parser$expression_ts$parseTemplateElement(parser, isTagged);
    const quasis = [curElt];

    while (true) {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof) || curElt.tail === true) {
        break;
      }

      const exprPpenContext = parser.expectOpening(
      ___$romejs$js_parser$src$tokenizer$types_ts$types.dollarBraceL,
      ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
      'template expression value');
      expressions.push(___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'template expression value'));
      parser.expectClosing(exprPpenContext);

      curElt = ___$romejs$js_parser$src$parser$expression_ts$parseTemplateElement(parser, isTagged);
      quasis.push(curElt);
    }

    parser.expectClosing(openContext);

    return {
      loc: parser.finishLoc(start),
      type: 'TemplateLiteral',
      expressions: expressions,
      quasis: quasis};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseObjectExpression(parser, refShorthandDefaultPos) {
    const propHash = new Set();
    let first = true;

    const start = parser.getPosition();
    const properties = [];

    const openContext = parser.expectOpening(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL, ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR, 'object');

    while (true) {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (!parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
          break;
        }

        if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
        const prop = Object.assign({}, ___$romejs$js_parser$src$parser$lval_ts$parseSpread(parser), {
          type: 'SpreadProperty'});
        properties.push(prop);
        continue;
      }

      const start = parser.getPosition();
      let isGenerator = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.star);
      let isAsync = false;

      let key;
      let computed;
      let variance;
      let escapePosition;

      if (parser.isContextual('async')) {
        if (isGenerator) {
          parser.unexpectedToken();
        }

        const asyncId = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon) ||
        parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) ||
        parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR) ||
        parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eq) ||
        parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
          key = asyncId;
          computed = false;
        } else {
          if (parser.hasPrecedingLineBreak()) {
            parser.addDiagnostic({
              message: 'There shouldn\'t be any newlines between async and the rest of the function'});
          }

          isAsync = true;
          if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.star)) {
            parser.next();
            isGenerator = true;
          }
          escapePosition = parser.state.escapePosition;
          ({computed: computed, key: key, variance: variance} = ___$romejs$js_parser$src$parser$expression_ts$parsePropertyName(parser));
        }
      } else {
        escapePosition = parser.state.escapePosition;
        ({computed: computed, key: key, variance: variance} = ___$romejs$js_parser$src$parser$expression_ts$parsePropertyName(parser));
      }

      const prop = ___$romejs$js_parser$src$parser$expression_ts$parseObjectPropertyValue(parser, {
        name: {
          computed: computed,
          key: key,
          variance: variance},
        start: start,
        isGenerator: isGenerator,
        isAsync: isAsync,
        isPattern: false,
        refShorthandDefaultPos: refShorthandDefaultPos,
        escapePosition: escapePosition});
      if (prop.type === 'Unknown') {
        continue;
      }

      ___$romejs$js_parser$src$parser$expression_ts$checkPropClash(parser, prop, propHash);
      properties.push(prop);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'ObjectExpression',
      properties: properties};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseObjectPattern(parser, refShorthandDefaultPos) {
    const propHash = new Set();
    let first = true;

    const start = parser.getPosition();
    const properties = [];

    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
    'object pattern');

    let firstRestLocation = undefined;

    while (true) {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR)) {
        break;
      }

      if (first) {
        first = false;
      } else {
        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma);

        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      let isGenerator = false;
      let isAsync = false;
      let start = parser.getPosition();

      if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
        const argument = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);

        const prop = {
          type: 'RestProperty',
          loc: parser.finishLoc(start),
          argument: argument};

        properties.push(___$romejs$js_parser$src$parser$lval_ts$toAssignable(parser, prop, true, 'object pattern'));

        if (firstRestLocation !== undefined) {
          parser.addDiagnostic({
            loc: prop.loc,
            message: 'Cannot have multiple rest elements when destructuring'});
        }

        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
          break;
        }

        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma) &&
        parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR) {
          parser.addDiagnostic({
            message: 'A trailing comma is not permitted after the rest element'});
          parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma);
          break;
        } else {
          firstRestLocation = prop.loc;
          continue;
        }
      }

      start = parser.getPosition();

      const {computed: computed, key: key, variance: variance} = ___$romejs$js_parser$src$parser$expression_ts$parsePropertyName(parser);

      const prop = ___$romejs$js_parser$src$parser$expression_ts$parseObjectPropertyValue(parser, {
        name: {
          computed: computed,
          key: key,
          variance: variance},
        start: start,
        isGenerator: isGenerator,
        isAsync: isAsync,
        isPattern: true,
        refShorthandDefaultPos: refShorthandDefaultPos,
        escapePosition: undefined});

      if (prop.type === 'Unknown') {
        continue;
      }

      ___$romejs$js_parser$src$parser$expression_ts$checkPropClash(parser, prop, propHash);

      if (prop.type !== 'ObjectProperty') {
        throw new Error(`Should have already been validated but got ${prop.type}`);
      }

      properties.push(prop);
    }

    parser.expectClosing(openContext);

    if (firstRestLocation !== undefined) {
      ___$romejs$js_parser$src$parser$lval_ts$raiseRestNotLast(parser, firstRestLocation);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'ObjectPattern',
      properties: properties};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$isGetterOrSetterMethod(parser, name, isPattern) {
    return !isPattern &&
    name.computed !== true &&
    name.key.type === 'Identifier' &&
    (name.key.name === 'get' || name.key.name === 'set') &&
    (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string) ||
    parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.num) ||
    parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL) ||
    parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name) ||
    !!parser.state.tokenType.keyword);
  }

  function ___$romejs$js_parser$src$parser$expression_ts$checkGetterSetterParamCount(parser, method, kind) {
    const paramCount = ___$romejs$js_parser$src$parser$expression_ts$getGetterSetterExpectedParamCount(parser, method, kind);

    if (method.params.length !== paramCount) {
      if (kind === 'get') {
        parser.addDiagnostic({
          loc: method.loc,
          message: 'getter should have no params'});
      } else {
        parser.addDiagnostic({
          loc: method.loc,
          message: 'setter should have exactly one param'});
      }
    }

    if (kind === 'set') {
      const lastParam = method.params[method.params.length - 1];
      if (lastParam !== undefined && ___$romejs$js_parser$src$parser$lval_ts$isRestLike(lastParam)) {
        parser.addDiagnostic({
          loc: lastParam.loc,
          message: 'setter function argument must not be a rest parameter'});
      }
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$getGetterSetterExpectedParamCount(parser, method, kind) {
    const baseCount = kind === 'get' ? 0 : 1;

    const firstParam = method.params[0];
    const hasContextParam = firstParam !== undefined &&
    firstParam.type === 'Identifier' &&
    firstParam.name === 'this';

    return hasContextParam ? baseCount + 1 : baseCount;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseObjectMethod(parser, {
    name: name,
    start: start,
    isGenerator: isGenerator,
    isAsync: isAsync,
    isPattern: isPattern,
    escapePosition: escapePosition}) {
    if (isAsync || isGenerator || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
      if (isPattern) {
        parser.addDiagnostic({
          message: 'Object methods aren\'t allowed in object patterns'});
      }

      const partial = ___$romejs$js_parser$src$parser$expression_ts$parseMethod(parser, {
        kind: 'method',
        isClass: false,
        isGenerator: isGenerator,
        isAsync: isAsync,
        isConstructor: false});
      ___$romejs$invariant$src$index_ts$default(partial.body !== undefined, 'Expected body');

      return Object.assign({}, partial, {
        loc: parser.finishLoc(start)}, name, {
        type: 'ObjectMethod',
        kind: 'method'});
    }

    if (___$romejs$js_parser$src$parser$expression_ts$isGetterOrSetterMethod(parser, name, isPattern)) {
      if (isAsync) {
        parser.addDiagnostic({
          message: 'An object setter/getter can\'t be async'});
      }

      if (isGenerator) {
        parser.addDiagnostic({
          message: 'An object setter/getter can\'t be a generator'});
      }

      const kind = name.key.name;
      ___$romejs$invariant$src$index_ts$default(
      kind === 'get' || kind === 'set',
      'name should be get or set as we already validated it as such');
      parser.banUnicodeEscape(escapePosition, kind);

      const methodName = ___$romejs$js_parser$src$parser$expression_ts$parsePropertyName(parser);

      const partial = ___$romejs$js_parser$src$parser$expression_ts$parseMethod(parser, {
        kind: kind,
        isClass: false,
        isGenerator: false,
        isAsync: false,
        isConstructor: false});
      ___$romejs$invariant$src$index_ts$default(partial.body !== undefined, 'Expected body');

      const method = Object.assign({}, partial, {
        loc: parser.finishLoc(start)}, methodName, {
        type: 'ObjectMethod',
        kind: kind});
      ___$romejs$js_parser$src$parser$expression_ts$checkGetterSetterParamCount(parser, method, method.kind);
      return method;
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseObjectProperty(parser, name, start, isPattern, refShorthandDefaultPos) {
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      const value = isPattern ? ___$romejs$js_parser$src$parser$lval_ts$parseMaybeDefault(parser) : ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(
      parser,
      'object property value',
      false,
      refShorthandDefaultPos);

      return Object.assign({
        loc: parser.finishLoc(start)}, name, {
        type: 'ObjectProperty',
        value: value});
    }

    if (name.computed !== true && name.key.type === 'Identifier') {
      ___$romejs$js_parser$src$parser$expression_ts$checkReservedWord(
      parser,
      name.key.name,
      parser.getLoc(name.key),
      true,
      true);

      let shorthand = false;
      let value;
      if (isPattern) {
        value = ___$romejs$js_parser$src$parser$lval_ts$parseMaybeDefault(parser, start, parser.cloneNode(name.key));
      } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eq) && refShorthandDefaultPos) {
        if (refShorthandDefaultPos.index === 0) {
          refShorthandDefaultPos.index = parser.state.startPos.index;
        }
        value = ___$romejs$js_parser$src$parser$lval_ts$parseMaybeDefault(parser, start, parser.cloneNode(name.key));
      } else {
        value = parser.cloneNode(name.key);
        shorthand = true;
      }

      const node = Object.assign({
        loc: parser.finishLoc(start)}, name, {
        type: 'ObjectProperty',
        value: value});

      if (shorthand) {
        parser.addExtra(node, 'shorthand', shorthand);
      }

      return node;
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseObjectPropertyValue(parser, {
    name: name,
    start: start,
    isGenerator: isGenerator,
    isAsync: isAsync,
    isPattern: isPattern,
    refShorthandDefaultPos: refShorthandDefaultPos,
    escapePosition: escapePosition}) {
    if (name.variance !== undefined) {
      parser.addDiagnostic({
        loc: name.variance.loc,
        message: 'variance not allowed here'});
    }

    let typeParameters = ___$romejs$js_parser$src$parser$type_systems_ts$maybeParseTypeParameters(parser);
    if (typeParameters !== undefined && !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
      parser.unexpectedToken();
    }

    let node = ___$romejs$js_parser$src$parser$expression_ts$parseObjectMethod(parser, {
      name: name,
      start: start,
      isGenerator: isGenerator,
      isAsync: isAsync,
      isPattern: isPattern,
      escapePosition: escapePosition}) ||
    ___$romejs$js_parser$src$parser$expression_ts$parseObjectProperty(parser, name, start, isPattern, refShorthandDefaultPos);

    if (node === undefined) {
      parser.unexpectedToken();
      node = parser.createUnknownNode('object property value', start);
    }

    if (typeParameters) {
      return Object.assign({}, node, {
        typeParameters: typeParameters});
    } else {
      return node;
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parsePropertyName(parser) {
    const variance = ___$romejs$js_parser$src$parser$flow_ts$parseFlowVariance(parser);

    let key;
    let computed = false;

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL)) {
      const openContext = parser.expectOpening(
      ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL,
      ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR,
      'property name');
      computed = true;
      key = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'property name');
      parser.expectClosing(openContext);
    } else {
      parser.pushScope('PROPERTY_NAME', true);

      key =
      parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.num) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string) ? ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'property name') : ___$romejs$js_parser$src$parser$expression_ts$parseMaybePrivateName(parser);

      if (key.type !== 'PrivateName') {
        computed = false;
      }

      parser.popScope('PROPERTY_NAME');
    }

    return {key: key, variance: variance, computed: computed};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseMethod(parser, opts) {
    const {kind: kind, isClass: isClass, isGenerator: isGenerator, isAsync: isAsync, isConstructor: isConstructor} = opts;

    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    parser.pushScope('FUNCTION', true);
    parser.pushScope('NON_ARROW_FUNCTION');
    parser.pushScope('METHOD', kind);
    parser.pushScope('GENERATOR', isGenerator);
    parser.state.yieldPos = 0;
    parser.state.awaitPos = 0;

    const allowTSModifiers = isConstructor;
    const {typeParameters: typeParameters, params: params} = ___$romejs$js_parser$src$parser$statement_ts$parseFunctionParams(
    parser,
    kind,
    allowTSModifiers);
    const {body: body, returnType: returnType} = ___$romejs$js_parser$src$parser$expression_ts$parseFunctionBodyAndFinish(parser, {
      allowBodiless: isClass,
      isArrowFunction: false,
      isAsync: isAsync,
      isGenerator: isGenerator,
      isMethod: true,
      id: undefined,
      params: params,
      start: parser.getPosition()});

    parser.popScope('METHOD');
    parser.popScope('GENERATOR');
    parser.popScope('FUNCTION');
    parser.popScope('NON_ARROW_FUNCTION');
    parser.state.yieldPos = oldYieldPos;
    parser.state.awaitPos = oldAwaitPos;

    return {
      generator: isGenerator,
      async: isAsync,
      typeParameters: typeParameters,
      params: params,
      body: body,
      returnType: returnType};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseArrowExpression(parser, start, params, isAsync = false) {
    if (parser.state.yieldInPossibleArrowParameters) {
      parser.addDiagnostic({
        start: parser.state.yieldInPossibleArrowParameters,
        message: 'Yield cannot be used as name inside a generator function'});
    }

    parser.pushScope('FUNCTION', true);

    params = ___$romejs$js_parser$src$parser$expression_ts$normalizeArrowFunctionParameters(parser, start, params);

    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
    parser.pushScope('GENERATOR', false);
    parser.state.maybeInArrowParameters = false;
    parser.state.yieldPos = 0;
    parser.state.awaitPos = 0;

    const body = ___$romejs$js_parser$src$parser$expression_ts$parseFunctionBody(parser, {
      allowBodiless: false,
      isArrowFunction: true,
      isMethod: false,
      isAsync: isAsync,
      isGenerator: false,
      params: params,
      id: undefined,
      start: start});

    parser.popScope('GENERATOR');
    parser.popScope('FUNCTION');
    parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    parser.state.yieldPos = oldYieldPos;
    parser.state.awaitPos = oldAwaitPos;

    return {
      loc: parser.finishLoc(start),
      type: 'ArrowFunctionExpression',
      params: params,
      async: isAsync,
      body: body};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$normalizeArrowFunctionParameters(parser, start, params) {
    if (parser.state.noArrowParamsConversionAt.indexOf(start.index) !== -1) {
      return params;
    } else {
      return ___$romejs$js_parser$src$parser$lval_ts$toAssignableList(parser, params, true, 'arrow function parameters');
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$isStrictBody(parser, body) {
    const isBlockStatement = body.type === 'BlockStatement';

    if (isBlockStatement && body.directives !== undefined) {
      for (const directive of body.directives) {
        if (directive.value.value === 'use strict') {
          return true;
        }
      }
    }

    return false;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseFunctionBodyAndFinish(parser, opts) {
    let returnType = undefined;
    let predicate;

    if (!opts.isArrowFunction && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      [returnType, predicate] = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotationAndPredicate(parser);
    }

    if (opts.allowBodiless &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL) &&
    parser.isLineTerminator()) {
      return {
        predicate: predicate,
        returnType: returnType,
        body: undefined};
    }

    const body = ___$romejs$js_parser$src$parser$expression_ts$parseFunctionBody(parser, opts);
    return {body: body, predicate: predicate, returnType: returnType};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseFunctionBody(parser, opts) {
    if (opts.isArrowFunction) {
      return ___$romejs$js_parser$src$parser$expression_ts$forwardNoArrowParamsConversionAt(parser, opts.start, () => ___$$priv$romejs$js_parser$src$parser$expression_ts$_parseFunctionBody(parser, opts));
    } else {
      return ___$$priv$romejs$js_parser$src$parser$expression_ts$_parseFunctionBody(parser, opts);
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$_parseFunctionBody(parser, opts) {
    const {isArrowFunction: isArrowFunction, isAsync: isAsync, isGenerator: isGenerator} = opts;

    const isExpression = isArrowFunction && !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL);

    parser.pushScope('PARAMETERS', false);
    parser.pushScope('ASYNC', isAsync);

    let body;
    if (isExpression) {
      body = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'function body');
    } else {
      const oldLabels = parser.state.labels;
      parser.pushScope('GENERATOR', isGenerator);

      parser.state.labels = [];

      body = ___$romejs$js_parser$src$parser$statement_ts$parseBlock(parser, true);

      parser.popScope('GENERATOR');

      parser.state.labels = oldLabels;
    }

    parser.popScope('ASYNC');
    ___$romejs$js_parser$src$parser$expression_ts$checkFunctionNameAndParams(parser, opts, body);
    parser.popScope('PARAMETERS');

    let firstDirective;
    if (!___$$priv$romejs$js_parser$src$parser$expression_ts$isSimpleParamList(opts.params) &&
    body.type === 'BlockStatement' &&
    body.directives !== undefined) {
      firstDirective = body.directives[0];
    }

    if (firstDirective !== undefined &&
    firstDirective.value.value === 'use strict') {
      parser.addDiagnostic({
        loc: firstDirective.loc,
        message: 'Illegal \'use strict\' directive in function with non-simple parameter list'});
    }

    return body;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$checkFunctionNameAndParams(parser, opts, body, force) {
    const {isArrowFunction: isArrowFunction, isMethod: isMethod, id: id, params: params, start: start} = opts;

    if (isArrowFunction &&
    force !== true &&
    parser.state.noArrowParamsConversionAt.indexOf(start.index) !== -1) {
      return undefined;
    }

    const _isStrictBody = ___$romejs$js_parser$src$parser$expression_ts$isStrictBody(parser, body);
    const isStrict = parser.inScope('STRICT') || _isStrictBody;

    const isSimpleParams = ___$$priv$romejs$js_parser$src$parser$expression_ts$isSimpleParamList(params);
    const shouldCheckLVal = isStrict || isArrowFunction || isMethod || !isSimpleParams;

    parser.pushScope('STRICT', isStrict);

    if (shouldCheckLVal) {
      const clashes = new Map();

      if (id !== undefined) {
        ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, id, true, undefined, 'function name');
      }

      for (const param of params) {
        if (_isStrictBody && param.type !== 'Identifier') {
          parser.addDiagnostic({
            loc: param.loc,
            message: 'Non-simple parameter in strict mode'});
        }
        ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, param, true, clashes, 'function parameter list');
      }
    }

    parser.popScope('STRICT');
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$isSimpleParamList(params) {
    for (const param of params) {
      if (param.type !== 'Identifier') {
        return false;
      }
    }
    return true;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseExpressionList(parser, context, openContext, allowEmpty, refShorthandDefaultPos) {
    const elts = [];
    let first = true;

    while (true) {
      if (parser.match(openContext.close) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
        break;
      }

      if (first) {
        first = false;
      } else {
        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma);

        if (parser.match(openContext.close)) {
          break;
        }
      }

      elts.push(
      ___$romejs$js_parser$src$parser$expression_ts$parseExpressionListItem(
      parser,
      context,
      allowEmpty,
      refShorthandDefaultPos));
    }

    parser.expectClosing(openContext);

    return elts;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseExpressionListItem(parser, context, maybeAllowEmpty, refShorthandDefaultPos, refNeedsArrowPos, refTrailingCommaPos) {
    const allowEmpty = Boolean(maybeAllowEmpty);
    const start = parser.getPosition();

    let elt;
    if (allowEmpty && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
      elt = undefined;
    } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
      const spreadNodeStart = parser.state.startPos;

      elt = ___$romejs$js_parser$src$parser$expression_ts$parseParenItem(
      parser,
      ___$romejs$js_parser$src$parser$lval_ts$parseSpread(parser, refShorthandDefaultPos, refNeedsArrowPos),
      spreadNodeStart);

      if (refTrailingCommaPos && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        refTrailingCommaPos.index = parser.state.startPos.index;
      }
    } else {
      elt = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(
      parser,
      context,
      false,
      refShorthandDefaultPos,
      ___$romejs$js_parser$src$parser$expression_ts$parseParenItem,
      refNeedsArrowPos);
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      const expression = elt;
      const typeAnnotation = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotation(parser);
      return {
        loc: parser.finishLoc(start),
        type: 'FlowTypeCastExpression',
        expression: expression,
        typeAnnotation: typeAnnotation,
        _exprListItem: true};
    } else {
      return elt;
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, liberal) {
    const start = parser.getPosition();
    const name = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifierName(parser, liberal);
    return ___$romejs$js_parser$src$parser$expression_ts$createIdentifier(parser, start, name);
  }

  function ___$romejs$js_parser$src$parser$expression_ts$createIdentifier(parser, start, name) {
    return {
      type: 'Identifier',
      name: name,
      loc: parser.finishLoc(start)};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseIdentifierName(parser, liberal = false) {
    const loc = parser.finishLocAt(parser.state.startPos, parser.state.endPos);

    if (!liberal) {
      ___$romejs$js_parser$src$parser$expression_ts$checkReservedWord(
      parser,
      String(parser.state.tokenValue),
      loc,
      !!parser.state.tokenType.keyword,
      false);
    }

    let name;

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
      name = String(parser.state.tokenValue);
    } else if (parser.state.tokenType.keyword !== undefined) {
      name = parser.state.tokenType.keyword;

      if ((name === 'class' || name === 'function') &&
      (parser.state.lastEndPos.index !== parser.state.lastStartPos.index + 1 ||
      parser.input.charCodeAt(parser.state.lastStartPos.index) !== ___$romejs$string_charcodes$src$index_ts$dot)) {
        parser.state.context.pop();
      }
    } else {
      parser.addDiagnostic({
        message: 'Expected an identifier here'});
      name = '';
    }

    if (!liberal) {
      ___$romejs$js_parser$src$parser$expression_ts$checkReservedWord(
      parser,
      name,
      loc,
      parser.state.tokenType.keyword !== undefined,
      false);
    }

    parser.next();
    return name;
  }

  function ___$romejs$js_parser$src$parser$expression_ts$checkReservedWord(parser, word, loc, checkKeywords, isBinding) {
    if (parser.isSyntaxEnabled('ts')) {
      return undefined;
    }

    if (parser.inScope('GENERATOR') && word === 'yield') {
      parser.addDiagnostic({
        loc: loc,
        message: 'Can not use \'yield\' as identifier inside a generator'});
    }

    if (parser.inScope('ASYNC') && word === 'await') {
      parser.addDiagnostic({
        loc: loc,
        message: 'Can not use keyword \'await\' outside an async function'});
    }

    if (parser.inScope('CLASS_PROPERTY') && word === 'arguments') {
      parser.addDiagnostic({
        loc: loc,
        message: '\'arguments\' is not allowed in class field initializer'});
    }

    if (checkKeywords && ___$romejs$js_parser_utils$src$identifier_ts$isKeyword(word)) {
      parser.addDiagnostic({
        loc: loc,
        message: `Unexpected keyword '${word}'`});
    }

    let isReserved = false;
    if (parser.inScope('STRICT')) {
      if (isBinding) {
        isReserved = ___$romejs$js_parser_utils$src$identifier_ts$isStrictBindReservedWord(word, parser.inModule);
      } else {
        isReserved = ___$romejs$js_parser_utils$src$identifier_ts$isStrictReservedWord(word, parser.inModule);
      }
    } else {
      isReserved = ___$romejs$js_parser_utils$src$identifier_ts$isReservedWord(word, parser.inModule);
    }

    if (isReserved) {
      if (!parser.inScope('ASYNC') && word === 'await') {
        parser.addDiagnostic({
          loc: loc,
          message: 'Can not use keyword \'await\' outside an async function'});
      } else {
        parser.addDiagnostic({
          loc: loc,
          message: `${word} is a reserved word`});
      }
    }
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseAwait(parser) {
    if (!parser.state.awaitPos) {
      parser.state.awaitPos = parser.state.index;
    }

    if (!parser.inScope('ASYNC')) {
      parser.addDiagnostic({
        message: 'Can\'t use await outside of an async function'});
    }

    const start = parser.getPosition();
    parser.next();

    if (parser.inScope('PARAMETERS')) {
      parser.addDiagnostic({
        message: 'await is not allowed in async function parameters'});
    }

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.star)) {
      parser.addDiagnostic({
        start: start,
        message: 'await* has been removed from the async functions proposal. Use Promise.all() instead.'});
    }

    const argument = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeUnary(parser, 'await argument');
    return {
      type: 'AwaitExpression',
      loc: parser.finishLoc(start),
      argument: argument};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseYield(parser, noIn) {
    if (!parser.state.yieldPos) {
      parser.state.yieldPos = parser.state.index;
    }

    const start = parser.getPosition();

    if (parser.inScope('PARAMETERS')) {
      parser.addDiagnostic({
        start: start,
        message: 'yield is not allowed in generator parameters'});
    }

    if (parser.state.maybeInArrowParameters &&
    parser.state.yieldInPossibleArrowParameters === undefined) {
      parser.state.yieldInPossibleArrowParameters = start;
    }

    parser.next();

    let delegate;
    let argument;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.semi) ||
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.star) && !parser.state.tokenType.startsExpr ||
    parser.canInsertSemicolon()) {
      delegate = false;
      argument = null;
    } else {
      delegate = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.star);
      argument = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'yield argument', noIn);
    }

    return {
      type: 'YieldExpression',
      loc: parser.finishLoc(start),
      delegate: delegate,
      argument: argument};
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$parseNullLiteral(parser) {
    const start = parser.getPosition();
    parser.next();
    return {
      type: 'NullLiteral',
      loc: parser.finishLoc(start)};
  }

  function ___$romejs$js_parser$src$parser$expression_ts$parseStringLiteral(parser) {
    const start = parser.getPosition();
    const value = String(parser.state.tokenValue);
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'StringLiteral',
      value: value};
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$parseBigIntLiteral(parser) {
    const start = parser.getPosition();
    const value = String(parser.state.tokenValue);
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'BigIntLiteral',
      value: value};
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$parseNumericLiteral(parser) {
    const start = parser.getPosition();
    const value = Number(parser.state.tokenValue);
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'NumericLiteral',
      value: value};
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$parseRegExpLiteral(parser) {
    const start = parser.getPosition();
    const value = parser.state.tokenValue;
    if (!(value instanceof ___$romejs$js_parser$src$tokenizer$index_ts$RegExpTokenValue)) {
      throw new Error('Expected regex token value');
    }
    parser.next();

    const {flags: flags} = value;
    return {
      loc: parser.finishLoc(start),
      type: 'RegExpLiteral',
      pattern: value.pattern,
      global: flags.has('g'),
      multiline: flags.has('m'),
      sticky: flags.has('y'),
      insensitive: flags.has('i'),
      noDotNewline: flags.has('s'),
      unicode: flags.has('u')};
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$parseImportOrMetaProperty(parser) {
    if (parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.dot) {
      return ___$romejs$js_parser$src$parser$expression_ts$parseImportMetaProperty(parser);
    }

    const start = parser.getPosition();
    parser.next();
    if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
      parser.unexpectedToken(undefined, ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL);
    }
    return {
      type: 'Import',
      loc: parser.finishLoc(start)};
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$parseSuper(parser) {
    if (!parser.inScope('METHOD') &&
    !parser.inScope('CLASS_PROPERTY') &&
    parser.sourceType !== 'template') {
      parser.addDiagnostic({
        message: 'super is only allowed in object methods and classes'});
    }

    const start = parser.getPosition();
    parser.next();

    if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL) &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.dot)) {
      parser.addDiagnostic({
        message: 'Invalid super suffix operator'});
    }

    const loc = parser.finishLoc(start);

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) &&
    (parser.getLastScope('METHOD') !== 'constructor' ||
    parser.getLastScope('CLASS') !== 'derived') &&
    parser.sourceType !== 'template') {
      parser.addDiagnostic({
        loc: loc,
        message: 'super() is only valid inside a class constructor of a subclass',
        advice: [{
          type: 'log',
          category: 'info',
          message: 'Maybe a typo in the method name (\'constructor\') or not extending another class?'}]});
    }

    return {
      type: 'Super',
      loc: loc};
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$parseDoExpression(parser) {
    const start = parser.getPosition();
    parser.next();
    const oldLabels = parser.state.labels;
    parser.state.labels = [];
    parser.pushScope('FUNCTION', false);
    const body = ___$romejs$js_parser$src$parser$statement_ts$parseBlock(parser, false);
    parser.popScope('FUNCTION');
    parser.state.labels = oldLabels;
    return {
      type: 'DoExpression',
      body: body,
      loc: parser.finishLoc(start)};
  }

  function ___$$priv$romejs$js_parser$src$parser$expression_ts$parseArrayExpression(parser, refShorthandDefaultPos) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL, ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR, 'array');

    let elements = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionList(
    parser,
    'array element',
    openContext,
    true,
    refShorthandDefaultPos);

    if (!parser.state.maybeInArrowParameters) {
      elements = ___$romejs$js_parser$src$parser$lval_ts$toReferencedList(parser, elements);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'ArrayExpression',
      elements: elements};
  }

  // romejs/js-parser/src/parser/lval.ts

  const ___$romejs$js_parser$src$parser$lval_ts = {
    toAssignable: ___$romejs$js_parser$src$parser$lval_ts$toAssignable,
    toAssignableObjectExpressionProp: ___$romejs$js_parser$src$parser$lval_ts$toAssignableObjectExpressionProp,
    toAssignableList: ___$romejs$js_parser$src$parser$lval_ts$toAssignableList,
    toReferencedList: ___$romejs$js_parser$src$parser$lval_ts$toReferencedList,
    toReferencedListDeep: ___$romejs$js_parser$src$parser$lval_ts$toReferencedListDeep,
    parseSpread: ___$romejs$js_parser$src$parser$lval_ts$parseSpread,
    parseRest: ___$romejs$js_parser$src$parser$lval_ts$parseRest,
    parsePattern: ___$romejs$js_parser$src$parser$lval_ts$parsePattern,
    parseBindingList: ___$romejs$js_parser$src$parser$lval_ts$parseBindingList,
    parseBindingListNonEmpty: ___$romejs$js_parser$src$parser$lval_ts$parseBindingListNonEmpty,
    parseAssignableListItem: ___$romejs$js_parser$src$parser$lval_ts$parseAssignableListItem,
    parseAssignableListItemTypes: ___$romejs$js_parser$src$parser$lval_ts$parseAssignableListItemTypes,
    parseMaybeDefault: ___$romejs$js_parser$src$parser$lval_ts$parseMaybeDefault,
    checkLVal: ___$romejs$js_parser$src$parser$lval_ts$checkLVal,
    checkToRestConversion: ___$romejs$js_parser$src$parser$lval_ts$checkToRestConversion,
    hasCommaAfterRest: ___$romejs$js_parser$src$parser$lval_ts$hasCommaAfterRest,
    raiseRestNotLast: ___$romejs$js_parser$src$parser$lval_ts$raiseRestNotLast,
    checkCommaAfterRestFromSpread: ___$romejs$js_parser$src$parser$lval_ts$checkCommaAfterRestFromSpread,
    isRestLike: ___$romejs$js_parser$src$parser$lval_ts$isRestLike};
  const ___$$priv$romejs$js_parser$src$parser$lval_ts$VALID_REST_ARGUMENT_TYPES = ['Identifier', 'MemberExpression'];

  function ___$romejs$js_parser$src$parser$lval_ts$toAssignable(parser, node, isBinding, contextDescription) {
    if (node) {
      switch (node.type) {
        case 'Identifier':
        case 'ObjectPattern':
        case 'ArrayPattern':
        case 'AssignmentPattern':
        case 'RestProperty':
        case 'RestElement':
          break;

        case 'FlowTypeCastExpression':
          return ___$romejs$js_parser$src$parser$lval_ts$toAssignable(
          parser,
          ___$romejs$js_parser$src$parser$type_systems_ts$typeCastToParameter(parser, node),
          isBinding,
          contextDescription);

        case 'TSParameterProperty':
          return ___$romejs$js_parser$src$parser$lval_ts$toAssignable(parser, node, isBinding, contextDescription);

        case 'TSAsExpression':
        case 'TSNonNullExpression':
        case 'TSTypeAssertion':
          return parser.retainParenthesized(node, Object.assign({}, node, {
            expression: ___$romejs$js_parser$src$parser$lval_ts$toAssignable(
            parser,
            node.expression,
            isBinding,
            contextDescription)}));

        case 'ObjectExpression':
          {
            const props = [];
            for (let index = 0; index < node.properties.length; index++) {
              const prop = node.properties[index];
              const isLast = index === node.properties.length - 1;
              props.push(
              ___$romejs$js_parser$src$parser$lval_ts$toAssignableObjectExpressionProp(parser, prop, isBinding, isLast));
            }
            return parser.retainParenthesized(node, {
              type: 'ObjectPattern',
              loc: node.loc,
              properties: props});
          }

        case 'ObjectProperty':
          return parser.retainParenthesized(node, Object.assign({}, node, {
            value: ___$romejs$js_parser$src$parser$lval_ts$toAssignable(
            parser,
            node.value,
            isBinding,
            contextDescription)}));

        case 'SpreadProperty':
          {
            ___$romejs$js_parser$src$parser$lval_ts$checkToRestConversion(parser, node);

            return parser.retainParenthesized(node, {
              type: 'RestProperty',
              loc: node.loc,
              argument: ___$romejs$js_parser$src$parser$lval_ts$toAssignable(
              parser,
              node.argument,
              isBinding,
              contextDescription)});
          }

        case 'SpreadElement':
          {
            ___$romejs$js_parser$src$parser$lval_ts$checkToRestConversion(parser, node);

            return parser.retainParenthesized(node, {
              type: 'RestElement',
              loc: node.loc,
              argument: ___$romejs$js_parser$src$parser$lval_ts$toAssignable(
              parser,
              node.argument,
              isBinding,
              contextDescription)});
          }

        case 'ArrayExpression':
          return parser.retainParenthesized(node, {
            type: 'ArrayPattern',
            loc: node.loc,
            elements: ___$romejs$js_parser$src$parser$lval_ts$toAssignableList(
            parser,
            node.elements,
            isBinding,
            contextDescription)});

        case 'AssignmentExpression':
          {
            if (node.operator !== '=') {
              parser.addDiagnostic({
                loc: parser.getLoc(node.left),
                message: 'Only \'=\' operator can be used for specifying default value.'});
            }

            return parser.retainParenthesized(node, {
              type: 'AssignmentPattern',
              left: node.left,
              right: node.right,
              loc: node.loc});
          }

        default:
          {
            if (node.type === 'MemberExpression' && !isBinding) {
              return node;
            }

            const message = `Invalid left-hand side in ${contextDescription}`;
            parser.addDiagnostic({
              loc: node.loc,
              message: message});
            return parser.createUnknownNode(contextDescription);
          }}
    }

    return node;
  }

  function ___$romejs$js_parser$src$parser$lval_ts$toAssignableObjectExpressionProp(parser, prop, isBinding, isLast) {
    if (prop.type === 'ObjectMethod') {
      const error = prop.kind === 'get' || prop.kind === 'set' ? 'Object pattern can\'t contain getter or setter' : 'Object pattern can\'t contain methods';

      parser.addDiagnostic({
        loc: prop.key.loc,
        message: error});

      return parser.createUnknownNode('object pattern with method');
    } else if (prop.type === 'RestElement') {
      if (!isLast) {
        ___$romejs$js_parser$src$parser$lval_ts$raiseRestNotLast(parser, parser.getLoc(prop));
      }

      return parser.retainParenthesized(prop, Object.assign({
        type: 'RestProperty'}, prop));
    } else {
      return ___$romejs$js_parser$src$parser$lval_ts$toAssignable(
      parser,
      prop,
      isBinding,
      'object destructuring pattern');
    }
  }

  function ___$romejs$js_parser$src$parser$lval_ts$toAssignableList(parser, exprList, isBinding, contextDescription) {
    const newList = [];

    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];
      if (expr === undefined) {
        continue;
      }

      if (expr.type === 'FlowTypeCastExpression' ||
      expr.type === 'TSTypeCastExpression') {
        exprList[i] = ___$romejs$js_parser$src$parser$type_systems_ts$typeCastToParameter(parser, expr);
      }

      if (expr.type === 'TSAsExpression' || expr.type === 'TSTypeAssertion') {
        parser.addDiagnostic({
          loc: expr.loc,
          message: 'Unexpected type cast in parameter position'});
      }
    }

    let end = exprList.length;
    if (end > 0) {
      let last = exprList[end - 1];

      if (last !== undefined && last.type === 'RestElement') {
        newList[end - 1] = last;
        end--;
      }

      if (last !== undefined && last.type === 'SpreadElement') {
        const arg = ___$romejs$js_parser$src$parser$lval_ts$toAssignable(
        parser,
        last.argument,
        isBinding,
        contextDescription);

        newList[end - 1] = parser.retainParenthesized(last, {
          type: 'RestElement',
          argument: arg,
          loc: last.loc});

        if (!['Identifier', 'MemberExpression', 'ArrayPattern', 'ObjectPattern'].includes(arg.type)) {
          parser.unexpectedToken(parser.getLoc(arg).start);
        }

        end--;
      }
    }

    for (let i = 0; i < end; i++) {
      const elt = exprList[i];
      if (elt === undefined) {
        continue;
      }

      if (elt.type === 'SpreadElement' || elt.type === 'RestElement') {
        ___$romejs$js_parser$src$parser$lval_ts$raiseRestNotLast(parser, parser.getLoc(elt));
      }

      newList[i] = ___$romejs$js_parser$src$parser$lval_ts$toAssignable(parser, elt, isBinding, contextDescription);
    }

    return newList;
  }

  function ___$romejs$js_parser$src$parser$lval_ts$toReferencedList(parser, exprList, isParenthesizedExpr) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];
      if (expr &&
      expr.type === 'FlowTypeCastExpression' &&
      !parser.isParenthesized(expr) &&
      (exprList.length > 1 || !isParenthesizedExpr)) {
        parser.addDiagnostic({
          loc: expr.typeAnnotation.loc,
          message: 'The type cast expression is expected to be wrapped with parentheses'});
      }
    }

    return exprList;
  }

  function ___$romejs$js_parser$src$parser$lval_ts$toReferencedListDeep(parser, exprList, isParenthesizedExpr) {
    ___$romejs$js_parser$src$parser$lval_ts$toReferencedList(parser, exprList, isParenthesizedExpr);

    for (const expr of exprList) {
      if (expr && expr.type === 'ArrayExpression') {
        ___$romejs$js_parser$src$parser$lval_ts$toReferencedListDeep(parser, expr.elements);
      }
    }

    return exprList;
  }

  function ___$romejs$js_parser$src$parser$lval_ts$parseSpread(parser, refShorthandDefaultPos, refNeedsArrowPos) {
    const start = parser.getPosition();
    parser.next();

    const argument = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(
    parser,
    'spread argument',
    false,
    refShorthandDefaultPos,
    undefined,
    refNeedsArrowPos);

    if (parser.state.commaAfterSpreadAt === -1 && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
      parser.state.commaAfterSpreadAt = parser.state.index;
    }

    return {
      loc: parser.finishLoc(start),
      type: 'SpreadElement',
      argument: argument};
  }

  function ___$romejs$js_parser$src$parser$lval_ts$parseRest(parser) {
    const start = parser.getPosition();
    parser.next();

    const argument = ___$romejs$js_parser$src$parser$lval_ts$parsePattern(parser);
    return {
      loc: parser.finishLoc(start),
      type: 'RestElement',
      argument: argument};
  }

  function ___$romejs$js_parser$src$parser$lval_ts$parsePattern(parser) {
    switch (parser.state.tokenType) {
      case ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL:
        return ___$$priv$romejs$js_parser$src$parser$lval_ts$parseArrayPattern(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL:
        return ___$romejs$js_parser$src$parser$expression_ts$parseObjectPattern(parser);}

    return ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
  }

  function ___$$priv$romejs$js_parser$src$parser$lval_ts$parseArrayPattern(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR,
    'array pattern');
    const elements = ___$romejs$js_parser$src$parser$lval_ts$parseBindingList(parser, openContext, true);
    return {
      loc: parser.finishLoc(start),
      type: 'ArrayPattern',
      elements: elements};
  }

  function ___$romejs$js_parser$src$parser$lval_ts$parseBindingList(parser, openContext, allowEmpty = false, allowTSModifiers = false) {
    const elts = [];
    let first = true;
    while (true) {
      if (parser.match(openContext.close) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (!parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
          parser.addDiagnostic({
            message: `Expected a comma to separate items in ${openContext.name}`});
          break;
        }
      }

      if (allowEmpty && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        elts.push(undefined);
      } else if (parser.match(openContext.close)) {
        parser.expectClosing(openContext);
        break;
      } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
        elts.push(___$romejs$js_parser$src$parser$lval_ts$parseAssignableListItemTypes(parser, ___$romejs$js_parser$src$parser$lval_ts$parseRest(parser)));

        if (!___$romejs$js_parser$src$parser$lval_ts$hasCommaAfterRest(parser)) {
          parser.expectClosing(openContext);
          break;
        }
      } else {
        elts.push(___$romejs$js_parser$src$parser$lval_ts$parseAssignableListItem(parser, allowTSModifiers));
      }
    }
    return elts;
  }

  function ___$romejs$js_parser$src$parser$lval_ts$parseBindingListNonEmpty(parser, openContext, allowTSModifiers) {
    const list = ___$romejs$js_parser$src$parser$lval_ts$parseBindingList(parser, openContext, false, allowTSModifiers);

    return list;
  }

  function ___$romejs$js_parser$src$parser$lval_ts$parseAssignableListItem(parser, allowTSModifiers) {
    const start = parser.getPosition();

    let accessibility;
    let readonly = false;
    if (allowTSModifiers) {
      accessibility = ___$romejs$js_parser$src$parser$typescript_ts$parseTSAccessModifier(parser);
      readonly = ___$romejs$js_parser$src$parser$typescript_ts$hasTSModifier(parser, ['readonly']);
    }

    const left = ___$romejs$js_parser$src$parser$lval_ts$parseAssignableListItemTypes(parser, ___$romejs$js_parser$src$parser$lval_ts$parseMaybeDefault(parser));
    const elt = ___$romejs$js_parser$src$parser$lval_ts$parseMaybeDefault(parser, start, left);

    if (accessibility !== undefined || readonly) {
      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'Accessibility and readonly syntax found but TS is not enabled'});
      }

      if (elt.type !== 'Identifier' && elt.type !== 'AssignmentPattern') {
        parser.addDiagnostic({
          start: start,
          message: 'A parameter property may not be declared using a binding pattern.'});
      }

      return {
        loc: parser.finishLoc(start),
        type: 'TSParameterProperty',
        parameter: elt,
        accessibility: accessibility,
        readonly: readonly};
    }

    return elt;
  }

  function ___$romejs$js_parser$src$parser$lval_ts$parseAssignableListItemTypes(parser, param) {
    let typeAnnotation;
    let optional;

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.question)) {
      if (param.type !== 'Identifier') {
        parser.addDiagnostic({
          loc: param.loc,
          message: 'A binding pattern parameter cannot be optional in an implementation signature.'});
      }

      optional = true;
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotation(parser);
    }

    return Object.assign({}, param, {
      optional: optional,
      typeAnnotation: typeAnnotation});
  }

  function ___$romejs$js_parser$src$parser$lval_ts$parseMaybeDefault(parser, start = parser.getPosition(), left = ___$romejs$js_parser$src$parser$lval_ts$parsePattern(parser)) {
    let target;

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.eq)) {
      const right = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'assignment pattern right');
      target = {
        loc: parser.finishLoc(start),
        type: 'AssignmentPattern',
        left: left,
        right: right};
    } else {
      target = left;
    }

    if (target.type === 'AssignmentPattern' &&
    target.typeAnnotation &&
    parser.getLoc(target.right).start.index <
    parser.getLoc(target.typeAnnotation).start.index) {
      parser.addDiagnostic({
        loc: target.typeAnnotation.loc,
        message: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`'});
    }

    return target;
  }

  const ___$$priv$romejs$js_parser$src$parser$lval_ts$ALLOWED_PARENTHESIZED_LVAL_TYPES = ['Identifier', 'MemberExpression', 'TSAsExpression', 'TSTypeAssertion'];

  function ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, expr, maybeIsBinding, checkClashes, contextDescription) {
    const isBinding = maybeIsBinding === undefined ? false : maybeIsBinding;

    if (parser.isParenthesized(expr) &&
    !___$$priv$romejs$js_parser$src$parser$lval_ts$ALLOWED_PARENTHESIZED_LVAL_TYPES.includes(expr.type)) {
      let adviceMsg;
      if (expr.type === 'ObjectPattern') {
        adviceMsg = 'Did you use `({a}) = 0` instead of `({a} = 0)`?';
      } else if (expr.type === 'ArrayPattern') {
        adviceMsg = 'Did you use `([a]) = 0` instead of `([a] = 0)`?';
      }
      const advice = [];
      if (adviceMsg !== undefined) {
        advice.push({
          type: 'log',
          category: 'info',
          message: adviceMsg});
      }

      parser.addDiagnostic({
        message: 'Invalid parenthesized binding',
        advice: advice,
        loc: expr.loc});
    }

    switch (expr.type) {
      case 'FlowTypeCastExpression':
        return undefined;

      case 'TSParameterProperty':
        ___$romejs$js_parser$src$parser$lval_ts$checkLVal(
        parser,
        expr.parameter,
        isBinding,
        checkClashes,
        'parameter property');
        return undefined;

      case 'TSAsExpression':
      case 'TSNonNullExpression':
      case 'TSTypeAssertion':
        ___$romejs$js_parser$src$parser$lval_ts$checkLVal(
        parser,
        expr.expression,
        isBinding,
        checkClashes,
        contextDescription);
        return undefined;

      case 'Identifier':
        if (parser.inScope('STRICT') &&
        ___$romejs$js_parser_utils$src$identifier_ts$isStrictBindReservedWord(expr.name, parser.inModule)) {
          parser.addDiagnostic({
            loc: expr.loc,
            message: `${expr.name} is a reserved word`});
        }

        if (checkClashes !== undefined) {
          const clash = checkClashes.get(expr.name);

          if (clash === undefined) {
            checkClashes.set(expr.name, expr);
          } else {
            const loc = parser.getLoc(clash);
            parser.addDiagnostic({
              loc: expr.loc,
              message: 'Argument name clash in strict mode',
              advice: [{
                type: 'log',
                category: 'info',
                message: 'Collides with this existing definition'}, {
                type: 'frame',
                filename: parser.filename,
                start: loc.start,
                end: loc.end}]});
          }
        }
        break;

      case 'MemberExpression':
        if (isBinding) {
          parser.addDiagnostic({
            loc: expr.loc,
            message: 'Binding member expression'});
        }
        break;

      case 'ObjectPattern':
        for (let prop of expr.properties) {
          if (prop.type === 'ObjectProperty') {
            prop = prop.value;
          }
          ___$romejs$js_parser$src$parser$lval_ts$checkLVal(
          parser,
          prop,
          isBinding,
          checkClashes,
          'object destructuring pattern');
        }
        break;

      case 'ArrayPattern':
        for (const elem of expr.elements) {
          if (elem) {
            ___$romejs$js_parser$src$parser$lval_ts$checkLVal(
            parser,
            elem,
            isBinding,
            checkClashes,
            'array destructuring pattern');
          }
        }
        break;

      case 'AssignmentPattern':
        ___$romejs$js_parser$src$parser$lval_ts$checkLVal(
        parser,
        expr.left,
        isBinding,
        checkClashes,
        'assignment pattern');
        break;

      case 'RestElement':
        ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, expr.argument, isBinding, checkClashes, 'rest element');
        break;

      case 'RestProperty':
        ___$romejs$js_parser$src$parser$lval_ts$checkLVal(
        parser,
        expr.argument,
        isBinding,
        checkClashes,
        'rest property');
        break;

      default:
        {
          const messageParts = [isBinding ? 'Binding invalid' : 'Invalid', 'left-hand side', contextDescription ? 'in ' + contextDescription : 'expression'];
          parser.addDiagnostic({
            loc: expr.loc,
            message: messageParts.join(' ')});
        }}
  }

  function ___$romejs$js_parser$src$parser$lval_ts$checkToRestConversion(parser, node) {
    if (___$$priv$romejs$js_parser$src$parser$lval_ts$VALID_REST_ARGUMENT_TYPES.includes(node.argument.type) === false) {
      parser.addDiagnostic({
        loc: node.argument.loc,
        message: 'Invalid rest operator\'s argument'});
    }
  }

  function ___$romejs$js_parser$src$parser$lval_ts$hasCommaAfterRest(parser) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
      ___$romejs$js_parser$src$parser$lval_ts$raiseRestNotLast(parser);
      return true;
    }

    return false;
  }

  function ___$romejs$js_parser$src$parser$lval_ts$raiseRestNotLast(parser, loc, start) {
    parser.addDiagnostic({
      start: start,
      loc: loc,
      message: `The rest element has to be the last element when destructuring`});
  }

  function ___$romejs$js_parser$src$parser$lval_ts$checkCommaAfterRestFromSpread(parser) {
    if (parser.state.commaAfterSpreadAt > -1) {
      ___$romejs$js_parser$src$parser$lval_ts$raiseRestNotLast(
      parser,
      undefined,
      parser.getPositionFromIndex(parser.state.commaAfterSpreadAt));
    }
  }

  function ___$romejs$js_parser$src$parser$lval_ts$isRestLike(node) {
    return node.type === 'TSRestType' ||
    node.type === 'RestElement' ||
    node.type === 'FlowFunctionTypeParamRest';
  }

  // romejs/js-parser/src/parser/statement.ts

  const ___$romejs$js_parser$src$parser$statement_ts = {
    parseTopLevel: ___$romejs$js_parser$src$parser$statement_ts$parseTopLevel,
    parsePossibleInterpreterDirective: ___$romejs$js_parser$src$parser$statement_ts$parsePossibleInterpreterDirective,
    expressionStatementToDirective: ___$romejs$js_parser$src$parser$statement_ts$expressionStatementToDirective,
    isLetStart: ___$romejs$js_parser$src$parser$statement_ts$isLetStart,
    parseStatement: ___$romejs$js_parser$src$parser$statement_ts$parseStatement,
    isAsyncFunctionDeclarationStart: ___$romejs$js_parser$src$parser$statement_ts$isAsyncFunctionDeclarationStart,
    assertModuleNodeAllowed: ___$romejs$js_parser$src$parser$statement_ts$assertModuleNodeAllowed,
    parseBreakContinueStatement: ___$romejs$js_parser$src$parser$statement_ts$parseBreakContinueStatement,
    parseDebuggerStatement: ___$romejs$js_parser$src$parser$statement_ts$parseDebuggerStatement,
    parseDoStatement: ___$romejs$js_parser$src$parser$statement_ts$parseDoStatement,
    parseForStatement: ___$romejs$js_parser$src$parser$statement_ts$parseForStatement,
    assertVarKind: ___$romejs$js_parser$src$parser$statement_ts$assertVarKind,
    parseFunctionStatement: ___$romejs$js_parser$src$parser$statement_ts$parseFunctionStatement,
    parseIfStatement: ___$romejs$js_parser$src$parser$statement_ts$parseIfStatement,
    parseReturnStatement: ___$romejs$js_parser$src$parser$statement_ts$parseReturnStatement,
    parseSwitchStatement: ___$romejs$js_parser$src$parser$statement_ts$parseSwitchStatement,
    parseThrowStatement: ___$romejs$js_parser$src$parser$statement_ts$parseThrowStatement,
    parseTryStatement: ___$romejs$js_parser$src$parser$statement_ts$parseTryStatement,
    parseVarStatement: ___$romejs$js_parser$src$parser$statement_ts$parseVarStatement,
    parseWhileStatement: ___$romejs$js_parser$src$parser$statement_ts$parseWhileStatement,
    parseWithStatement: ___$romejs$js_parser$src$parser$statement_ts$parseWithStatement,
    parseEmptyStatement: ___$romejs$js_parser$src$parser$statement_ts$parseEmptyStatement,
    parseLabeledStatement: ___$romejs$js_parser$src$parser$statement_ts$parseLabeledStatement,
    parseExpressionStatement: ___$romejs$js_parser$src$parser$statement_ts$parseExpressionStatement,
    parseBlock: ___$romejs$js_parser$src$parser$statement_ts$parseBlock,
    isValidDirective: ___$romejs$js_parser$src$parser$statement_ts$isValidDirective,
    parseBlockBody: ___$romejs$js_parser$src$parser$statement_ts$parseBlockBody,
    parseBlockOrModuleBlockBody: ___$romejs$js_parser$src$parser$statement_ts$parseBlockOrModuleBlockBody,
    parseFor: ___$romejs$js_parser$src$parser$statement_ts$parseFor,
    parseForIn: ___$romejs$js_parser$src$parser$statement_ts$parseForIn,
    parseVar: ___$romejs$js_parser$src$parser$statement_ts$parseVar,
    parseVarHead: ___$romejs$js_parser$src$parser$statement_ts$parseVarHead,
    parseFunction: ___$romejs$js_parser$src$parser$statement_ts$parseFunction,
    parseFunctionParams: ___$romejs$js_parser$src$parser$statement_ts$parseFunctionParams};
  const ___$$priv$romejs$js_parser$src$parser$statement_ts$loopLabel = {kind: 'loop'};
  const ___$$priv$romejs$js_parser$src$parser$statement_ts$switchLabel = {kind: 'switch'};

  function ___$romejs$js_parser$src$parser$statement_ts$parseTopLevel(parser) {
    const start = parser.getPosition();
    const openContext = {
      name: 'top-level',
      start: start,
      indent: 0,
      close: ___$romejs$js_parser$src$tokenizer$types_ts$types.eof};

    ___$romejs$js_parser$src$tokenizer$index_ts$nextToken(parser);

    const interpreter = ___$romejs$js_parser$src$parser$statement_ts$parsePossibleInterpreterDirective(parser);
    const {body: body, directives: directives} = ___$romejs$js_parser$src$parser$statement_ts$parseBlockBody(parser, true, true, openContext);

    const loc = parser.finishLoc(start);

    return {
      type: 'Program',
      loc: loc,
      body: body,
      directives: directives,
      diagnostics: parser.getDiagnostics(),
      filename: parser.getFilenameAssert(),
      comments: parser.state.comments,
      sourceType: parser.sourceType,
      interpreter: interpreter,
      syntax: Array.from(parser.syntax)};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parsePossibleInterpreterDirective(parser) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.hash) &&
    parser.input[parser.state.endPos.index] === '!') {
      const comment = ___$romejs$js_parser$src$tokenizer$index_ts$skipLineComment(parser, 2);

      parser.next();

      return {
        type: 'InterpreterDirective',
        value: comment.value,
        loc: comment.loc};
    }
  }

  function ___$romejs$js_parser$src$parser$statement_ts$expressionStatementToDirective(parser, stmt) {
    const expr = stmt.expression;

    const literalStart = parser.getLoc(expr).start;
    const start = parser.getLoc(stmt).start;

    const raw = parser.getRawInput(
    parser.getLoc(expr).start.index,
    parser.getLoc(expr).end.index);
    const val = raw.slice(1, -1);

    const end = parser.getLoc(stmt).end;
    const literalEnd = parser.getLoc(stmt).end;

    return {
      loc: parser.finishLocAt(start, end),
      type: 'Directive',
      value: {
        loc: parser.finishLocAt(literalStart, literalEnd),
        type: 'DirectiveLiteral',
        value: val}};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$isLetStart(parser, context) {
    if (!parser.isContextual('let')) {
      return false;
    }

    ___$romejs$js_parser_utils$src$whitespace_ts$skipWhiteSpace.lastIndex = parser.state.index;
    const skip = ___$romejs$js_parser_utils$src$whitespace_ts$skipWhiteSpace.exec(parser.input);
    if (skip == null) {
      throw new Error('Should never be true');
    }

    const next = parser.state.index + skip[0].length;
    const nextCh = parser.input.charCodeAt(next);

    if (nextCh === ___$romejs$string_charcodes$src$index_ts$leftSquareBracket) {
      return true;
    }

    if (context !== undefined) {
      return false;
    }

    if (nextCh === ___$romejs$string_charcodes$src$index_ts$leftCurlyBrace) {
      return true;
    }

    if (___$romejs$js_parser_utils$src$identifier_ts$isIdentifierStart(nextCh)) {
      let pos = next + 1;
      while (___$romejs$js_parser_utils$src$identifier_ts$isIdentifierChar(parser.input.charCodeAt(pos))) {
        pos++;
      }

      const ident = parser.getRawInput(next, pos);
      if (!___$romejs$js_parser_utils$src$identifier_ts$keywordRelationalOperator.test(ident)) {
        return true;
      }
    }
    return false;
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, context = undefined, topLevel = false) {
    let starttype = parser.state.tokenType;
    const start = parser.getPosition();

    if (starttype === ___$romejs$js_parser$src$tokenizer$types_ts$types._const && parser.isSyntaxEnabled('ts')) {
      const ahead = parser.lookaheadState();
      if (ahead.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.name && ahead.tokenValue === 'enum') {
        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._const);
        parser.expectContextual('enum');
        return ___$romejs$js_parser$src$parser$typescript_ts$parseTSEnumDeclaration(parser, start, true);
      }
    }

    let kind;
    if (___$romejs$js_parser$src$parser$statement_ts$isLetStart(parser, context)) {
      starttype = ___$romejs$js_parser$src$tokenizer$types_ts$types._var;
      kind = 'let';
    }

    switch (starttype) {
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._break:
        return ___$romejs$js_parser$src$parser$statement_ts$parseBreakContinueStatement(parser, start, true);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._continue:
        return ___$romejs$js_parser$src$parser$statement_ts$parseBreakContinueStatement(parser, start, false);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._debugger:
        return ___$romejs$js_parser$src$parser$statement_ts$parseDebuggerStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._do:
        return ___$romejs$js_parser$src$parser$statement_ts$parseDoStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._for:
        return ___$romejs$js_parser$src$parser$statement_ts$parseForStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._function:
        if (parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.dot) {
          break;
        }

        if (context !== undefined) {
          if (parser.inScope('STRICT')) {
            parser.addDiagnostic({
              message: 'In strict mode code, functions can only be declared at top level or inside a block'});
          } else if (context !== 'if' && context !== 'label') {
            parser.addDiagnostic({
              message: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement'});
          }
        }

        const result = ___$romejs$js_parser$src$parser$statement_ts$parseFunctionStatement(parser, start);

        if (context !== undefined && result.generator === true) {
          parser.addDiagnostic({
            message: 'Generators can only be declared at the top level or inside a block',
            loc: result.loc});
        }

        return result;

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._class:
        {
          if (context !== undefined) {
            parser.unexpectedToken();
          }
          const node = ___$romejs$js_parser$src$parser$classes_ts$parseClass(parser, start, true);
          ___$romejs$invariant$src$index_ts$default(
          node.type === 'ClassDeclaration',
          'Should always be a ClassDeclaration because we set isStatement for parseClass');
          return node;
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._if:
        return ___$romejs$js_parser$src$parser$statement_ts$parseIfStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._return:
        return ___$romejs$js_parser$src$parser$statement_ts$parseReturnStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._switch:
        return ___$romejs$js_parser$src$parser$statement_ts$parseSwitchStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._throw:
        return ___$romejs$js_parser$src$parser$statement_ts$parseThrowStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._try:
        return ___$romejs$js_parser$src$parser$statement_ts$parseTryStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._const:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._var:
        kind =
        kind === undefined ? ___$romejs$js_parser$src$parser$statement_ts$assertVarKind(String(parser.state.tokenValue)) : kind;
        if (context !== undefined && kind !== 'var') {
          parser.addDiagnostic({
            message: 'Lexical declaration cannot appear in a single-statement context'});
        }
        return ___$romejs$js_parser$src$parser$statement_ts$parseVarStatement(parser, start, kind);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._while:
        return ___$romejs$js_parser$src$parser$statement_ts$parseWhileStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._with:
        return ___$romejs$js_parser$src$parser$statement_ts$parseWithStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL:
        return ___$romejs$js_parser$src$parser$statement_ts$parseBlock(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.semi:
        return ___$romejs$js_parser$src$parser$statement_ts$parseEmptyStatement(parser, start);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._export:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._import:
        {
          const nextToken = parser.lookaheadState();
          if (nextToken.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL || nextToken.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.dot) {
            break;
          }

          parser.next();

          let result;
          if (starttype == ___$romejs$js_parser$src$tokenizer$types_ts$types._import) {
            result = ___$romejs$js_parser$src$parser$modules_ts$parseImport(parser, start);
          } else {
            result = ___$romejs$js_parser$src$parser$modules_ts$parseExport(parser, start);
          }

          if (!topLevel) {
            parser.addDiagnostic({
              message: '\'import\' and \'export\' may only appear at the top level'});
          }

          ___$romejs$js_parser$src$parser$statement_ts$assertModuleNodeAllowed(parser, result);

          return result;
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.name:
        if (___$romejs$js_parser$src$parser$statement_ts$isAsyncFunctionDeclarationStart(parser)) {
          if (context !== undefined) {
            parser.addDiagnostic({
              message: 'Async functions can only be declared at the top level or inside a block'});
          }

          parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.name);

          parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._function);

          return ___$romejs$js_parser$src$parser$statement_ts$parseFunction(parser, {
            start: start,
            isStatement: true,
            isAsync: true});
        }}

    const maybeName = String(parser.state.tokenValue);
    const expr = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'statement expression');

    if (starttype === ___$romejs$js_parser$src$tokenizer$types_ts$types.name &&
    expr.type === 'Identifier' &&
    parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      return ___$romejs$js_parser$src$parser$statement_ts$parseLabeledStatement(parser, start, maybeName, expr, context);
    } else {
      return ___$romejs$js_parser$src$parser$statement_ts$parseExpressionStatement(parser, start, expr);
    }
  }

  function ___$romejs$js_parser$src$parser$statement_ts$isAsyncFunctionDeclarationStart(parser) {
    if (!parser.isContextual('async')) {
      return false;
    }

    const {input: input} = parser;
    const {index: index} = parser.state;

    ___$romejs$js_parser_utils$src$whitespace_ts$skipWhiteSpace.lastIndex = index;
    const skip = ___$romejs$js_parser_utils$src$whitespace_ts$skipWhiteSpace.exec(input);

    if (!skip || skip.length === 0) {
      return false;
    }

    const next = index + skip[0].length;

    return !___$romejs$js_parser_utils$src$whitespace_ts$lineBreak.test(parser.getRawInput(index, next)) &&
    parser.getRawInput(next, next + 8) === 'function' &&
    (next + 8 === input.length || !___$romejs$js_parser_utils$src$identifier_ts$isIdentifierChar(input.charCodeAt(next + 8)));
  }

  function ___$romejs$js_parser$src$parser$statement_ts$assertModuleNodeAllowed(parser, node) {
    if (node.type === 'ImportDeclaration' &&
    (node.importKind === 'type' || node.importKind === 'typeof') ||
    node.type === 'ExportNamedDeclaration' && node.exportKind === 'type' ||
    node.type === 'ExportAllDeclaration' && node.exportKind === 'type') {
      return undefined;
    }

    if (!parser.inModule) {
      parser.addDiagnostic({
        start: node.start,
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`});
    }
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseBreakContinueStatement(parser, start, isBreak) {
    const keyword = isBreak ? 'break' : 'continue';
    parser.next();

    let label;
    if (parser.isLineTerminator()) {
      label = undefined;
    } else if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
      parser.unexpectedToken();
    } else {
      label = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
      parser.semicolon();
    }

    let i;
    for (i = 0; i < parser.state.labels.length; ++i) {
      const lab = parser.state.labels[i];
      if (label === undefined || lab.name === label.name) {
        if (lab.kind !== undefined && (isBreak || lab.kind === 'loop')) {
          break;
        }

        if (label && isBreak) {
          break;
        }
      }
    }
    if (i === parser.state.labels.length) {
      parser.addDiagnostic({
        start: start,
        message: 'Unsyntactic ' + keyword});
    }

    if (isBreak) {
      return {
        loc: parser.finishLoc(start),
        type: 'BreakStatement',
        label: label};
    } else {
      return {
        loc: parser.finishLoc(start),
        type: 'ContinueStatement',
        label: label};
    }
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseDebuggerStatement(parser, start) {
    parser.next();
    parser.semicolon();
    return {loc: parser.finishLoc(start), type: 'DebuggerStatement'};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseDoStatement(parser, start) {
    parser.next();
    parser.state.labels.push(___$$priv$romejs$js_parser$src$parser$statement_ts$loopLabel);
    const body = ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, 'do');
    parser.state.labels.pop();
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._while);
    const test = ___$romejs$js_parser$src$parser$expression_ts$parseParenExpression(parser, 'do test');
    parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.semi);
    return {
      loc: parser.finishLoc(start),
      type: 'DoWhileStatement',
      body: body,
      test: test};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseForStatement(parser, start) {
    parser.next();
    parser.state.labels.push(___$$priv$romejs$js_parser$src$parser$statement_ts$loopLabel);

    let awaitAt;
    if (parser.inScope('ASYNC') && parser.eatContextual('await')) {
      awaitAt = parser.getEndPosition();
    }

    const openContext = parser.expectOpening(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL, ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR, 'for head');

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.semi)) {
      if (awaitAt) {
        parser.unexpectedToken();
      }
      return ___$romejs$js_parser$src$parser$statement_ts$parseFor(parser, start, openContext, undefined);
    }

    const _isLet = ___$romejs$js_parser$src$parser$statement_ts$isLetStart(parser);
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._var) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._const) || _isLet) {
      const initStart = parser.getPosition();

      const kind = ___$romejs$js_parser$src$parser$statement_ts$assertVarKind(
      _isLet ? 'let' : String(parser.state.tokenValue));
      parser.next();

      const declarations = ___$romejs$js_parser$src$parser$statement_ts$parseVar(parser, initStart, kind, true);

      const init = {
        loc: parser.finishLoc(initStart),
        type: 'VariableDeclaration',
        kind: kind,
        declarations: declarations};

      if ((parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._in) || parser.isContextual('of')) &&
      init.declarations.length === 1) {
        return ___$romejs$js_parser$src$parser$statement_ts$parseForIn(parser, start, openContext, init, awaitAt);
      }

      if (awaitAt !== undefined) {
        parser.addDiagnostic({
          start: awaitAt,
          message: 'Can\'t have an await on a regular for loop'});
      }

      return ___$romejs$js_parser$src$parser$statement_ts$parseFor(parser, start, openContext, init);
    }

    const refShorthandDefaultPos = {index: 0};
    let init = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'for init', true, refShorthandDefaultPos);

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._in) || parser.isContextual('of')) {
      const description = parser.isContextual('of') ? 'for-of statement' : 'for-in statement';
      init = ___$romejs$js_parser$src$parser$lval_ts$toAssignable(parser, init, undefined, description);
      ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, init, undefined, undefined, description);
      return ___$romejs$js_parser$src$parser$statement_ts$parseForIn(parser, start, openContext, init, awaitAt);
    }

    if (refShorthandDefaultPos.index > 0) {
      parser.unexpectedToken(
      parser.getPositionFromIndex(refShorthandDefaultPos.index));
    }

    if (awaitAt !== undefined) {
      parser.addDiagnostic({
        start: awaitAt,
        message: 'Can\'t have an await on a regular for loop'});
    }

    return ___$romejs$js_parser$src$parser$statement_ts$parseFor(parser, start, openContext, init);
  }

  function ___$romejs$js_parser$src$parser$statement_ts$assertVarKind(kind) {
    if (kind === 'let' || kind === 'var' || kind === 'const') {
      return kind;
    } else {
      throw new Error(`Expected valid variable kind but got ${kind}`);
    }
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseFunctionStatement(parser, start) {
    parser.next();
    const node = ___$romejs$js_parser$src$parser$statement_ts$parseFunction(parser, {
      start: start,
      isStatement: true});
    if (node.type !== 'FunctionDeclaration' &&
    node.type !== 'TSDeclareFunction') {
      throw new Error(`parseFunction() should have returned a FunctionDeclaration or TSDeclareFunction but got ${node.type}`);
    }
    return node;
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseIfStatement(parser, start) {
    parser.next();
    const test = ___$romejs$js_parser$src$parser$expression_ts$parseParenExpression(parser, 'if test');
    const consequent = ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, 'if');
    const alternate = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types._else) ? ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, 'if') : undefined;
    return {
      loc: parser.finishLoc(start),
      type: 'IfStatement',
      test: test,
      consequent: consequent,
      alternate: alternate};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseReturnStatement(parser, start) {
    if (!parser.inScope('FUNCTION') &&
    parser.sourceType !== 'template' &&
    !parser.options.allowReturnOutsideFunction) {
      parser.addDiagnostic({
        message: '\'return\' outside of function'});
    }

    parser.next();

    let argument;
    if (!parser.isLineTerminator()) {
      argument = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'return argument');
      parser.semicolon();
    }

    return {
      loc: parser.finishLoc(start),
      type: 'ReturnStatement',
      argument: argument};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseSwitchStatement(parser, start) {
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._switch);
    const discriminant = ___$romejs$js_parser$src$parser$expression_ts$parseParenExpression(parser, 'switch discriminant');
    const cases = [];
    const hasBrace = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL);
    const openContext = parser.expectOpening(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL, ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR, 'switch body');
    parser.state.labels.push(___$$priv$romejs$js_parser$src$parser$statement_ts$switchLabel);

    if (hasBrace) {
      let cur;

      function pushCase() {
        if (cur === undefined) {
          return undefined;
        }

        cases.push({
          loc: parser.finishLoc(cur.start),
          type: 'SwitchCase',
          test: cur.test,
          consequent: cur.consequent});

        cur = undefined;
      }

      let sawDefault;

      while (true) {
        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
          break;
        }

        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._case) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._default)) {
          pushCase();

          const isCase = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._case);

          parser.next();

          let test;
          if (isCase) {
            test = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'case test');
          } else {
            if (sawDefault) {
              parser.addDiagnostic({
                start: parser.state.lastStartPos,
                message: 'Multiple default clauses'});
            }
            sawDefault = true;
          }

          cur = {
            start: parser.getPosition(),
            consequent: [],
            test: test};

          parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
        } else {
          const stmt = ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, undefined);
          if (cur === undefined) {
            parser.addDiagnostic({
              loc: stmt.loc,
              message: 'Statement outside of a case or default block'});
          } else {
            cur.consequent.push(stmt);
          }
        }
      }

      pushCase();
    }

    parser.expectClosing(openContext);
    parser.state.labels.pop();

    return {
      loc: parser.finishLoc(start),
      type: 'SwitchStatement',
      discriminant: discriminant,
      cases: cases};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseThrowStatement(parser, start) {
    parser.next();
    if (___$romejs$js_parser_utils$src$whitespace_ts$lineBreak.test(
    parser.getRawInput(
    parser.state.lastEndPos.index,
    parser.state.startPos.index))) {
      parser.addDiagnostic({
        start: parser.state.lastEndPos,
        message: 'Illegal newline after throw'});
    }

    const argument = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'throw argument');
    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'ThrowStatement',
      argument: argument};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseTryStatement(parser, start) {
    parser.next();

    const block = ___$romejs$js_parser$src$parser$statement_ts$parseBlock(parser);
    let handler = undefined;

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._catch)) {
      const clauseStart = parser.getPosition();
      parser.next();

      let param;
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
        const openContext = parser.expectOpening(
        ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
        ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
        'catch clause param');
        param = ___$romejs$js_parser$src$parser$lval_ts$parsePattern(parser);
        const clashes = new Map();
        ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, param, true, clashes, 'catch clause');
        parser.expectClosing(openContext);
      }

      const body = ___$romejs$js_parser$src$parser$statement_ts$parseBlock(parser);
      handler = {
        loc: parser.finishLoc(clauseStart),
        type: 'CatchClause',
        body: body,
        param: param};
    }

    const finalizer = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types._finally) ? ___$romejs$js_parser$src$parser$statement_ts$parseBlock(parser) : undefined;

    if (!handler && !finalizer) {
      parser.addDiagnostic({
        start: start,
        message: 'Missing catch or finally clause'});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TryStatement',
      block: block,
      finalizer: finalizer,
      handler: handler};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseVarStatement(parser, start, kind) {
    parser.next();
    const declarations = ___$romejs$js_parser$src$parser$statement_ts$parseVar(parser, start, kind, false);
    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'VariableDeclaration',
      kind: kind,
      declarations: declarations};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseWhileStatement(parser, start) {
    parser.next();
    const test = ___$romejs$js_parser$src$parser$expression_ts$parseParenExpression(parser, 'while test');
    parser.state.labels.push(___$$priv$romejs$js_parser$src$parser$statement_ts$loopLabel);
    const body = ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, 'while');
    parser.state.labels.pop();
    return {loc: parser.finishLoc(start), type: 'WhileStatement', test: test, body: body};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseWithStatement(parser, start) {
    parser.next();
    const object = ___$romejs$js_parser$src$parser$expression_ts$parseParenExpression(parser, 'with object');
    const body = ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, 'with');
    const loc = parser.finishLoc(start);

    if (parser.inScope('STRICT')) {
      parser.addDiagnostic({
        loc: loc,
        message: '\'with\' in strict mode'});
    }

    return {
      type: 'WithStatement',
      loc: loc,
      object: object,
      body: body};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseEmptyStatement(parser, start) {
    parser.next();
    return {loc: parser.finishLoc(start), type: 'EmptyStatement'};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseLabeledStatement(parser, start, maybeName, expr, context) {
    for (const label of parser.state.labels) {
      if (label.name === maybeName) {
        parser.addDiagnostic({
          loc: expr.loc,
          message: `Label '${maybeName}' is already declared`});
      }
    }

    let kind = undefined;
    if (parser.state.tokenType.isLoop) {
      kind = 'loop';
    } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._switch)) {
      kind = 'switch';
    }
    for (let i = parser.state.labels.length - 1; i >= 0; i--) {
      const label = parser.state.labels[i];
      if (label.statementStart === start.index) {
        label.statementStart = parser.state.startPos.index;
        label.kind = kind;
      } else {
        break;
      }
    }

    parser.state.labels.push({
      name: maybeName,
      kind: kind,
      statementStart: parser.state.startPos.index});

    let statementContext = 'label';
    if (context !== undefined) {
      if (context.includes('label')) {
        statementContext = context;
      } else {
        statementContext = context + 'label';
      }
    }
    const body = ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, statementContext);

    if (body.type == 'ClassDeclaration' ||
    body.type == 'VariableDeclaration' && body.kind !== 'var' ||
    body.type == 'FunctionDeclaration' &&
    (parser.inScope('STRICT') ||
    body.generator === true ||
    body.async === true)) {
      parser.addDiagnostic({
        loc: body.loc,
        message: 'Invalid labeled declaration'});
    }

    parser.state.labels.pop();
    return {
      loc: parser.finishLoc(start),
      type: 'LabeledStatement',
      label: expr,
      body: body};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseExpressionStatement(parser, start, expr) {
    const node = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeExpressionStatement(parser, start, expr);
    if (node !== undefined) {
      return node;
    }

    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'ExpressionStatement',
      expression: expr};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseBlock(parser, allowDirectives) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL, ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR, 'block');
    const {body: body, directives: directives} = ___$romejs$js_parser$src$parser$statement_ts$parseBlockBody(
    parser,
    allowDirectives,
    false,
    openContext);
    return {
      loc: parser.finishLoc(start),
      type: 'BlockStatement',
      directives: directives,
      body: body};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$isValidDirective(parser, stmt) {
    return stmt.type === 'ExpressionStatement' &&
    stmt.expression.type === 'StringLiteral' &&
    !parser.isParenthesized(stmt.expression);
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseBlockBody(parser, allowDirectives = false, topLevel, openContext) {
    return ___$romejs$js_parser$src$parser$statement_ts$parseBlockOrModuleBlockBody(
    parser,
    allowDirectives,
    topLevel,
    openContext);
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseBlockOrModuleBlockBody(parser, allowDirectives, topLevel, openContext) {
    const body = [];
    const directives = [];

    let parsedNonDirective = false;
    let didSetStrict = undefined;
    let octalPosition;

    while (true) {
      if (parser.match(openContext.close) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (!parsedNonDirective && parser.state.containsOctal && !octalPosition) {
        octalPosition = parser.state.octalPosition;
      }

      const stmt = ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, undefined, topLevel);

      if (allowDirectives &&
      !parsedNonDirective &&
      stmt.type === 'ExpressionStatement' &&
      ___$romejs$js_parser$src$parser$statement_ts$isValidDirective(parser, stmt)) {
        const directive = ___$romejs$js_parser$src$parser$statement_ts$expressionStatementToDirective(parser, stmt);
        directives.push(directive);

        if (didSetStrict === undefined &&
        directive.value.value === 'use strict') {
          ___$romejs$js_parser$src$tokenizer$index_ts$setStrict(parser, true);
          didSetStrict = true;

          if (octalPosition !== undefined) {
            parser.addDiagnostic({
              index: octalPosition,
              message: 'Octal literal in strict mode'});
          }
        }

        continue;
      }

      parsedNonDirective = true;
      body.push(stmt);
    }

    if (didSetStrict) {
      parser.popScope('STRICT');
    }

    return {body: body, directives: directives};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseFor(parser, start, openContext, init) {
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.semi);

    const test = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.semi) ? undefined : ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'for test');
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.semi);

    const update = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenR) ? undefined : ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'for update');
    parser.expectClosing(openContext);

    const body = ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, 'for');
    parser.state.labels.pop();

    return {
      loc: parser.finishLoc(start),
      type: 'ForStatement',
      init: init,
      test: test,
      update: update,
      body: body};
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseForIn(parser, start, openContext, init, awaitAt) {
    const isForIn = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._in);
    const type = isForIn ? 'ForInStatement' : 'ForOfStatement';
    parser.next();

    const isAwait = awaitAt !== undefined;
    if (isForIn && isAwait) {
      parser.addDiagnostic({
        start: awaitAt,
        message: 'Unexpected await for `for-in`'});
    }

    if (init.type === 'VariableDeclaration' &&
    init.declarations[0].init !== undefined &&
    (!isForIn ||
    parser.inScope('STRICT') ||
    init.kind !== 'var' ||
    init.declarations[0].id.type !== 'Identifier')) {
      parser.addDiagnostic({
        loc: init.loc,
        message: `${isForIn ? 'for-in' : 'for-of'} loop variable declaration may not have an initializer`});
    } else if (init.type === 'AssignmentPattern') {
      parser.addDiagnostic({
        loc: init.loc,
        message: 'Invalid left-hand side in for-loop'});
    }

    const left = init;
    const right = isForIn ? ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'for right') : ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'for right');
    parser.expectClosing(openContext);

    const body = ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser, 'for');
    parser.state.labels.pop();

    if (type === 'ForOfStatement') {
      return {
        loc: parser.finishLoc(start),
        type: type,
        await: isAwait,
        left: left,
        right: right,
        body: body};
    } else {
      return {
        loc: parser.finishLoc(start),
        type: type,
        left: left,
        right: right,
        body: body};
    }
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseVar(parser, start, kind, isFor) {
    const declarations = [];

    for (;;) {
      const start = parser.getPosition();
      const id = ___$romejs$js_parser$src$parser$statement_ts$parseVarHead(parser, start);

      let init;
      if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.eq)) {
        init = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'var init', isFor);
      } else {
        if (kind === 'const' &&
        !(parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._in) || parser.isContextual('of'))) {
          if (!parser.isSyntaxEnabled('ts')) {
            parser.addDiagnostic({
              message: 'const with no initializer isn\'t allowed',
              loc: id.loc});
          }
        }

        if (kind !== 'const' &&
        id.type !== 'Identifier' &&
        !(isFor && (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._in) || parser.isContextual('of')))) {
          parser.addDiagnostic({
            start: parser.state.lastEndPos,
            message: 'Complex binding patterns require an initialization value'});
        }
      }

      declarations.push({
        loc: parser.finishLoc(start),
        type: 'VariableDeclarator',
        id: id,
        init: init});

      if (!parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    return declarations;
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseVarHead(parser, start) {
    const id = ___$romejs$js_parser$src$parser$lval_ts$parsePattern(parser);
    ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, id, true, undefined, 'variable declaration');

    let definite;
    if (id.type === 'Identifier' && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bang)) {
      definite = true;

      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'TypeScript syntax isnt enabled for definite syntax'});
      }

      parser.next();
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      const typeAnnotation = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotation(parser);

      return Object.assign({
        loc: parser.finishLoc(start)}, id, {
        typeAnnotation: typeAnnotation,
        definite: definite});
    } else if (definite) {
      return Object.assign({}, id, {
        definite: definite});
    } else {
      return id;
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$statement_ts$parseFunctionId(parser, requireId) {
    if (requireId || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
      return ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
    }
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseFunction(parser, opts) {
    const {
      start: start,
      isStatement: isStatement,
      isArrowFunction = false,
      isAsync = false,
      requiredStatementId = true} = opts;

    const isGenerator = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.star);

    let id;
    if (isStatement) {
      id = ___$$priv$romejs$js_parser$src$parser$statement_ts$parseFunctionId(parser, requiredStatementId);
    }

    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    parser.pushScope('FUNCTION_LOC', start);
    parser.pushScope('FUNCTION', true);
    parser.pushScope('METHOD', false);
    parser.pushScope('GENERATOR', isGenerator);
    parser.pushScope('ASYNC', isAsync);
    parser.pushScope('CLASS_PROPERTY', false);
    if (!isArrowFunction) {
      parser.pushScope('NON_ARROW_FUNCTION');
    }
    parser.state.yieldPos = 0;
    parser.state.awaitPos = 0;

    if (!isStatement) {
      id = ___$$priv$romejs$js_parser$src$parser$statement_ts$parseFunctionId(parser, false);
    }

    const {params: params, typeParameters: typeParameters} = ___$romejs$js_parser$src$parser$statement_ts$parseFunctionParams(parser);
    const {body: body, returnType: returnType} = ___$romejs$js_parser$src$parser$expression_ts$parseFunctionBodyAndFinish(parser, {
      allowBodiless: isStatement,
      id: id,
      params: params,
      isArrowFunction: isArrowFunction,
      isMethod: false,
      isAsync: isAsync,
      isGenerator: isGenerator,
      start: start});

    parser.state.yieldPos = oldYieldPos;
    parser.state.awaitPos = oldAwaitPos;

    if (!isArrowFunction) {
      parser.popScope('NON_ARROW_FUNCTION');
    }
    parser.popScope('FUNCTION');
    parser.popScope('FUNCTION_LOC');
    parser.popScope('CLASS_PROPERTY');
    parser.popScope('METHOD');
    parser.popScope('GENERATOR');
    parser.popScope('ASYNC');

    const node = {
      generator: isGenerator,
      async: isAsync,
      id: id,
      params: params,
      typeParameters: typeParameters,
      returnType: returnType};

    if (body === undefined) {
      return Object.assign({
        type: 'TSDeclareFunction'}, node, {
        body: undefined,
        loc: parser.finishLoc(start)});
    }

    if (isStatement) {
      return Object.assign({
        type: 'FunctionDeclaration'}, node, {
        body: body,
        loc: parser.finishLoc(start)});
    } else {
      return Object.assign({
        type: 'FunctionExpression'}, node, {
        body: body,
        loc: parser.finishLoc(start)});
    }
  }

  function ___$romejs$js_parser$src$parser$statement_ts$parseFunctionParams(parser, kind, allowTSModifiers) {
    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$type_systems_ts$maybeParseTypeParameters(parser);

      if (typeParameters !== undefined && (kind === 'get' || kind === 'set')) {
        parser.addDiagnostic({
          loc: typeParameters.loc,
          message: 'An accessor cannot have type parameters'});
      }
    }

    parser.pushScope('PARAMETERS', true);

    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
    'function params');
    const params = ___$romejs$js_parser$src$parser$lval_ts$parseBindingListNonEmpty(
    parser,
    openContext,
    allowTSModifiers);

    parser.popScope('PARAMETERS');
    ___$romejs$js_parser$src$parser$expression_ts$checkYieldAwaitInDefaultParams(parser);
    return {params: params, typeParameters: typeParameters};
  }

  // romejs/js-parser/src/parser/jsx.ts

  const ___$romejs$js_parser$src$parser$jsx_ts = {
    parseJSXText: ___$romejs$js_parser$src$parser$jsx_ts$parseJSXText,
    parseJSXElement: ___$romejs$js_parser$src$parser$jsx_ts$parseJSXElement};
  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$isFragment(object) {
    return object ? object.type === 'JSXOpeningFragment' ||
    object.type === 'JSXClosingFragment' : false;
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$getQualifiedJSXName(node) {
    if (node === undefined) {
      return '';
    }

    if (node.type === 'JSXOpeningElement' || node.type === 'JSXClosingElement') {
      return ___$$priv$romejs$js_parser$src$parser$jsx_ts$getQualifiedJSXName(node.name);
    }

    if (node.type === 'JSXIdentifier') {
      node = ___$romejs$js_ast$src$index_ts.jsxIdentifier.assert(node);
      return node.name;
    }

    if (node.type === 'JSXNamespacedName') {
      node = ___$romejs$js_ast$src$index_ts.jsxNamespacedName.assert(node);
      return node.namespace.name + ':' + node.name.name;
    }

    if (node.type === 'JSXMemberExpression') {
      node = ___$romejs$js_ast$src$index_ts.jsxMemberExpression.assert(node);
      return ___$$priv$romejs$js_parser$src$parser$jsx_ts$getQualifiedJSXName(node.object) +
      '.' +
      ___$$priv$romejs$js_parser$src$parser$jsx_ts$getQualifiedJSXName(node.property);
    }

    throw new Error('Node had unexpected type: ' + node.type);
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXIdentifier(parser) {
    const start = parser.getPosition();
    let name;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.jsxName)) {
      name = String(parser.state.tokenValue);
    } else if (parser.state.tokenType.keyword !== undefined) {
      name = parser.state.tokenType.keyword;
    } else {
      parser.addDiagnostic({
        message: 'Unknown JSX identifier token'});
      name = '';
    }
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'JSXIdentifier',
      name: name};
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXNamespacedName(parser) {
    const start = parser.getPosition();

    const namespace = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXIdentifier(parser);
    if (!parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      return namespace;
    }

    const name = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXIdentifier(parser);
    return {
      loc: parser.finishLoc(start),
      type: 'JSXNamespacedName',
      name: name,
      namespace: namespace};
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXElementName(parser) {
    const start = parser.getPosition();

    let node = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXNamespacedName(parser);

    while (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.dot)) {
      const property = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXIdentifier(parser);
      node = {
        loc: parser.finishLoc(start),
        type: 'JSXMemberExpression',
        object: node,
        property: property};
    }

    return node;
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXAttributeValue(parser) {
    let node;
    switch (parser.state.tokenType) {
      case ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL:
        node = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXExpressionContainer(parser);
        if (node.expression.type === 'JSXEmptyExpression') {
          parser.addDiagnostic({
            loc: node.loc,
            message: 'JSX attributes must only be assigned a non-empty expression'});
        }
        return node;

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagStart:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types.string:
        return ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'jsx attribute value');

      default:
        parser.addDiagnostic({
          message: 'JSX value should be either an expression or a quoted JSX text'});}
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXEmptyExpression(parser) {
    return {
      loc: parser.finishLoc(parser.state.lastEndPos),
      type: 'JSXEmptyExpression'};
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXSpreadChild(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
    'jsx spread child');
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis);
    const expression = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'jsx spread child expression');
    parser.expectClosing(openContext);

    return {
      loc: parser.finishLoc(start),
      type: 'JSXSpreadChild',
      expression: expression};
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXExpressionContainer(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
    'jsx expression container');
    let expression;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR)) {
      expression = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXEmptyExpression(parser);
    } else {
      expression = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'jsx inner expression container');
    }
    parser.expectClosing(openContext);
    return {
      loc: parser.finishLoc(start),
      type: 'JSXExpressionContainer',
      expression: expression};
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXAttribute(parser) {
    const start = parser.getPosition();

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL)) {
      const openContext = parser.expectOpening(
      ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
      ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
      'jsx attribute spread');
      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis);
      const argument = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'jsx attribute spread');
      parser.expectClosing(openContext);
      return {
        loc: parser.finishLoc(start),
        type: 'JSXSpreadAttribute',
        argument: argument};
    }

    const name = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXNamespacedName(parser);
    const value = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.eq) ? ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXAttributeValue(parser) : undefined;
    return {
      loc: parser.finishLoc(start),
      type: 'JSXAttribute',
      name: name,
      value: value};
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXOpeningElementAt(parser, start) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagEnd)) {
      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagEnd);
      return {
        loc: parser.finishLoc(start),
        type: 'JSXOpeningFragment'};
    }

    const attributes = [];
    const name = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXElementName(parser);

    let typeArguments;
    if (parser.isRelational('<')) {
      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'JSX element type arguments are only allowed in TS'});
      }

      typeArguments = ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeArguments(parser);
    }

    while (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.slash) &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagEnd) &&
    !parser.atEOF()) {
      attributes.push(___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXAttribute(parser));
    }
    const selfClosing = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.slash);
    if (!parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagEnd)) {
      parser.addDiagnostic({
        message: 'Unclosed JSX element open'});
    }
    return {
      loc: parser.finishLoc(start),
      type: 'JSXOpeningElement',
      typeArguments: typeArguments,
      name: name,
      attributes: attributes,
      selfClosing: selfClosing};
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXClosingElementAt(parser, start) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagEnd)) {
      if (!parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagEnd)) {
        parser.addDiagnostic({
          message: 'Unclosed JSX fragment close'});
      }

      return {
        loc: parser.finishLoc(start),
        type: 'JSXClosingFragment'};
    }

    const name = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXElementName(parser);

    if (!parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagEnd)) {
      parser.addDiagnostic({
        message: 'Unclosed JSX element close'});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'JSXClosingElement',
      name: name};
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXElementAt(parser, start) {
    const children = [];
    const openingElement = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXOpeningElementAt(parser, start);

    let closingElement = undefined;

    if (openingElement.type === 'JSXOpeningElement' &&
    openingElement.selfClosing !== true) {
      contents: while (true) {
        switch (parser.state.tokenType) {
          case ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagStart:
            {
              const start = parser.getPosition();
              parser.next();
              if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.slash)) {
                closingElement = ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXClosingElementAt(parser, start);
                break contents;
              }
              children.push(___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXElementAt(parser, start));
              break;
            }

          case ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxText:
            children.push(___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'jsx text'));
            break;

          case ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL:
            if (parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis) {
              children.push(___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXSpreadChild(parser));
            } else {
              children.push(___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXExpressionContainer(parser));
            }
            break;

          default:
            parser.addDiagnostic({
              message: 'Unknown JSX children start'});
            parser.next();
            break contents;}
      }

      if (___$$priv$romejs$js_parser$src$parser$jsx_ts$isFragment(openingElement) &&
      !___$$priv$romejs$js_parser$src$parser$jsx_ts$isFragment(closingElement) &&
      closingElement !== undefined) {
        parser.addDiagnostic({
          loc: parser.getLoc(closingElement),
          message: 'Expected corresponding JSX closing tag for <>'});
        closingElement = {
          type: 'JSXClosingFragment',
          loc: closingElement === undefined ? openingElement.loc : closingElement.loc};
      }

      if (!___$$priv$romejs$js_parser$src$parser$jsx_ts$isFragment(openingElement) &&
      ___$$priv$romejs$js_parser$src$parser$jsx_ts$isFragment(closingElement) &&
      closingElement !== undefined) {
        parser.addDiagnostic({
          loc: parser.getLoc(closingElement),
          message: 'Expected corresponding JSX closing tag for <' +
          ___$$priv$romejs$js_parser$src$parser$jsx_ts$getQualifiedJSXName(___$romejs$js_ast$src$index_ts.jsxOpeningElement.assert(openingElement).name) +
          '>'});

        closingElement = {
          type: 'JSXClosingElement',
          loc: ___$romejs$js_ast$src$index_ts.jsxClosingFragment.assert(closingElement).loc,
          name: ___$romejs$js_ast$src$index_ts.jsxOpeningElement.assert(openingElement).name};
      }

      if (!___$$priv$romejs$js_parser$src$parser$jsx_ts$isFragment(openingElement) &&
      !___$$priv$romejs$js_parser$src$parser$jsx_ts$isFragment(closingElement) &&
      closingElement !== undefined) {
        if (___$$priv$romejs$js_parser$src$parser$jsx_ts$getQualifiedJSXName(closingElement) !==
        ___$$priv$romejs$js_parser$src$parser$jsx_ts$getQualifiedJSXName(openingElement)) {
          parser.addDiagnostic({
            loc: parser.getLoc(closingElement),
            message: 'Expected corresponding JSX closing tag for <' +
            ___$$priv$romejs$js_parser$src$parser$jsx_ts$getQualifiedJSXName(
            ___$romejs$js_ast$src$index_ts.jsxOpeningElement.assert(openingElement).name) +
            '>'});

          closingElement = {
            type: 'JSXClosingElement',
            loc: closingElement === undefined ? openingElement.loc : closingElement.loc,
            name: ___$romejs$js_ast$src$index_ts.jsxOpeningElement.assert(openingElement).name};
        }
      }
    }

    if (___$$priv$romejs$js_parser$src$parser$jsx_ts$isFragment(openingElement)) {
      ___$$priv$romejs$js_parser$src$parser$jsx_ts$checkAccidentalFragment(parser);
      return {
        loc: parser.finishLoc(start),
        type: 'JSXFragment',
        openingFragment: ___$romejs$js_ast$src$index_ts.jsxOpeningFragment.assert(openingElement),
        closingFragment: closingElement === undefined ? undefined : ___$romejs$js_ast$src$index_ts.jsxClosingFragment.assert(closingElement),
        children: children};
    } else {
      ___$$priv$romejs$js_parser$src$parser$jsx_ts$checkAccidentalFragment(parser);
      return {
        loc: parser.finishLoc(start),
        type: 'JSXElement',
        openingElement: ___$romejs$js_ast$src$index_ts.jsxOpeningElement.assert(openingElement),
        closingElement: closingElement === undefined ? undefined : ___$romejs$js_ast$src$index_ts.jsxClosingElement.assert(closingElement),
        children: children};
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$jsx_ts$checkAccidentalFragment(parser) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.relational) && parser.state.tokenValue === '<') {
      parser.addDiagnostic({
        message: 'Adjacent JSX elements must be wrapped in an enclosing tag. ' +
        'Did you want a JSX fragment <>...</>?'});
    }
  }

  function ___$romejs$js_parser$src$parser$jsx_ts$parseJSXText(parser) {
    const start = parser.getPosition();
    const value = String(parser.state.tokenValue);
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'JSXText',
      value: value};
  }

  function ___$romejs$js_parser$src$parser$jsx_ts$parseJSXElement(parser) {
    parser.expectSyntaxEnabled('jsx');

    const start = parser.getPosition();
    parser.next();
    return ___$$priv$romejs$js_parser$src$parser$jsx_ts$parseJSXElementAt(parser, start);
  }

  // romejs/js-parser/src/parser/flow.ts

  const ___$romejs$js_parser$src$parser$flow_ts = {
    hasTypeImportKind: ___$romejs$js_parser$src$parser$flow_ts$hasTypeImportKind,
    isMaybeDefaultImport: ___$romejs$js_parser$src$parser$flow_ts$isMaybeDefaultImport,
    parseFlowTypeParameterInstantiationCallOrNew: ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterInstantiationCallOrNew,
    parseFlowTypeAndPredicateInitialiser: ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAndPredicateInitialiser,
    parseFlowDeclare: ___$romejs$js_parser$src$parser$flow_ts$parseFlowDeclare,
    parseFlowInterface: ___$romejs$js_parser$src$parser$flow_ts$parseFlowInterface,
    checkReservedType: ___$romejs$js_parser$src$parser$flow_ts$checkReservedType,
    parseFlowRestrictedIdentifier: ___$romejs$js_parser$src$parser$flow_ts$parseFlowRestrictedIdentifier,
    parseFlowTypeAlias: ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAlias,
    parseFlowOpaqueType: ___$romejs$js_parser$src$parser$flow_ts$parseFlowOpaqueType,
    parseFlowTypeParameterDeclaration: ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterDeclaration,
    parseFlowTypeParameterInstantiation: ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterInstantiation,
    parseFlowTypeAnnotation: ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAnnotation,
    parseFlowClassImplemented: ___$romejs$js_parser$src$parser$flow_ts$parseFlowClassImplemented,
    parseFlowVariance: ___$romejs$js_parser$src$parser$flow_ts$parseFlowVariance,
    parseAsyncArrowWithFlowTypeParameters: ___$romejs$js_parser$src$parser$flow_ts$parseAsyncArrowWithFlowTypeParameters,
    parseFlowObjectTypeInternalSlot: ___$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeInternalSlot};
  const ___$$priv$romejs$js_parser$src$parser$flow_ts$primitiveTypes = ['any', 'bool', 'boolean', 'empty', 'false', 'mixed', 'null', 'number', 'bigint', 'static', 'string', 'true', 'typeof', 'void', 'interface', 'extends', '_'];

  const ___$$priv$romejs$js_parser$src$parser$flow_ts$exportSuggestions = new Map([['const', 'declare export var'], ['let', 'declare export var'], ['type', 'export type'], ['interface', 'export interface']]);

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$checkNotUnderscore(parser, id) {
    if (id.name === '_') {
      parser.addDiagnostic({
        loc: id.loc,
        message: '`_` is only allowed as a type argument to call or new'});
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$isEsModuleType(bodyElement) {
    return bodyElement.type === 'DeclareExportAllDeclaration' ||
    bodyElement.type === 'FlowDeclareExportDeclaration' &&
    (!bodyElement.declaration ||
    bodyElement.declaration.type !== 'FlowTypeAlias' &&
    bodyElement.declaration.type !== 'FlowInterfaceDeclaration');
  }

  function ___$romejs$js_parser$src$parser$flow_ts$hasTypeImportKind(kind) {
    return kind === 'type' || kind === 'typeof';
  }

  function ___$romejs$js_parser$src$parser$flow_ts$isMaybeDefaultImport(state) {
    return (state.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.name || !!state.tokenType.keyword) &&
    state.tokenValue !== 'from';
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterInstantiationCallOrNew(parser) {
    const start = parser.getPosition();
    const params = [];

    parser.pushScope('TYPE', true);

    if (parser.expectRelational('<')) {
      while (!parser.isRelational('>')) {
        params.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeOrImplicitInstantiation(parser));

        if (!parser.isRelational('>') && !parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
          break;
        }
      }
      parser.expectRelational('>');
    }

    parser.popScope('TYPE');

    return {
      type: 'FlowTypeParameterInstantiation',
      loc: parser.finishLoc(start),
      params: params};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeOrImplicitInstantiation(parser) {
    if (parser.state.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.name && parser.state.tokenValue === '_') {
      const startPos = parser.state.startPos;
      const node = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
      return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowGenericType(parser, startPos, node);
    } else {
      return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser, tok) {
    parser.pushScope('TYPE', true);
    parser.expect(tok || ___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
    const type = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);
    parser.popScope('TYPE');
    return type;
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPredicate(parser) {
    const start = parser.getPosition();
    const moduloPos = parser.state.startPos;
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.modulo);
    const checksPos = parser.state.startPos;
    parser.expectContextual('checks');

    if (moduloPos.line !== checksPos.line ||
    moduloPos.column !== checksPos.column - 1) {
      parser.addDiagnostic({
        start: moduloPos,
        message: 'Spaces between \xb4%\xb4 and \xb4checks\xb4 are not allowed here.'});
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
      const openContext = parser.expectOpening(
      ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
      ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
      'flow declared predicate');
      const value = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'flow declared predicate');
      parser.expectClosing(openContext);
      return {
        loc: parser.finishLoc(start),
        type: 'FlowDeclaredPredicate',
        value: value};
    } else {
      return {
        loc: parser.finishLoc(start),
        type: 'FlowInferredPredicate'};
    }
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAndPredicateInitialiser(parser) {
    parser.expectSyntaxEnabled('flow');

    parser.pushScope('TYPE', true);
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
    let type = undefined;
    let predicate = undefined;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.modulo)) {
      parser.popScope('TYPE');
      predicate = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPredicate(parser);
    } else {
      type = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);
      parser.popScope('TYPE');
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.modulo)) {
        predicate = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPredicate(parser);
      }
    }
    return [type, predicate];
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareClass(parser, start) {
    parser.next();

    return Object.assign({}, ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceish(parser, true), {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareClass'});
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareFunction(parser, start) {
    parser.next();

    const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);

    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    }

    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
    'flow function type params');
    const params = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowFunctionTypeParams(parser);
    parser.expectClosing(openContext);

    const [returnType, predicate] = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAndPredicateInitialiser(parser);

    parser.semicolon();

    if (predicate !== undefined && predicate.type === 'FlowInferredPredicate') {
      parser.addDiagnostic({
        loc: predicate.loc,
        message: 'Predicate function declarations need to declare a predicate expression'});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareFunction',
      id: Object.assign({
        loc: parser.finishLoc(start)}, id, {
        typeAnnotation: {
          loc: parser.finishLoc(start),
          type: 'FlowTypeAnnotation',
          typeAnnotation: {
            loc: parser.finishLoc(start),
            type: 'FlowFunctionTypeAnnotation',
            params: params,
            returnType: returnType,
            typeParameters: typeParameters}}}),
      predicate: predicate};
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowDeclare(parser, start, insideModule = false) {
    parser.expectSyntaxEnabled('flow');

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._class)) {
      return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareClass(parser, start);
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._function)) {
      return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareFunction(parser, start);
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._var)) {
      return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareVariable(parser, start);
    }

    if (parser.isContextual('module')) {
      if (parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.dot) {
        return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareModuleExports(parser, start);
      } else {
        if (insideModule) {
          parser.addDiagnostic({
            message: '`declare module` cannot be used inside another `declare module`'});
        }
        return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareModule(parser, start);
      }
    }

    if (parser.isContextual('type')) {
      return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareTypeAlias(parser, start);
    }

    if (parser.isContextual('opaque')) {
      return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareOpaqueType(parser, start);
    }

    if (parser.isContextual('interface')) {
      return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareInterface(parser, start);
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._export)) {
      return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareExportDeclaration(parser, start, insideModule);
    }

    parser.addDiagnostic({
      message: 'Unknown start to Flow declaration'});
    return parser.createUnknownNode('flow declaration', start);
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareVariable(parser, start) {
    parser.next();
    const id = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAnnotatableIdentifier(
    parser,
    true);
    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareVariable',
      id: id};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareModule(parser, start) {
    parser.next();

    let id;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string)) {
      id = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'flow declare module id');
    } else {
      id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
    }

    const bodyStart = parser.getPosition();
    const body = [];
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
    'flow declare module body');

    while (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR)) {
      let bodyNodeStart = parser.getPosition();

      let bodyNode;
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._import)) {
        const lookahead = parser.lookaheadState();
        if (lookahead.tokenValue !== 'type' &&
        lookahead.tokenValue !== 'typeof') {
          parser.addDiagnostic({
            message: 'Imports within a `declare module` body must always be `import type` or `import typeof`'});
        }
        parser.next();
        bodyNode = ___$romejs$js_parser$src$parser$modules_ts$parseImport(parser, bodyNodeStart);
      } else {
        if (!parser.expectContextual(
        'declare',
        'Only declares and type imports are allowed inside declare module')) {
          break;
        }

        bodyNode = ___$romejs$js_parser$src$parser$flow_ts$parseFlowDeclare(parser, bodyNodeStart, true);
      }

      body.push(bodyNode);
    }

    parser.expectClosing(openContext);

    const bodyNode = {
      loc: parser.finishLoc(bodyStart),
      type: 'BlockStatement',
      body: body};

    let kind;
    let hasModuleExport = false;
    const errorMessage = 'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module';

    for (const bodyElement of body) {
      if (___$$priv$romejs$js_parser$src$parser$flow_ts$isEsModuleType(bodyElement)) {
        if (kind === 'commonjs') {
          parser.addDiagnostic({
            loc: bodyElement.loc,
            message: errorMessage});
        }
        kind = 'es';
      } else if (bodyElement.type === 'FlowDeclareModuleExports') {
        if (hasModuleExport) {
          parser.addDiagnostic({
            loc: bodyElement.loc,
            message: 'Duplicate `declare module.exports` statement'});
        }

        if (kind === 'es') {
          parser.addDiagnostic({
            loc: bodyElement.loc,
            message: errorMessage});
        }

        kind = 'commonjs';
        hasModuleExport = true;
      }
    }

    return {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareModule',
      id: id,
      kind: kind === undefined ? 'commonjs' : kind,
      body: bodyNode};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareExportDeclaration(parser, start, insideModule) {
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._export);

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types._default)) {
      let declaration;
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._function) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._class)) {
        declaration = ___$romejs$js_parser$src$parser$flow_ts$parseFlowDeclare(parser, parser.getPosition());
      } else {
        declaration = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);
        parser.semicolon();
      }

      return {
        loc: parser.finishLoc(start),
        type: 'FlowDeclareExportDeclaration',
        declaration: declaration,
        default: true};
    } else {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._const) ||
      ___$romejs$js_parser$src$parser$statement_ts$isLetStart(parser) ||
      (parser.isContextual('type') || parser.isContextual('interface')) &&
      !insideModule) {
        const label = String(parser.state.tokenValue);
        const suggestion = String(___$$priv$romejs$js_parser$src$parser$flow_ts$exportSuggestions.get(label));
        parser.addDiagnostic({
          message: `\`declare export ${label}\` is not supported. Use \`${suggestion}\` instead`});
      }

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._var) ||
      parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._function) ||
      parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._class) ||
      parser.isContextual('opaque')) {
        const declaration = ___$romejs$js_parser$src$parser$flow_ts$parseFlowDeclare(parser, parser.getPosition());

        return {
          loc: parser.finishLoc(start),
          type: 'FlowDeclareExportDeclaration',
          declaration: declaration,
          default: false};
      }

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.star) ||
      parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL) ||
      parser.isContextual('interface') ||
      parser.isContextual('type') ||
      parser.isContextual('opaque')) {
        const node = ___$romejs$js_parser$src$parser$modules_ts$parseExport(parser, start);

        if (node.type === 'ExportNamedDeclaration') {
          return {
            loc: parser.finishLoc(start),
            type: 'FlowDeclareExportDeclaration',
            default: false,
            declaration: node.declaration,
            specifiers: node.specifiers};
        } else if (node.type === 'ExportAllDeclaration') {
          return {
            loc: parser.finishLoc(start),
            type: 'FlowDeclareExportAllDeclaration',
            source: node.source};
        }
      }
    }

    parser.addDiagnostic({
      start: start,
      message: 'No valid start for Flow declare export declaration found'});
    return parser.createUnknownNode('flow declare export declaration', start);
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareModuleExports(parser, start) {
    parser.expectContextual('module');
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.dot);
    parser.expectContextual('exports');
    const typeAnnotation = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAnnotation(parser);
    parser.semicolon();

    return {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareModuleExports',
      typeAnnotation: typeAnnotation};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareTypeAlias(parser, start) {
    parser.next();
    return Object.assign({}, ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAlias(parser, start), {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareTypeAlias'});
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareOpaqueType(parser, start) {
    parser.next();
    return Object.assign({}, ___$romejs$js_parser$src$parser$flow_ts$parseFlowOpaqueType(parser, start, true), {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareOpaqueType'});
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowDeclareInterface(parser, start) {
    parser.next();
    return Object.assign({}, ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceish(parser), {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareInterface'});
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceish(parser, isClass = false) {
    const id = ___$romejs$js_parser$src$parser$flow_ts$parseFlowRestrictedIdentifier(parser, !isClass);

    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    }

    const _extends = [];
    const mixins = [];
    const _implements = [];

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types._extends)) {
      do {
        _extends.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (!isClass && parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma));
    }

    if (parser.isContextual('mixins')) {
      parser.next();
      do {
        ___$romejs$invariant$src$index_ts$default(
        mixins !== undefined,
        'expected mixins to be present as it was set before in this method');
        mixins.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma));
    }

    if (parser.isContextual('implements')) {
      parser.next();
      do {
        _implements.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma));
    }

    const body = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectType(parser, {
      allowStatic: isClass,
      allowExact: false,
      allowSpread: false,
      allowProto: isClass,
      allowInexact: false});
    return {
      body: body,
      extends: _extends,
      mixins: mixins,
      id: id,
      typeParameters: typeParameters,
      implements: _implements};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceType(parser) {
    const start = parser.getPosition();
    parser.expectContextual('interface');

    const _extends = [];
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types._extends)) {
      do {
        _extends.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma));
    }

    const body = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectType(parser, {
      allowStatic: false,
      allowExact: false,
      allowSpread: false,
      allowProto: false,
      allowInexact: false});

    return {
      type: 'FlowInterfaceTypeAnnotation',
      loc: parser.finishLoc(start),
      extends: _extends,
      body: body};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceExtends(parser) {
    const start = parser.getPosition();

    const id = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowQualifiedTypeIdentifier(parser);
    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterInstantiation(parser);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'FlowInterfaceExtends',
      id: id,
      typeParameters: typeParameters};
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowInterface(parser, start) {
    parser.expectSyntaxEnabled('flow');
    return Object.assign({}, ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceish(parser), {
      loc: parser.finishLoc(start),
      type: 'FlowInterfaceDeclaration'});
  }

  function ___$romejs$js_parser$src$parser$flow_ts$checkReservedType(parser, word, loc) {
    if (___$$priv$romejs$js_parser$src$parser$flow_ts$primitiveTypes.includes(word)) {
      parser.addDiagnostic({
        loc: loc,
        message: `Cannot overwrite primitive type ${word}`});
    }
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowRestrictedIdentifier(parser, liberal) {
    ___$romejs$js_parser$src$parser$flow_ts$checkReservedType(
    parser,
    String(parser.state.tokenValue),
    parser.finishLocAt(parser.state.startPos, parser.state.endPos));
    return ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, liberal);
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAlias(parser, start) {
    parser.expectSyntaxEnabled('flow');

    const id = ___$romejs$js_parser$src$parser$flow_ts$parseFlowRestrictedIdentifier(parser);
    let typeParameters;

    if (parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    } else {
      typeParameters = undefined;
    }

    const right = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.eq);
    parser.semicolon();

    return {
      loc: parser.finishLoc(start),
      type: 'FlowTypeAlias',
      id: id,
      typeParameters: typeParameters,
      right: right};
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowOpaqueType(parser, start, declare) {
    parser.expectSyntaxEnabled('flow');
    parser.expectContextual('type');
    const id = ___$romejs$js_parser$src$parser$flow_ts$parseFlowRestrictedIdentifier(parser, true);

    let typeParameters;
    if (parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    } else {
      typeParameters = undefined;
    }

    let supertype = undefined;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      supertype = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
    }

    let impltype = undefined;
    if (!declare) {
      impltype = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.eq);
    }
    parser.semicolon();

    return {
      loc: parser.finishLoc(start),
      type: 'FlowOpaqueType',
      id: id,
      typeParameters: typeParameters,
      supertype: supertype,
      impltype: impltype};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameter(parser, allowDefault = true, requireDefault = false) {
    const start = parser.getPosition();

    const variance = ___$romejs$js_parser$src$parser$flow_ts$parseFlowVariance(parser);

    const ident = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAnnotatableIdentifier(parser);
    const name = ident.name;
    const bound = ident.typeAnnotation;
    if (bound !== undefined && bound.type === 'TSTypeAnnotation') {
      throw new Error('Received a TS type annotation node in Flow mode');
    }

    let def;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eq)) {
      if (!allowDefault) {
        parser.addDiagnostic({
          message: 'Default type parameters arent allowed here'});
      }

      parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.eq);
      def = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);
    } else if (requireDefault) {
      parser.addDiagnostic({
        message: 'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.'});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'FlowTypeParameter',
      default: def,
      name: name,
      variance: variance,
      bound: bound};
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, allowDefault) {
    parser.expectSyntaxEnabled('flow');

    const start = parser.getPosition();
    const params = [];

    parser.pushScope('TYPE', true);

    parser.expectRelational('<');

    let defaultRequired = false;

    do {
      const param = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameter(parser, allowDefault, defaultRequired);

      if (param.default) {
        defaultRequired = true;
      }

      params.push(param);

      if (!parser.isRelational('>') && !parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        break;
      }
    } while (!parser.isRelational('>'));

    parser.expectRelational('>');

    parser.popScope('TYPE');

    return {
      loc: parser.finishLoc(start),
      type: 'FlowTypeParameterDeclaration',
      params: params};
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterInstantiation(parser) {
    parser.expectSyntaxEnabled('flow');

    const start = parser.getPosition();
    const params = [];

    parser.pushScope('TYPE', true);

    parser.expectRelational('<');
    const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
    parser.state.noAnonFunctionType = false;

    while (!parser.isRelational('>')) {
      params.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser));

      if (!parser.isRelational('>') && !parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    parser.state.noAnonFunctionType = oldNoAnonFunctionType;
    parser.expectRelational('>');

    parser.popScope('TYPE');

    return {
      loc: parser.finishLoc(start),
      type: 'FlowTypeParameterInstantiation',
      params: params};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectPropertyKey(parser) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.num) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string)) {
      return ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'flow object property key');
    } else {
      return ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeIndexer(parser, start, isStatic, variance) {
    let id;
    let key;

    if (parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.colon) {
      id = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectPropertyKey(parser);
      key = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser);
    } else {
      id = undefined;
      key = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);
    }
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR);
    const value = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser);

    return {
      loc: parser.finishLoc(start),
      type: 'FlowObjectTypeIndexer',
      static: isStatic,
      key: key,
      id: id,
      value: value,
      variance: variance};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeMethodish(parser, start) {
    let typeParameters = undefined;

    if (parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, false);
    }

    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
    'function object method params');
    const params = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowFunctionTypeParams(parser);
    parser.expectClosing(openContext);
    const returnType = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser);

    return {
      loc: parser.finishLoc(start),
      type: 'FlowFunctionTypeAnnotation',
      params: params,
      typeParameters: typeParameters,
      returnType: returnType};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeCallProperty(parser, start, isStatic) {
    const valueNode = parser.getPosition();
    const value = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeMethodish(parser, valueNode);
    return {
      loc: parser.finishLoc(start),
      type: 'FlowObjectTypeCallProperty',
      static: isStatic,
      value: value};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectType(parser, opts) {
    const {allowExact: allowExact, allowSpread: allowSpread, allowProto: allowProto, allowInexact: allowInexact} = opts;
    let {allowStatic: allowStatic} = opts;

    parser.pushScope('TYPE', true);

    const start = parser.getPosition();

    const properties = [];

    let openContext;
    let exact;
    let inexact;
    if (allowExact && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceBarL)) {
      openContext = parser.expectOpening(
      ___$romejs$js_parser$src$tokenizer$types_ts$types.braceBarL,
      ___$romejs$js_parser$src$tokenizer$types_ts$types.braceBarR,
      'flow exact object');
      exact = true;
    } else {
      openContext = parser.expectOpening(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL, ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR, 'flow object');
      exact = false;
    }

    while (true) {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof) || parser.match(openContext.close)) {
        break;
      }

      let isStatic = false;
      let protoStart = undefined;

      if (allowProto && parser.isContextual('proto')) {
        const lookahead = parser.lookaheadState();

        if (lookahead.tokenType !== ___$romejs$js_parser$src$tokenizer$types_ts$types.colon &&
        lookahead.tokenType !== ___$romejs$js_parser$src$tokenizer$types_ts$types.question) {
          parser.next();
          protoStart = parser.state.startPos;
          allowStatic = false;
        }
      }

      if (allowStatic && parser.isContextual('static')) {
        const lookahead = parser.lookaheadState();

        if (lookahead.tokenType !== ___$romejs$js_parser$src$tokenizer$types_ts$types.colon &&
        lookahead.tokenType !== ___$romejs$js_parser$src$tokenizer$types_ts$types.question) {
          parser.next();
          isStatic = true;
        }
      }

      const variance = ___$romejs$js_parser$src$parser$flow_ts$parseFlowVariance(parser);

      if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL)) {
        if (protoStart !== undefined) {
          parser.unexpectedToken(protoStart);
        }

        if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL)) {
          if (variance) {
            parser.addDiagnostic({
              loc: variance.loc,
              message: 'Variance not allowed'});
          }

          properties.push(
          ___$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeInternalSlot(parser, start, isStatic));
        } else {
          properties.push(
          ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeIndexer(parser, start, isStatic, variance));
        }
      } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) || parser.isRelational('<')) {
        if (protoStart !== undefined) {
          parser.unexpectedToken(protoStart);
        }

        if (variance) {
          parser.addDiagnostic({
            loc: variance.loc,
            message: 'Variance not allowed'});
        }

        properties.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeCallProperty(parser, start, isStatic));
      } else {
        let kind = 'init';

        if (parser.isContextual('get') || parser.isContextual('set')) {
          const lookahead = parser.lookaheadState();
          if (lookahead.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.name ||
          lookahead.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.string ||
          lookahead.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.num) {
            const value = String(parser.state.tokenValue);
            if (value !== 'get' && value !== 'set') {
              throw new Error('Expected get or set as we already validated it above');
            }
            kind = value;
            parser.next();
          }
        }

        const propOrInexact = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeProperty(parser, {
          start: start,
          isStatic: isStatic,
          protoStart: protoStart,
          variance: variance,
          kind: kind,
          allowSpread: allowSpread,
          allowInexact: allowInexact});

        if (propOrInexact === undefined) {
          inexact = true;
        } else {
          properties.push(propOrInexact);
        }
      }

      ___$$priv$romejs$js_parser$src$parser$flow_ts$flowObjectTypeSemicolon(parser);
    }

    parser.expectClosing(openContext);
    parser.popScope('TYPE');

    return {
      loc: parser.finishLoc(start),
      type: 'FlowObjectTypeAnnotation',
      properties: properties,
      exact: exact,
      inexact: inexact};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeProperty(parser, opts) {
    const {
      start: start,
      isStatic: isStatic,
      protoStart: protoStart,
      variance: variance,
      kind: kind,
      allowSpread: allowSpread,
      allowInexact: allowInexact} = opts;

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
      if (!allowSpread) {
        parser.addDiagnostic({
          message: 'Spread operator cannot appear in class or interface definitions'});
      }

      if (protoStart !== undefined) {
        parser.unexpectedToken(protoStart);
      }

      if (variance) {
        parser.addDiagnostic({
          loc: variance.loc,
          message: 'Spread properties cannot have variance'});
      }

      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis);

      const isInexactToken = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma) || parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.semi);

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR)) {
        if (allowInexact) {
          return undefined;
        }

        parser.addDiagnostic({
          message: 'Explicit inexact syntax is only allowed inside inexact objects'});
      }

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceBarR)) {
        parser.addDiagnostic({
          message: 'Explicit inexact syntax cannot appear inside an explicit exact object type'});
      }

      if (isInexactToken) {
        parser.addDiagnostic({
          message: 'Explicit inexact syntax must appear at the end of an inexact object'});
      }

      const argument = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);
      return {
        loc: parser.finishLoc(start),
        type: 'FlowObjectTypeSpreadProperty',
        argument: argument};
    } else {
      const proto = protoStart !== undefined;
      const key = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectPropertyKey(parser);
      let value = undefined;
      let optional = false;

      if (parser.isRelational('<') || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
        if (protoStart !== undefined) {
          parser.unexpectedToken(protoStart);
        }

        if (variance) {
          parser.addDiagnostic({
            loc: variance.loc,
            message: 'Type methods can\'t have variance'});
        }

        value = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeMethodish(parser, start);

        if (kind === 'get' || kind === 'set') {
          ___$romejs$js_parser$src$parser$expression_ts$checkGetterSetterParamCount(parser, value, kind);
        }
      } else {
        if (kind !== 'init') {
          parser.unexpectedToken();
        }

        if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.question)) {
          optional = true;
        }
        value = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser);
      }

      return {
        loc: parser.finishLoc(start),
        type: 'FlowObjectTypeProperty',
        key: key,
        static: isStatic,
        kind: kind,
        value: value,
        variance: variance,
        optional: optional,
        proto: proto};
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$flowObjectTypeSemicolon(parser) {
    if (!parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.semi) &&
    !parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma) &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR) &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceBarR)) {
      parser.unexpectedToken();
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowQualifiedTypeIdentifier(parser, start = parser.getPosition(), id) {
    let node = id === undefined ? ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser) : id;

    while (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.dot)) {
      const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
      node = {
        loc: parser.finishLoc(start),
        type: 'FlowQualifiedTypeIdentifier',
        id: id,
        qualification: node};
    }

    return node;
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowGenericType(parser, start, _id) {
    let typeParameters = undefined;
    const id = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowQualifiedTypeIdentifier(parser, start, _id);

    if (parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterInstantiation(parser);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'FlowGenericTypeAnnotation',
      id: id,
      typeParameters: typeParameters};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeofType(parser) {
    const start = parser.getPosition();
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._typeof);
    const argument = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPrimaryType(parser);
    return {
      loc: parser.finishLoc(start),
      type: 'FlowTypeofTypeAnnotation',
      argument: argument};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTupleType(parser) {
    const start = parser.getPosition();
    const types = [];
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR,
    'flow tuple type');

    while (parser.state.index < parser.length && !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR)) {
      types.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser));
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR)) {
        break;
      }

      if (!parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        break;
      }
    }
    parser.expectClosing(openContext);
    return {
      loc: parser.finishLoc(start),
      type: 'FlowTupleTypeAnnotation',
      types: types};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowFunctionTypeParam(parser) {
    let name = undefined;
    let optional = false;
    let typeAnnotation = undefined;
    const start = parser.getPosition();
    const lh = parser.lookaheadState();
    if (lh.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.colon || lh.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.question) {
      name = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
      if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.question)) {
        optional = true;
      }
      typeAnnotation = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser);
    } else {
      typeAnnotation = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);
    }
    return {
      loc: parser.finishLoc(start),
      type: 'FlowFunctionTypeParam',
      name: name,
      optional: optional,
      typeAnnotation: typeAnnotation};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$reinterpretTypeAsFlowFunctionTypeParam(parser, type) {
    return {
      loc: parser.finishLoc(parser.getLoc(type).start),
      type: 'FlowFunctionTypeParam',
      name: undefined,
      optional: false,
      typeAnnotation: type};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowFunctionTypeParams(parser) {
    const params = [];

    while (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenR) && !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
      params.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowFunctionTypeParam(parser));

      if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenR) && !parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
      const param = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowFunctionTypeParam(parser);
      params.push({
        type: 'FlowFunctionTypeParamRest',
        loc: param.loc,
        param: param});
    }

    return params;
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$flowIdentToTypeAnnotation(parser, start, id) {
    switch (id.name) {
      case 'any':
        return {
          loc: parser.finishLoc(start),
          type: 'FlowAnyTypeAnnotation'};

      case 'void':
        return {
          loc: parser.finishLoc(start),
          type: 'FlowVoidTypeAnnotation'};

      case 'bool':
      case 'boolean':
        return {
          loc: parser.finishLoc(start),
          type: 'FlowBooleanTypeAnnotation'};

      case 'mixed':
        return {
          loc: parser.finishLoc(start),
          type: 'FlowMixedTypeAnnotation'};

      case 'empty':
        return {
          loc: parser.finishLoc(start),
          type: 'FlowEmptyTypeAnnotation'};

      case 'number':
        return {
          loc: parser.finishLoc(start),
          type: 'FlowNumberTypeAnnotation'};

      case 'string':
        return {
          loc: parser.finishLoc(start),
          type: 'FlowStringTypeAnnotation'};

      case 'bigint':
        return {
          loc: parser.finishLoc(start),
          type: 'FlowBigIntTypeAnnotation'};

      default:
        ___$$priv$romejs$js_parser$src$parser$flow_ts$checkNotUnderscore(parser, id);
        return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowGenericType(parser, start, id);}
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPrimaryType(parser) {
    const start = parser.getPosition();
    let type;
    let isGroupedType = false;
    const oldNoAnonFunctionType = parser.state.noAnonFunctionType;

    switch (parser.state.tokenType) {
      case ___$romejs$js_parser$src$tokenizer$types_ts$types.name:
        if (parser.isContextual('interface')) {
          return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowInterfaceType(parser);
        }

        return ___$$priv$romejs$js_parser$src$parser$flow_ts$flowIdentToTypeAnnotation(parser, start, ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser));

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL:
        return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectType(parser, {
          allowStatic: false,
          allowExact: false,
          allowSpread: true,
          allowProto: false,
          allowInexact: true});

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.braceBarL:
        return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectType(parser, {
          allowStatic: false,
          allowExact: true,
          allowSpread: true,
          allowProto: false,
          allowInexact: false});

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL:
        return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTupleType(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.relational:
        if (parser.state.tokenValue === '<') {
          const typeParameters = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, false);
          const openContext = parser.expectOpening(
          ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
          ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
          'flow function params');
          const params = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowFunctionTypeParams(parser);
          parser.expectClosing(openContext);

          parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.arrow);

          const returnType = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);

          return {
            loc: parser.finishLoc(start),
            type: 'FlowFunctionTypeAnnotation',
            typeParameters: typeParameters,
            params: params,
            returnType: returnType};
        }
        break;

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL:
        {
          const openContext = parser.expectOpening(
          ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
          ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
          'flow function params');

          if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenR) && !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
            if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
              const token = parser.lookaheadState().tokenType;
              isGroupedType = token !== ___$romejs$js_parser$src$tokenizer$types_ts$types.question && token !== ___$romejs$js_parser$src$tokenizer$types_ts$types.colon;
            } else {
              isGroupedType = true;
            }
          }

          if (isGroupedType) {
            parser.state.noAnonFunctionType = false;
            type = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);
            parser.state.noAnonFunctionType = oldNoAnonFunctionType;

            if (parser.state.noAnonFunctionType ||
            !(parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma) ||
            parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenR) &&
            parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.arrow)) {
              parser.expectClosing(openContext);
              return type;
            } else {
              parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma);
            }
          }

          let params;
          if (type) {
            const firstParam = ___$$priv$romejs$js_parser$src$parser$flow_ts$reinterpretTypeAsFlowFunctionTypeParam(parser, type);
            params = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowFunctionTypeParams(parser);
            params = [firstParam, ...params];
          } else {
            params = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowFunctionTypeParams(parser);
          }

          parser.expectClosing(openContext);
          parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.arrow);

          const returnType = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);

          return {
            loc: parser.finishLoc(start),
            type: 'FlowFunctionTypeAnnotation',
            typeParameters: undefined,
            params: params,
            returnType: returnType};
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.string:
        {
          const value = parser.state.tokenValue;
          parser.next();
          return {
            loc: parser.finishLoc(start),
            type: 'FlowStringLiteralTypeAnnotation',
            value: value};
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._true:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._false:
        {
          const value = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._true);
          parser.next();
          return {
            loc: parser.finishLoc(start),
            type: 'FlowBooleanLiteralTypeAnnotation',
            value: value};
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.plusMin:
        {
          if (parser.state.tokenValue === '-') {
            parser.next();
            if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.num)) {
              parser.addDiagnostic({
                message: `Unexpected token, expected "number"`});
              parser.next();
              return {
                loc: parser.finishLoc(start),
                type: 'FlowNumericLiteralTypeAnnotation',
                value: NaN};
            }

            const value = Number(parser.state.tokenValue);
            parser.next();
            return {
              loc: parser.finishLoc(start),
              type: 'FlowNumericLiteralTypeAnnotation',
              value: -value};
          }
          break;
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.num:
        {
          const value = Number(parser.state.tokenValue);
          parser.next();
          return {
            loc: parser.finishLoc(start),
            type: 'FlowNumericLiteralTypeAnnotation',
            value: value};
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._null:
        parser.next();
        return {
          type: 'FlowNullLiteralTypeAnnotation',
          loc: parser.finishLoc(start)};

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._this:
        parser.next();
        return {
          type: 'FlowThisTypeAnnotation',
          loc: parser.finishLoc(start)};

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.star:
        parser.next();
        return {
          type: 'FlowExistsTypeAnnotation',
          loc: parser.finishLoc(start)};

      default:
        if (parser.state.tokenType.keyword === 'typeof') {
          return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeofType(parser);
        } else if (parser.state.tokenType.keyword !== undefined) {
          const label = parser.state.tokenType.label;
          parser.next();
          return ___$romejs$js_parser$src$parser$expression_ts$createIdentifier(parser, start, label);
        }}

    parser.addDiagnostic({
      message: 'Unknown flow primarty type start'});
    return parser.createUnknownNode('flow primary type', start);
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPostfixType(parser) {
    const startPos = parser.state.startPos;
    let type = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPrimaryType(parser);
    while (!parser.canInsertSemicolon() && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL)) {
      const elementType = type;
      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL);
      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR);
      type = {
        loc: parser.finishLoc(startPos),
        type: 'FlowArrayTypeAnnotation',
        elementType: elementType};
    }
    return type;
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPrefixType(parser) {
    const start = parser.getPosition();
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.question)) {
      return {
        loc: parser.finishLoc(start),
        type: 'FlowNullableTypeAnnotation',
        typeAnnotation: ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPrefixType(parser)};
    } else {
      return ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPostfixType(parser);
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowAnonFunctionWithoutParens(parser) {
    const param = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowPrefixType(parser);

    if (!parser.state.noAnonFunctionType && parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.arrow)) {
      const start = parser.getLoc(param).start;
      const params = [___$$priv$romejs$js_parser$src$parser$flow_ts$reinterpretTypeAsFlowFunctionTypeParam(parser, param)];
      const rest = undefined;
      const returnType = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser);
      const typeParameters = undefined;
      return {
        loc: parser.finishLoc(start),
        type: 'FlowFunctionTypeAnnotation',
        params: params,
        rest: rest,
        returnType: returnType,
        typeParameters: typeParameters};
    }

    return param;
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowIntersectionType(parser) {
    const start = parser.getPosition();
    parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.bitwiseAND);

    const type = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowAnonFunctionWithoutParens(parser);
    const types = [type];
    while (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.bitwiseAND)) {
      types.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowAnonFunctionWithoutParens(parser));
    }

    if (types.length === 1) {
      return type;
    } else {
      return {
        loc: parser.finishLoc(start),
        type: 'FlowIntersectionTypeAnnotation',
        types: types};
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowUnionType(parser) {
    const start = parser.getPosition();
    parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.bitwiseOR);

    const type = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowIntersectionType(parser);
    const types = [type];

    while (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.bitwiseOR)) {
      types.push(___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowIntersectionType(parser));
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.logicalOR)) {
      parser.addDiagnostic({
        message: 'Unexpected ||, did you mean just |?'});
    }

    if (types.length === 1) {
      return type;
    } else {
      return {
        loc: parser.finishLoc(start),
        type: 'FlowUnionTypeAnnotation',
        types: types};
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowType(parser) {
    parser.pushScope('TYPE', true);
    const type = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowUnionType(parser);
    parser.popScope('TYPE');

    parser.state.exprAllowed =
    parser.state.exprAllowed || parser.state.noAnonFunctionType;
    return type;
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAnnotation(parser) {
    parser.expectSyntaxEnabled('flow');

    const start = parser.getPosition();
    const typeAnnotation = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser);
    return {
      loc: parser.finishLoc(start),
      type: 'FlowTypeAnnotation',
      typeAnnotation: typeAnnotation};
  }

  function ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAnnotatableIdentifier(parser, allowPrimitiveOverride = false) {
    const start = parser.getPosition();
    const ident = allowPrimitiveOverride ? ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser) : ___$romejs$js_parser$src$parser$flow_ts$parseFlowRestrictedIdentifier(parser);

    let typeAnnotation = undefined;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAnnotation(parser);
    }

    if (typeAnnotation === undefined) {
      return ident;
    } else {
      return Object.assign({}, ident, {
        loc: parser.finishLoc(start),
        typeAnnotation: typeAnnotation});
    }
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowClassImplemented(parser) {
    const implemented = [];

    do {
      const start = parser.getPosition();
      const id = ___$romejs$js_parser$src$parser$flow_ts$parseFlowRestrictedIdentifier(parser, true);

      let typeParameters;
      if (parser.isRelational('<')) {
        typeParameters = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterInstantiation(parser);
      }

      implemented.push({
        loc: parser.finishLoc(start),
        type: 'FlowClassImplements',
        id: id,
        typeParameters: typeParameters});
    } while (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma));

    return implemented;
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowVariance(parser) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.plusMin)) {
      parser.expectSyntaxEnabled('flow');
      const start = parser.getPosition();
      let kind;
      if (parser.state.tokenValue === '+') {
        kind = 'plus';
      } else {
        kind = 'minus';
      }
      parser.next();
      return {
        loc: parser.finishLoc(start),
        type: 'FlowVariance',
        kind: kind};
    }
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseAsyncArrowWithFlowTypeParameters(parser, startPos) {
    const {params: params, typeParameters: typeParameters} = ___$romejs$js_parser$src$parser$statement_ts$parseFunctionParams(parser);

    const {returnType: returnType, valid: valid, predicate: predicate} = ___$romejs$js_parser$src$parser$expression_ts$parseArrowHead(parser);
    if (!valid) {
      parser.addDiagnostic({
        message: 'Invalid async arrow with type parameters'});
      return undefined;
    }

    return Object.assign({}, ___$romejs$js_parser$src$parser$expression_ts$parseArrowExpression(parser, startPos, params, true), {
      returnType: returnType,
      predicate: predicate,
      typeParameters: typeParameters});
  }

  function ___$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeInternalSlot(parser, start, isStatic) {
    const id = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectPropertyKey(parser);
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR);
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR);

    let optional = false;
    let value;
    if (parser.isRelational('<') || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL)) {
      value = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowObjectTypeMethodish(parser, start);
    } else {
      optional = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.question);
      value = ___$$priv$romejs$js_parser$src$parser$flow_ts$parseFlowTypeInitialiser(parser);
    }

    return {
      type: 'FlowObjectTypeInternalSlot',
      optional: optional,
      value: value,
      id: id,
      loc: parser.finishLoc(start)};
  }

  // romejs/js-parser/src/parser/typescript.ts

  const ___$romejs$js_parser$src$parser$typescript_ts = {
    parseTSModifier: ___$romejs$js_parser$src$parser$typescript_ts$parseTSModifier,
    hasTSModifier: ___$romejs$js_parser$src$parser$typescript_ts$hasTSModifier,
    parseTSTypeParameters: ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeParameters,
    tryTSNextParseConstantContext: ___$romejs$js_parser$src$parser$typescript_ts$tryTSNextParseConstantContext,
    tsCheckLiteralForConstantContext: ___$romejs$js_parser$src$parser$typescript_ts$tsCheckLiteralForConstantContext,
    tryTSParseIndexSignature: ___$romejs$js_parser$src$parser$typescript_ts$tryTSParseIndexSignature,
    parseTSTypeOrTypePredicateAnnotation: ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation,
    parseTSTypeAnnotation: ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAnnotation,
    parseTSTypeAssertion: ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAssertion,
    parseTSHeritageClause: ___$romejs$js_parser$src$parser$typescript_ts$parseTSHeritageClause,
    parseTSInterfaceDeclaration: ___$romejs$js_parser$src$parser$typescript_ts$parseTSInterfaceDeclaration,
    parseTSTypeAliasDeclaration: ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAliasDeclaration,
    tsNextThenParseType: ___$romejs$js_parser$src$parser$typescript_ts$tsNextThenParseType,
    parseTSEnumDeclaration: ___$romejs$js_parser$src$parser$typescript_ts$parseTSEnumDeclaration,
    parseTSModuleBlock: ___$romejs$js_parser$src$parser$typescript_ts$parseTSModuleBlock,
    parseTSModuleOrNamespaceDeclaration: ___$romejs$js_parser$src$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration,
    parseTSAmbientExternalModuleDeclaration: ___$romejs$js_parser$src$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration,
    parseTSImportEqualsDeclaration: ___$romejs$js_parser$src$parser$typescript_ts$parseTSImportEqualsDeclaration,
    parseTSDeclare: ___$romejs$js_parser$src$parser$typescript_ts$parseTSDeclare,
    parseTSAbstractClass: ___$romejs$js_parser$src$parser$typescript_ts$parseTSAbstractClass,
    parseTSTypeArguments: ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeArguments,
    isTSDeclarationStart: ___$romejs$js_parser$src$parser$typescript_ts$isTSDeclarationStart,
    parseTSAccessModifier: ___$romejs$js_parser$src$parser$typescript_ts$parseTSAccessModifier,
    isTSAbstractClass: ___$romejs$js_parser$src$parser$typescript_ts$isTSAbstractClass,
    parseTSExport: ___$romejs$js_parser$src$parser$typescript_ts$parseTSExport};
  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$keywordTypeFromName(value) {
    switch (value) {
      case 'any':
        return 'TSAnyKeyword';

      case 'boolean':
        return 'TSBooleanKeyword';

      case 'bigint':
        return 'TSBigIntKeyword';

      case 'never':
        return 'TSNeverKeyword';

      case 'number':
        return 'TSNumberKeyword';

      case 'object':
        return 'TSObjectKeyword';

      case 'string':
        return 'TSStringKeyword';

      case 'symbol':
        return 'TSSymbolKeyword';

      case 'undefined':
        return 'TSUndefinedKeyword';

      case 'unknown':
        return 'TSUnknownKeyword';

      default:
        return undefined;}
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsIdentifier(parser) {
    return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsNextTokenCanFollowModifier(parser) {
    parser.next();
    return !parser.hasPrecedingLineBreak() &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenR) &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon) &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eq) &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.question) &&
    !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bang);
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSModifier(parser, allowedModifiers) {
    if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
      return undefined;
    }

    const modifier = String(parser.state.tokenValue);
    if (allowedModifiers.includes(modifier) &&
    ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryTSParse(parser, ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsNextTokenCanFollowModifier)) {
      return modifier;
    }
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$hasTSModifier(parser, allowedModifiers) {
    return ___$romejs$js_parser$src$parser$typescript_ts$parseTSModifier(parser, allowedModifiers) !== undefined;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsListTerminator(parser, kind) {
    switch (kind) {
      case 'EnumMembers':
      case 'TypeMembers':
        return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR);

      case 'HeritageClauseElement':
        return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL);

      case 'TupleElementTypes':
        return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR);

      case 'TypeParametersOrArguments':
        return parser.isRelational('>');}

    throw new Error('Unreachable');
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSList(parser, kind, parseElement) {
    const result = [];
    while (!___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsListTerminator(parser, kind)) {
      result.push(parseElement(parser));
    }
    return result;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSDelimitedList(parser, kind, parseElement) {
    const result = [];

    while (true) {
      if (___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsListTerminator(parser, kind)) {
        break;
      }

      const element = parseElement(parser);
      if (element == undefined) {
        break;
      }

      result.push(element);

      if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        continue;
      }

      if (___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsListTerminator(parser, kind)) {
        break;
      }

      if (parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    return result;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSBracketedList(parser, kind, parseElement, bracket, skipFirstToken) {
    if (!skipFirstToken) {
      if (bracket) {
        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL);
      } else {
        parser.expectRelational('<');
      }
    }

    const result = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSDelimitedList(parser, kind, parseElement);

    if (bracket) {
      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR);
    } else {
      parser.expectRelational('>');
    }

    return result;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSImportType(parser) {
    const start = parser.getPosition();
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._import);
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
    'ts import type');

    if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string)) {
      parser.addDiagnostic({
        message: 'Argument in a type import must be a string literal'});
    }

    const argument = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'ts import argument');
    parser.expectClosing(openContext);

    let qualifier;
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.dot)) {
      qualifier = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSEntityName(parser, true);
    }

    let typeParameters;
    if (parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeArguments(parser);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSImportType',
      argument: argument,
      qualifier: qualifier,
      typeParameters: typeParameters};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSEntityName(parser, allowReservedWords) {
    let entity = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(
    parser);
    while (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.dot)) {
      const start = parser.getLoc(entity).start;
      const right = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, allowReservedWords);
      entity = {
        loc: parser.finishLoc(start),
        type: 'TSQualifiedName',
        left: entity,
        right: right};
    }
    return entity;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeReference(parser) {
    const start = parser.getPosition();
    const typeName = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSEntityName(parser, false);
    let typeParameters;
    if (!parser.hasPrecedingLineBreak() && parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeArguments(parser);
    }
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeReference',
      typeName: typeName,
      typeParameters: typeParameters};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSThisTypePredicate(parser, lhs) {
    parser.next();
    const start = parser.getLoc(lhs).start;
    const parameterName = lhs;
    const typeAnnotation = ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAnnotation(parser, false);

    return {
      loc: parser.finishLoc(start),
      type: 'TSTypePredicate',
      parameterName: parameterName,
      typeAnnotation: typeAnnotation};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSThisTypeNode(parser) {
    const start = parser.getPosition();
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'TSThisType'};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeQuery(parser) {
    const start = parser.getPosition();
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._typeof);
    let exprName;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._import)) {
      exprName = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSImportType(parser);
    } else {
      exprName = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSEntityName(parser, true);
    }
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeQuery',
      exprName: exprName};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeParameter(parser) {
    const start = parser.getPosition();
    const name = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifierName(parser);
    const constraint = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsEatThenParseType(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types._extends);
    const _default = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsEatThenParseType(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.eq);
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeParameter',
      name: name,
      constraint: constraint,
      default: _default};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryParseTSTypeParameters(parser) {
    if (parser.isRelational('<')) {
      return ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeParameters(parser);
    }
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeParameters(parser) {
    const start = parser.getPosition();

    parser.expectRelational('<');

    const params = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSBracketedList(
    parser,
    'TypeParametersOrArguments',
    ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeParameter,
    false,
    true);

    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeParameterDeclaration',
      params: params};
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$tryTSNextParseConstantContext(parser) {
    if (parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types._const) {
      parser.next();
      return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeReference(parser);
    }
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, node) {
    switch (node.type) {
      case 'StringLiteral':
      case 'TemplateLiteral':
      case 'NumericLiteral':
      case 'BooleanLiteral':
      case 'SpreadElement':
      case 'ObjectMethod':
      case 'ObjectExpression':
        break;

      case 'ArrayExpression':
        for (const elem of node.elements) {
          if (elem) {
            ___$romejs$js_parser$src$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, elem);
          }
        }
        break;

      case 'ObjectProperty':
        ___$romejs$js_parser$src$parser$typescript_ts$tsCheckLiteralForConstantContext(
        parser,
        node.value);
        break;

      case 'UnaryExpression':
        ___$romejs$js_parser$src$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, node.argument);
        break;

      default:
        parser.addDiagnostic({
          loc: node.loc,
          message: 'Only literal values are allowed in constant contexts'});}
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsFillSignature(parser, returnToken) {
    const returnTokenRequired = returnToken === ___$romejs$js_parser$src$tokenizer$types_ts$types.arrow;
    const typeParameters = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryParseTSTypeParameters(parser);
    const parameters = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSBindingListForSignature(parser);

    let typeAnnotation;
    if (returnTokenRequired) {
      typeAnnotation = ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, returnToken);
    } else if (parser.match(returnToken)) {
      typeAnnotation = ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, returnToken);
    }

    return {
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSBindingListForSignature(parser) {
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
    'ts signature parameters');
    const patterns = ___$romejs$js_parser$src$parser$lval_ts$parseBindingListNonEmpty(parser, openContext);

    for (const pattern of patterns) {
      if (pattern.type !== 'Identifier' &&
      pattern.type !== 'RestElement' &&
      pattern.type !== 'ObjectPattern' &&
      pattern.type !== 'ArrayPattern') {
        parser.addDiagnostic({
          loc: pattern.loc,
          message: `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${pattern.type}`});
      }
    }

    return patterns;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeMemberSemicolon(parser) {
    if (!parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
      parser.semicolon();
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSConstructSignatureDeclaration(parser) {
    const start = parser.getPosition();
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._new);
    const signature = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsFillSignature(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
    parser.semicolon();
    return Object.assign({
      type: 'TSConstructSignatureDeclaration',
      loc: parser.finishLoc(start)}, signature);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSCallSignatureDeclaration(parser) {
    const start = parser.getPosition();
    const signature = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsFillSignature(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
    parser.semicolon();
    return Object.assign({
      type: 'TSCallSignatureDeclaration',
      loc: parser.finishLoc(start)}, signature);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsUnambiguouslyIndexSignature(parser) {
    parser.next();
    return parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.name) && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$tryTSParseIndexSignature(parser, start) {
    if (!(parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL) &&
    ___$$priv$romejs$js_parser$src$parser$typescript_ts$lookaheadTS(parser, ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsUnambiguouslyIndexSignature))) {
      return undefined;
    }

    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL);

    const idStart = parser.getPosition();
    const id = Object.assign({}, ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser), {
      typeAnnotation: ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAnnotation(parser),
      loc: parser.finishLoc(idStart)});

    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR);
    const parameters = [id];

    const typeAnnotation = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryTSParseTypeAnnotation(parser);

    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'TSIndexSignature',
      typeAnnotation: typeAnnotation,
      parameters: parameters};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSPropertyOrMethodSignature(parser, start, readonly) {
    const name = ___$romejs$js_parser$src$parser$expression_ts$parsePropertyName(parser);
    const optional = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.question);

    if (!readonly && (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) || parser.isRelational('<'))) {
      const signature = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsFillSignature(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
      ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeMemberSemicolon(parser);
      return Object.assign({
        loc: parser.finishLoc(start),
        type: 'TSMethodSignature',
        optional: optional}, signature, name);
    } else {
      const typeAnnotation = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryTSParseTypeAnnotation(parser);
      ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeMemberSemicolon(parser);
      return Object.assign({
        loc: parser.finishLoc(start),
        type: 'TSPropertySignature',
        optional: optional,
        readonly: readonly,
        typeAnnotation: typeAnnotation}, name);
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeMember(parser) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) || parser.isRelational('<')) {
      return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSCallSignatureDeclaration(parser);
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._new) &&
    ___$$priv$romejs$js_parser$src$parser$typescript_ts$lookaheadTS(parser, ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsStartOfConstructSignature)) {
      return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSConstructSignatureDeclaration(parser);
    }

    const start = parser.getPosition();
    const readonly = ___$romejs$js_parser$src$parser$typescript_ts$hasTSModifier(parser, ['readonly']);

    const idx = ___$romejs$js_parser$src$parser$typescript_ts$tryTSParseIndexSignature(parser, start);
    if (idx) {
      return Object.assign({}, idx, {
        readonly: readonly});
    }

    return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSPropertyOrMethodSignature(parser, start, readonly);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsStartOfConstructSignature(parser) {
    parser.next();
    return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) || parser.isRelational('<');
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeLiteral(parser) {
    const start = parser.getPosition();
    const members = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSObjectTypeMembers(parser);
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeLiteral',
      members: members};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSObjectTypeMembers(parser) {
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
    'ts object type members');
    const members = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSList(parser, 'TypeMembers', ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeMember);
    parser.expectClosing(openContext);
    return members;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsStartOfMappedType(parser) {
    parser.next();

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.plusMin)) {
      return parser.isContextual('readonly');
    }

    if (parser.isContextual('readonly')) {
      parser.next();
    }

    if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL)) {
      return false;
    }

    parser.next();

    if (!___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsIdentifier(parser)) {
      return false;
    }

    parser.next();

    return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._in);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSMappedTypeParameter(parser) {
    const start = parser.getPosition();
    const name = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifierName(parser);
    const constraint = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsExpectThenParseType(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types._in);
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeParameter',
      name: name,
      constraint: constraint};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$toPlusMin(val) {
    const str = String(val);
    if (str === '+' || str === '-') {
      return str;
    } else {
      throw new Error('Expected +/-');
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSMappedType(parser) {
    const start = parser.getPosition();

    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
    'ts mapped type');

    let readonly;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.plusMin)) {
      readonly = ___$$priv$romejs$js_parser$src$parser$typescript_ts$toPlusMin(parser.state.tokenValue);
      parser.next();
      parser.expectContextual('readonly');
    } else if (parser.eatContextual('readonly')) {
      readonly = true;
    }

    const paramOpenContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR,
    'ts mapped type parameter');
    const typeParameter = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSMappedTypeParameter(parser);
    parser.expectClosing(paramOpenContext);

    let optional;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.plusMin)) {
      optional = ___$$priv$romejs$js_parser$src$parser$typescript_ts$toPlusMin(parser.state.tokenValue);
      parser.next();
      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.question);
    } else if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.question)) {
      optional = true;
    }

    const typeAnnotation = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryTSParseType(parser);
    parser.semicolon();
    parser.expectClosing(openContext);

    return {
      loc: parser.finishLoc(start),
      type: 'TSMappedType',
      typeParameter: typeParameter,
      typeAnnotation: typeAnnotation,
      optional: optional,
      readonly: readonly};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTupleType(parser) {
    const start = parser.getPosition();
    const elementTypes = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSBracketedList(
    parser,
    'TupleElementTypes',
    ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTupleElementType,
    true,
    false);

    let seenOptionalElement = false;
    for (const elementNode of elementTypes) {
      if (elementNode.type === 'TSOptionalType') {
        seenOptionalElement = true;
      } else if (seenOptionalElement && elementNode.type !== 'TSRestType') {
        parser.addDiagnostic({
          loc: elementNode.loc,
          message: 'A required element cannot follow an optional element.'});
      }
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSTupleType',
      elementTypes: elementTypes};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTupleElementType(parser) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
      const start = parser.getPosition();
      parser.next();
      const typeAnnotation = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSType(parser);
      ___$romejs$js_parser$src$parser$lval_ts$hasCommaAfterRest(parser);
      return {
        loc: parser.finishLoc(start),
        type: 'TSRestType',
        typeAnnotation: typeAnnotation};
    }

    const typeAnnotation = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSType(parser);

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.question)) {
      const start = parser.getLoc(typeAnnotation).start;
      return {
        loc: parser.finishLoc(start),
        type: 'TSOptionalType',
        typeAnnotation: typeAnnotation};
    }

    return typeAnnotation;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSParenthesizedType(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
    'ts parenthesized type');
    const typeAnnotation = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSType(parser);
    parser.expectClosing(openContext);
    return {
      loc: parser.finishLoc(start),
      type: 'TSParenthesizedType',
      typeAnnotation: typeAnnotation};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSFunctionType(parser) {
    const start = parser.getPosition();
    const signature = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsFillSignature(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.arrow);
    return Object.assign({
      type: 'TSFunctionType',
      loc: parser.finishLoc(start)}, signature);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSConstructorType(parser) {
    const start = parser.getPosition();
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._new);
    const signature = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsFillSignature(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.arrow);
    return Object.assign({
      type: 'TSConstructorType',
      loc: parser.finishLoc(start)}, signature);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSLiteralTypeNode(parser) {
    const start = parser.getPosition();

    const literal = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'ts literal type');
    if (literal.type !== 'StringLiteral' &&
    literal.type !== 'NumericLiteral' &&
    literal.type !== 'BooleanLiteral') {
      parser.addDiagnostic({
        loc: literal.loc,
        message: 'Not a valid TS literal type'});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSLiteralType',
      literal: literal};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTemplateLiteralType(parser) {
    const start = parser.getPosition();
    const templateNode = ___$romejs$js_parser$src$parser$expression_ts$parseTemplate(parser, false);
    if (templateNode.expressions.length > 0) {
      parser.addDiagnostic({
        loc: parser.getLoc(templateNode.expressions[0]),
        message: 'Template literal types cannot have any substitution'});
    }

    const literal = templateNode;
    return {
      loc: parser.finishLoc(start),
      type: 'TSLiteralType',
      literal: literal};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSNonArrayType(parser) {
    switch (parser.state.tokenType) {
      case ___$romejs$js_parser$src$tokenizer$types_ts$types.name:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._void:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._null:
        {
          let type;
          if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._void)) {
            type = 'TSVoidKeyword';
          } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._null)) {
            type = 'TSNullKeyword';
          } else {
            type = ___$$priv$romejs$js_parser$src$parser$typescript_ts$keywordTypeFromName(String(parser.state.tokenValue));
          }
          if (type !== undefined && parser.lookaheadState().tokenType !== ___$romejs$js_parser$src$tokenizer$types_ts$types.dot) {
            const start = parser.getPosition();
            parser.next();
            return {
              loc: parser.finishLoc(start),
              type: type};
          }
          return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeReference(parser);
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.string:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types.num:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._true:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._false:
        return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSLiteralTypeNode(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.plusMin:
        if (parser.state.tokenValue === '-') {
          const start = parser.getPosition();
          if (parser.lookaheadState().tokenType !== ___$romejs$js_parser$src$tokenizer$types_ts$types.num) {
            throw parser.unexpected();
          }

          const literal = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeUnary(parser, 'ts literal type');
          return {
            loc: parser.finishLoc(start),
            type: 'TSLiteralType',
            literal: literal};
        }
        break;

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._this:
        {
          const thisKeyword = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSThisTypeNode(parser);
          if (parser.isContextual('is') && !parser.hasPrecedingLineBreak()) {
            return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSThisTypePredicate(parser, thisKeyword);
          } else {
            return thisKeyword;
          }
        }

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._typeof:
        return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeQuery(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._import:
        return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSImportType(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL:
        return ___$$priv$romejs$js_parser$src$parser$typescript_ts$lookaheadTS(parser, ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsStartOfMappedType) ? ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSMappedType(parser) : ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeLiteral(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL:
        return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTupleType(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL:
        return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSParenthesizedType(parser);

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.backQuote:
        return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTemplateLiteralType(parser);}

    parser.addDiagnostic({
      message: 'Unknown TS non array type start'});

    return parser.createUnknownNode('ts non array type start');
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSArrayTypeOrHigher(parser) {
    let type = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSNonArrayType(parser);
    while (!parser.hasPrecedingLineBreak() && parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL)) {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR)) {
        const start = parser.getLoc(type).start;
        const elementType = type;
        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR);
        type = {
          loc: parser.finishLoc(start),
          type: 'TSArrayType',
          elementType: elementType};
      } else {
        const start = parser.getLoc(type).start;
        const objectType = type;
        const indexType = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSType(parser);
        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR);
        type = {
          loc: parser.finishLoc(start),
          type: 'TSIndexedAccessType',
          objectType: objectType,
          indexType: indexType};
      }
    }
    return type;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeOperator(parser, operator) {
    const start = parser.getPosition();
    parser.expectContextual(operator);

    const typeAnnotation = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeOperatorOrHigher(parser);

    const node = {
      loc: parser.finishLoc(start),
      type: 'TSTypeOperator',
      typeAnnotation: typeAnnotation,
      operator: operator};

    if (operator === 'readonly') {
      ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsCheckTypeAnnotationForReadOnly(parser, node);
    }

    return node;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsCheckTypeAnnotationForReadOnly(parser, node) {
    switch (node.typeAnnotation.type) {
      case 'TSTupleType':
      case 'TSArrayType':
        return undefined;

      default:
        parser.addDiagnostic({
          loc: node.loc,
          message: '\'readonly\' type modifier is only permitted on array and tuple literal types.'});
        break;}
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSInferType(parser) {
    const inferStart = parser.getPosition();
    parser.expectContextual('infer');

    const start = parser.getPosition();
    const typeParameter = {
      type: 'TSTypeParameter',
      name: ___$romejs$js_parser$src$parser$expression_ts$parseIdentifierName(parser),
      loc: parser.finishLoc(start)};

    return {
      loc: parser.finishLoc(inferStart),
      type: 'TSInferType',
      typeParameter: typeParameter};
  }

  const ___$$priv$romejs$js_parser$src$parser$typescript_ts$TS_TYPE_OPERATORS = ['keyof', 'unique', 'readonly'];

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeOperatorOrHigher(parser) {
    let operator;

    for (const op of ___$$priv$romejs$js_parser$src$parser$typescript_ts$TS_TYPE_OPERATORS) {
      if (parser.isContextual(op)) {
        operator = op;
        break;
      }
    }

    if (operator !== undefined) {
      return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeOperator(parser, operator);
    } else if (parser.isContextual('infer')) {
      return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSInferType(parser);
    } else {
      return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSArrayTypeOrHigher(parser);
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSUnionOrIntersectionType(parser, kind, parseConstituentType, operator) {
    parser.eat(operator);
    let type = parseConstituentType(parser);
    if (parser.match(operator)) {
      const types = [type];
      while (parser.eat(operator)) {
        types.push(parseConstituentType(parser));
      }
      const start = parser.getLoc(type).start;
      type = {
        loc: parser.finishLoc(start),
        type: kind,
        types: types};
    }
    return type;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSIntersectionTypeOrHigher(parser) {
    return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSUnionOrIntersectionType(
    parser,
    'TSIntersectionType',
    ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypeOperatorOrHigher,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.bitwiseAND);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSUnionTypeOrHigher(parser) {
    return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSUnionOrIntersectionType(
    parser,
    'TSUnionType',
    ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSIntersectionTypeOrHigher,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.bitwiseOR);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsStartOfFunctionType(parser) {
    if (parser.isRelational('<')) {
      return true;
    }
    return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) &&
    ___$$priv$romejs$js_parser$src$parser$typescript_ts$lookaheadTS(parser, ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsUnambiguouslyStartOfFunctionType);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsSkipParameterStart(parser) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._this)) {
      parser.next();
      return true;
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL)) {
      let braceStackCounter = 1;
      parser.next();

      while (braceStackCounter > 0) {
        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL)) {
          braceStackCounter++;
        } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR)) {
          braceStackCounter--;
        }
        parser.next();
      }
      return true;
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL)) {
      let braceStackCounter = 1;
      parser.next();

      while (braceStackCounter > 0) {
        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL)) {
          braceStackCounter++;
        } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR)) {
          braceStackCounter--;
        }
        parser.next();
      }
      return true;
    }

    return false;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsUnambiguouslyStartOfFunctionType(parser) {
    parser.next();
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenR) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis)) {
      return true;
    }
    if (___$$priv$romejs$js_parser$src$parser$typescript_ts$tsSkipParameterStart(parser)) {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon) ||
      parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma) ||
      parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.question) ||
      parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eq)) {
        return true;
      }
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenR)) {
        parser.next();
        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.arrow)) {
          return true;
        }
      }
    }
    return false;
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, returnToken) {
    const start = parser.getPosition();
    parser.pushScope('TYPE', true);
    parser.expect(returnToken);

    let typePredicateVariable;
    if (___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsIdentifier(parser)) {
      typePredicateVariable = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryTSParse(parser, ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypePredicatePrefix);
    }
    if (typePredicateVariable === undefined) {
      parser.popScope('TYPE');
      return ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAnnotation(parser, false, start);
    }

    const type = ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAnnotation(parser, false);

    const typePredicateStart = parser.getLoc(typePredicateVariable).start;
    parser.popScope('TYPE');

    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeAnnotation',
      typeAnnotation: {
        loc: parser.finishLoc(typePredicateStart),
        type: 'TSTypePredicate',
        parameterName: typePredicateVariable,
        typeAnnotation: type}};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryTSParseTypeAnnotation(parser) {
    return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon) ? ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAnnotation(parser) : undefined;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryTSParseType(parser) {
    return ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsEatThenParseType(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSTypePredicatePrefix(parser) {
    const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
    if (parser.isContextual('is') && !parser.hasPrecedingLineBreak()) {
      parser.next();
      return id;
    }
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAnnotation(parser, eatColon = true, start = parser.getPosition()) {
    parser.pushScope('TYPE', true);

    if (eatColon) {
      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
    }

    const typeAnnotation = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSType(parser);
    parser.popScope('TYPE');

    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeAnnotation',
      typeAnnotation: typeAnnotation};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSType(parser) {
    parser.pushScope('TYPE', true);

    const type = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSNonConditionalType(parser);
    if (parser.hasPrecedingLineBreak() || !parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types._extends)) {
      parser.popScope('TYPE');
      return type;
    }

    const start = parser.getLoc(type).start;
    const checkType = type;
    const extendsType = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSNonConditionalType(parser);
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.question);
    const trueType = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSType(parser);
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
    const falseType = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSType(parser);
    parser.popScope('TYPE');
    return {
      loc: parser.finishLoc(start),
      type: 'TSConditionalType',
      checkType: checkType,
      extendsType: extendsType,
      trueType: trueType,
      falseType: falseType};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSNonConditionalType(parser) {
    if (___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsStartOfFunctionType(parser)) {
      return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSFunctionType(parser);
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._new)) {
      return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSConstructorType(parser);
    }

    return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSUnionTypeOrHigher(parser);
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAssertion(parser) {
    const start = parser.getPosition();
    const _const = ___$romejs$js_parser$src$parser$typescript_ts$tryTSNextParseConstantContext(parser);
    const typeAnnotation = _const || ___$romejs$js_parser$src$parser$typescript_ts$tsNextThenParseType(parser);
    parser.expectRelational('>');

    const expression = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeUnary(parser, 'ts type assertion');
    if (_const) {
      ___$romejs$js_parser$src$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, expression);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeAssertion',
      expression: expression,
      typeAnnotation: typeAnnotation};
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSHeritageClause(parser, descriptor) {
    const originalStart = parser.state.startPos;
    const delimitedList = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSDelimitedList(
    parser,
    'HeritageClauseElement',
    ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSExpressionWithTypeArguments);

    if (!delimitedList.length) {
      parser.addDiagnostic({
        start: originalStart,
        message: `'${descriptor}' list cannot be empty.`});
    }

    return delimitedList;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSExpressionWithTypeArguments(parser) {
    const start = parser.getPosition();

    const expression = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSEntityName(parser, false);

    let typeParameters;
    if (parser.isRelational('<')) {
      typeParameters = ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeArguments(parser);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSExpressionWithTypeArguments',
      expression: expression,
      typeParameters: typeParameters};
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSInterfaceDeclaration(parser, start) {
    parser.pushScope('TYPE', true);
    const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
    const typeParameters = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryParseTSTypeParameters(parser);

    let _extends;
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types._extends)) {
      _extends = ___$romejs$js_parser$src$parser$typescript_ts$parseTSHeritageClause(parser, 'extends');
    }

    const bodyStart = parser.getPosition();
    const bodyItems = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSObjectTypeMembers(parser);
    const body = {
      loc: parser.finishLoc(bodyStart),
      type: 'TSInterfaceBody',
      body: bodyItems};

    parser.popScope('TYPE');
    return {
      loc: parser.finishLoc(start),
      type: 'TSInterfaceDeclaration',
      id: id,
      body: body,
      typeParameters: typeParameters,
      extends: _extends};
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAliasDeclaration(parser, start) {
    const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
    const typeParameters = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryParseTSTypeParameters(parser);
    const typeAnnotation = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsExpectThenParseType(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.eq);
    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeAliasDeclaration',
      id: id,
      typeParameters: typeParameters,
      typeAnnotation: typeAnnotation};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsInNoContext(parser, cb) {
    const oldContext = parser.state.context;
    parser.state.context = [oldContext[0]];
    const res = cb(parser);
    parser.state.context = oldContext;
    return res;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsEatThenParseType(parser, token) {
    if (parser.match(token)) {
      return ___$romejs$js_parser$src$parser$typescript_ts$tsNextThenParseType(parser);
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsExpectThenParseType(parser, token) {
    return ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsDoThenParseType(parser, () => {
      parser.expect(token);
    });
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$tsNextThenParseType(parser) {
    return ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsDoThenParseType(parser, () => parser.next());
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsDoThenParseType(parser, cb) {
    cb();
    return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSType(parser);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSEnumMember(parser) {
    const start = parser.getPosition();

    const id = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string) ? ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'ts enum member id') : ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);

    let initializer;
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.eq)) {
      initializer = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'ts enum member initializer');
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSEnumMember',
      initializer: initializer,
      id: id};
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSEnumDeclaration(parser, start, isConst) {
    const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);

    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
    'ts enum declaration');

    const members = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSDelimitedList(
    parser,
    'EnumMembers',
    ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSEnumMember);
    parser.expectClosing(openContext);

    return {
      loc: parser.finishLoc(start),
      type: 'TSEnumDeclaration',
      members: members,
      id: id,
      const: isConst};
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSModuleBlock(parser) {
    const start = parser.getPosition();

    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
    'ts module block');

    const {body: body} = ___$romejs$js_parser$src$parser$statement_ts$parseBlockOrModuleBlockBody(
    parser,
    false,
    true,
    openContext);
    return {
      loc: parser.finishLoc(start),
      type: 'TSModuleBlock',
      body: body};
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, start) {
    const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);

    let body;
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.dot)) {
      body = ___$romejs$js_parser$src$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, parser.getPosition());
    } else {
      body = ___$romejs$js_parser$src$parser$typescript_ts$parseTSModuleBlock(parser);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSModuleDeclaration',
      id: id,
      body: body};
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(parser, start) {
    let global;
    let id;
    if (parser.isContextual('global')) {
      global = true;
      id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
    } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string)) {
      id = ___$romejs$js_parser$src$parser$expression_ts$parseStringLiteral(parser);
    } else {
      throw parser.unexpected();
    }

    let body;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL)) {
      body = ___$romejs$js_parser$src$parser$typescript_ts$parseTSModuleBlock(parser);
    } else {
      parser.semicolon();
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSModuleDeclaration',
      id: id,
      global: global,
      body: body};
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSImportEqualsDeclaration(parser, start, isExport = false) {
    const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.eq);

    const moduleReference = ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSModuleReference(parser);
    parser.semicolon();

    return {
      loc: parser.finishLoc(start),
      type: 'TSImportEqualsDeclaration',
      id: id,
      moduleReference: moduleReference};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsExternalModuleReference(parser) {
    return parser.isContextual('require') &&
    parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSModuleReference(parser) {
    return ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsIsExternalModuleReference(parser) ? ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSExternalModuleReference(parser) : ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSEntityName(parser, false);
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSExternalModuleReference(parser) {
    const start = parser.getPosition();
    parser.expectContextual('require');
    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR,
    'ts external module reference');

    let expression;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string)) {
      expression = ___$romejs$js_parser$src$parser$expression_ts$parseStringLiteral(parser);
    } else {
      parser.addDiagnostic({
        message: 'Invalid TS external module reference expression'});

      ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'ts external module reference expression');

      expression = {
        loc: parser.finishLoc(start),
        type: 'StringLiteral',
        value: ''};
    }

    parser.expectClosing(openContext);

    return {
      loc: parser.finishLoc(start),
      type: 'TSExternalModuleReference',
      expression: expression};
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$lookaheadTS(parser, f) {
    const state = parser.cloneState();
    const res = f(parser);
    parser.state = state;
    return res;
  }

  function ___$$priv$romejs$js_parser$src$parser$typescript_ts$tryTSParse(parser, f) {
    const state = parser.cloneState();
    const result = f(parser);
    if (result === undefined || result === false) {
      parser.state = state;
      return undefined;
    } else {
      return result;
    }
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSDeclare(parser, start) {
    let starttype = parser.state.tokenType;
    let kind;
    if (parser.isContextual('let')) {
      starttype = ___$romejs$js_parser$src$tokenizer$types_ts$types._var;
      kind = 'let';
    }

    if (starttype === ___$romejs$js_parser$src$tokenizer$types_ts$types._const &&
    parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._const) &&
    parser.isLookaheadContextual('enum')) {
      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._const);
      parser.expectContextual('enum');
      return Object.assign({
        declare: true}, ___$romejs$js_parser$src$parser$typescript_ts$parseTSEnumDeclaration(parser, start, true));
    }

    switch (starttype) {
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._function:
        return Object.assign({}, ___$romejs$js_parser$src$parser$statement_ts$parseFunctionStatement(parser, start), {
          declare: true});

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._class:
        return Object.assign({}, ___$romejs$js_parser$src$parser$classes_ts$parseClass(
        parser,
        start,
        true,
        false), {
          declare: true});

      case ___$romejs$js_parser$src$tokenizer$types_ts$types._const:
      case ___$romejs$js_parser$src$tokenizer$types_ts$types._var:
        kind =
        kind === undefined ? ___$romejs$js_parser$src$parser$statement_ts$assertVarKind(String(parser.state.tokenValue)) : kind;
        return Object.assign({
          declare: true}, ___$romejs$js_parser$src$parser$statement_ts$parseVarStatement(parser, start, kind));

      case ___$romejs$js_parser$src$tokenizer$types_ts$types.name:
        {
          const value = String(parser.state.tokenValue);
          if (value === 'global') {
            return Object.assign({
              declare: true}, ___$romejs$js_parser$src$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(parser, start));
          } else if (___$romejs$js_parser$src$parser$typescript_ts$isTSDeclarationStart(parser)) {
            const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
            const decl = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeExpressionStatement(parser, start, id);

            return Object.assign({}, decl, {
              declare: true});
          }
        }}

    parser.addDiagnostic({
      message: 'Unknown typescript declare start'});
    return parser.createUnknownNode('typescript declare start', start);
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSAbstractClass(parser, start, optionalId) {
    const node = ___$romejs$js_parser$src$parser$classes_ts$parseClass(parser, start, true, optionalId);
    if (node.type !== 'ClassDeclaration') {
      throw new Error('Passed isStatement above');
    }
    return Object.assign({}, node, {
      abstract: true});
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeArguments(parser) {
    const start = parser.getPosition();
    parser.pushScope('TYPE', true);

    const params = ___$$priv$romejs$js_parser$src$parser$typescript_ts$tsInNoContext(parser, () => {
      parser.expectRelational('<');
      return ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSDelimitedList(
      parser,
      'TypeParametersOrArguments',
      ___$$priv$romejs$js_parser$src$parser$typescript_ts$parseTSType);
    });

    parser.state.exprAllowed = false;
    parser.popScope('TYPE');
    parser.expectRelational('>');

    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeParameterInstantiation',
      params: params};
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$isTSDeclarationStart(parser) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
      switch (parser.state.tokenValue) {
        case 'abstract':
        case 'declare':
        case 'enum':
        case 'interface':
        case 'module':
        case 'namespace':
        case 'type':
          return true;}
    }

    return false;
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSAccessModifier(parser) {
    return ___$romejs$js_parser$src$parser$typescript_ts$parseTSModifier(parser, ['public', 'protected', 'private']);
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$isTSAbstractClass(parser) {
    return parser.isContextual('abstract') &&
    parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types._class;
  }

  function ___$romejs$js_parser$src$parser$typescript_ts$parseTSExport(parser, start) {
    if (!parser.isSyntaxEnabled('ts')) {
      return undefined;
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._import)) {
      parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._import);
      return ___$romejs$js_parser$src$parser$typescript_ts$parseTSImportEqualsDeclaration(parser, start, true);
    }

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.eq)) {
      const expression = ___$romejs$js_parser$src$parser$expression_ts$parseExpression(parser, 'ts export assignment');
      parser.semicolon();
      return {
        loc: parser.finishLoc(start),
        type: 'TSExportAssignment',
        expression: expression};
    }

    if (parser.eatContextual('as')) {
      parser.expectContextual('namespace');
      const id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
      parser.semicolon();
      return {
        loc: parser.finishLoc(start),
        type: 'TSNamespaceExportDeclaration',
        id: id};
    }
  }

  // romejs/js-parser/src/parser/classes.ts

  const ___$romejs$js_parser$src$parser$classes_ts = {
    parseClass: ___$romejs$js_parser$src$parser$classes_ts$parseClass};
  function ___$romejs$js_parser$src$parser$classes_ts$parseClass(parser, start, isStatement, optionalId) {
    parser.pushScope('METHOD', false);
    parser.pushScope('STRICT', true);

    parser.next();
    const {id: id, typeParameters: typeParameters} = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassId(parser, isStatement, optionalId);
    const {superClass: superClass, superTypeParameters: superTypeParameters, implemented: implemented} = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassSuper(
    parser);

    parser.pushScope('CLASS', superClass === undefined ? 'normal' : 'derived');

    const body = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassBody(parser);

    parser.popScope('CLASS');
    parser.popScope('STRICT');
    parser.popScope('METHOD');

    if (isStatement) {
      return {
        loc: parser.finishLoc(start),
        type: 'ClassDeclaration',
        id: id,
        body: body,
        typeParameters: typeParameters,
        superClass: superClass,
        superTypeParameters: superTypeParameters,
        implements: implemented};
    } else {
      return {
        loc: parser.finishLoc(start),
        type: 'ClassExpression',
        id: id,
        body: body,
        typeParameters: typeParameters,
        superClass: superClass,
        superTypeParameters: superTypeParameters,
        implements: implemented};
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$isClassProperty(parser) {
    return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.bang) ||
    parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon) ||
    parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eq) ||
    parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.semi) ||
    parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR);
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$isClassMethod(parser) {
    return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.parenL) || parser.isRelational('<');
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$isNonstaticConstructor(parser, name) {
    return !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon) &&
    name.computed === false &&
    name.static === false &&
    (name.key.type === 'Identifier' && name.key.name === 'constructor' ||
    name.key.type === 'StringLiteral' && name.key.value === 'constructor');
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassBody(parser) {
    parser.pushScope('STRICT', true);
    parser.state.classLevel++;

    const state = {hadConstructor: false};

    const body = [];

    const openContext = parser.expectOpening(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL, ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR, 'class body');

    while (true) {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
        break;
      }

      if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.semi)) {
        continue;
      }

      body.push(___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassMember(parser, state));
    }

    parser.expectClosing(openContext);

    parser.state.classLevel--;
    parser.popScope('STRICT');

    return body;
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassMember(parser, state) {
    const start = parser.getPosition();
    const escapePosition = parser.state.escapePosition;

    let accessibility;
    if (parser.isSyntaxEnabled('ts')) {
      accessibility = ___$romejs$js_parser$src$parser$typescript_ts$parseTSAccessModifier(parser);
    }

    let isStatic = false;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name) && parser.state.tokenValue === 'static') {
      const key = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);

      const name = {
        static: false,
        variance: undefined,
        typeAnnotation: undefined,
        computed: false,
        key: key,
        accessibility: accessibility,
        optional: false,
        abstract: false,
        readonly: false};

      if (___$$priv$romejs$js_parser$src$parser$classes_ts$isClassMethod(parser)) {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassMethod(parser, {
          start: start,
          name: name,
          kind: 'method',
          isStatic: false,
          isAsync: false,
          isGenerator: false,
          isConstructor: false});
      }

      if (___$$priv$romejs$js_parser$src$parser$classes_ts$isClassProperty(parser)) {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassProperty(parser, start, name);
      }

      if (escapePosition !== undefined) {
        parser.addDiagnostic({
          index: escapePosition,
          message: 'No escapes allowed in static contextual keyword'});
      }

      isStatic = true;
    }

    return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassMemberWithIsStatic(
    parser,
    start,
    state,
    isStatic,
    accessibility);
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassMemberWithIsStatic(parser, start, state, isStatic, accessibility) {
    let abstract = false;
    let readonly = false;

    const mod = ___$romejs$js_parser$src$parser$typescript_ts$parseTSModifier(parser, ['abstract', 'readonly']);
    switch (mod) {
      case 'readonly':
        readonly = true;
        abstract = ___$romejs$js_parser$src$parser$typescript_ts$hasTSModifier(parser, ['abstract']);
        break;

      case 'abstract':
        abstract = true;
        readonly = ___$romejs$js_parser$src$parser$typescript_ts$hasTSModifier(parser, ['readonly']);
        break;}

    const nameOpts = {
      static: isStatic,
      accessibility: accessibility,
      readonly: readonly,
      abstract: abstract};

    if (!abstract && !isStatic && accessibility === undefined) {
      const indexSignature = ___$romejs$js_parser$src$parser$typescript_ts$tryTSParseIndexSignature(parser, start);
      if (indexSignature) {
        return Object.assign({}, indexSignature, {
          readonly: readonly});
      }
    }

    if (readonly) {
      const name = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPropertyName(parser, nameOpts);
      if (name.key.type === 'PrivateName') {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPrivateProperty(parser, start, name);
      } else {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$pushClassProperty(parser, start, name);
      }
    }

    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.star)) {
      const name = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPropertyName(parser, nameOpts);

      if (name.key.type === 'PrivateName') {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPrivateMethod(parser, {
          start: start,
          name: name,
          isGenerator: true,
          isAsync: false,
          kind: 'method'});
      }

      if (___$$priv$romejs$js_parser$src$parser$classes_ts$isNonstaticConstructor(parser, name)) {
        parser.addDiagnostic({
          loc: name.key.loc,
          message: 'Constructor can\'t be a generator'});
      }

      return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassMethod(parser, {
        start: start,
        name: name,
        kind: 'method',
        isStatic: false,
        isGenerator: true,
        isAsync: false,
        isConstructor: false});
    }

    const escapePosition = parser.state.escapePosition;
    const name = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPropertyName(parser, nameOpts);
    const {key: key} = name;

    if (___$$priv$romejs$js_parser$src$parser$classes_ts$isClassMethod(parser)) {
      if (key.type === 'PrivateName') {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPrivateMethod(parser, {
          start: start,
          name: name,
          isGenerator: false,
          isAsync: false,
          kind: 'method'});
      }

      const isConstructor = ___$$priv$romejs$js_parser$src$parser$classes_ts$isNonstaticConstructor(parser, name);

      let kind = 'method';
      if (isConstructor) {
        kind = 'constructor';

        if (state.hadConstructor && !parser.isSyntaxEnabled('ts')) {
          parser.addDiagnostic({
            loc: key.loc,
            message: 'Duplicate constructor in the same class'});
        }
        state.hadConstructor = true;
      }

      return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassMethod(parser, {
        start: start,
        name: name,
        kind: kind,
        isStatic: isStatic,
        isGenerator: false,
        isAsync: false,
        isConstructor: isConstructor});
    }

    if (___$$priv$romejs$js_parser$src$parser$classes_ts$isClassProperty(parser)) {
      if (key.type === 'PrivateName') {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPrivateProperty(parser, start, name);
      } else {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$pushClassProperty(parser, start, name);
      }
    }

    if (key.type === 'Identifier' &&
    key.name === 'async' &&
    !parser.isLineTerminator()) {
      parser.banUnicodeEscape(escapePosition, 'async');

      const isGenerator = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.star);
      if (isGenerator) {
        parser.next();
      }

      const name = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPropertyName(parser, nameOpts);

      if (name.key.type === 'PrivateName') {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPrivateMethod(parser, {
          start: start,
          name: name,
          isGenerator: isGenerator,
          isAsync: true,
          kind: 'method'});
      } else {
        const method = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassMethod(parser, {
          start: start,
          name: name,
          kind: 'method',
          isStatic: isStatic,
          isGenerator: isGenerator,
          isAsync: true,
          isConstructor: false});

        if (___$$priv$romejs$js_parser$src$parser$classes_ts$isNonstaticConstructor(parser, name)) {
          parser.addDiagnostic({
            loc: key.loc,
            message: 'Constructor can\'t be an async function'});
        }

        return method;
      }
    }

    if (key.type === 'Identifier' &&
    (key.name === 'get' || key.name === 'set') &&
    !(parser.isLineTerminator() && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.star))) {
      const kind = key.name;
      parser.banUnicodeEscape(escapePosition, kind);

      const name = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPropertyName(parser, nameOpts);

      if (name.key.type === 'PrivateName') {
        const method = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPrivateMethod(parser, {
          start: start,
          name: name,
          isGenerator: false,
          isAsync: false,
          kind: kind});
        ___$romejs$js_parser$src$parser$expression_ts$checkGetterSetterParamCount(parser, method, method.kind);
        return method;
      } else {
        const method = ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassMethod(parser, {
          start: start,
          name: name,
          kind: kind,
          isStatic: false,
          isGenerator: false,
          isAsync: false,
          isConstructor: false});

        if (___$$priv$romejs$js_parser$src$parser$classes_ts$isNonstaticConstructor(parser, name)) {
          parser.addDiagnostic({
            loc: name.key.loc,
            message: 'Constructor can\'t have get/set modifier'});
        }

        ___$romejs$js_parser$src$parser$expression_ts$checkGetterSetterParamCount(parser, method, method.kind);
        return method;
      }
    }

    if (parser.isLineTerminator()) {
      if (key.type === 'PrivateName') {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPrivateProperty(parser, start, name);
      } else {
        return ___$$priv$romejs$js_parser$src$parser$classes_ts$pushClassProperty(parser, start, name);
      }
    }

    parser.addDiagnostic({
      message: 'Unknown class property start'});
    return parser.createUnknownNode('class property start');
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPropertyName(parser, opts) {
    let typeAnnotation;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotation(parser);
    }

    const {variance: variance, computed: computed, key: key} = ___$romejs$js_parser$src$parser$expression_ts$parsePropertyName(parser);

    if (computed === false &&
    opts.static === true &&
    (key.type === 'Identifier' && key.name === 'prototype' ||
    key.type === 'StringLiteral' && key.value === 'prototype')) {
      parser.addDiagnostic({
        loc: key.loc,
        message: 'Classes may not have static property named prototype'});
    }

    if (key.type === 'PrivateName' && key.id.name === 'constructor') {
      parser.addDiagnostic({
        loc: key.loc,
        message: 'Classes may not have a private field named \'#constructor\''});
    }

    let optional = false;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.question)) {
      optional = true;

      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'Optional syntax but ts is not enabled'});
      }

      parser.next();
    }

    return Object.assign({
      key: key,
      computed: computed,
      variance: variance,
      typeAnnotation: typeAnnotation,
      optional: optional}, opts);
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$pushClassProperty(parser, start, name) {
    if (___$$priv$romejs$js_parser$src$parser$classes_ts$isNonstaticConstructor(parser, name)) {
      parser.addDiagnostic({
        loc: name.key.loc,
        message: 'Classes may not have a non-static field named \'constructor\''});
    }

    return ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassProperty(parser, start, name);
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassMethod(parser, opts) {
    const {start: start, name: name, kind: kind, isGenerator: isGenerator, isAsync: isAsync, isConstructor: isConstructor} = opts;

    if (name.variance !== undefined) {
      parser.addDiagnostic({
        loc: name.variance.loc,
        message: 'variance not allowed here'});
    }

    const typeParameters = ___$romejs$js_parser$src$parser$type_systems_ts$maybeParseTypeParameters(parser);

    const method = Object.assign({}, ___$romejs$js_parser$src$parser$expression_ts$parseMethod(parser, {
      kind: kind,
      isClass: true,
      isGenerator: isGenerator,
      isAsync: isAsync,
      isConstructor: isConstructor}), {
      loc: parser.finishLoc(start),
      kind: kind,
      computed: name.computed,
      key: name.key,
      static: name.static,
      variance: name.variance,
      typeParameters: typeParameters});

    if (method.body === undefined) {
      return Object.assign({}, method, {
        type: 'TSDeclareMethod'});
    } else {
      return Object.assign({}, method, {
        type: 'ClassMethod'});
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPrivateMethod(parser, opts) {
    const {start: start, name: name, isGenerator: isGenerator, isAsync: isAsync, kind: kind} = opts;

    if (name.variance !== undefined) {
      parser.addDiagnostic({
        loc: name.variance.loc,
        message: 'variance not allowed here'});
    }

    const typeParameters = ___$romejs$js_parser$src$parser$type_systems_ts$maybeParseTypeParameters(parser);
    const method = ___$romejs$js_parser$src$parser$expression_ts$parseMethod(parser, {
      kind: kind,
      isClass: true,
      isGenerator: isGenerator,
      isAsync: isAsync,
      isConstructor: false});
    ___$romejs$invariant$src$index_ts$default(method.body !== undefined, 'Expected body');

    return Object.assign({}, method, {
      loc: parser.finishLoc(start),
      computed: name.computed,
      key: name.key,
      static: name.static,
      variance: name.variance,
      kind: kind,
      type: 'ClassPrivateMethod',
      typeParameters: typeParameters});
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassPrivateProperty(parser, start, name) {
    parser.pushScope('CLASS_PROPERTY', true);

    let typeAnnotation;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotation(parser);
    }

    const value = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.eq) ? ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'class private property value') : undefined;
    parser.semicolon();
    parser.popScope('CLASS_PROPERTY');

    const {key: key} = name;
    ___$romejs$invariant$src$index_ts$default(key.type === 'PrivateName', 'expected key to be PrivateName');

    return Object.assign({
      loc: parser.finishLoc(start)}, name, {
      key: key,
      type: 'ClassPrivateProperty',
      value: value,
      typeAnnotation: typeAnnotation});
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassProperty(parser, start, name) {
    let definite;
    if (!name.optional && parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.bang)) {
      definite = true;

      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'Definite syntax but ts is not enabled'});
      }
    }

    let typeAnnotation;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotation(parser);
    }

    parser.pushScope('CLASS_PROPERTY', true);

    let value;
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eq)) {
      parser.next();
      value = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'class property value');
    }
    parser.semicolon();

    parser.popScope('CLASS_PROPERTY');

    return Object.assign({
      loc: parser.finishLoc(start)}, name, {
      type: 'ClassProperty',
      definite: definite,
      typeAnnotation: typeAnnotation,
      value: value});
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassId(parser, isStatement, optionalId) {
    let idAllowed = true;

    if ((isStatement === false || optionalId === true) &&
    parser.isContextual('implements')) {
      idAllowed = false;
    }

    let id;
    if (idAllowed) {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
        id = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
      } else {
        if (optionalId === true || isStatement === false) {
          id = undefined;
        } else {
          parser.addDiagnostic({
            message: 'A class name is required'});
        }
      }
    }

    const typeParameters = ___$romejs$js_parser$src$parser$type_systems_ts$maybeParseTypeParameters(parser, true);
    return {id: id, typeParameters: typeParameters};
  }

  function ___$$priv$romejs$js_parser$src$parser$classes_ts$parseClassSuper(parser) {
    let superClass = parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types._extends) ? ___$romejs$js_parser$src$parser$expression_ts$parseExpressionWithPossibleSubscripts(parser, 'class heritage') : undefined;
    let superTypeParameters;

    if (superClass !== undefined) {
      superTypeParameters = ___$romejs$js_parser$src$parser$type_systems_ts$maybeParseTypeArguments(parser);
    }

    let implemented;
    if (parser.isContextual('implements')) {
      parser.next();
      implemented = ___$romejs$js_parser$src$parser$type_systems_ts$parseClassImplements(parser);
    }

    return {superClass: superClass, superTypeParameters: superTypeParameters, implemented: implemented};
  }

  // romejs/js-parser/src/parser/type-systems.ts

  const ___$romejs$js_parser$src$parser$type_systems_ts = {
    isTypeSystemEnabled: ___$romejs$js_parser$src$parser$type_systems_ts$isTypeSystemEnabled,
    parseClassImplements: ___$romejs$js_parser$src$parser$type_systems_ts$parseClassImplements,
    parseTypeAnnotation: ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotation,
    parseInterface: ___$romejs$js_parser$src$parser$type_systems_ts$parseInterface,
    parseDeclare: ___$romejs$js_parser$src$parser$type_systems_ts$parseDeclare,
    parseTypeAnnotationAndPredicate: ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotationAndPredicate,
    parseTypeAlias: ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAlias,
    parseTypeParameters: ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeParameters,
    maybeParseTypeParameters: ___$romejs$js_parser$src$parser$type_systems_ts$maybeParseTypeParameters,
    parseTypeArguments: ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeArguments,
    parseTypeCallArguments: ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeCallArguments,
    maybeParseTypeArguments: ___$romejs$js_parser$src$parser$type_systems_ts$maybeParseTypeArguments,
    parseTypeExpressionStatement: ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeExpressionStatement,
    typeCastToParameter: ___$romejs$js_parser$src$parser$type_systems_ts$typeCastToParameter};
  function ___$romejs$js_parser$src$parser$type_systems_ts$isTypeSystemEnabled(parser) {
    return parser.isSyntaxEnabled('flow') || parser.isSyntaxEnabled('ts');
  }

  function ___$$priv$romejs$js_parser$src$parser$type_systems_ts$parseFlowOrTS(parser, flow, ts) {
    if (parser.isSyntaxEnabled('flow')) {
      return flow(parser);
    } else if (parser.isSyntaxEnabled('ts')) {
      return ts(parser);
    } else {
      if (!___$romejs$js_parser$src$parser$type_systems_ts$isTypeSystemEnabled(parser)) {
        parser.addDiagnostic({
          message: `Expected Flow or TypeScript syntax to be enabled for this`});
      }

      const branches = parser.createBranch();
      branches.add(flow);
      branches.add(ts);
      return branches.pick();
    }
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$parseClassImplements(parser) {
    return ___$$priv$romejs$js_parser$src$parser$type_systems_ts$parseFlowOrTS(parser, ___$romejs$js_parser$src$parser$flow_ts$parseFlowClassImplemented, () => ___$romejs$js_parser$src$parser$typescript_ts$parseTSHeritageClause(parser, 'implements'));
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotation(parser) {
    return ___$$priv$romejs$js_parser$src$parser$type_systems_ts$parseFlowOrTS(parser, ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAnnotation, () => ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAnnotation(parser, true));
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$parseInterface(parser, start) {
    parser.addDiagnosticFilter({
      message: 'interface is a reserved word',
      start: start});

    return ___$$priv$romejs$js_parser$src$parser$type_systems_ts$parseFlowOrTS(
    parser,
    () => ___$romejs$js_parser$src$parser$flow_ts$parseFlowInterface(parser, start),
    () => ___$romejs$js_parser$src$parser$typescript_ts$parseTSInterfaceDeclaration(parser, start));
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$parseDeclare(parser, start) {
    return ___$$priv$romejs$js_parser$src$parser$type_systems_ts$parseFlowOrTS(
    parser,
    () => ___$romejs$js_parser$src$parser$flow_ts$parseFlowDeclare(parser, start),
    () => ___$romejs$js_parser$src$parser$typescript_ts$parseTSDeclare(parser, start));
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAnnotationAndPredicate(parser) {
    return ___$$priv$romejs$js_parser$src$parser$type_systems_ts$parseFlowOrTS(
    parser,
    () => {
      const start = parser.getPosition();
      const [type, predicate] = ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAndPredicateInitialiser(parser);

      const returnType = {
        loc: parser.finishLoc(start),
        type: 'FlowTypeAnnotation',
        typeAnnotation: type};

      return [returnType, predicate];
    },
    () => {
      return [___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.colon), undefined];
    });
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAlias(parser, start) {
    return ___$$priv$romejs$js_parser$src$parser$type_systems_ts$parseFlowOrTS(
    parser,
    () => ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeAlias(parser, start),
    () => ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeAliasDeclaration(parser, start));
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeParameters(parser, allowDefault = false) {
    return ___$$priv$romejs$js_parser$src$parser$type_systems_ts$parseFlowOrTS(
    parser,
    () => ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, allowDefault),
    ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeParameters);
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$maybeParseTypeParameters(parser, allowDefault) {
    if (parser.isRelational('<')) {
      return ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeParameters(parser, allowDefault);
    }
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeArguments(parser) {
    return ___$$priv$romejs$js_parser$src$parser$type_systems_ts$parseFlowOrTS(
    parser,
    ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterInstantiation,
    ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeArguments);
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeCallArguments(parser) {
    return ___$$priv$romejs$js_parser$src$parser$type_systems_ts$parseFlowOrTS(
    parser,
    ___$romejs$js_parser$src$parser$flow_ts$parseFlowTypeParameterInstantiationCallOrNew,
    ___$romejs$js_parser$src$parser$typescript_ts$parseTSTypeArguments);
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$maybeParseTypeArguments(parser) {
    if (parser.isRelational('<')) {
      return ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeArguments(parser);
    }
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeExpressionStatement(parser, start, expr) {
    if (expr.type !== 'Identifier') {
      return undefined;
    }

    if (parser.isSyntaxEnabled('ts') && parser.hasPrecedingLineBreak()) {
      return undefined;
    }

    switch (expr.name) {
      case 'declare':
        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._class) ||
        parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name) ||
        parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._function) ||
        parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._const) ||
        parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._var) ||
        parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._export)) {
          return ___$romejs$js_parser$src$parser$type_systems_ts$parseDeclare(parser, start);
        } else {
          break;
        }

      case 'interface':
        return ___$romejs$js_parser$src$parser$type_systems_ts$parseInterface(parser, start);

      case 'type':
        return ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAlias(parser, start);

      case 'opaque':
        return ___$romejs$js_parser$src$parser$flow_ts$parseFlowOpaqueType(parser, start, false);

      case 'abstract':
        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._class)) {
          return ___$romejs$js_parser$src$parser$typescript_ts$parseTSAbstractClass(parser, start, false);
        } else {
          break;
        }

      case 'enum':
        {
          if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
            return ___$romejs$js_parser$src$parser$typescript_ts$parseTSEnumDeclaration(parser, start, false);
          } else {
            break;
          }
        }

      case 'module':
        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string)) {
          return ___$romejs$js_parser$src$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(parser, start);
        } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name) && !parser.isLineTerminator()) {
          return ___$romejs$js_parser$src$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, start);
        } else {
          break;
        }

      case 'namespace':
        if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
          return undefined;
        }

        return ___$romejs$js_parser$src$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, start);

      case 'global':
        if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL)) {
          const global = true;
          const id = expr;
          const body = ___$romejs$js_parser$src$parser$typescript_ts$parseTSModuleBlock(parser);
          return {
            loc: parser.finishLoc(start),
            type: 'TSModuleDeclaration',
            global: global,
            id: id,
            body: body};
        }}
  }

  function ___$romejs$js_parser$src$parser$type_systems_ts$typeCastToParameter(parser, node) {
    node.expression.typeAnnotation = node.typeAnnotation;

    return Object.assign({}, node.expression, {
      typeAnnotation: node.typeAnnotation});
  }

  // romejs/js-parser/src/parser/modules.ts

  const ___$romejs$js_parser$src$parser$modules_ts = {
    parseExport: ___$romejs$js_parser$src$parser$modules_ts$parseExport,
    parseImport: ___$romejs$js_parser$src$parser$modules_ts$parseImport};
  function ___$romejs$js_parser$src$parser$modules_ts$parseExport(parser, start) {
    const tsNode = ___$romejs$js_parser$src$parser$typescript_ts$parseTSExport(parser, start);
    if (tsNode !== undefined) {
      return tsNode;
    }

    let exportKind = 'value';
    let source;
    let declaration;
    let specifiers;

    if (___$$priv$romejs$js_parser$src$parser$modules_ts$shouldParseExportStar(parser)) {
      return ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportStar(parser, start);
    } else if (___$$priv$romejs$js_parser$src$parser$modules_ts$isExportDefaultSpecifier(parser)) {
      let specifiers = [];

      const defStart = parser.getPosition();
      const defExported = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);

      specifiers.push({
        loc: parser.finishLoc(defStart),
        type: 'ExportDefaultSpecifier',
        exported: defExported});

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.comma) &&
      parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.star) {
        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma);
        const specifierStart = parser.getPosition();
        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.star);
        parser.expectContextual('as');
        const exported = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
        specifiers.push({
          loc: parser.finishLoc(specifierStart),
          type: 'ExportNamespaceSpecifier',
          exported: exported});
      } else {
        specifiers = [...specifiers, ...___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportSpecifiersMaybe(parser)];
      }

      source = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportFrom(parser, true);
    } else if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types._default)) {
      const declaration = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportDefaultExpression(parser);
      ___$$priv$romejs$js_parser$src$parser$modules_ts$checkExport(parser, specifiers, declaration, true, true);

      return {
        loc: parser.finishLoc(start),
        type: 'ExportDefaultDeclaration',
        declaration: declaration};
    } else if (___$$priv$romejs$js_parser$src$parser$modules_ts$shouldParseExportDeclaration(parser)) {
      ({declaration: declaration, source: source, specifiers: specifiers, exportKind: exportKind} = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportDeclaration(
      parser));
    } else if (parser.isContextual('async') &&
    !___$romejs$js_parser$src$parser$statement_ts$isAsyncFunctionDeclarationStart(parser)) {
      const next = parser.lookaheadState();

      parser.addDiagnostic({
        start: next.startPos,
        end: next.endPos,
        message: 'Started with `export async` so we expected to receive an async function but no function keyword was found'});
      declaration = undefined;
      specifiers = [];
      source = undefined;
    } else {
      declaration = undefined;
      specifiers = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportSpecifiers(parser);
      source = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportFrom(parser, false);
    }

    ___$$priv$romejs$js_parser$src$parser$modules_ts$checkExport(
    parser,
    specifiers,
    declaration,
    true,
    false,
    source !== undefined);

    if (declaration !== undefined) {
      if (declaration.type !== 'VariableDeclaration' &&
      declaration.type !== 'ClassDeclaration' &&
      declaration.type !== 'FunctionDeclaration' &&
      declaration.type !== 'TSModuleDeclaration' &&
      declaration.type !== 'TSEnumDeclaration' &&
      declaration.type !== 'FlowInterfaceDeclaration' &&
      declaration.type !== 'TSTypeAliasDeclaration' &&
      declaration.type !== 'TSInterfaceDeclaration' &&
      declaration.type !== 'TSDeclareFunction' &&
      declaration.type !== 'FlowOpaqueType' &&
      declaration.type !== 'FlowTypeAlias') {
        parser.addDiagnostic({
          loc: declaration.loc,
          message: 'Invalid export declaration'});
        return parser.createUnknownNode('export declaration', start);
      }
    }

    return {
      loc: parser.finishLoc(start),
      type: 'ExportNamedDeclaration',
      exportKind: exportKind,
      specifiers: specifiers,
      source: source,
      declaration: declaration};
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportDefaultExpression(parser) {
    if (parser.isSyntaxEnabled('ts')) {
      if (___$romejs$js_parser$src$parser$typescript_ts$isTSAbstractClass(parser)) {
        const start = parser.getPosition();
        parser.next();
        return ___$romejs$js_parser$src$parser$typescript_ts$parseTSAbstractClass(parser, start, true);
      }

      if (parser.state.tokenValue === 'interface' && !parser.isLineTerminator()) {
        const start = parser.getPosition();
        parser.next();
        return ___$romejs$js_parser$src$parser$typescript_ts$parseTSInterfaceDeclaration(parser, start);
      }
    }

    const start = parser.getPosition();
    const isAsync = ___$romejs$js_parser$src$parser$statement_ts$isAsyncFunctionDeclarationStart(parser);
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types._function) || isAsync) {
      if (isAsync) {
        parser.eatContextual('async');
        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types._function);
      }

      return ___$romejs$js_parser$src$parser$statement_ts$parseFunction(parser, {
        start: start,
        isStatement: true,
        isAsync: isAsync,
        requiredStatementId: false});
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._class)) {
      return ___$romejs$js_parser$src$parser$classes_ts$parseClass(parser, start, true, true);
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._const) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._var) || ___$romejs$js_parser$src$parser$statement_ts$isLetStart(parser)) {
      parser.addDiagnostic({
        message: 'Only expressions, functions or classes are allowed as the `default` export.'});
    }

    const res = ___$romejs$js_parser$src$parser$expression_ts$parseMaybeAssign(parser, 'export default declaration');
    parser.semicolon();
    return res;
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportDeclaration(parser) {
    if (parser.isContextual('type')) {
      const start = parser.getPosition();
      parser.next();

      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL)) {
        const specifiers = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportSpecifiers(parser);
        const source = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportFrom(parser, false);
        return {
          exportKind: 'type',
          specifiers: specifiers,
          source: source};
      } else {
        return {
          exportKind: 'type',
          declaration: ___$romejs$js_parser$src$parser$type_systems_ts$parseTypeAlias(parser, start)};
      }
    }

    if (parser.isContextual('opaque')) {
      const declarationNode = parser.getPosition();
      parser.next();

      return {
        exportKind: 'type',
        declaration: ___$romejs$js_parser$src$parser$flow_ts$parseFlowOpaqueType(parser, declarationNode, false)};
    }

    if (parser.isContextual('interface')) {
      const declarationNode = parser.getPosition();
      parser.next();
      return {
        exportKind: 'type',
        declaration: ___$romejs$js_parser$src$parser$type_systems_ts$parseInterface(parser, declarationNode)};
    }

    return {
      exportKind: 'value',
      declaration: ___$romejs$js_parser$src$parser$statement_ts$parseStatement(parser)};
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$isExportDefaultSpecifier(parser) {
    const lookahead = parser.lookaheadState();
    if (lookahead.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.comma ||
    lookahead.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.name && lookahead.tokenValue === 'from') {
      return true;
    }

    if (parser.isSyntaxEnabled('ts') && ___$romejs$js_parser$src$parser$typescript_ts$isTSDeclarationStart(parser)) {
      return false;
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name) &&
    (parser.state.tokenValue === 'type' ||
    parser.state.tokenValue === 'interface' ||
    parser.state.tokenValue == 'opaque')) {
      return false;
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name)) {
      return parser.state.tokenValue !== 'async' && parser.state.tokenValue !== 'let';
    }

    if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._default)) {
      return false;
    }

    return false;
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportSpecifiersMaybe(parser) {
    if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
      return ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportSpecifiers(parser);
    } else {
      return [];
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportFrom(parser, expect) {
    let source;

    if (parser.eatContextual('from')) {
      const isString = parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string);

      source = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'export from');

      if (!isString) {
        parser.addDiagnostic({
          loc: source.loc,
          message: 'Import from only allows strings'});

        source = {
          type: 'StringLiteral',
          value: '',
          loc: source.loc};
      }
    } else if (expect) {
      parser.addDiagnostic({
        message: 'Expected `from` for an export node'});

      source = {
        type: 'StringLiteral',
        value: '',
        loc: parser.finishLoc(parser.getPosition())};
    }

    parser.semicolon();

    return source;
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$shouldParseExportStar(parser) {
    return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.star) ||
    parser.isContextual('type') &&
    parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.star;
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportStar(parser, start) {
    let exportKind;
    if (parser.eatContextual('type')) {
      exportKind = 'type';
    }

    parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.star);

    if (parser.isContextual('as')) {
      const {source: source, specifiers: specifiers} = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportNamespace(parser, exportKind);
      return {
        loc: parser.finishLoc(start),
        type: 'ExportNamedDeclaration',
        exportKind: exportKind,
        specifiers: specifiers,
        source: source};
    } else {
      const source = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportFrom(parser, true);
      ___$romejs$invariant$src$index_ts$default(
      source !== undefined,
      'Passed `true` above which expects there to be a string');
      return {
        loc: parser.finishLoc(start),
        type: 'ExportAllDeclaration',
        exportKind: exportKind,
        source: source};
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportNamespace(parser, exportKind) {
    if (exportKind === 'type') {
      parser.addDiagnostic({
        message: 'Can\'t have a type export namespacer specifier'});
    }

    const specifierStart = parser.state.lastStartPos;
    parser.next();
    const exported = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);

    let specifiers = [];

    specifiers.push({
      loc: parser.finishLoc(specifierStart),
      type: 'ExportNamespaceSpecifier',
      exported: exported});

    specifiers = [...specifiers, ...___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportSpecifiersMaybe(parser)];

    const source = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportFrom(parser, true);

    return {source: source, specifiers: specifiers};
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$shouldParseExportDeclaration(parser) {
    return ___$romejs$js_parser$src$parser$typescript_ts$isTSDeclarationStart(parser) ||
    parser.isContextual('type') ||
    parser.isContextual('interface') ||
    parser.isContextual('opaque') ||
    parser.state.tokenType.keyword === 'var' ||
    parser.state.tokenType.keyword === 'const' ||
    parser.state.tokenType.keyword === 'function' ||
    parser.state.tokenType.keyword === 'class' ||
    ___$romejs$js_parser$src$parser$statement_ts$isLetStart(parser) ||
    ___$romejs$js_parser$src$parser$statement_ts$isAsyncFunctionDeclarationStart(parser) ||
    parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.at);
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$checkExport(parser, specifiers, declaration, checkNames = false, isDefault = false, isFrom = false) {
    if (checkNames === false) {
      return undefined;
    }

    if (isDefault) {
      if (declaration !== undefined) {
        ___$$priv$romejs$js_parser$src$parser$modules_ts$checkDuplicateExports(parser, declaration, 'default');
      }
      return undefined;
    }

    if (specifiers !== undefined && specifiers.length > 0) {
      for (const specifier of specifiers) {
        ___$$priv$romejs$js_parser$src$parser$modules_ts$checkDuplicateExports(parser, specifier, specifier.exported.name);

        if (specifier.type === 'ExportSpecifier') {
          const {local: local} = specifier;
          if (!isFrom && local !== undefined) {
            ___$romejs$js_parser$src$parser$expression_ts$checkReservedWord(
            parser,
            local.name,
            parser.getLoc(local),
            true,
            false);
          }
        }
      }
      return undefined;
    }

    if (declaration !== undefined) {
      if (declaration.type === 'FunctionDeclaration' ||
      declaration.type === 'ClassDeclaration') {
        ___$romejs$invariant$src$index_ts$default(declaration.id !== undefined, 'expected declaration.id');
        ___$$priv$romejs$js_parser$src$parser$modules_ts$checkDuplicateExports(parser, declaration, declaration.id.name);
      }

      if (declaration.type === 'VariableDeclaration') {
        for (const node of ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(declaration)) {
          ___$$priv$romejs$js_parser$src$parser$modules_ts$checkDuplicateExports(parser, node, node.name);
        }
      }
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$checkDuplicateExports(parser, node, name) {
    if (parser.isSyntaxEnabled('ts')) {
      return undefined;
    }

    const existing = parser.state.exportedIdentifiers.get(name);
    if (existing !== undefined) {
      parser.addDiagnostic({
        loc: node.loc,
        message: name === 'default' ? 'Only one default export allowed per module.' : `\`${name}\` has already been exported. Exported identifiers must be unique.`,
        advice: [{
          type: 'log',
          category: 'info',
          message: 'First defined here'}, {
          type: 'frame',
          filename: parser.filename,
          start: existing.start,
          end: existing.end}]});
    }

    parser.state.exportedIdentifiers.set(name, parser.getLoc(node));
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$parseExportSpecifiers(parser) {
    const specifiers = [];
    let first = true;

    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
    'export specifiers');

    while (true) {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma);
        if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      const start = parser.getPosition();
      const local = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);
      const exported = parser.eatContextual('as') ? ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true) : parser.cloneNode(local);
      specifiers.push({
        loc: parser.finishLoc(start),
        type: 'ExportSpecifier',
        local: local,
        exported: exported});
    }

    return specifiers;
  }

  function ___$romejs$js_parser$src$parser$modules_ts$parseImport(parser, start) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name) && parser.lookaheadState().tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.eq) {
      return ___$romejs$js_parser$src$parser$typescript_ts$parseTSImportEqualsDeclaration(parser, start);
    }

    let specifiers;
    let source;
    let importKind;

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string)) {
      specifiers = [];
      source = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'import source');
    } else {
      ({specifiers: specifiers, importKind: importKind} = ___$$priv$romejs$js_parser$src$parser$modules_ts$parseImportSpecifiers(parser, start));

      if (parser.expectContextual('from') && parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string)) {
        source = ___$romejs$js_parser$src$parser$expression_ts$parseExpressionAtom(parser, 'import source');
      } else {
        parser.addDiagnostic({
          message: 'import missing a source'});

        source = {
          type: 'StringLiteral',
          value: '',
          loc: parser.finishLoc(start)};
      }
    }

    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'ImportDeclaration',
      specifiers: specifiers,
      source: source,
      importKind: importKind};
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$shouldParseDefaultImport(parser, kind) {
    if (___$romejs$js_parser$src$parser$flow_ts$hasTypeImportKind(kind)) {
      return ___$romejs$js_parser$src$parser$flow_ts$isMaybeDefaultImport(parser.state);
    } else {
      return parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name);
    }
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$parseImportSpecifierLocal(parser, kind, contextDescription) {
    const local = ___$romejs$js_parser$src$parser$flow_ts$hasTypeImportKind(kind) ? ___$romejs$js_parser$src$parser$flow_ts$parseFlowRestrictedIdentifier(parser, true) : ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);

    ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, local, true, undefined, contextDescription);
    return local;
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$parseImportSpecifiers(parser, start) {
    let importKind = undefined;

    const lh = parser.lookaheadState();
    if (lh.tokenType !== ___$romejs$js_parser$src$tokenizer$types_ts$types.name ||
    lh.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.name && lh.tokenValue !== 'from') {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types._typeof)) {
        importKind = 'typeof';
      } else if (parser.isContextual('type')) {
        importKind = 'type';
      }
    }

    if (importKind) {
      if (importKind === 'type' && lh.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.star) {
        parser.addDiagnostic({
          start: lh.startPos,
          message: 'import * is not allowed'});
      }

      if (___$romejs$js_parser$src$parser$flow_ts$isMaybeDefaultImport(lh) ||
      lh.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL ||
      lh.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.star) {
        parser.next();
      }
    }

    const specifiers = [];

    let first = true;
    if (___$$priv$romejs$js_parser$src$parser$modules_ts$shouldParseDefaultImport(parser, importKind)) {
      const start = parser.getPosition();

      specifiers.push({
        local: ___$$priv$romejs$js_parser$src$parser$modules_ts$parseImportSpecifierLocal(
        parser,
        importKind,
        'default import specifier'),
        loc: parser.finishLoc(start),
        type: 'ImportDefaultSpecifier'});

      if (!parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.comma)) {
        return {specifiers: specifiers, importKind: importKind};
      }
    }

    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.star)) {
      const start = parser.getPosition();
      parser.next();
      parser.expectContextual('as');

      specifiers.push({
        local: ___$$priv$romejs$js_parser$src$parser$modules_ts$parseImportSpecifierLocal(
        parser,
        importKind,
        'import namespace specifier'),
        loc: parser.finishLoc(start),
        type: 'ImportNamespaceSpecifier'});

      return {specifiers: specifiers, importKind: importKind};
    }

    const openContext = parser.expectOpening(
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR,
    'import specifiers');

    while (true) {
      if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR) || parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.colon)) {
          parser.addDiagnostic({
            message: 'ES2015 named imports do not destructure. Use another statement for destructuring after the import.'});
        }

        parser.expect(___$romejs$js_parser$src$tokenizer$types_ts$types.comma);

        if (parser.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      specifiers.push(___$$priv$romejs$js_parser$src$parser$modules_ts$parseImportSpecifier(parser, importKind));
    }

    return {specifiers: specifiers, importKind: importKind};
  }

  function ___$$priv$romejs$js_parser$src$parser$modules_ts$parseImportSpecifier(parser, nodeKind) {
    const start = parser.getPosition();
    const firstIdentPos = parser.state.startPos;
    const firstIdent = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);

    let imported;
    let local;
    let importKind = undefined;
    if (firstIdent.name === 'type') {
      importKind = 'type';
    } else if (firstIdent.name === 'typeof') {
      importKind = 'typeof';
    }

    let isBinding = false;
    if (parser.isContextual('as') && !parser.isLookaheadContextual('as')) {
      const as_ident = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);
      if (importKind !== undefined &&
      !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name) &&
      parser.state.tokenType.keyword === undefined) {
        imported = as_ident;
        local = parser.cloneNode(as_ident);
      } else {
        imported = firstIdent;
        importKind = undefined;
        local = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
      }
    } else if (importKind !== undefined &&
    (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name) || parser.state.tokenType.keyword)) {
      imported = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser, true);
      if (parser.eatContextual('as')) {
        local = ___$romejs$js_parser$src$parser$expression_ts$parseIdentifier(parser);
      } else {
        isBinding = true;
        local = parser.cloneNode(imported);
      }
    } else {
      isBinding = true;
      imported = firstIdent;
      importKind = undefined;
      local = parser.cloneNode(imported);
    }

    const nodeIsTypeImport = ___$romejs$js_parser$src$parser$flow_ts$hasTypeImportKind(nodeKind);
    const specifierIsTypeImport = ___$romejs$js_parser$src$parser$flow_ts$hasTypeImportKind(importKind);

    if (nodeIsTypeImport && specifierIsTypeImport) {
      parser.addDiagnostic({
        start: firstIdentPos,
        message: 'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements'});
    }

    const loc = parser.finishLoc(start);

    if (nodeIsTypeImport || specifierIsTypeImport) {
      ___$romejs$js_parser$src$parser$flow_ts$checkReservedType(parser, local.name, loc);
    }

    if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
      ___$romejs$js_parser$src$parser$expression_ts$checkReservedWord(parser, local.name, loc, true, true);
    }

    ___$romejs$js_parser$src$parser$lval_ts$checkLVal(parser, local, true, undefined, 'import specifier');

    return {
      type: 'ImportSpecifier',
      loc: loc,
      local: local,
      imported: imported,
      importKind: importKind};
  }

  // romejs/js-parser/src/parser/index.ts


  // romejs/js-parser/src/tokenizer/index.ts

  const ___$$priv$romejs$js_parser$src$tokenizer$index_ts$HEX_NUMBER = /^[\da-fA-F]+$/;
  const ___$$priv$romejs$js_parser$src$tokenizer$index_ts$DECIMAL_NUMBER = /^\d+$/;

  const ___$$priv$romejs$js_parser$src$tokenizer$index_ts$forbiddenNumericSeparatorSiblings = {
    decBinOct: [___$romejs$string_charcodes$src$index_ts$dot, ___$romejs$string_charcodes$src$index_ts$uppercaseB, ___$romejs$string_charcodes$src$index_ts$uppercaseE, ___$romejs$string_charcodes$src$index_ts$uppercaseO, ___$romejs$string_charcodes$src$index_ts$underscore, ___$romejs$string_charcodes$src$index_ts$lowercaseB, ___$romejs$string_charcodes$src$index_ts$lowercaseE, ___$romejs$string_charcodes$src$index_ts$lowercaseO],
    hex: [___$romejs$string_charcodes$src$index_ts$dot, ___$romejs$string_charcodes$src$index_ts$uppercaseX, ___$romejs$string_charcodes$src$index_ts$underscore, ___$romejs$string_charcodes$src$index_ts$lowercaseX]};

  const ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin = [___$romejs$string_charcodes$src$index_ts$digit0, ___$romejs$string_charcodes$src$index_ts$digit1];
  const ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct = [...___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin, ___$romejs$string_charcodes$src$index_ts$digit2, ___$romejs$string_charcodes$src$index_ts$digit3, ___$romejs$string_charcodes$src$index_ts$digit4, ___$romejs$string_charcodes$src$index_ts$digit5, ___$romejs$string_charcodes$src$index_ts$digit6, ___$romejs$string_charcodes$src$index_ts$digit7];
  const ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec = [...___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct, ___$romejs$string_charcodes$src$index_ts$digit8, ___$romejs$string_charcodes$src$index_ts$digit9];

  const ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsHex = [...___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec, ___$romejs$string_charcodes$src$index_ts$uppercaseA, ___$romejs$string_charcodes$src$index_ts$uppercaseB, ___$romejs$string_charcodes$src$index_ts$uppercaseC, ___$romejs$string_charcodes$src$index_ts$uppercaseD, ___$romejs$string_charcodes$src$index_ts$uppercaseE, ___$romejs$string_charcodes$src$index_ts$uppercaseF, ___$romejs$string_charcodes$src$index_ts$lowercaseA, ___$romejs$string_charcodes$src$index_ts$lowercaseB, ___$romejs$string_charcodes$src$index_ts$lowercaseC, ___$romejs$string_charcodes$src$index_ts$lowercaseD, ___$romejs$string_charcodes$src$index_ts$lowercaseE, ___$romejs$string_charcodes$src$index_ts$lowercaseF];
  const ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblings = {
    bin: ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin,
    oct: ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct,
    dec: ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec,
    hex: ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblingsHex};

  class ___$romejs$js_parser$src$tokenizer$index_ts$Token {
    constructor(state, parser) {
      this.type = state.tokenType;
      this.value = state.tokenValue;
      this.loc = {
        filename: parser.filename,
        start: state.startPos,
        end: state.endPos};
    }
  }

  class ___$romejs$js_parser$src$tokenizer$index_ts$RegExpTokenValue {
    constructor(pattern, flags) {
      this.pattern = pattern;
      this.flags = flags;
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$codePointToString(code) {
    if (code <= 65535) {
      return String.fromCharCode(code);
    } else {
      return String.fromCharCode(
      (code - 65536 >> 10) + 55296,
      (code - 65536 & 1023) + 56320);
    }
  }

  function ___$romejs$js_parser$src$tokenizer$index_ts$setStrict(parser, isStrict) {
    parser.pushScope('STRICT', isStrict);

    if (!parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.num) && !parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.string)) {
      return undefined;
    }

    parser.state.index = parser.state.startPos.index;
    while (parser.state.index < parser.state.lineStartIndex) {
      parser.state.lineStartIndex =
      parser.input.lastIndexOf('\n', parser.state.lineStartIndex - 2) + 1;
      parser.state.curLine--;
    }
    ___$romejs$js_parser$src$tokenizer$index_ts$nextToken(parser);
  }

  function ___$romejs$js_parser$src$tokenizer$index_ts$getCurContext(parser) {
    return parser.state.context[parser.state.context.length - 1];
  }

  function ___$romejs$js_parser$src$tokenizer$index_ts$nextToken(parser) {
    const curContext = ___$romejs$js_parser$src$tokenizer$index_ts$getCurContext(parser);

    if (!curContext || !curContext.preserveSpace) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$skipSpace(parser);
    }

    parser.state.containsOctal = false;
    parser.state.octalPosition = undefined;
    parser.state.startPos = parser.getPositionFromState();

    if (parser.state.index >= parser.length) {
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.eof);
      return undefined;
    }

    if (curContext.override) {
      curContext.override(parser);
    } else {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken(parser, ___$$priv$romejs$js_parser$src$tokenizer$index_ts$fullCharCodeAtPos(parser));
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken(parser, code) {
    const matchedJSX = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readJSXToken(parser, code);
    if (matchedJSX) {
      return undefined;
    } else {
      return ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readNormalToken(parser, code);
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readJSXToken(parser, code) {
    if (parser.inScope('PROPERTY_NAME')) {
      return false;
    }

    if (parser.inScope('TYPE')) {
      return false;
    }

    if (!parser.shouldTokenizeJSX()) {
      return false;
    }

    const context = ___$romejs$js_parser$src$tokenizer$index_ts$getCurContext(parser);

    if (context === ___$romejs$js_parser$src$tokenizer$context_ts$types.jsxInner) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsx(parser);
      return true;
    }

    if (context === ___$romejs$js_parser$src$tokenizer$context_ts$types.jsxOpenTag || context === ___$romejs$js_parser$src$tokenizer$context_ts$types.jsxCloseTag) {
      if (___$romejs$js_parser_utils$src$identifier_ts$isIdentifierStart(code)) {
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsxWord(parser);
        return true;
      }

      if (code === ___$romejs$string_charcodes$src$index_ts$greaterThan) {
        parser.state.index++;
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagEnd);
        return true;
      }

      if ((code === ___$romejs$string_charcodes$src$index_ts$quotationMark || code === ___$romejs$string_charcodes$src$index_ts$apostrophe) &&
      context === ___$romejs$js_parser$src$tokenizer$context_ts$types.jsxOpenTag) {
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsxString(parser, code);
        return true;
      }
    }

    if (code === ___$romejs$string_charcodes$src$index_ts$lessThan &&
    parser.state.exprAllowed &&
    parser.input.charCodeAt(parser.state.index + 1) !== ___$romejs$string_charcodes$src$index_ts$exclamationMark) {
      parser.state.index++;
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagStart);
      return true;
    }

    return false;
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readNormalToken(parser, code) {
    if (___$romejs$js_parser_utils$src$identifier_ts$isIdentifierStart(code) || code === ___$romejs$string_charcodes$src$index_ts$backslash) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readWord(parser);
    } else {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$getTokenFromCode(parser, code);
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$fullCharCodeAtPos(parser) {
    return ___$romejs$js_parser_utils$src$identifier_ts$getFullCharCodeAt(parser.input, parser.state.index);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$pushComment(parser, opts) {
    const comment = {
      type: opts.block ? 'CommentBlock' : 'CommentLine',
      value: opts.text,
      loc: parser.finishLocAt(opts.startPos, opts.endPos)};

    if (opts.text.includes('@flow')) {
      parser.syntax.add('flow');

      parser.syntax.add('jsx');
    }

    if (parser.isLookahead === false) {
      parser.state.comments.push(comment);
      ___$romejs$js_parser$src$parser$comments_ts$addComment(parser, comment);

      if (parser.isTrackingTokens === true) {
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.comment);
        parser.tokens.push(new ___$romejs$js_parser$src$tokenizer$index_ts$Token(parser.state, parser));
      }
    }

    return comment;
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$skipBlockComment(parser) {
    const startPos = parser.getPosition();
    const startIndex = parser.state.index;
    const endIndex = parser.input.indexOf('*/', parser.state.index += 2);

    if (endIndex === -1) {
      parser.addDiagnostic({
        end: parser.getPositionFromIndex(parser.state.index - 2),
        message: 'Unterminated comment'});
      return undefined;
    }

    parser.state.index = endIndex + 2;
    ___$romejs$js_parser_utils$src$whitespace_ts$lineBreakG.lastIndex = startIndex;
    let match;
    while ((match = ___$romejs$js_parser_utils$src$whitespace_ts$lineBreakG.exec(parser.input)) &&
    match.index < parser.state.index) {
      parser.state.curLine++;
      parser.resetTokenizerLine();
      parser.state.lineStartIndex = match.index + match[0].length;
    }

    ___$$priv$romejs$js_parser$src$tokenizer$index_ts$pushComment(parser, {
      block: true,
      text: parser.getRawInput(startIndex + 2, endIndex),
      startPos: startPos,
      endPos: parser.getPosition()});
  }

  function ___$romejs$js_parser$src$tokenizer$index_ts$skipLineComment(parser, startSkip) {
    const startIndex = parser.state.index;
    const startPos = parser.getPosition();
    let ch = parser.input.charCodeAt(parser.state.index += startSkip);
    if (parser.state.index < parser.length) {
      while (ch !== ___$romejs$string_charcodes$src$index_ts$lineFeed &&
      ch !== ___$romejs$string_charcodes$src$index_ts$carriageReturn &&
      ch !== ___$romejs$string_charcodes$src$index_ts$lineSeparator &&
      ch !== ___$romejs$string_charcodes$src$index_ts$paragraphSeparator &&
      ++parser.state.index < parser.length) {
        ch = parser.input.charCodeAt(parser.state.index);
      }
    }

    return ___$$priv$romejs$js_parser$src$tokenizer$index_ts$pushComment(parser, {
      block: false,
      text: parser.getRawInput(startIndex + startSkip, parser.state.index),
      startPos: startPos,
      endPos: parser.getPosition()});
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$skipSpace(parser) {
    loop: while (parser.state.index < parser.length) {
      const ch = parser.input.charCodeAt(parser.state.index);

      if (parser.state.lineStart) {
        if (ch === ___$romejs$string_charcodes$src$index_ts$space || ch === ___$romejs$string_charcodes$src$index_ts$tab) {
          parser.state.indentLevel++;
        } else {
          parser.state.lineStart = false;
        }
      }

      if (ch === ___$romejs$string_charcodes$src$index_ts$carriageReturn &&
      parser.input.charCodeAt(parser.state.index + 1) === ___$romejs$string_charcodes$src$index_ts$lineFeed) {
        parser.state.index++;
      }

      switch (ch) {
        case ___$romejs$string_charcodes$src$index_ts$space:
        case ___$romejs$string_charcodes$src$index_ts$nonBreakingSpace:
          parser.state.index++;
          break;

        case ___$romejs$string_charcodes$src$index_ts$carriageReturn:
        case ___$romejs$string_charcodes$src$index_ts$lineFeed:
        case ___$romejs$string_charcodes$src$index_ts$lineSeparator:
        case ___$romejs$string_charcodes$src$index_ts$paragraphSeparator:
          parser.state.index++;
          parser.state.curLine++;
          parser.resetTokenizerLine();
          break;

        case ___$romejs$string_charcodes$src$index_ts$slash:
          switch (parser.input.charCodeAt(parser.state.index + 1)) {
            case ___$romejs$string_charcodes$src$index_ts$asterisk:
              ___$$priv$romejs$js_parser$src$tokenizer$index_ts$skipBlockComment(parser);
              break;

            case ___$romejs$string_charcodes$src$index_ts$slash:
              ___$romejs$js_parser$src$tokenizer$index_ts$skipLineComment(parser, 2);
              break;

            default:
              break loop;}
          break;

        default:
          if (ch > ___$romejs$string_charcodes$src$index_ts$backSpace && ch < ___$romejs$string_charcodes$src$index_ts$shiftOut ||
          ch >= ___$romejs$string_charcodes$src$index_ts$oghamSpaceMark &&
          ___$romejs$js_parser_utils$src$whitespace_ts$nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            parser.state.index++;
          } else {
            break loop;
          }}
    }
  }

  function ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, type, val) {
    parser.state.endPos = parser.getPositionFromState();

    const prevType = parser.state.tokenType;
    parser.state.tokenType = type;
    parser.state.tokenValue = val;

    ___$$priv$romejs$js_parser$src$tokenizer$index_ts$updateContext(parser, prevType);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_dot(parser) {
    const next = parser.input.charCodeAt(parser.state.index + 1);
    if (next >= ___$romejs$string_charcodes$src$index_ts$digit0 && next <= ___$romejs$string_charcodes$src$index_ts$digit9) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readNumber(parser, true);
      return undefined;
    }

    const next2 = parser.input.charCodeAt(parser.state.index + 2);
    if (next === ___$romejs$string_charcodes$src$index_ts$dot && next2 === ___$romejs$string_charcodes$src$index_ts$dot) {
      parser.state.index += 3;
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.ellipsis);
    } else {
      parser.state.index++;
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.dot);
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_slash(parser) {
    if (parser.state.exprAllowed) {
      parser.state.index++;
      ___$romejs$js_parser$src$tokenizer$index_ts$readRegexp(parser);
      return undefined;
    }

    const next = parser.input.charCodeAt(parser.state.index + 1);
    if (next === ___$romejs$string_charcodes$src$index_ts$equalsTo) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.assign, 2);
    } else {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.slash, 1);
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_mult_modulo(parser, code) {
    let type = code === ___$romejs$string_charcodes$src$index_ts$asterisk ? ___$romejs$js_parser$src$tokenizer$types_ts$types.star : ___$romejs$js_parser$src$tokenizer$types_ts$types.modulo;
    let width = 1;
    let next = parser.input.charCodeAt(parser.state.index + 1);
    const exprAllowed = parser.state.exprAllowed;

    if (code === ___$romejs$string_charcodes$src$index_ts$asterisk && next === ___$romejs$string_charcodes$src$index_ts$asterisk) {
      width++;
      next = parser.input.charCodeAt(parser.state.index + 2);
      type = ___$romejs$js_parser$src$tokenizer$types_ts$types.exponent;
    }

    if (next === ___$romejs$string_charcodes$src$index_ts$equalsTo && !exprAllowed) {
      width++;
      type = ___$romejs$js_parser$src$tokenizer$types_ts$types.assign;
    }

    ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, type, width);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_pipe_amp(parser, code) {
    const next = parser.input.charCodeAt(parser.state.index + 1);

    if (next === code) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(
      parser,
      code === ___$romejs$string_charcodes$src$index_ts$verticalBar ? ___$romejs$js_parser$src$tokenizer$types_ts$types.logicalOR : ___$romejs$js_parser$src$tokenizer$types_ts$types.logicalAND,
      2);
      return undefined;
    }

    if (code === ___$romejs$string_charcodes$src$index_ts$verticalBar && next === ___$romejs$string_charcodes$src$index_ts$rightCurlyBrace) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.braceBarR, 2);
      return undefined;
    }

    if (next === ___$romejs$string_charcodes$src$index_ts$equalsTo) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.assign, 2);
      return undefined;
    }

    ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(
    parser,
    code === ___$romejs$string_charcodes$src$index_ts$verticalBar ? ___$romejs$js_parser$src$tokenizer$types_ts$types.bitwiseOR : ___$romejs$js_parser$src$tokenizer$types_ts$types.bitwiseAND,
    1);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_caret(parser) {
    const next = parser.input.charCodeAt(parser.state.index + 1);
    if (next === ___$romejs$string_charcodes$src$index_ts$equalsTo) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.assign, 2);
    } else {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.bitwiseXOR, 1);
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_plus_min(parser, code) {
    const next = parser.input.charCodeAt(parser.state.index + 1);

    if (next === code) {
      if (next === ___$romejs$string_charcodes$src$index_ts$dash &&
      !parser.inModule &&
      parser.input.charCodeAt(parser.state.index + 2) === ___$romejs$string_charcodes$src$index_ts$greaterThan &&
      (parser.state.lastEndPos.index === 0 ||
      ___$romejs$js_parser_utils$src$whitespace_ts$lineBreak.test(
      parser.getRawInput(parser.state.lastEndPos.index, parser.state.index)))) {
        ___$romejs$js_parser$src$tokenizer$index_ts$skipLineComment(parser, 3);
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$skipSpace(parser);
        ___$romejs$js_parser$src$tokenizer$index_ts$nextToken(parser);
        return undefined;
      }
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.incDec, 2);
      return undefined;
    }

    if (next === ___$romejs$string_charcodes$src$index_ts$equalsTo) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.assign, 2);
    } else {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.plusMin, 1);
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_lt_gt(parser, code) {
    const next = parser.input.charCodeAt(parser.state.index + 1);
    let size = 1;

    if (next === code && !parser.inScope('TYPE')) {
      size =
      code === ___$romejs$string_charcodes$src$index_ts$greaterThan &&
      parser.input.charCodeAt(parser.state.index + 2) === ___$romejs$string_charcodes$src$index_ts$greaterThan ? 3 : 2;
      if (parser.input.charCodeAt(parser.state.index + size) === ___$romejs$string_charcodes$src$index_ts$equalsTo) {
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.assign, size + 1);
        return undefined;
      }
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.bitShift, size);
      return undefined;
    }

    if (code === ___$romejs$string_charcodes$src$index_ts$lessThan &&
    next === ___$romejs$string_charcodes$src$index_ts$exclamationMark &&
    !parser.inModule &&
    parser.input.charCodeAt(parser.state.index + 2) === ___$romejs$string_charcodes$src$index_ts$dash &&
    parser.input.charCodeAt(parser.state.index + 3) === ___$romejs$string_charcodes$src$index_ts$dash) {
      ___$romejs$js_parser$src$tokenizer$index_ts$skipLineComment(parser, 4);
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$skipSpace(parser);
      ___$romejs$js_parser$src$tokenizer$index_ts$nextToken(parser);
      return undefined;
    }

    if (next === ___$romejs$string_charcodes$src$index_ts$equalsTo) {
      size = 2;
    }

    ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.relational, size);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_eq_excl(parser, code) {
    const next = parser.input.charCodeAt(parser.state.index + 1);
    if (next === ___$romejs$string_charcodes$src$index_ts$equalsTo) {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(
      parser,
      ___$romejs$js_parser$src$tokenizer$types_ts$types.equality,
      parser.input.charCodeAt(parser.state.index + 2) === ___$romejs$string_charcodes$src$index_ts$equalsTo ? 3 : 2);
      return undefined;
    }
    if (code === ___$romejs$string_charcodes$src$index_ts$equalsTo && next === ___$romejs$string_charcodes$src$index_ts$greaterThan) {
      parser.state.index += 2;
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.arrow);
      return undefined;
    }
    ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, code === ___$romejs$string_charcodes$src$index_ts$equalsTo ? ___$romejs$js_parser$src$tokenizer$types_ts$types.eq : ___$romejs$js_parser$src$tokenizer$types_ts$types.bang, 1);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_question(parser) {
    const next = parser.input.charCodeAt(parser.state.index + 1);
    const next2 = parser.input.charCodeAt(parser.state.index + 2);
    if (next === ___$romejs$string_charcodes$src$index_ts$questionMark && !parser.inScope('TYPE')) {
      if (next2 === ___$romejs$string_charcodes$src$index_ts$equalsTo) {
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.assign, 3);
      } else {
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.nullishCoalescing, 2);
      }
    } else if (next === ___$romejs$string_charcodes$src$index_ts$dot &&
    !(next2 >= ___$romejs$string_charcodes$src$index_ts$digit0 && next2 <= ___$romejs$string_charcodes$src$index_ts$digit9)) {
      parser.state.index += 2;
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.questionDot);
    } else {
      parser.state.index++;
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.question);
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_numberSign(parser) {
    if (parser.state.classLevel > 0 || parser.state.index === 0) {
      parser.state.index++;
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.hash);
      return undefined;
    }

    let advice;
    if (parser.input[parser.state.index + 1] === '!') {
      advice = [{
        type: 'log',
        category: 'info',
        message: 'Did you want to write a hashbang? A hashbang can only be the first thing in a file.'}];
    }

    parser.addDiagnostic({
      message: `Unexpected character '#'`,
      advice: advice});
    parser.state.index++;
    ___$romejs$js_parser$src$tokenizer$index_ts$nextToken(parser);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$getTokenFromCode(parser, code) {
    if (code === ___$romejs$string_charcodes$src$index_ts$digit0) {
      const next = parser.input.charCodeAt(parser.state.index + 1);

      if (next === ___$romejs$string_charcodes$src$index_ts$lowercaseX || next === ___$romejs$string_charcodes$src$index_ts$uppercaseX) {
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readRadixNumber(parser, 16);
        return undefined;
      }

      if (next === ___$romejs$string_charcodes$src$index_ts$lowercaseO || next === ___$romejs$string_charcodes$src$index_ts$uppercaseO) {
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readRadixNumber(parser, 8);
        return undefined;
      }

      if (next === ___$romejs$string_charcodes$src$index_ts$lowercaseB || next === ___$romejs$string_charcodes$src$index_ts$uppercaseB) {
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readRadixNumber(parser, 2);
        return undefined;
      }
    }

    switch (code) {
      case ___$romejs$string_charcodes$src$index_ts$numberSign:
        return ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_numberSign(parser);

      case ___$romejs$string_charcodes$src$index_ts$dot:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_dot(parser);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$leftParenthesis:
        parser.state.index++;
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.parenL);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$rightParenthesis:
        parser.state.index++;
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$semicolon:
        parser.state.index++;
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.semi);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$comma:
        parser.state.index++;
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.comma);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$leftSquareBracket:
        parser.state.index++;
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketL);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$rightSquareBracket:
        parser.state.index++;
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.bracketR);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$leftCurlyBrace:
        if (parser.input.charCodeAt(parser.state.index + 1) === ___$romejs$string_charcodes$src$index_ts$verticalBar) {
          ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.braceBarL, 2);
        } else {
          parser.state.index++;
          ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL);
        }
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$rightCurlyBrace:
        parser.state.index++;
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.braceR);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$colon:
        if (parser.input.charCodeAt(parser.state.index + 1) === ___$romejs$string_charcodes$src$index_ts$colon) {
          ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.doubleColon, 2);
        } else {
          parser.state.index++;
          ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.colon);
        }
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$questionMark:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_question(parser);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$atSign:
        {
          const next = parser.input.charCodeAt(parser.state.index + 1);
          if (next === ___$romejs$string_charcodes$src$index_ts$atSign) {
            parser.state.isIterator = true;
            ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readWord(parser);
          } else {
            parser.state.index++;
            ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.at);
          }
          return undefined;
        }

      case ___$romejs$string_charcodes$src$index_ts$graveAccent:
        parser.state.index++;
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.backQuote);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$digit0:
      case ___$romejs$string_charcodes$src$index_ts$digit1:
      case ___$romejs$string_charcodes$src$index_ts$digit2:
      case ___$romejs$string_charcodes$src$index_ts$digit3:
      case ___$romejs$string_charcodes$src$index_ts$digit4:
      case ___$romejs$string_charcodes$src$index_ts$digit5:
      case ___$romejs$string_charcodes$src$index_ts$digit6:
      case ___$romejs$string_charcodes$src$index_ts$digit7:
      case ___$romejs$string_charcodes$src$index_ts$digit8:
      case ___$romejs$string_charcodes$src$index_ts$digit9:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readNumber(parser, false);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$quotationMark:
      case ___$romejs$string_charcodes$src$index_ts$apostrophe:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readString(parser, code);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$slash:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_slash(parser);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$percentSign:
      case ___$romejs$string_charcodes$src$index_ts$asterisk:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_mult_modulo(parser, code);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$verticalBar:
      case ___$romejs$string_charcodes$src$index_ts$ampersand:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_pipe_amp(parser, code);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$caret:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_caret(parser);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$plusSign:
      case ___$romejs$string_charcodes$src$index_ts$dash:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_plus_min(parser, code);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$lessThan:
      case ___$romejs$string_charcodes$src$index_ts$greaterThan:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_lt_gt(parser, code);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$equalsTo:
      case ___$romejs$string_charcodes$src$index_ts$exclamationMark:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_eq_excl(parser, code);
        return undefined;

      case ___$romejs$string_charcodes$src$index_ts$tilde:
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.tilde, 1);
        return undefined;}

    parser.addDiagnostic({
      message: `Unexpected character '${___$$priv$romejs$js_parser$src$tokenizer$index_ts$codePointToString(code)}'`});
    parser.state.index++;
    ___$romejs$js_parser$src$tokenizer$index_ts$nextToken(parser);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$finishOp(parser, type, size) {
    const str = parser.getRawInput(parser.state.index, parser.state.index + size);
    parser.state.index += size;
    ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, type, str);
  }

  function ___$romejs$js_parser$src$tokenizer$index_ts$readRegexp(parser) {
    const start = parser.state.index;
    let escaped, inClass;
    for (;;) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated regular expression'});
        break;
      }

      const ch = parser.input.charAt(parser.state.index);
      if (___$romejs$js_parser_utils$src$whitespace_ts$lineBreak.test(ch)) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated regular expression'});
        break;
      }

      if (escaped) {
        escaped = false;
      } else {
        if (ch === '[') {
          inClass = true;
        } else if (ch === ']' && inClass) {
          inClass = false;
        } else if (ch === '/' && !inClass) {
          break;
        }
        escaped = ch === '\\';
      }

      parser.state.index++;
    }

    const content = parser.getRawInput(start, parser.state.index);
    parser.state.index++;

    const rawMods = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readWord1(parser);

    if (parser.state.escapePosition !== undefined) {
      parser.addDiagnostic({
        index: parser.state.escapePosition,
        message: 'Regular expression flags can\'t contain unicode escapes'});
    }

    const mods = ___$romejs$js_parser_utils$src$regex_ts$validateRegexFlags(rawMods, (msg, index) => {
      parser.addDiagnostic({
        index: start + index,
        message: msg});
    });

    ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.regexp, new ___$romejs$js_parser$src$tokenizer$index_ts$RegExpTokenValue(content, mods));
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readInt(parser, radix, len) {
    const start = parser.state.index;
    const forbiddenSiblings = radix === 16 ? ___$$priv$romejs$js_parser$src$tokenizer$index_ts$forbiddenNumericSeparatorSiblings.hex : ___$$priv$romejs$js_parser$src$tokenizer$index_ts$forbiddenNumericSeparatorSiblings.decBinOct;

    let allowedSiblings;
    if (radix === 16) {
      allowedSiblings = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblings.hex;
    } else if (radix === 10) {
      allowedSiblings = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblings.dec;
    } else if (radix === 8) {
      allowedSiblings = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblings.oct;
    } else {
      allowedSiblings = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$allowedNumericSeparatorSiblings.bin;
    }

    let total = 0;

    for (let i = 0, e = len === undefined ? Infinity : len; i < e; ++i) {
      const code = parser.input.charCodeAt(parser.state.index);
      let val;

      const prev = parser.input.charCodeAt(parser.state.index - 1);
      const next = parser.input.charCodeAt(parser.state.index + 1);
      if (code === ___$romejs$string_charcodes$src$index_ts$underscore) {
        if (allowedSiblings.indexOf(next) === -1) {
          parser.addDiagnostic({
            message: 'Invalid or unexpected token'});
        }

        if (forbiddenSiblings.indexOf(prev) > -1 ||
        forbiddenSiblings.indexOf(next) > -1 ||
        Number.isNaN(next)) {
          parser.addDiagnostic({
            message: 'Invalid or unexpected token'});
        }

        parser.state.index++;
        continue;
      }

      if (code >= ___$romejs$string_charcodes$src$index_ts$lowercaseA) {
        val = code - ___$romejs$string_charcodes$src$index_ts$lowercaseA + ___$romejs$string_charcodes$src$index_ts$lineFeed;
      } else if (code >= ___$romejs$string_charcodes$src$index_ts$uppercaseA) {
        val = code - ___$romejs$string_charcodes$src$index_ts$uppercaseA + ___$romejs$string_charcodes$src$index_ts$lineFeed;
      } else if (___$romejs$string_charcodes$src$index_ts$isDigit(code)) {
        val = code - ___$romejs$string_charcodes$src$index_ts$digit0;
      } else {
        val = Infinity;
      }

      if (val >= radix) {
        break;
      }

      parser.state.index++;
      total = total * radix + val;
    }

    if (parser.state.index === start ||
    len !== undefined && parser.state.index - start !== len) {
      return undefined;
    }

    return total;
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readRadixNumber(parser, radix) {
    const start = parser.state.index;
    let isBigInt = false;

    parser.state.index += 2;

    const val = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readInt(parser, radix);
    if (val === undefined) {
      parser.addDiagnostic({
        index: start + 2,
        message: 'Expected number in radix ' + radix});
    }

    if (parser.input.charCodeAt(parser.state.index) === ___$romejs$string_charcodes$src$index_ts$lowercaseN) {
      parser.state.index++;
      isBigInt = true;
    }

    if (___$romejs$js_parser_utils$src$identifier_ts$isIdentifierStart(___$$priv$romejs$js_parser$src$tokenizer$index_ts$fullCharCodeAtPos(parser))) {
      parser.addDiagnostic({
        index: parser.state.index,
        message: 'Identifier directly after number'});
    }

    if (isBigInt) {
      const str = parser.getRawInput(start, parser.state.index).replace(/[_n]/g, '');
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.bigint, str);
      return undefined;
    }

    ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.num, val);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readNumber(parser, startsWithDot) {
    const start = parser.state.startPos;
    let isFloat = false;
    let isBigInt = false;

    if (!startsWithDot && ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readInt(parser, 10) === undefined) {
      parser.addDiagnostic({
        index: parser.state.index,
        message: 'Invalid number'});
    }

    let isOctal = parser.state.index - start.index >= 2 &&
    parser.input.charCodeAt(start.index) === ___$romejs$string_charcodes$src$index_ts$digit0;
    if (isOctal) {
      if (parser.inScope('STRICT')) {
        parser.addDiagnostic({
          index: parser.state.index,
          message: 'Legacy octal literals are not allowed in strict mode'});
      }

      if (/[89]/.test(parser.getRawInput(start.index, parser.state.index))) {
        isOctal = false;
      }
    }

    let next = parser.input.charCodeAt(parser.state.index);
    if (next === ___$romejs$string_charcodes$src$index_ts$dot && !isOctal) {
      parser.state.index++;
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readInt(parser, 10);
      isFloat = true;
      next = parser.input.charCodeAt(parser.state.index);
    }

    if ((next === ___$romejs$string_charcodes$src$index_ts$uppercaseE || next === ___$romejs$string_charcodes$src$index_ts$lowercaseE) &&
    !isOctal) {
      next = parser.input.charCodeAt(++parser.state.index);

      if (next === ___$romejs$string_charcodes$src$index_ts$plusSign || next === ___$romejs$string_charcodes$src$index_ts$dash) {
        parser.state.index++;
      }

      if (___$$priv$romejs$js_parser$src$tokenizer$index_ts$readInt(parser, 10) === undefined) {
        parser.addDiagnostic({
          index: parser.state.index,
          message: 'Invalid number'});
      }

      isFloat = true;
      next = parser.input.charCodeAt(parser.state.index);
    }

    if (next === ___$romejs$string_charcodes$src$index_ts$lowercaseN) {
      if (isFloat) {
        parser.addDiagnostic({
          index: parser.state.index,
          message: 'A bigint can\'t have a decimal'});
      }

      if (isOctal) {
        parser.addDiagnostic({
          index: parser.state.index,
          message: 'A bigint can\'t be an octal'});
      }

      parser.state.index++;
      isBigInt = true;
    }

    if (___$romejs$js_parser_utils$src$identifier_ts$isIdentifierStart(parser.input.codePointAt(parser.state.index))) {
      parser.addDiagnostic({
        index: parser.state.index,
        message: 'Identifier directly after number'});
    }

    const str = parser.getRawInput(start.index, parser.state.index).replace(/[_n]/g, '');

    if (isBigInt) {
      ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.bigint, str);
      return undefined;
    }

    const val = isOctal ? parseInt(str, 8) : parseFloat(str);
    ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.num, val);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readCodePoint(parser, throwOnInvalid) {
    const ch = parser.input.charCodeAt(parser.state.index);
    let code;

    if (ch === ___$romejs$string_charcodes$src$index_ts$leftCurlyBrace) {
      const codePos = parser.state.index++;
      code = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readHexChar(
      parser,
      parser.input.indexOf('}', parser.state.index) - parser.state.index,
      throwOnInvalid);
      parser.state.index++;
      if (code === undefined) {
        parser.state.invalidTemplateEscapePosition--;
      } else if (code > 1114111) {
        if (throwOnInvalid) {
          parser.addDiagnostic({
            index: codePos,
            message: 'Code point out of bounds'});
        } else {
          parser.state.invalidTemplateEscapePosition = codePos - 2;
          return undefined;
        }
      }
    } else {
      code = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readHexChar(parser, 4, throwOnInvalid);
    }
    return code;
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readString(parser, quote) {
    let out = '';
    let chunkStart = ++parser.state.index;

    while (true) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated string constant'});
        break;
      }

      const ch = parser.input.charCodeAt(parser.state.index);
      if (ch === quote) {
        break;
      }

      if (ch === ___$romejs$string_charcodes$src$index_ts$backslash) {
        out += parser.getRawInput(chunkStart, parser.state.index);

        out += ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readEscapedChar(parser, false);
        chunkStart = parser.state.index;
      } else if (ch === ___$romejs$string_charcodes$src$index_ts$lineSeparator ||
      ch === ___$romejs$string_charcodes$src$index_ts$paragraphSeparator) {
        parser.state.index++;
        parser.state.curLine++;
      } else {
        if (___$romejs$js_parser_utils$src$whitespace_ts$isNewLine(ch)) {
          parser.addDiagnostic({
            end: parser.getPositionFromIndex(parser.state.index),
            message: 'Unterminated string constant'});
        }
        parser.state.index++;
      }
    }

    out += parser.getRawInput(chunkStart, parser.state.index++);
    ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.string, out);
  }

  function ___$romejs$js_parser$src$tokenizer$index_ts$readTemplateToken(parser) {
    let out = '';
    let chunkStart = parser.state.index;
    let containsInvalid = false;

    while (true) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated template'});
        break;
      }

      const ch = parser.input.charCodeAt(parser.state.index);
      if (ch === ___$romejs$string_charcodes$src$index_ts$graveAccent ||
      ch === ___$romejs$string_charcodes$src$index_ts$dollarSign &&
      parser.input.charCodeAt(parser.state.index + 1) === ___$romejs$string_charcodes$src$index_ts$leftCurlyBrace) {
        if (parser.state.index === parser.state.startPos.index &&
        parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.template)) {
          if (ch === ___$romejs$string_charcodes$src$index_ts$dollarSign) {
            parser.state.index += 2;
            ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.dollarBraceL);
            return undefined;
          } else {
            parser.state.index++;
            ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.backQuote);
            return undefined;
          }
        }
        out += parser.getRawInput(chunkStart, parser.state.index);
        ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.template, containsInvalid ? undefined : out);
        return undefined;
      }

      if (ch === ___$romejs$string_charcodes$src$index_ts$backslash) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        const escaped = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readEscapedChar(parser, true);
        if (escaped === undefined) {
          containsInvalid = true;
        } else {
          out += escaped;
        }
        chunkStart = parser.state.index;
      } else if (___$romejs$js_parser_utils$src$whitespace_ts$isNewLine(ch)) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        parser.state.index++;

        if (ch === ___$romejs$string_charcodes$src$index_ts$carriageReturn &&
        parser.input.charCodeAt(parser.state.index) === ___$romejs$string_charcodes$src$index_ts$lineFeed) {
          parser.state.index++;
        }

        switch (ch) {
          case ___$romejs$string_charcodes$src$index_ts$carriageReturn:
          case ___$romejs$string_charcodes$src$index_ts$lineFeed:
            out += '\n';
            break;

          default:
            out += String.fromCharCode(ch);
            break;}

        parser.state.curLine++;
        parser.resetTokenizerLine();
        chunkStart = parser.state.index;
      } else {
        parser.state.index++;
      }
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readEscapedChar(parser, inTemplate) {
    const throwOnInvalid = !inTemplate;
    const ch = parser.input.charCodeAt(++parser.state.index);
    parser.state.index++;

    if (ch === ___$romejs$string_charcodes$src$index_ts$carriageReturn &&
    parser.input.charCodeAt(parser.state.index) === ___$romejs$string_charcodes$src$index_ts$lineFeed) {
      parser.state.index++;
    }

    switch (ch) {
      case ___$romejs$string_charcodes$src$index_ts$lowercaseN:
        return '\n';

      case ___$romejs$string_charcodes$src$index_ts$lowercaseR:
        return '\r';

      case ___$romejs$string_charcodes$src$index_ts$lowercaseX:
        {
          const code = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readHexChar(parser, 2, throwOnInvalid);
          return code === undefined ? undefined : String.fromCharCode(code);
        }

      case ___$romejs$string_charcodes$src$index_ts$lowercaseU:
        {
          const code = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readCodePoint(parser, throwOnInvalid);
          return code === undefined ? undefined : ___$$priv$romejs$js_parser$src$tokenizer$index_ts$codePointToString(code);
        }

      case ___$romejs$string_charcodes$src$index_ts$lowercaseT:
        return '\t';

      case ___$romejs$string_charcodes$src$index_ts$lowercaseB:
        return '\b';

      case ___$romejs$string_charcodes$src$index_ts$lowercaseV:
        return '\x0b';

      case ___$romejs$string_charcodes$src$index_ts$lowercaseF:
        return '\f';

      case ___$romejs$string_charcodes$src$index_ts$carriageReturn:
      case ___$romejs$string_charcodes$src$index_ts$lineFeed:
        parser.state.curLine++;
        parser.resetTokenizerLine();
        return '';

      default:
        if (ch >= ___$romejs$string_charcodes$src$index_ts$digit0 && ch <= ___$romejs$string_charcodes$src$index_ts$digit7) {
          const codePos = parser.state.index - 1;
          const octalMatches = parser.input.substr(parser.state.index - 1, 3).match(/^[0-7]+/);

          if (octalMatches == null) {
            throw new Error('No octals found, impossible since we checked it');
          }

          let octalStr = octalMatches[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }

          if (octal > 0) {
            if (inTemplate) {
              parser.state.invalidTemplateEscapePosition = codePos;
              return undefined;
            } else if (parser.inScope('STRICT')) {
              parser.addDiagnostic({
                index: codePos,
                message: 'Octal literal in strict mode'});
            } else if (!parser.state.containsOctal) {
              parser.state.containsOctal = true;
              parser.state.octalPosition = codePos;
            }
          }

          parser.state.index += octalStr.length - 1;
          return String.fromCharCode(octal);
        }

        return String.fromCharCode(ch);}
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readHexChar(parser, len, throwOnInvalid) {
    const start = parser.state.index;
    const n = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readInt(parser, 16, len);

    if (n === undefined) {
      if (throwOnInvalid) {
        parser.addDiagnostic({
          index: start,
          message: 'Bad character escape sequence'});
        return 0;
      }

      const codePos = parser.state.index;
      parser.state.index = codePos - 1;
      parser.state.invalidTemplateEscapePosition = codePos - 1;
    }

    return n;
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readWord1(parser) {
    parser.state.escapePosition = undefined;
    let word = '';
    let first = true;
    let chunkStart = parser.state.index;

    while (parser.state.index < parser.length) {
      const ch = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$fullCharCodeAtPos(parser);

      if (___$romejs$js_parser_utils$src$identifier_ts$isIdentifierChar(ch)) {
        parser.state.index += ch <= 65535 ? 1 : 2;
      } else if (parser.state.isIterator && ch === ___$romejs$string_charcodes$src$index_ts$atSign) {
        parser.state.index++;
      } else if (ch === ___$romejs$string_charcodes$src$index_ts$backslash) {
        parser.state.escapePosition = parser.state.index;

        word += parser.getRawInput(chunkStart, parser.state.index);

        if (parser.input.charCodeAt(++parser.state.index) !== ___$romejs$string_charcodes$src$index_ts$lowercaseU) {
          parser.addDiagnostic({
            index: parser.state.index,
            message: 'Expecting Unicode escape sequence \\uXXXX'});
        }

        parser.state.index++;

        const esc = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readCodePoint(parser, true);
        if (esc === undefined) {
          throw new Error('readCodePoint() should have thrown an error');
        }

        const isValid = first ? ___$romejs$js_parser_utils$src$identifier_ts$isIdentifierStart : ___$romejs$js_parser_utils$src$identifier_ts$isIdentifierChar;
        if (isValid(esc) === false) {
          parser.addDiagnostic({
            index: parser.state.index,
            message: 'Invalid Unicode escape'});
        }

        word += ___$$priv$romejs$js_parser$src$tokenizer$index_ts$codePointToString(esc);
        chunkStart = parser.state.index;
      } else {
        break;
      }

      first = false;
    }

    return word + parser.getRawInput(chunkStart, parser.state.index);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readWord(parser) {
    const word = ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readWord1(parser);
    let type = ___$romejs$js_parser$src$tokenizer$types_ts$keywords.get(word) || ___$romejs$js_parser$src$tokenizer$types_ts$types.name;

    if (type.keyword !== undefined && parser.state.escapePosition !== undefined) {
      parser.addDiagnostic({
        index: parser.state.escapePosition,
        message: `Escape sequence in keyword ${word}`});
    }

    if (parser.state.isIterator &&
    (!___$$priv$romejs$js_parser$src$tokenizer$index_ts$isIterator(word) || !parser.inScope('TYPE'))) {
      parser.addDiagnostic({
        message: `Invalid identifier ${word}`});
    }

    ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, type, word);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$isIterator(word) {
    return word === '@@iterator' || word === '@@asyncIterator';
  }

  function ___$romejs$js_parser$src$tokenizer$index_ts$isBraceBlock(parser, prevType) {
    const parent = ___$romejs$js_parser$src$tokenizer$index_ts$getCurContext(parser);
    if (parent === ___$romejs$js_parser$src$tokenizer$context_ts$types.functionExpression || parent === ___$romejs$js_parser$src$tokenizer$context_ts$types.functionStatement) {
      return true;
    }
    if (prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.colon &&
    (parent === ___$romejs$js_parser$src$tokenizer$context_ts$types.braceStatement || parent === ___$romejs$js_parser$src$tokenizer$context_ts$types.braceExpression)) {
      return !parent.isExpr;
    }

    if (prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types._return ||
    prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.name && parser.state.exprAllowed) {
      return ___$romejs$js_parser_utils$src$whitespace_ts$lineBreak.test(
      parser.getRawInput(
      parser.state.lastEndPos.index,
      parser.state.startPos.index));
    }

    if (prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types._else ||
    prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.semi ||
    prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.eof ||
    prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.parenR ||
    prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.arrow) {
      return true;
    }

    if (prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.braceL) {
      return parent === ___$romejs$js_parser$src$tokenizer$context_ts$types.braceStatement;
    }

    if (prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types._var || prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.name || prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types._const) {
      return false;
    }

    if (prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.relational) {
      return true;
    }

    return !parser.state.exprAllowed;
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$updateContext(parser, prevType) {
    if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceL)) {
      const curContext = ___$romejs$js_parser$src$tokenizer$index_ts$getCurContext(parser);
      if (curContext === ___$romejs$js_parser$src$tokenizer$context_ts$types.jsxOpenTag) {
        parser.state.context.push(___$romejs$js_parser$src$tokenizer$context_ts$types.braceExpression);
      } else if (curContext === ___$romejs$js_parser$src$tokenizer$context_ts$types.jsxInner) {
        parser.state.context.push(___$romejs$js_parser$src$tokenizer$context_ts$types.templateQuasi);
      } else {
        ___$$priv$romejs$js_parser$src$tokenizer$index_ts$_updateContext(parser, prevType);
      }
      parser.state.exprAllowed = true;
    } else if (parser.match(___$romejs$js_parser$src$tokenizer$types_ts$types.slash) && prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagStart) {
      parser.state.context.length -= 2;
      parser.state.context.push(___$romejs$js_parser$src$tokenizer$context_ts$types.jsxCloseTag);
      parser.state.exprAllowed = false;
    } else {
      ___$$priv$romejs$js_parser$src$tokenizer$index_ts$_updateContext(parser, prevType);
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$_updateContext(parser, prevType) {
    const type = parser.state.tokenType;

    if (type.keyword !== undefined &&
    (prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.dot || prevType === ___$romejs$js_parser$src$tokenizer$types_ts$types.questionDot)) {
      parser.state.exprAllowed = false;
    } else if (type.updateContext !== undefined) {
      type.updateContext(parser, prevType);
    } else {
      parser.state.exprAllowed = type.beforeExpr;
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsx(parser) {
    let out = '';
    let chunkStart = parser.state.index;
    while (true) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated JSX contents'});
        break;
      }

      const code = parser.input.charCodeAt(parser.state.index);

      if (code === ___$romejs$string_charcodes$src$index_ts$lessThan || code === ___$romejs$string_charcodes$src$index_ts$leftCurlyBrace) {
        if (parser.state.index === parser.state.startPos.index) {
          if (code === ___$romejs$string_charcodes$src$index_ts$lessThan && parser.state.exprAllowed) {
            parser.state.index++;
            return ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxTagStart);
          }

          return ___$$priv$romejs$js_parser$src$tokenizer$index_ts$getTokenFromCode(parser, code);
        }

        out += parser.getRawInput(chunkStart, parser.state.index);
        return ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxText, out);
      }

      if (code === ___$romejs$string_charcodes$src$index_ts$ampersand) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsxEntity(parser);
        chunkStart = parser.state.index;
        continue;
      }

      if (___$romejs$js_parser_utils$src$whitespace_ts$isNewLine(code)) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsxNewLine(parser, true);
        chunkStart = parser.state.index;
      } else {
        parser.state.index++;
      }
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsxNewLine(parser, normalizeCRLF) {
    const ch = parser.input.charCodeAt(parser.state.index);
    let out;
    parser.state.index++;

    if (ch === ___$romejs$string_charcodes$src$index_ts$carriageReturn &&
    parser.input.charCodeAt(parser.state.index) === ___$romejs$string_charcodes$src$index_ts$lineFeed) {
      parser.state.index++;
      out = normalizeCRLF ? '\n' : '\r\n';
    } else {
      out = String.fromCharCode(ch);
    }

    parser.state.curLine++;
    parser.resetTokenizerLine();
    return out;
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsxString(parser, quote) {
    let out = '';
    let chunkStart = ++parser.state.index;
    while (true) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated string constant'});
        break;
      }

      const ch = parser.input.charCodeAt(parser.state.index);
      if (ch === quote) {
        break;
      }

      if (ch === ___$romejs$string_charcodes$src$index_ts$ampersand) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsxEntity(parser);
        chunkStart = parser.state.index;
      } else if (___$romejs$js_parser_utils$src$whitespace_ts$isNewLine(ch)) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsxNewLine(parser, false);
        chunkStart = parser.state.index;
      } else {
        parser.state.index++;
      }
    }

    out += parser.getRawInput(chunkStart, parser.state.index++);
    return ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(parser, ___$romejs$js_parser$src$tokenizer$types_ts$types.string, out);
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsxEntity(parser) {
    let str = '';
    let count = 0;
    let entity;
    let ch = parser.input[parser.state.index];

    const startIndex = ++parser.state.index;
    while (parser.state.index < parser.length && count++ < 10) {
      ch = parser.input[parser.state.index++];
      if (ch === ';') {
        if (str[0] === '#') {
          if (str[1] === 'x') {
            str = str.substr(2);
            if (___$$priv$romejs$js_parser$src$tokenizer$index_ts$HEX_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 16));
            }
          } else {
            str = str.substr(1);
            if (___$$priv$romejs$js_parser$src$tokenizer$index_ts$DECIMAL_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 10));
            }
          }
        } else {
          entity = ___$romejs$js_parser$src$xhtmlEntities_ts$default[str];
        }
        break;
      }
      str += ch;
    }

    if (entity === undefined) {
      parser.state.index = startIndex;
      return '&';
    } else {
      return entity;
    }
  }

  function ___$$priv$romejs$js_parser$src$tokenizer$index_ts$readToken_jsxWord(parser) {
    let ch;
    const start = parser.state.index;
    do {
      ch = parser.input.charCodeAt(++parser.state.index);
    } while (___$romejs$js_parser_utils$src$identifier_ts$isIdentifierChar(ch) || ch === ___$romejs$string_charcodes$src$index_ts$dash);
    return ___$romejs$js_parser$src$tokenizer$index_ts$finishToken(
    parser,
    ___$romejs$js_parser$src$tokenizer$types_ts$types.jsxName,
    parser.getRawInput(start, parser.state.index));
  }

  // romejs/js-parser/src/tokenizer/state.ts

  const ___$$priv$romejs$js_parser$src$tokenizer$state_ts$EMPTY_POS = {
    line: 1,
    column: 0,
    index: 0};

  function ___$romejs$js_parser$src$tokenizer$state_ts$createInitialState(options) {
    return {
      scopes: {},
      diagnostics: [],
      diagnosticFilters: [],
      potentialArrowAt: -1,
      commaAfterSpreadAt: -1,
      yieldPos: 0,
      awaitPos: 0,
      noArrowAt: [],
      noArrowParamsConversionAt: [],
      maybeInArrowParameters: false,
      isIterator: false,
      noAnonFunctionType: false,
      classLevel: 0,
      labels: [],
      yieldInPossibleArrowParameters: undefined,
      comments: [],
      trailingComments: [],
      leadingComments: [],
      commentStack: [],
      commentPreviousNode: undefined,
      index: 0,
      lineStartIndex: 0,
      curLine: 1,
      tokenType: ___$romejs$js_parser$src$tokenizer$types_ts$types.eof,
      tokenValue: undefined,
      startPos: ___$$priv$romejs$js_parser$src$tokenizer$state_ts$EMPTY_POS,
      endPos: ___$$priv$romejs$js_parser$src$tokenizer$state_ts$EMPTY_POS,
      lastStartPos: ___$$priv$romejs$js_parser$src$tokenizer$state_ts$EMPTY_POS,
      lastEndPos: ___$$priv$romejs$js_parser$src$tokenizer$state_ts$EMPTY_POS,
      context: [___$romejs$js_parser$src$tokenizer$context_ts$types.braceStatement],
      exprAllowed: true,
      containsOctal: false,
      escapePosition: undefined,
      octalPosition: undefined,
      invalidTemplateEscapePosition: undefined,
      exportedIdentifiers: new Map(),
      possibleIncorrectOpenParens: [],
      lineStart: true,
      indentLevel: 0};
  }

  // romejs/js-parser/src/ParserBranchFinder.ts

  class ___$romejs$js_parser$src$ParserBranchFinder_ts$default {
    constructor(parser) {
      this.parser = parser;
      this.branch = undefined;
      this.picked = false;
    }

    hasBranch() {
      return this.branch !== undefined;
    }

    hasBranchResult() {
      return this.branch !== undefined && this.branch.result !== undefined;
    }

    add(callback, opts = {}) {
      const topBranch = this.branch;

      if (topBranch !== undefined && topBranch.optimal) {
        return this;
      }

      const {maxNewDiagnostics: maxNewDiagnostics, diagnosticsPriority: diagnosticsPriority} = opts;
      const {parser: parser} = this;
      const prevState = parser.cloneState();

      parser.pushScope('MAX_NEW_DIAGNOSTICS', maxNewDiagnostics);

      let result;
      try {
        result = callback(parser);
      } catch (err) {
        if (err instanceof ___$romejs$js_parser$src$Parser_ts$DiagnosticsFatalError) {
          parser.setState(prevState);
          return this;
        } else {
          throw err;
        }
      }

      const newState = parser.state;
      parser.popScope('MAX_NEW_DIAGNOSTICS');
      parser.setState(prevState);

      const newDiagnosticCount = newState.diagnostics.length;
      const prevDiagnosticCount = prevState.diagnostics.length;
      if (maxNewDiagnostics !== undefined &&
      newDiagnosticCount - prevDiagnosticCount > maxNewDiagnostics) {
        throw new Error(`Max diagnostics unexpectedly exceeded ${maxNewDiagnostics}. Prev: ${prevDiagnosticCount} New: ${newDiagnosticCount}`);
      }

      const branch = {
        diagnosticsPriority: diagnosticsPriority,
        result: result,
        state: newState,
        newDiagnosticCount: newDiagnosticCount - prevDiagnosticCount,
        diagnosticCount: newDiagnosticCount,
        optimal: newDiagnosticCount === prevDiagnosticCount};

      let shouldPromote = false;

      if (topBranch === undefined || branch.optimal) {
        shouldPromote = true;
      } else {
        if (branch.diagnosticCount < topBranch.diagnosticCount) {
          shouldPromote = true;
        }

        if (branch.diagnosticsPriority !== undefined &&
        topBranch.diagnosticsPriority === undefined) {
          shouldPromote = true;
        }

        if (branch.diagnosticsPriority !== undefined &&
        topBranch.diagnosticsPriority !== undefined &&
        branch.diagnosticsPriority > topBranch.diagnosticsPriority) {
          shouldPromote = true;
        }

        if (topBranch.diagnosticsPriority !== undefined &&
        branch.diagnosticsPriority === undefined) {
          shouldPromote = false;
        }
      }

      if (shouldPromote) {
        this.branch = branch;
      }

      return this;
    }

    getBranch() {
      if (this.branch === undefined) {
        throw new Error('No branch');
      } else {
        return this.branch;
      }
    }

    pickOptional() {
      if (this.hasBranch()) {
        return this.pick();
      } else {
        return undefined;
      }
    }

    pick() {
      if (this.picked) {
        throw new Error('Already been picked');
      }
      this.picked = true;

      const {parser: parser} = this;
      const branch = this.getBranch();

      const {result: result, state: state} = branch;
      parser.setState(state);
      return result;
    }
  }

  // romejs/js-parser/src/Parser.ts

  const ___$$priv$romejs$js_parser$src$Parser_ts$COMMENT_KEYS = ['leadingComments', 'trailingComments', 'innerComments'];

  const ___$$priv$romejs$js_parser$src$Parser_ts$TOKEN_MISTAKES = {
    ';': ':',
    ',': '.'};

  class ___$romejs$js_parser$src$Parser_ts$DiagnosticsFatalError extends Error {
    constructor() {
      super(
      'Diagnostics exceeded maxDiagnostics state cap, this error is expected to be handled by a try-catch in the call stack');
    }
  }

  class ___$romejs$js_parser$src$Parser_ts$default extends ___$romejs$parser_core$src$index_ts$ParserCore {
    constructor(rawOptions, input) {
      const options = ___$romejs$js_parser$src$options_ts$normalizeOptions(rawOptions);
      const state = ___$romejs$js_parser$src$tokenizer$state_ts$createInitialState(options);

      const parserOpts = {
        filename: options.filename,
        input: input};
      super(parserOpts, '@romejs/js-parser', state);

      this.tokens = [];
      this.isTrackingTokens = options.tokens;

      this.isLookahead = false;

      this.sourceType = options.sourceType;
      this.options = options;
      this.inModule =
      this.options.sourceType === 'template' ||
      this.options.sourceType === 'module';
      this.parenthesized = new WeakSet();

      this.syntax = new Set(options.syntax);
    }

    resetTokenizerLine() {
      this.state.lineStartIndex = this.state.index;
      this.state.lineStart = true;
      this.state.indentLevel = 0;
    }

    getScope(type) {
      let scope = this.state.scopes[type];
      if (scope === undefined) {
        scope = [];
        this.state.scopes[type] = scope;
      }
      return scope;
    }

    getLastScope(type) {
      const scope = this.getScope(type);
      return scope[scope.length - 1];
    }

    pushScope(type, value) {
      this.getScope(type).push(value);
    }

    popScope(type) {
      this.getScope(type).pop();
    }

    inScope(type) {
      return this.hasScope(type) && this.getLastScope(type) !== false;
    }

    hasScope(type) {
      return this.getScope(type).length > 0;
    }

    addParenthesized(node) {
      this.parenthesized.add(node);
    }

    isParenthesized(node) {
      return this.parenthesized.has(node);
    }

    retainParenthesized(before, derived) {
      if (this.isParenthesized(before)) {
        this.addParenthesized(derived);

        if (before.extra !== undefined) {
          this.addExtra(derived, 'parenStart', before.extra.parenStart);
        }
      }
      return derived;
    }

    setState(newState) {
      const maxDiagnostics = this.getLastScope('MAX_NEW_DIAGNOSTICS');
      if (typeof maxDiagnostics === 'number' && maxDiagnostics !== -1) {
        const diff = newState.diagnostics.length - this.state.diagnostics.length;
        if (diff > maxDiagnostics) {
          throw new ___$romejs$js_parser$src$Parser_ts$DiagnosticsFatalError();
        }
      }

      this.state = newState;
    }

    atEOF() {
      return this.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof);
    }

    createBranch() {
      return new ___$romejs$js_parser$src$ParserBranchFinder_ts$default(this);
    }

    tryBranch(fn) {
      const branch = new ___$romejs$js_parser$src$ParserBranchFinder_ts$default(this);
      branch.add(fn, {maxNewDiagnostics: 0});
      if (branch.hasBranchResult()) {
        return branch.pickOptional();
      }
    }

    createUnknownNode(reason, start = this.getPosition()) {
      return {
        type: 'Unknown',
        reason: reason,
        loc: this.finishLoc(start)};
    }

    assertNoSpace(message = 'Unexpected space') {
      const {state: state} = this;

      if (state.startPos.index > state.lastEndPos.index) {
        this.addDiagnostic({
          start: state.lastEndPos,
          end: state.lastEndPos,
          message: message});
      }
    }

    getDiagnostics() {
      const collector = new ___$romejs$diagnostics$src$DiagnosticsProcessor_ts$default({
        origins: ['Caught and filtered by js-parser']});

      for (const filter of this.state.diagnosticFilters) {
        collector.addFilter(filter);
      }

      return collector.addDiagnostics(this.state.diagnostics);
    }

    addDiagnosticFilter(diag) {
      this.state.diagnosticFilters.push(diag);
    }

    addCompleteDiagnostic(diags) {
      this.state.diagnostics = [...this.state.diagnostics, ...diags];
    }

    addDiagnostic(diag) {
      if (this.isLookahead) {
        return undefined;
      }

      let maxDiagnostics = this.getLastScope('MAX_NEW_DIAGNOSTICS');
      if (typeof maxDiagnostics === 'number') {
        maxDiagnostics--;
        this.popScope('MAX_NEW_DIAGNOSTICS');
        this.pushScope('MAX_NEW_DIAGNOSTICS', maxDiagnostics);
        if (maxDiagnostics < 0) {
          throw new ___$romejs$js_parser$src$Parser_ts$DiagnosticsFatalError();
        }
      }

      let {start: start, end: end} = diag;

      if (diag.index !== undefined) {
        start = this.getPositionFromIndex(diag.index);
        end = start;
      }

      if (diag.loc !== undefined) {
        start = diag.loc.start;
        end = diag.loc.end;
      }

      if (start === undefined && end === undefined) {
        start = this.getPosition();
        end = this.getEndPosition();
      }

      if (start === undefined && end !== undefined) {
        start = end;
      }

      if (start !== undefined && end === undefined) {
        end = start;
      }

      this.state.diagnostics.push({
        filename: this.filename,
        message: diag.message,
        advice: diag.advice,
        start: start,
        end: end,
        category: 'parse/js'});
    }

    shouldTokenizeJSX() {
      return !this.isSyntaxEnabled('ts') || this.isSyntaxEnabled('jsx');
    }

    isSyntaxEnabled(syntax) {
      return this.syntax.has(syntax);
    }

    expectSyntaxEnabled(syntax) {
      if (!this.isSyntaxEnabled(syntax)) {
        this.addDiagnostic({
          message: `Expected ${syntax} to be enabled`});
      }
    }

    getExtra(node, key) {
      if (node !== undefined && node.extra !== undefined) {
        return node.extra[key];
      }
    }

    addExtra(node, key, val) {
      if (!node) return undefined;

      const extra = node.extra = node.extra || {};
      extra[key] = val;
    }

    isRelational(op) {
      return this.match(___$romejs$js_parser$src$tokenizer$types_ts$types.relational) && this.state.tokenValue === op;
    }

    expectRelational(op) {
      if (this.eatRelational(op)) {
        return true;
      } else {
        this.addDiagnostic({
          message: 'Expected relational operator'});
        return false;
      }
    }

    isLookaheadRelational(op) {
      const l = this.lookaheadState();
      return l.tokenType == ___$romejs$js_parser$src$tokenizer$types_ts$types.relational && l.tokenValue == op;
    }

    banUnicodeEscape(index, name) {
      if (index !== undefined) {
        this.addDiagnostic({
          index: index,
          message: `${name} can't contain a unicode escape`});
      }
    }

    eatRelational(op) {
      if (this.isRelational(op)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }

    isContextual(name) {
      return this.match(___$romejs$js_parser$src$tokenizer$types_ts$types.name) &&
      this.state.tokenValue === name &&
      this.state.escapePosition === undefined;
    }

    isLookaheadContextual(name) {
      const l = this.lookaheadState();
      return l.tokenType === ___$romejs$js_parser$src$tokenizer$types_ts$types.name &&
      l.tokenValue === name &&
      l.escapePosition === undefined;
    }

    eatContextual(name) {
      if (this.isContextual(name)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }

    expectContextual(name, message = 'Expected keyword ' + name) {
      if (this.eatContextual(name)) {
        return true;
      } else {
        this.addDiagnostic({
          message: message});
        return false;
      }
    }

    canInsertSemicolon() {
      return this.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof) ||
      this.match(___$romejs$js_parser$src$tokenizer$types_ts$types.braceR) ||
      this.hasPrecedingLineBreak();
    }

    hasPrecedingLineBreak() {
      return ___$romejs$js_parser_utils$src$whitespace_ts$lineBreak.test(
      this.getRawInput(this.state.lastEndPos.index, this.state.startPos.index));
    }

    isLineTerminator() {
      return this.eat(___$romejs$js_parser$src$tokenizer$types_ts$types.semi) || this.canInsertSemicolon();
    }

    semicolon() {
      if (!this.isLineTerminator()) {
        this.addDiagnostic({
          message: 'Expected a semicolon here or a line terminator'});
      }
    }

    expect(type, pos) {
      if (this.eat(type)) {
        return true;
      } else {
        this.unexpectedToken(pos, type);
        return false;
      }
    }

    expectOpening(open, close, name) {
      const pos = this.getPosition();
      const indent = this.state.indentLevel;
      this.expect(open);
      return {
        indent: indent,
        start: pos,
        name: name,
        close: close};
    }

    expectClosing(context) {
      if (this.match(context.close)) {
        if (this.state.indentLevel !== context.indent) {
          this.state.possibleIncorrectOpenParens.push(context);
        }
        this.next();
        return true;
      } else {
        const currPos = this.getPosition();

        const advice = [{
          type: 'log',
          category: 'info',
          message: `This is where we expected to find '${context.close.label}'`}, {
          type: 'frame',
          filename: this.filename,
          start: currPos,
          end: currPos}];

        const possibleThief = this.state.possibleIncorrectOpenParens.shift();
        if (possibleThief !== undefined) {
          advice.push({
            type: 'log',
            category: 'info',
            message: `We found this ${possibleThief.name} that looks supicious. It could be the real culprit that's unclosed.`});

          advice.push({
            type: 'frame',
            filename: this.filename,
            start: possibleThief.start,
            end: possibleThief.start});
        }

        this.addDiagnostic({
          message: `Unclosed ${context.name}`,
          start: context.start,
          end: context.start,
          advice: advice});
        return false;
      }
    }

    unexpectedToken(pos, tokenType) {
      const advice = [];
      let message = 'Unexpected token';

      if (tokenType !== undefined) {
        message += `, expected "${tokenType.label}"`;

        const possibleMistake = ___$$priv$romejs$js_parser$src$Parser_ts$TOKEN_MISTAKES[tokenType.label];
        if (possibleMistake !== undefined &&
        possibleMistake === this.state.tokenType.label) {
          advice.push({
            type: 'log',
            category: 'info',
            message: `Did you accidently hold shift?`});
        }
      }

      this.addDiagnostic({
        message: message,
        start: pos === undefined ? this.state.startPos : pos,
        end: pos === undefined ? this.state.endPos : pos,
        advice: advice});
    }

    unexpected() {
      throw new Error('js-parser should never throw an exception, use addDiagnostic or unexpectedToken instead');
    }

    tokenize() {
      throw new Error('js-parser does not use the parser-core tokenizer');
    }

    cloneNode(node) {
      const node2 = {};

      for (const key of Object.keys(node)) {
        if (!___$$priv$romejs$js_parser$src$Parser_ts$COMMENT_KEYS.includes(key)) {
          node2[key] = node[key];
        }
      }

      return node2;
    }

    resetStartLocationFromNode(node, locationNode) {
      ___$romejs$invariant$src$index_ts$default(node.loc, 'expected node loc');
      ___$romejs$invariant$src$index_ts$default(locationNode.loc, 'expected locationNode loc');
      node.loc = Object.assign({}, node.loc, {
        start: locationNode.loc.start});
    }

    next() {
      if (this.isTrackingTokens === true && this.isLookahead === false) {
        this.tokens.push(new ___$romejs$js_parser$src$tokenizer$index_ts$Token(this.state, this));
      }

      this.state.lastEndPos = this.state.endPos;
      this.state.lastStartPos = this.state.startPos;
      ___$romejs$js_parser$src$tokenizer$index_ts$nextToken(this);
    }

    eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      }

      return false;
    }

    match(type) {
      return this.state.tokenType === type;
    }

    lookaheadState() {
      const old = this.state;
      this.state = this.cloneState(true);

      this.isLookahead = true;
      this.next();
      this.isLookahead = false;

      const curr = this.state;
      this.state = old;
      return curr;
    }

    cloneState(skipArrays = false) {
      const state = Object.assign({}, this.state);

      for (const key in state) {
        let val = state[key];

        const shouldSlice = skipArrays === false || key === 'context';
        if (shouldSlice && Array.isArray(val)) {
          state[key] = val.slice();
        }
      }

      const scopes = Object.assign({}, state.scopes);
      state.scopes = scopes;
      for (const type in scopes) {
        const scope = scopes[type];
        scopes[type] = scope.slice();
      }

      return state;
    }

    getPosition() {
      return this.state.startPos;
    }

    getEndPosition() {
      return this.state.lastEndPos;
    }

    getPositionFromState() {
      const {state: state} = this;
      return {
        index: state.index,
        line: state.curLine,
        column: state.index - state.lineStartIndex};
    }

    parse() {
      if (this.inModule) {
        this.pushScope('ASYNC', true);
        this.pushScope('STRICT', true);
      }

      const program = ___$romejs$js_parser$src$parser$statement_ts$parseTopLevel(this);

      if (this.inModule) {
        this.popScope('ASYNC');
        this.popScope('STRICT');
      }

      for (const type in this.state.scopes) {
        if (this.hasScope(type)) {
          throw new Error(`Finished parsing but there was still a ${type} scope stack`);
        }
      }

      if (!this.match(___$romejs$js_parser$src$tokenizer$types_ts$types.eof)) {
        throw new Error('Finish parsing but we arent at the end of the file');
      }

      return program;
    }
  }

  // romejs/js-parser/src/index.ts

  function ___$romejs$js_parser$src$index_ts$parse(input, options) {
    return new ___$romejs$js_parser$src$Parser_ts$default(options, input).parse();
  }

  function ___$romejs$js_parser$src$index_ts$tokenise(input, options) {
    const parser = new ___$romejs$js_parser$src$Parser_ts$default(Object.assign({}, options, {
      tokens: true}), input);
    return parser.tokens;
  }

  // romejs/js-ast-utils/src/template.ts

  const ___$$priv$romejs$js_ast_utils$src$template_ts$templateCache = new Map();

  function ___$$priv$romejs$js_ast_utils$src$template_ts$getTemplate(strs) {
    const cached = ___$$priv$romejs$js_ast_utils$src$template_ts$templateCache.get(strs);
    if (cached) {
      return cached;
    }

    const pathCount = strs.length - 1;

    let placeholders = {};
    const placeholderIds = [];
    for (let i = 0; i < pathCount; i++) {
      const id = `__${String(i)}__`;
      placeholderIds.push(id);
      placeholders[id] = undefined;
    }

    let code = '';
    for (let i = 0; i < strs.length; i++) {
      code += strs[i];

      const placeholder = placeholderIds[i];
      if (placeholder) {
        code += placeholder;
      }
    }

    let ast = ___$romejs$js_parser$src$index_ts$parse(code, {
      sourceType: 'template',
      filename: 'template'});

    ast = ___$romejs$js_ast_utils$src$assertSingleNode_ts$default(___$romejs$js_ast_utils$src$removeLoc_ts$default(ast));

    const collectPlaceholderPaths = path => {
      const {node: node} = path;
      if (node.type === 'Identifier' && node.name in placeholders) {
        placeholders[node.name] = path.getPathKeys();
      }
      return node;
    };
    const context = new ___$romejs$js_compiler$src$lib$Context_ts$default({ast: ast, projectConfig: ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG});
    context.reduce(ast, [{name: 'collectPlaceholderPaths', enter: collectPlaceholderPaths}]);

    const placeholderPaths = [];
    for (const id in placeholders) {
      const path = placeholders[id];
      if (path) {
        placeholderPaths.push(path);
      } else {
        throw new Error(`Failed to find placeholder path for ${id}`);
      }
    }

    return {ast: ast, placeholderPaths: placeholderPaths};
  }

  function ___$romejs$js_ast_utils$src$template_ts$default(strs, ...substitutions) {
    const {ast: ast, placeholderPaths: placeholderPaths} = ___$$priv$romejs$js_ast_utils$src$template_ts$getTemplate(strs);

    if (!substitutions.length) {
      return ast;
    }

    ___$romejs$invariant$src$index_ts$default(
    placeholderPaths.length === substitutions.length,
    'expected subtituions to be the same length as paths');

    const newAst = Object.assign({}, ast);

    for (let i = 0; i < placeholderPaths.length; i++) {
      const paths = placeholderPaths[i];

      let substitute = substitutions[i];
      if (typeof substitute === 'string') {
        substitute = ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: substitute});
      }

      let target = newAst;

      for (let i = 0; i < paths.length; i++) {
        const key = paths[i];
        const isLast = i === paths.length - 1;

        if (isLast) {
          target[key] = substitute;
        } else {
          let currTarget = target[key];
          if (Array.isArray(currTarget)) {
            currTarget = currTarget.slice();
          } else {
            currTarget = Object.assign({}, currTarget);
          }
          target[key] = currTarget;
          target = currTarget;
        }
      }
    }

    return newAst;
  }

  ___$romejs$js_ast_utils$src$template_ts$default.expression = (strs, ...substitutions) => {
    const first = ___$romejs$js_ast_utils$src$template_ts$default.statement(strs, ...substitutions);

    ___$romejs$invariant$src$index_ts$default(
    first.type === 'ExpressionStatement',
    'Single statement should be an ExpressionStatement');

    return first.expression;
  };

  ___$romejs$js_ast_utils$src$template_ts$default.statement = (strs, ...substitutions) => {
    const ast = ___$romejs$js_ast$src$core$Program_ts$program.assert(___$romejs$js_ast_utils$src$template_ts$default(strs, ...substitutions));

    const body = ast.body;
    ___$romejs$invariant$src$index_ts$default(
    body.length === 1,
    'More than one statement isn\'t allowed for a template.');
    return body[0];
  };

  // romejs/js-ast-utils/src/isInTypeAnnotation.ts

  function ___$romejs$js_ast_utils$src$isInTypeAnnotation_ts$default(path) {
    const parentTypeAnnotation = path.findAncestry(path => ___$romejs$js_ast_utils$src$isTypeNode_ts$default(path.node));
    return parentTypeAnnotation !== undefined;
  }

  // romejs/js-ast-utils/src/index.ts


  // romejs/js-compiler/src/scope/utils.ts

  function ___$romejs$js_compiler$src$scope$utils_ts$addFunctionBindings(scope, node, hasArguments = true) {
    scope.evaluate(node.typeParameters);

    for (const param of node.params) {
      for (const id of ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(param)) {
        scope.addBinding(
        new ___$romejs$js_compiler$src$scope$bindings_ts$LetBinding({
          node: id,
          name: id.name,
          scope: scope}));
      }
    }

    if (hasArguments) {
      scope.addBinding(
      new ___$romejs$js_compiler$src$scope$bindings_ts$ArgumentsBinding({
        name: 'arguments',
        node: node,
        scope: scope}));
    }

    ___$romejs$js_compiler$src$scope$utils_ts$addVarBindings(scope, node);
  }

  function ___$romejs$js_compiler$src$scope$utils_ts$addVarBindings(scope, topNode) {
    const {context: context} = scope.getRootScope();

    context.reduce(
    topNode,
    [{
      name: 'scopeVarFunc',
      enter: path => {
        const {node: node, parent: parent} = path;

        if (___$romejs$js_ast_utils$src$isFunctionNode_ts$default(node) && node !== topNode) {
          return ___$romejs$js_compiler$src$constants_ts$REDUCE_SKIP_SUBTREE;
        }

        if (node.type === 'VariableDeclaration' && node.kind === 'var') {
          scope.evaluate(node, parent);
        }

        return node;
      }}],
    {
      scope: scope,
      noScopeCreation: true});
  }

  // romejs/js-compiler/src/scope/pure-evaluators/ArrowFunctionExpression.ts

  function ___$romejs$js_compiler$src$scope$pure_evaluators$ArrowFunctionExpression_ts$default(node, parent, scope) {
    const newScope = scope.fork('function', node);
    ___$romejs$js_compiler$src$scope$utils_ts$addFunctionBindings(newScope, node, false);
    return newScope;
  }

  // romejs/js-compiler/src/scope/pure-evaluators/ClassMethod.ts

  function ___$romejs$js_compiler$src$scope$pure_evaluators$ClassMethod_ts$default(node, parent, scope) {
    const newScope = scope.fork('function', node);
    ___$romejs$js_compiler$src$scope$utils_ts$addFunctionBindings(newScope, node);
    return newScope;
  }

  // romejs/js-compiler/src/scope/pure-evaluators/FunctionExpression.ts

  function ___$romejs$js_compiler$src$scope$pure_evaluators$FunctionExpression_ts$default(node, parent, scope) {
    const newScope = scope.fork('function', node);
    if (node.id !== undefined) {
      newScope.addBinding(
      new ___$romejs$js_compiler$src$scope$bindings_ts$LetBinding({
        node: node.id,
        name: node.id.name,
        scope: scope}));
    }
    ___$romejs$js_compiler$src$scope$utils_ts$addFunctionBindings(newScope, node);
    return newScope;
  }

  // romejs/js-compiler/src/scope/pure-evaluators/ObjectMethod.ts

  function ___$romejs$js_compiler$src$scope$pure_evaluators$ObjectMethod_ts$default(node, parent, scope) {
    const newScope = scope.fork('function', node);
    ___$romejs$js_compiler$src$scope$utils_ts$addFunctionBindings(newScope, node);
    return newScope;
  }

  // romejs/js-compiler/src/scope/pure-evaluators/BlockStatement.ts

  function ___$romejs$js_compiler$src$scope$pure_evaluators$BlockStatement_ts$default(node, parent, scope) {
    const newScope = scope.fork('block', node);
    for (const child of node.body) {
      newScope.evaluate(child, node);
    }
    return newScope;
  }

  // romejs/js-compiler/src/scope/pure-evaluators/ClassExpression.ts

  function ___$romejs$js_compiler$src$scope$pure_evaluators$ClassExpression_ts$default(node, parent, scope) {
    const newScope = scope.fork('class', node);
    newScope.evaluate(node.typeParameters);
    return newScope;
  }

  // romejs/js-compiler/src/scope/pure-evaluators/CatchClause.ts

  function ___$romejs$js_compiler$src$scope$pure_evaluators$CatchClause_ts$default(node, parent, scope) {
    const newScope = scope.fork('block', node);
    if (node.param !== undefined) {
      for (const id of ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(node.param)) {
        scope.addBinding(
        new ___$romejs$js_compiler$src$scope$bindings_ts$LetBinding({
          node: id,
          name: id.name,
          scope: scope}));
      }
    }
    return newScope;
  }

  // romejs/js-compiler/src/scope/pure-evaluators/Program.ts

  function ___$romejs$js_compiler$src$scope$pure_evaluators$Program_ts$default(node, parent, scope) {
    const newScope = scope.fork('program', node);
    for (const child of node.body) {
      newScope.evaluate(child, node);
    }
    ___$romejs$js_compiler$src$scope$utils_ts$addVarBindings(newScope, node);
    return newScope;
  }

  // romejs/js-compiler/src/scope/pure-evaluators/ForStatement.ts

  function ___$romejs$js_compiler$src$scope$pure_evaluators$ForStatement_ts$default(node, parent, scope) {
    const newScope = scope.fork('loop', node);
    newScope.evaluate(node.init, node);
    return newScope;
  }

  // romejs/js-compiler/src/scope/pure-evaluators/ForOfStatement.ts

  function ___$romejs$js_compiler$src$scope$pure_evaluators$ForOfStatement_ts$default(node, parent, scope) {
    const newScope = scope.fork('loop', node);
    newScope.evaluate(node.left, node);
    return newScope;
  }

  // romejs/js-compiler/src/scope/pure-evaluators/index.ts

  const ___$romejs$js_compiler$src$scope$pure_evaluators$index_ts = {
    get ArrowFunctionExpression() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$ArrowFunctionExpression_ts$default;
    },
    get ClassMethod() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$ClassMethod_ts$default;
    },
    get FunctionExpression() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$FunctionExpression_ts$default;
    },
    get ObjectMethod() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$ObjectMethod_ts$default;
    },
    get BlockStatement() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$BlockStatement_ts$default;
    },
    get ClassExpression() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$ClassExpression_ts$default;
    },
    get CatchClause() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$CatchClause_ts$default;
    },
    get Program() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$Program_ts$default;
    },
    get ForStatement() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$ForStatement_ts$default;
    },
    get ForOfStatement() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$ForOfStatement_ts$default;
    },
    get ForInStatement() {
      return ___$romejs$js_compiler$src$scope$pure_evaluators$ForOfStatement_ts$default;
    }};

  // romejs/js-compiler/src/scope/evaluators/ClassDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$ClassDeclaration_ts$default(node, parent, scope) {
    if (node.id !== undefined) {
      scope.addBinding(
      new ___$romejs$js_compiler$src$scope$bindings_ts$ClassBinding({
        name: node.id.name,
        node: node.id,
        scope: scope}));
    }
    return ___$romejs$js_compiler$src$scope$pure_evaluators$ClassExpression_ts$default(node, parent, scope);
  }

  // romejs/js-compiler/src/scope/evaluators/FunctionDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$FunctionDeclaration_ts$default(node, parent, scope) {
    if (node.id !== undefined) {
      scope.addBinding(
      new ___$romejs$js_compiler$src$scope$bindings_ts$FunctionBinding({
        node: node.id,
        name: node.id.name,
        scope: scope}));
    }
    const newScope = scope.fork('function', node);
    ___$romejs$js_compiler$src$scope$utils_ts$addFunctionBindings(newScope, node);
    return newScope;
  }

  // romejs/js-compiler/src/scope/evaluators/VariableDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$VariableDeclaration_ts$default(node, parent, scope) {
    for (const id of ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(node)) {
      switch (node.kind) {
        case 'let':
          scope.addBinding(
          new ___$romejs$js_compiler$src$scope$bindings_ts$LetBinding({
            node: id,
            name: id.name,
            scope: scope}));
          break;

        case 'const':
          scope.addBinding(
          new ___$romejs$js_compiler$src$scope$bindings_ts$ConstBinding({
            node: id,
            name: id.name,
            scope: scope}));
          break;

        case 'var':
          const funcScope = scope.getParentScope('function') ||
          scope.getParentScope('program') ||
          scope.getRootScope();
          funcScope.addBinding(
          new ___$romejs$js_compiler$src$scope$bindings_ts$VarBinding({
            node: id,
            name: id.name,
            scope: scope}));
          break;}
    }
  }

  // romejs/js-compiler/src/scope/evaluators/FlowTypeAlias.ts

  function ___$romejs$js_compiler$src$scope$evaluators$FlowTypeAlias_ts$default(node, parent, scope) {
    scope.evaluate(node.typeParameters);
    scope.addBinding(
    new ___$romejs$js_compiler$src$scope$bindings_ts$TypeBinding({
      node: node.id,
      name: node.id.name,
      scope: scope}));
  }

  // romejs/js-compiler/src/scope/evaluators/ExportDefaultDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$ExportDefaultDeclaration_ts$default(node, parent, scope) {
    const {declaration: declaration} = node;
    const newScope = scope.evaluate(declaration, node);
    if ((declaration.type === 'ClassDeclaration' ||
    declaration.type === 'FunctionDeclaration') &&
    declaration.id !== undefined) {
      newScope.getBindingAssert(declaration.id.name).setExported(true);
    }
    return newScope;
  }

  // romejs/js-compiler/src/scope/evaluators/ExportNamedDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$ExportNamedDeclaration_ts$default(node, parent, scope) {
    const newScope = scope.evaluate(node.declaration, node);
    for (const id of ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(node)) {
      newScope.getBindingAssert(id.name).setExported(true);
    }
    return newScope;
  }

  // romejs/js-compiler/src/scope/evaluators/ImportDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$ImportDeclaration_ts$default(node, parent, scope) {
    const source = node.source.value;

    for (const specifier of node.specifiers) {
      let kind = specifier.importKind || node.importKind || 'value';
      let meta;

      if (specifier.type === 'ImportNamespaceSpecifier') {
        meta = {
          kind: kind,
          type: 'namespace',
          source: source};
      } else if (specifier.type === 'ImportDefaultSpecifier') {
        meta = {
          kind: kind,
          type: 'name',
          imported: 'default',
          source: source};
      } else if (specifier.type === 'ImportSpecifier') {
        meta = {
          kind: kind,
          type: 'name',
          imported: specifier.imported.name,
          source: source};
      }

      if (meta === undefined) {
        return undefined;
      }

      scope.addBinding(
      new ___$romejs$js_compiler$src$scope$bindings_ts$ImportBinding({
        node: specifier.local,
        name: specifier.local.name,
        scope: scope}, meta));
    }
  }

  // romejs/js-compiler/src/scope/evaluators/FlowTypeParameterDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$FlowTypeParameterDeclaration_ts$default(node, parent, scope) {
    for (const id of ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(node)) {
      scope.addBinding(
      new ___$romejs$js_compiler$src$scope$bindings_ts$TypeBinding({
        node: id,
        name: id.name,
        scope: scope}));
    }
  }

  // romejs/js-compiler/src/scope/evaluators/FlowDeclareExportDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$FlowDeclareExportDeclaration_ts$default(node, parent, scope) {
    const {declaration: declaration} = node;
    const newScope = scope.evaluate(declaration, node);
    if (declaration !== undefined) {
      if (declaration.type === 'FlowDeclareOpaqueType') {
        newScope.getBindingAssert(declaration.id.name).setExported(true);
      }
    }
    return newScope;
  }

  // romejs/js-compiler/src/scope/evaluators/SwitchCase.ts

  function ___$romejs$js_compiler$src$scope$evaluators$SwitchCase_ts$default(node, parent, scope) {
    for (const child of node.consequent) {
      scope.evaluate(child, node);
    }
  }

  // romejs/js-compiler/src/scope/evaluators/SwitchStatement.ts

  function ___$romejs$js_compiler$src$scope$evaluators$SwitchStatement_ts$default(node, parent, scope) {
    for (const child of node.cases) {
      scope.evaluate(child, node);
    }
  }

  // romejs/js-compiler/src/scope/evaluators/FlowInterfaceDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$FlowInterfaceDeclaration_ts$default(node, parent, scope) {
    scope.addBinding(
    new ___$romejs$js_compiler$src$scope$bindings_ts$TypeBinding({
      node: node.id,
      name: node.id.name,
      scope: scope}));
  }

  // romejs/js-compiler/src/scope/evaluators/FlowOpaqueType.ts

  function ___$romejs$js_compiler$src$scope$evaluators$FlowOpaqueType_ts$default(node, parent, scope) {
    scope.addBinding(
    new ___$romejs$js_compiler$src$scope$bindings_ts$TypeBinding({
      node: node.id,
      name: node.id.name,
      scope: scope}));
  }

  // romejs/js-compiler/src/scope/evaluators/FlowDeclareOpaqueType.ts


  // romejs/js-compiler/src/scope/evaluators/FlowDeclareFunction.ts

  function ___$romejs$js_compiler$src$scope$evaluators$FlowDeclareFunction_ts$default(node, parent, scope) {
    scope.addBinding(
    new ___$romejs$js_compiler$src$scope$bindings_ts$TypeBinding({
      node: node.id,
      name: node.id.name,
      scope: scope}));
  }

  // romejs/js-compiler/src/scope/evaluators/TSTypeAliasDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$TSTypeAliasDeclaration_ts$default(node, parent, scope) {
    return ___$romejs$js_compiler$src$scope$evaluators$FlowTypeAlias_ts$default(node, parent, scope);
  }

  // romejs/js-compiler/src/scope/evaluators/TSImportEqualsDeclaration.ts

  function ___$romejs$js_compiler$src$scope$evaluators$TSImportEqualsDeclaration_ts$default(node, parent, scope) {
    const {moduleReference: moduleReference, id: id} = node;

    if (moduleReference.type === 'TSExternalModuleReference') {
      scope.addBinding(
      new ___$romejs$js_compiler$src$scope$bindings_ts$ImportBinding({
        node: id,
        name: id.name,
        scope: scope}, {
        type: 'namespace',
        source: moduleReference.expression.value}));
    } else {}
  }

  // romejs/js-compiler/src/scope/evaluators/index.ts

  const ___$romejs$js_compiler$src$scope$evaluators$index_ts = {
    get ClassDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$ClassDeclaration_ts$default;
    },
    get FunctionDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$FunctionDeclaration_ts$default;
    },
    get VariableDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$VariableDeclaration_ts$default;
    },
    get FlowTypeAlias() {
      return ___$romejs$js_compiler$src$scope$evaluators$FlowTypeAlias_ts$default;
    },
    get ExportDefaultDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$ExportDefaultDeclaration_ts$default;
    },
    get ExportNamedDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$ExportNamedDeclaration_ts$default;
    },
    get ImportDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$ImportDeclaration_ts$default;
    },
    get FlowTypeParameterDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$FlowTypeParameterDeclaration_ts$default;
    },
    get FlowDeclareExportDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$FlowDeclareExportDeclaration_ts$default;
    },
    get SwitchCase() {
      return ___$romejs$js_compiler$src$scope$evaluators$SwitchCase_ts$default;
    },
    get SwitchStatement() {
      return ___$romejs$js_compiler$src$scope$evaluators$SwitchStatement_ts$default;
    },
    get FlowInterfaceDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$FlowInterfaceDeclaration_ts$default;
    },
    get FlowOpaqueType() {
      return ___$romejs$js_compiler$src$scope$evaluators$FlowOpaqueType_ts$default;
    },
    get FlowDeclareOpaqueType() {
      return ___$romejs$js_compiler$src$scope$evaluators$FlowOpaqueType_ts$default;
    },
    get FlowDeclareFunction() {
      return ___$romejs$js_compiler$src$scope$evaluators$FlowDeclareFunction_ts$default;
    },
    get TSTypeAliasDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$TSTypeAliasDeclaration_ts$default;
    },
    get TSImportEqualsDeclaration() {
      return ___$romejs$js_compiler$src$scope$evaluators$TSImportEqualsDeclaration_ts$default;
    }};

  // romejs/js-compiler/src/scope/globals.ts

  const ___$romejs$js_compiler$src$scope$globals_ts$builtin = ['Array', 'ArrayBuffer', 'Atomics', 'BigInt', 'BigInt64Array', 'BigUint64Array', 'Boolean', 'constructor', 'DataView', 'Date', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'Error', 'escape', 'eval', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'globalThis', 'hasOwnProperty', 'Infinity', 'Int16Array', 'Int32Array', 'Int8Array', 'isFinite', 'isNaN', 'isPrototypeOf', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'parseFloat', 'parseInt', 'Promise', 'propertyIsEnumerable', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set', 'SharedArrayBuffer', 'String', 'Symbol', 'SyntaxError', 'toLocaleString', 'toString', 'TypeError', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray', 'undefined', 'unescape', 'URIError', 'valueOf', 'WeakMap', 'WeakSet'];

  const ___$romejs$js_compiler$src$scope$globals_ts$es5 = ['Array', 'Boolean', 'constructor', 'Date', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'Error', 'escape', 'eval', 'EvalError', 'Function', 'hasOwnProperty', 'Infinity', 'isFinite', 'isNaN', 'isPrototypeOf', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'parseFloat', 'parseInt', 'propertyIsEnumerable', 'RangeError', 'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'toLocaleString', 'toString', 'TypeError', 'undefined', 'unescape', 'URIError', 'valueOf'];

  const ___$romejs$js_compiler$src$scope$globals_ts$es2015 = ['Array', 'ArrayBuffer', 'Boolean', 'constructor', 'DataView', 'Date', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'Error', 'escape', 'eval', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'hasOwnProperty', 'Infinity', 'Int16Array', 'Int32Array', 'Int8Array', 'isFinite', 'isNaN', 'isPrototypeOf', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'parseFloat', 'parseInt', 'Promise', 'propertyIsEnumerable', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'SyntaxError', 'toLocaleString', 'toString', 'TypeError', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray', 'undefined', 'unescape', 'URIError', 'valueOf', 'WeakMap', 'WeakSet'];

  const ___$romejs$js_compiler$src$scope$globals_ts$es2017 = ['Array', 'ArrayBuffer', 'Atomics', 'Boolean', 'constructor', 'DataView', 'Date', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'Error', 'escape', 'eval', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'hasOwnProperty', 'Infinity', 'Int16Array', 'Int32Array', 'Int8Array', 'isFinite', 'isNaN', 'isPrototypeOf', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'parseFloat', 'parseInt', 'Promise', 'propertyIsEnumerable', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set', 'SharedArrayBuffer', 'String', 'Symbol', 'SyntaxError', 'toLocaleString', 'toString', 'TypeError', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray', 'undefined', 'unescape', 'URIError', 'valueOf', 'WeakMap', 'WeakSet'];

  const ___$romejs$js_compiler$src$scope$globals_ts$browser = ['AbortController', 'AbortSignal', 'addEventListener', 'alert', 'AnalyserNode', 'Animation', 'AnimationEffectReadOnly', 'AnimationEffectTiming', 'AnimationEffectTimingReadOnly', 'AnimationEvent', 'AnimationPlaybackEvent', 'AnimationTimeline', 'applicationCache', 'ApplicationCache', 'ApplicationCacheErrorEvent', 'atob', 'Attr', 'Audio', 'AudioBuffer', 'AudioBufferSourceNode', 'AudioContext', 'AudioDestinationNode', 'AudioListener', 'AudioNode', 'AudioParam', 'AudioProcessingEvent', 'AudioScheduledSourceNode', 'AudioWorkletGlobalScope ', 'AudioWorkletNode', 'AudioWorkletProcessor', 'BarProp', 'BaseAudioContext', 'BatteryManager', 'BeforeUnloadEvent', 'BiquadFilterNode', 'Blob', 'BlobEvent', 'blur', 'BroadcastChannel', 'btoa', 'BudgetService', 'ByteLengthQueuingStrategy', 'Cache', 'caches', 'CacheStorage', 'cancelAnimationFrame', 'cancelIdleCallback', 'CanvasCaptureMediaStreamTrack', 'CanvasGradient', 'CanvasPattern', 'CanvasRenderingContext2D', 'ChannelMergerNode', 'ChannelSplitterNode', 'CharacterData', 'clearInterval', 'clearTimeout', 'clientInformation', 'ClipboardEvent', 'close', 'closed', 'CloseEvent', 'Comment', 'CompositionEvent', 'confirm', 'console', 'ConstantSourceNode', 'ConvolverNode', 'CountQueuingStrategy', 'createImageBitmap', 'Credential', 'CredentialsContainer', 'crypto', 'Crypto', 'CryptoKey', 'CSS', 'CSSConditionRule', 'CSSFontFaceRule', 'CSSGroupingRule', 'CSSImportRule', 'CSSKeyframeRule', 'CSSKeyframesRule', 'CSSMediaRule', 'CSSNamespaceRule', 'CSSPageRule', 'CSSRule', 'CSSRuleList', 'CSSStyleDeclaration', 'CSSStyleRule', 'CSSStyleSheet', 'CSSSupportsRule', 'CustomElementRegistry', 'customElements', 'CustomEvent', 'DataTransfer', 'DataTransferItem', 'DataTransferItemList', 'defaultstatus', 'defaultStatus', 'DelayNode', 'DeviceMotionEvent', 'DeviceOrientationEvent', 'devicePixelRatio', 'dispatchEvent', 'document', 'Document', 'DocumentFragment', 'DocumentType', 'DOMError', 'DOMException', 'DOMImplementation', 'DOMMatrix', 'DOMMatrixReadOnly', 'DOMParser', 'DOMPoint', 'DOMPointReadOnly', 'DOMQuad', 'DOMRect', 'DOMRectReadOnly', 'DOMStringList', 'DOMStringMap', 'DOMTokenList', 'DragEvent', 'DynamicsCompressorNode', 'Element', 'ErrorEvent', 'event', 'Event', 'EventSource', 'EventTarget', 'external', 'fetch', 'File', 'FileList', 'FileReader', 'find', 'focus', 'FocusEvent', 'FontFace', 'FontFaceSetLoadEvent', 'FormData', 'frameElement', 'frames', 'GainNode', 'Gamepad', 'GamepadButton', 'GamepadEvent', 'getComputedStyle', 'getSelection', 'HashChangeEvent', 'Headers', 'history', 'History', 'HTMLAllCollection', 'HTMLAnchorElement', 'HTMLAreaElement', 'HTMLAudioElement', 'HTMLBaseElement', 'HTMLBodyElement', 'HTMLBRElement', 'HTMLButtonElement', 'HTMLCanvasElement', 'HTMLCollection', 'HTMLContentElement', 'HTMLDataElement', 'HTMLDataListElement', 'HTMLDetailsElement', 'HTMLDialogElement', 'HTMLDirectoryElement', 'HTMLDivElement', 'HTMLDListElement', 'HTMLDocument', 'HTMLElement', 'HTMLEmbedElement', 'HTMLFieldSetElement', 'HTMLFontElement', 'HTMLFormControlsCollection', 'HTMLFormElement', 'HTMLFrameElement', 'HTMLFrameSetElement', 'HTMLHeadElement', 'HTMLHeadingElement', 'HTMLHRElement', 'HTMLHtmlElement', 'HTMLIFrameElement', 'HTMLImageElement', 'HTMLInputElement', 'HTMLLabelElement', 'HTMLLegendElement', 'HTMLLIElement', 'HTMLLinkElement', 'HTMLMapElement', 'HTMLMarqueeElement', 'HTMLMediaElement', 'HTMLMenuElement', 'HTMLMetaElement', 'HTMLMeterElement', 'HTMLModElement', 'HTMLObjectElement', 'HTMLOListElement', 'HTMLOptGroupElement', 'HTMLOptionElement', 'HTMLOptionsCollection', 'HTMLOutputElement', 'HTMLParagraphElement', 'HTMLParamElement', 'HTMLPictureElement', 'HTMLPreElement', 'HTMLProgressElement', 'HTMLQuoteElement', 'HTMLScriptElement', 'HTMLSelectElement', 'HTMLShadowElement', 'HTMLSlotElement', 'HTMLSourceElement', 'HTMLSpanElement', 'HTMLStyleElement', 'HTMLTableCaptionElement', 'HTMLTableCellElement', 'HTMLTableColElement', 'HTMLTableElement', 'HTMLTableRowElement', 'HTMLTableSectionElement', 'HTMLTemplateElement', 'HTMLTextAreaElement', 'HTMLTimeElement', 'HTMLTitleElement', 'HTMLTrackElement', 'HTMLUListElement', 'HTMLUnknownElement', 'HTMLVideoElement', 'IDBCursor', 'IDBCursorWithValue', 'IDBDatabase', 'IDBFactory', 'IDBIndex', 'IDBKeyRange', 'IDBObjectStore', 'IDBOpenDBRequest', 'IDBRequest', 'IDBTransaction', 'IDBVersionChangeEvent', 'IdleDeadline', 'IIRFilterNode', 'Image', 'ImageBitmap', 'ImageBitmapRenderingContext', 'ImageCapture', 'ImageData', 'indexedDB', 'innerHeight', 'innerWidth', 'InputEvent', 'IntersectionObserver', 'IntersectionObserverEntry', 'Intl', 'isSecureContext', 'KeyboardEvent', 'KeyframeEffect', 'KeyframeEffectReadOnly', 'length', 'localStorage', 'location', 'Location', 'locationbar', 'matchMedia', 'MediaDeviceInfo', 'MediaDevices', 'MediaElementAudioSourceNode', 'MediaEncryptedEvent', 'MediaError', 'MediaKeyMessageEvent', 'MediaKeySession', 'MediaKeyStatusMap', 'MediaKeySystemAccess', 'MediaList', 'MediaQueryList', 'MediaQueryListEvent', 'MediaRecorder', 'MediaSettingsRange', 'MediaSource', 'MediaStream', 'MediaStreamAudioDestinationNode', 'MediaStreamAudioSourceNode', 'MediaStreamEvent', 'MediaStreamTrack', 'MediaStreamTrackEvent', 'menubar', 'MessageChannel', 'MessageEvent', 'MessagePort', 'MIDIAccess', 'MIDIConnectionEvent', 'MIDIInput', 'MIDIInputMap', 'MIDIMessageEvent', 'MIDIOutput', 'MIDIOutputMap', 'MIDIPort', 'MimeType', 'MimeTypeArray', 'MouseEvent', 'moveBy', 'moveTo', 'MutationEvent', 'MutationObserver', 'MutationRecord', 'name', 'NamedNodeMap', 'NavigationPreloadManager', 'navigator', 'Navigator', 'NetworkInformation', 'Node', 'NodeFilter', 'NodeIterator', 'NodeList', 'Notification', 'OfflineAudioCompletionEvent', 'OfflineAudioContext', 'offscreenBuffering', 'OffscreenCanvas', 'onabort', 'onafterprint', 'onanimationend', 'onanimationiteration', 'onanimationstart', 'onappinstalled', 'onauxclick', 'onbeforeinstallprompt', 'onbeforeprint', 'onbeforeunload', 'onblur', 'oncancel', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose', 'oncontextmenu', 'oncuechange', 'ondblclick', 'ondevicemotion', 'ondeviceorientation', 'ondeviceorientationabsolute', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'ondurationchange', 'onemptied', 'onended', 'onerror', 'onfocus', 'ongotpointercapture', 'onhashchange', 'oninput', 'oninvalid', 'onkeydown', 'onkeypress', 'onkeyup', 'onlanguagechange', 'onload', 'onloadeddata', 'onloadedmetadata', 'onloadstart', 'onlostpointercapture', 'onmessage', 'onmessageerror', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onoffline', 'ononline', 'onpagehide', 'onpageshow', 'onpause', 'onplay', 'onplaying', 'onpointercancel', 'onpointerdown', 'onpointerenter', 'onpointerleave', 'onpointermove', 'onpointerout', 'onpointerover', 'onpointerup', 'onpopstate', 'onprogress', 'onratechange', 'onrejectionhandled', 'onreset', 'onresize', 'onscroll', 'onsearch', 'onseeked', 'onseeking', 'onselect', 'onstalled', 'onstorage', 'onsubmit', 'onsuspend', 'ontimeupdate', 'ontoggle', 'ontransitionend', 'onunhandledrejection', 'onunload', 'onvolumechange', 'onwaiting', 'onwheel', 'open', 'openDatabase', 'opener', 'Option', 'origin', 'OscillatorNode', 'outerHeight', 'outerWidth', 'PageTransitionEvent', 'pageXOffset', 'pageYOffset', 'PannerNode', 'parent', 'Path2D', 'PaymentAddress', 'PaymentRequest', 'PaymentRequestUpdateEvent', 'PaymentResponse', 'performance', 'Performance', 'PerformanceEntry', 'PerformanceLongTaskTiming', 'PerformanceMark', 'PerformanceMeasure', 'PerformanceNavigation', 'PerformanceNavigationTiming', 'PerformanceObserver', 'PerformanceObserverEntryList', 'PerformancePaintTiming', 'PerformanceResourceTiming', 'PerformanceTiming', 'PeriodicWave', 'Permissions', 'PermissionStatus', 'personalbar', 'PhotoCapabilities', 'Plugin', 'PluginArray', 'PointerEvent', 'PopStateEvent', 'postMessage', 'Presentation', 'PresentationAvailability', 'PresentationConnection', 'PresentationConnectionAvailableEvent', 'PresentationConnectionCloseEvent', 'PresentationConnectionList', 'PresentationReceiver', 'PresentationRequest', 'print', 'ProcessingInstruction', 'ProgressEvent', 'PromiseRejectionEvent', 'prompt', 'PushManager', 'PushSubscription', 'PushSubscriptionOptions', 'queueMicrotask', 'RadioNodeList', 'Range', 'ReadableStream', 'registerProcessor', 'RemotePlayback', 'removeEventListener', 'Request', 'requestAnimationFrame', 'requestIdleCallback', 'resizeBy', 'ResizeObserver', 'ResizeObserverEntry', 'resizeTo', 'Response', 'RTCCertificate', 'RTCDataChannel', 'RTCDataChannelEvent', 'RTCDtlsTransport', 'RTCIceCandidate', 'RTCIceGatherer', 'RTCIceTransport', 'RTCPeerConnection', 'RTCPeerConnectionIceEvent', 'RTCRtpContributingSource', 'RTCRtpReceiver', 'RTCRtpSender', 'RTCSctpTransport', 'RTCSessionDescription', 'RTCStatsReport', 'RTCTrackEvent', 'screen', 'Screen', 'screenLeft', 'ScreenOrientation', 'screenTop', 'screenX', 'screenY', 'ScriptProcessorNode', 'scroll', 'scrollbars', 'scrollBy', 'scrollTo', 'scrollX', 'scrollY', 'SecurityPolicyViolationEvent', 'Selection', 'self', 'ServiceWorker', 'ServiceWorkerContainer', 'ServiceWorkerRegistration', 'sessionStorage', 'setInterval', 'setTimeout', 'ShadowRoot', 'SharedWorker', 'SourceBuffer', 'SourceBufferList', 'speechSynthesis', 'SpeechSynthesisEvent', 'SpeechSynthesisUtterance', 'StaticRange', 'status', 'statusbar', 'StereoPannerNode', 'stop', 'Storage', 'StorageEvent', 'StorageManager', 'styleMedia', 'StyleSheet', 'StyleSheetList', 'SubtleCrypto', 'SVGAElement', 'SVGAngle', 'SVGAnimatedAngle', 'SVGAnimatedBoolean', 'SVGAnimatedEnumeration', 'SVGAnimatedInteger', 'SVGAnimatedLength', 'SVGAnimatedLengthList', 'SVGAnimatedNumber', 'SVGAnimatedNumberList', 'SVGAnimatedPreserveAspectRatio', 'SVGAnimatedRect', 'SVGAnimatedString', 'SVGAnimatedTransformList', 'SVGAnimateElement', 'SVGAnimateMotionElement', 'SVGAnimateTransformElement', 'SVGAnimationElement', 'SVGCircleElement', 'SVGClipPathElement', 'SVGComponentTransferFunctionElement', 'SVGDefsElement', 'SVGDescElement', 'SVGDiscardElement', 'SVGElement', 'SVGEllipseElement', 'SVGFEBlendElement', 'SVGFEColorMatrixElement', 'SVGFEComponentTransferElement', 'SVGFECompositeElement', 'SVGFEConvolveMatrixElement', 'SVGFEDiffuseLightingElement', 'SVGFEDisplacementMapElement', 'SVGFEDistantLightElement', 'SVGFEDropShadowElement', 'SVGFEFloodElement', 'SVGFEFuncAElement', 'SVGFEFuncBElement', 'SVGFEFuncGElement', 'SVGFEFuncRElement', 'SVGFEGaussianBlurElement', 'SVGFEImageElement', 'SVGFEMergeElement', 'SVGFEMergeNodeElement', 'SVGFEMorphologyElement', 'SVGFEOffsetElement', 'SVGFEPointLightElement', 'SVGFESpecularLightingElement', 'SVGFESpotLightElement', 'SVGFETileElement', 'SVGFETurbulenceElement', 'SVGFilterElement', 'SVGForeignObjectElement', 'SVGGElement', 'SVGGeometryElement', 'SVGGradientElement', 'SVGGraphicsElement', 'SVGImageElement', 'SVGLength', 'SVGLengthList', 'SVGLinearGradientElement', 'SVGLineElement', 'SVGMarkerElement', 'SVGMaskElement', 'SVGMatrix', 'SVGMetadataElement', 'SVGMPathElement', 'SVGNumber', 'SVGNumberList', 'SVGPathElement', 'SVGPatternElement', 'SVGPoint', 'SVGPointList', 'SVGPolygonElement', 'SVGPolylineElement', 'SVGPreserveAspectRatio', 'SVGRadialGradientElement', 'SVGRect', 'SVGRectElement', 'SVGScriptElement', 'SVGSetElement', 'SVGStopElement', 'SVGStringList', 'SVGStyleElement', 'SVGSVGElement', 'SVGSwitchElement', 'SVGSymbolElement', 'SVGTextContentElement', 'SVGTextElement', 'SVGTextPathElement', 'SVGTextPositioningElement', 'SVGTitleElement', 'SVGTransform', 'SVGTransformList', 'SVGTSpanElement', 'SVGUnitTypes', 'SVGUseElement', 'SVGViewElement', 'TaskAttributionTiming', 'Text', 'TextDecoder', 'TextEncoder', 'TextEvent', 'TextMetrics', 'TextTrack', 'TextTrackCue', 'TextTrackCueList', 'TextTrackList', 'TimeRanges', 'toolbar', 'top', 'Touch', 'TouchEvent', 'TouchList', 'TrackEvent', 'TransitionEvent', 'TreeWalker', 'UIEvent', 'URL', 'URLSearchParams', 'ValidityState', 'visualViewport', 'VisualViewport', 'VTTCue', 'WaveShaperNode', 'WebAssembly', 'WebGL2RenderingContext', 'WebGLActiveInfo', 'WebGLBuffer', 'WebGLContextEvent', 'WebGLFramebuffer', 'WebGLProgram', 'WebGLQuery', 'WebGLRenderbuffer', 'WebGLRenderingContext', 'WebGLSampler', 'WebGLShader', 'WebGLShaderPrecisionFormat', 'WebGLSync', 'WebGLTexture', 'WebGLTransformFeedback', 'WebGLUniformLocation', 'WebGLVertexArrayObject', 'WebSocket', 'WheelEvent', 'window', 'Window', 'Worker', 'WritableStream', 'XMLDocument', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload', 'XMLSerializer', 'XPathEvaluator', 'XPathExpression', 'XPathResult', 'XSLTProcessor'];

  const ___$romejs$js_compiler$src$scope$globals_ts$worker = ['addEventListener', 'applicationCache', 'atob', 'Blob', 'BroadcastChannel', 'btoa', 'Cache', 'caches', 'clearInterval', 'clearTimeout', 'close', 'console', 'fetch', 'FileReaderSync', 'FormData', 'Headers', 'IDBCursor', 'IDBCursorWithValue', 'IDBDatabase', 'IDBFactory', 'IDBIndex', 'IDBKeyRange', 'IDBObjectStore', 'IDBOpenDBRequest', 'IDBRequest', 'IDBTransaction', 'IDBVersionChangeEvent', 'ImageData', 'importScripts', 'indexedDB', 'location', 'MessageChannel', 'MessagePort', 'name', 'navigator', 'Notification', 'onclose', 'onconnect', 'onerror', 'onlanguagechange', 'onmessage', 'onoffline', 'ononline', 'onrejectionhandled', 'onunhandledrejection', 'performance', 'Performance', 'PerformanceEntry', 'PerformanceMark', 'PerformanceMeasure', 'PerformanceNavigation', 'PerformanceResourceTiming', 'PerformanceTiming', 'postMessage', 'Promise', 'queueMicrotask', 'removeEventListener', 'Request', 'Response', 'self', 'ServiceWorkerRegistration', 'setInterval', 'setTimeout', 'TextDecoder', 'TextEncoder', 'URL', 'URLSearchParams', 'WebSocket', 'Worker', 'WorkerGlobalScope', 'XMLHttpRequest'];

  const ___$romejs$js_compiler$src$scope$globals_ts$node = ['__dirname', '__filename', 'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout', 'console', 'exports', 'global', 'Intl', 'module', 'process', 'queueMicrotask', 'require', 'setImmediate', 'setInterval', 'setTimeout', 'TextDecoder', 'TextEncoder', 'URL', 'URLSearchParams'];

  const ___$romejs$js_compiler$src$scope$globals_ts$commonjs = ['exports', 'global', 'module', 'require'];

  const ___$romejs$js_compiler$src$scope$globals_ts$serviceworker = ['addEventListener', 'applicationCache', 'atob', 'Blob', 'BroadcastChannel', 'btoa', 'Cache', 'caches', 'CacheStorage', 'clearInterval', 'clearTimeout', 'Client', 'clients', 'Clients', 'close', 'console', 'ExtendableEvent', 'ExtendableMessageEvent', 'fetch', 'FetchEvent', 'FileReaderSync', 'FormData', 'Headers', 'IDBCursor', 'IDBCursorWithValue', 'IDBDatabase', 'IDBFactory', 'IDBIndex', 'IDBKeyRange', 'IDBObjectStore', 'IDBOpenDBRequest', 'IDBRequest', 'IDBTransaction', 'IDBVersionChangeEvent', 'ImageData', 'importScripts', 'indexedDB', 'location', 'MessageChannel', 'MessagePort', 'name', 'navigator', 'Notification', 'onclose', 'onconnect', 'onerror', 'onfetch', 'oninstall', 'onlanguagechange', 'onmessage', 'onmessageerror', 'onnotificationclick', 'onnotificationclose', 'onoffline', 'ononline', 'onpush', 'onpushsubscriptionchange', 'onrejectionhandled', 'onsync', 'onunhandledrejection', 'performance', 'Performance', 'PerformanceEntry', 'PerformanceMark', 'PerformanceMeasure', 'PerformanceNavigation', 'PerformanceResourceTiming', 'PerformanceTiming', 'postMessage', 'Promise', 'queueMicrotask', 'registration', 'removeEventListener', 'Request', 'Response', 'self', 'ServiceWorker', 'ServiceWorkerContainer', 'ServiceWorkerGlobalScope', 'ServiceWorkerMessageEvent', 'ServiceWorkerRegistration', 'setInterval', 'setTimeout', 'skipWaiting', 'TextDecoder', 'TextEncoder', 'URL', 'URLSearchParams', 'WebSocket', 'WindowClient', 'Worker', 'WorkerGlobalScope', 'XMLHttpRequest'];

  // romejs/js-compiler/src/scope/Scope.ts

  let ___$$priv$romejs$js_compiler$src$scope$Scope_ts$scopeCounter = 0;

  Error.stackTraceLimit = Infinity;

  class ___$romejs$js_compiler$src$scope$Scope_ts$default {
    constructor(kind, node, parentScope, rootScope) {
      this.parentScope = parentScope;
      this.rootScope = rootScope;
      this.node = node;
      this.kind = kind;
      this.bindings = new Map();
      this.id = ___$$priv$romejs$js_compiler$src$scope$Scope_ts$scopeCounter++;

      this.childScopeCache = new WeakMap();
    }

    hasBindings() {
      return this.bindings.size > 0;
    }

    getOwnBindings() {
      return this.bindings;
    }

    getOwnBindingNames() {
      return Array.from(this.bindings.keys());
    }

    getParentScope(kind) {
      let scope = this.parentScope;
      while (scope !== undefined) {
        if (scope.kind === kind) {
          return scope;
        } else {
          scope = scope.parentScope;
        }
      }
    }

    getRootScope() {
      const {rootScope: rootScope} = this;
      if (rootScope === undefined) {
        throw new Error(`Expected rootScope`);
      }
      return rootScope;
    }

    evaluate(node, parent, pureOnly = false, force = false) {
      if (node === undefined) {
        return this;
      }

      if (!force && node === this.node) {
        return this;
      }
      const cached = this.childScopeCache.get(node);
      if (cached !== undefined) {
        return cached;
      }

      let evaluator = ___$romejs$js_compiler$src$scope$pure_evaluators$index_ts[node.type];

      if (!pureOnly && evaluator === undefined) {
        evaluator = ___$romejs$js_compiler$src$scope$evaluators$index_ts[node.type];
      }

      if (evaluator === undefined) {
        return this;
      }

      let scope = evaluator(node, parent, this);
      if (scope === undefined) {
        scope = this;
      }
      this.childScopeCache.set(node, scope);
      return scope;
    }

    fork(kind, node) {
      const rootScope = this.getRootScope();
      return new ___$romejs$js_compiler$src$scope$Scope_ts$default(kind, node, this, rootScope);
    }

    dump(root = true) {
      if (root) {
        console.log('START');
      }
      console.log('------', this.id, this.kind);
      for (const [name, binding] of this.bindings) {
        console.log(' ', binding.id, '-', binding.constructor.name, name);
      }
      if (this.parentScope !== undefined) {
        this.parentScope.dump(false);
      }
      if (root) {
        console.log('END');
      }
    }

    getOwnBinding(name) {
      return this.bindings.get(name);
    }

    getBinding(name) {
      const binding = this.getOwnBinding(name);
      if (binding !== undefined) {
        return binding;
      }

      const {parentScope: parentScope} = this;
      if (parentScope !== undefined) {
        return parentScope.getBinding(name);
      }

      return undefined;
    }

    getBindingAssert(name) {
      const binding = this.getBinding(name);
      if (binding === undefined) {
        throw new Error(`Expected ${name} binding`);
      }
      return binding;
    }

    addBinding(binding) {
      this.bindings.set(binding.name, binding);
      return binding;
    }

    hasBinding(name) {
      return this.getBinding(name) !== undefined;
    }

    generateUid(name) {
      return this.getRootScope().generateUid(name);
    }
  }

  const ___$$priv$romejs$js_compiler$src$scope$Scope_ts$GLOBAL_COMMENT_START = /^([\s+]|)global /;
  const ___$$priv$romejs$js_compiler$src$scope$Scope_ts$GLOBAL_COMMENT_COLON = /:(.*?)$/;

  class ___$romejs$js_compiler$src$scope$Scope_ts$RootScope extends ___$romejs$js_compiler$src$scope$Scope_ts$default {
    constructor(context, ast) {
      super('root', undefined, undefined, undefined);
      this.uids = new Set();
      this.context = context;

      this.globals = new Set([...___$romejs$js_compiler$src$scope$globals_ts$builtin, ...___$romejs$js_compiler$src$scope$globals_ts$es5, ...___$romejs$js_compiler$src$scope$globals_ts$es2015, ...___$romejs$js_compiler$src$scope$globals_ts$es2017, ...___$romejs$js_compiler$src$scope$globals_ts$browser, ...___$romejs$js_compiler$src$scope$globals_ts$worker, ...___$romejs$js_compiler$src$scope$globals_ts$node, ...___$romejs$js_compiler$src$scope$globals_ts$commonjs, ...___$romejs$js_compiler$src$scope$globals_ts$serviceworker, ...context.projectConfig.lint.globals, ...this.parseGlobalComments(ast)]);
    }

    parseGlobalComments(ast) {
      const globals = [];

      for (const {value: value} of ast.comments) {
        if (!___$$priv$romejs$js_compiler$src$scope$Scope_ts$GLOBAL_COMMENT_START.test(value)) {
          continue;
        }

        const clean = value.replace(___$$priv$romejs$js_compiler$src$scope$Scope_ts$GLOBAL_COMMENT_START, '');

        const parts = clean.split(',');

        for (const part of parts) {
          let name = part.trim();

          if (___$$priv$romejs$js_compiler$src$scope$Scope_ts$GLOBAL_COMMENT_COLON.test(name)) {
            const match = part.match(___$$priv$romejs$js_compiler$src$scope$Scope_ts$GLOBAL_COMMENT_COLON);
            if (match == null) {
              throw new Error('Used RegExp.test already so know this will always match');
            }

            name = name.replace(___$$priv$romejs$js_compiler$src$scope$Scope_ts$GLOBAL_COMMENT_COLON, '');

            const value = match[1].trim();

            if (value === 'false') {
              break;
            }
          }

          globals.push(name);
        }
      }

      return globals;
    }

    isGlobal(name) {
      return this.globals.has(name);
    }

    getRootScope() {
      return this;
    }

    generateUid(name) {
      const prefixed = `${___$romejs$js_compiler$src$constants_ts$SCOPE_PRIVATE_PREFIX}${name === undefined ? '' : name}`;

      let counter = 0;

      while (true) {
        const suffix = counter === 0 ? '' : String(counter);
        const name = prefixed + suffix;

        if (this.uids.has(name)) {
          counter++;
        } else {
          this.uids.add(name);
          return name;
        }
      }

      throw new Error('Unreachable');
    }
  }

  // romejs/js-compiler/src/api/createHook.ts

  const ___$romejs$js_compiler$src$api$createHook_ts$HOOK = 'HOOK';

  const ___$romejs$js_compiler$src$api$createHook_ts$CONSUMER = 'CONSUMER';

  function ___$romejs$js_compiler$src$api$createHook_ts$default(hook) {
    const id = Symbol();

    return {
      provide(state) {
        return {
          type: ___$romejs$js_compiler$src$api$createHook_ts$HOOK,
          name: hook.name,
          id: id,
          state: Object.assign({}, hook.defaultState, state),
          hook: hook};
      },

      consume(arg) {
        return {type: ___$romejs$js_compiler$src$api$createHook_ts$CONSUMER, id: id, arg: arg};
      }};
  }

  // romejs/js-compiler/src/methods/reduce.ts

  const ___$$priv$romejs$js_compiler$src$methods$reduce_ts$BAIL_EXIT = 'BAIL';
  const ___$$priv$romejs$js_compiler$src$methods$reduce_ts$KEEP_EXIT = 'KEEP';

  function ___$$priv$romejs$js_compiler$src$methods$reduce_ts$isHookLike(ret) {
    return ret != null && !Array.isArray(ret) && typeof ret !== 'string';
  }

  function ___$$priv$romejs$js_compiler$src$methods$reduce_ts$validateTransformReturn(name, node, opts) {
    if (typeof node === 'string') {
      throw new Error(`Returned a string from transform ${name} that doesn't correspond to any reduce constant`);
    }

    if (typeof node === 'undefined') {
      throw new Error('Returned `undefined` from transform ' +
      name +
      '. If you meant to delete this node then use `return' +
      ' null`, otherwise if you want to keep it then use `return path.node;`');
    }

    if (Array.isArray(node)) {
      if (opts.noArrays === true) {
        throw new Error(`Cannot replace this keyed node with an array of nodes - originated from 'transform ${name}`);
      }
      return undefined;
    }

    if (___$romejs$js_ast_utils$src$isNodeLike_ts$default(node) === false && node !== null) {
      throw new Error(`Expected a return value of \`null\` or a plain object with a \`type\` property - originated from 'transform ${name}`);
    }
  }

  function ___$$priv$romejs$js_compiler$src$methods$reduce_ts$shouldBailReduce(node) {
    if (Array.isArray(node)) {
      return true;
    }

    if (node === null) {
      return true;
    }

    return false;
  }

  function ___$$priv$romejs$js_compiler$src$methods$reduce_ts$consumeHook(hookConsume, path) {
    const hookRefs = path.findHooks(hookConsume.id);
    const oldNode = path.node;

    if (hookRefs.length === 0) {
      throw new Error('No requested hooks found');
    }

    for (const hookRef of hookRefs) {
      const {node: newNode, state: state} = hookRef.hook.consume(
      path,
      hookRef.state,
      hookConsume.arg);

      ___$$priv$romejs$js_compiler$src$methods$reduce_ts$validateTransformReturn(hookRef.name, newNode, path.opts);

      hookRef.state = state;

      if (newNode !== oldNode) {
        return newNode;
      }
    }

    return oldNode;
  }

  function ___$$priv$romejs$js_compiler$src$methods$reduce_ts$runExit(path, name, callback, state) {
    let transformedNode = callback(path, state);

    if (___$$priv$romejs$js_compiler$src$methods$reduce_ts$isHookLike(transformedNode)) {
      if (transformedNode.type === ___$romejs$js_compiler$src$api$createHook_ts$HOOK) {
        throw new Error(`Transform ${name} returned a hook. We have finished reducing the subtree.`);
      }

      if (transformedNode.type === ___$romejs$js_compiler$src$api$createHook_ts$CONSUMER) {
        transformedNode = ___$$priv$romejs$js_compiler$src$methods$reduce_ts$consumeHook(transformedNode, path);
      }
    }

    ___$$priv$romejs$js_compiler$src$methods$reduce_ts$validateTransformReturn(name, transformedNode, path.opts);

    if (___$$priv$romejs$js_compiler$src$methods$reduce_ts$shouldBailReduce(transformedNode)) {
      return [___$$priv$romejs$js_compiler$src$methods$reduce_ts$BAIL_EXIT, transformedNode];
    }

    if (transformedNode !== path.node) {
      path = path.fork(transformedNode);
    }

    return [___$$priv$romejs$js_compiler$src$methods$reduce_ts$KEEP_EXIT, path];
  }

  function ___$romejs$js_compiler$src$methods$reduce_ts$default(origNode, visitors, context, pathOpts = {}) {
    let hooks = [];

    let path = new ___$romejs$js_compiler$src$lib$Path_ts$default(origNode, context, pathOpts, hooks);

    for (const visitor of visitors) {
      const {enter: enter} = visitor;
      if (enter === undefined) {
        continue;
      }

      let transformedNode = enter(path);

      if (transformedNode === ___$romejs$js_compiler$src$constants_ts$REDUCE_SKIP_SUBTREE) {
        return origNode;
      }

      if (___$$priv$romejs$js_compiler$src$methods$reduce_ts$isHookLike(transformedNode)) {
        if (transformedNode.type === ___$romejs$js_compiler$src$api$createHook_ts$CONSUMER) {
          transformedNode = ___$$priv$romejs$js_compiler$src$methods$reduce_ts$consumeHook(transformedNode, path);
        }

        if (___$$priv$romejs$js_compiler$src$methods$reduce_ts$isHookLike(transformedNode) && transformedNode.type === ___$romejs$js_compiler$src$api$createHook_ts$HOOK) {
          hooks.push(transformedNode);

          transformedNode = path.node;
        }
      }

      ___$$priv$romejs$js_compiler$src$methods$reduce_ts$validateTransformReturn(visitor.name, transformedNode, path.opts);

      if (___$$priv$romejs$js_compiler$src$methods$reduce_ts$shouldBailReduce(transformedNode)) {
        return transformedNode;
      }

      if (transformedNode !== path.node) {
        path = path.fork(transformedNode);
      }
    }

    let {node: node} = path;
    const visitorKeys = ___$romejs$js_ast$src$utils_ts$visitorKeys.get(node.type);
    if (visitorKeys !== undefined) {
      const ancestryPaths = pathOpts.ancestryPaths || [];
      let childAncestryPaths = [path].concat(ancestryPaths);

      for (const key of visitorKeys) {
        const oldVal = node[key];

        if (Array.isArray(oldVal)) {
          let children = oldVal;

          let childrenOffset = 0;

          let length = children.length;

          for (let i = 0; i < length; i++) {
            const correctedIndex = childrenOffset + i;

            const child = children[correctedIndex];

            if (___$romejs$js_ast_utils$src$isNodeLike_ts$default(child)) {
              const newChild = ___$romejs$js_compiler$src$methods$reduce_ts$default(child, visitors, context, {
                noScopeCreation: pathOpts.noScopeCreation,
                parentScope: path.scope,
                ancestryPaths: childAncestryPaths,
                listKey: correctedIndex,
                nodeKey: key});

              if (newChild !== child) {
                children = children.slice();

                if (newChild === null ||
                Array.isArray(newChild) && newChild.length === 0) {
                  children.splice(correctedIndex, 1);

                  childrenOffset--;
                } else if (Array.isArray(newChild)) {
                  children.splice(correctedIndex, 1, ...newChild);

                  length += newChild.length;

                  i--;
                } else {
                  children[correctedIndex] = newChild;

                  i--;
                }

                node = Object.assign({}, node, {
                  [key]: children});

                path = path.fork(node);

                childAncestryPaths = [path].concat(ancestryPaths);
              }
            }
          }
        } else if (___$romejs$js_ast_utils$src$isNodeLike_ts$default(oldVal)) {
          let newVal = ___$romejs$js_compiler$src$methods$reduce_ts$default(oldVal, visitors, context, {
            noScopeCreation: pathOpts.noScopeCreation,
            parentScope: path.scope,
            ancestryPaths: childAncestryPaths,
            noArrays: true,
            nodeKey: key});

          if (newVal !== oldVal) {
            ___$romejs$invariant$src$index_ts$default(
            Array.isArray(newVal) === false,
            'should not be an array as noArrays: true was passed to reduce()');

            if (newVal === null) {
              newVal = undefined;
            }

            node = Object.assign({}, node, {
              [key]: newVal});

            path = path.fork(node);

            childAncestryPaths = [path].concat(ancestryPaths);
          }
        } else {
          continue;
        }
      }
    }

    for (const ref of hooks) {
      const {exit: exit} = ref.hook;
      if (exit === undefined) {
        continue;
      }

      const res = ___$$priv$romejs$js_compiler$src$methods$reduce_ts$runExit(path, ref.name, exit, ref.state);
      if (res[0] === ___$$priv$romejs$js_compiler$src$methods$reduce_ts$BAIL_EXIT) {
        return res[1];
      } else {
        path = res[1];
      }
    }

    for (const visitor of visitors) {
      if (visitor.exit !== undefined) {
        const res = ___$$priv$romejs$js_compiler$src$methods$reduce_ts$runExit(path, visitor.name, visitor.exit, undefined);
        if (res[0] === ___$$priv$romejs$js_compiler$src$methods$reduce_ts$BAIL_EXIT) {
          return res[1];
        } else {
          path = res[1];
        }
      }
    }

    return path.node;
  }

  // romejs/js-compiler/src/lib/Context.ts

  class ___$romejs$js_compiler$src$lib$Context_ts$default {
    constructor(arg) {
      const {ast: ast, projectConfig: projectConfig, options = {}, origin: origin} = arg;

      this.diagnostics = [];
      this.records = [];
      this.filename = ast.filename;
      this.projectConfig = projectConfig;
      this.options = options;
      this.origin = origin;
      this.cacheDependencies = new Set();
      this.rootScope = new ___$romejs$js_compiler$src$scope$Scope_ts$RootScope(this, ast);
    }

    async normalizeTransforms(transforms) {
      return Promise.all(
      transforms.map(async visitor => {
        if (typeof visitor === 'function') {
          return await visitor(this);
        } else {
          return visitor;
        }
      }));
    }

    getRootScope() {
      const {rootScope: rootScope} = this;
      if (rootScope === undefined) {
        throw new Error('Expected root scope');
      }
      return rootScope;
    }

    getCacheDependencies() {
      return Array.from(this.cacheDependencies);
    }

    addCacheDependency(filename) {
      this.cacheDependencies.add(filename);
    }

    reduce(ast, visitors, pathOpts) {
      return ___$romejs$js_compiler$src$methods$reduce_ts$default(ast, visitors, this, pathOpts);
    }

    record(record) {
      this.records.push(record);
    }

    addDiagnostics(diagnostics) {
      this.diagnostics = [...this.diagnostics, ...diagnostics];
    }

    addLocDiagnostic(loc, diag) {
      let origins = [];
      if (this.origin !== undefined) {
        origins.push(this.origin);
      }
      if (diag.origins !== undefined) {
        origins = origins.concat(diag.origins);
      }

      this.diagnostics.push(Object.assign({}, diag, {
        start: loc === undefined ? diag.start : loc.start,
        end: loc === undefined ? diag.end : loc.end,
        filename: loc === undefined ? this.filename : loc.filename,
        origins: origins}));
    }

    addNodeDiagnostic(node, diag) {
      return this.addLocDiagnostic(
      node === undefined ? undefined : node.loc,
      diag);
    }
  }

  // romejs/js-compiler/src/lib/Path.ts

  class ___$romejs$js_compiler$src$lib$Path_ts$default {
    constructor(node, context, opts, hooks = []) {
      const ancestryPaths = opts.ancestryPaths || [];
      this.ancestryPaths = ancestryPaths;
      this.parentPath = ancestryPaths[0];

      this.node = node;
      this.parent = this.parentPath ? this.parentPath.node : undefined;
      this.context = context;

      const parentScope = opts.parentScope === undefined ? context.getRootScope() : opts.parentScope;

      let scope = opts.scope;
      if (scope === undefined) {
        if (opts.noScopeCreation === true) {
          scope = parentScope;
        } else {
          scope = parentScope.evaluate(node, this.parent, true);
        }
      }
      this.scope = scope;

      this.nodeKey = opts.nodeKey;
      this.listKey = opts.listKey;

      this.opts = opts;

      this.hooks = hooks;
    }

    findHooks(id) {
      const handles = [];

      for (const {hooks: hooks} of this.ancestryPaths) {
        for (const hook of hooks) {
          if (hook.id === id) {
            handles.push(hook);
          }
        }
      }

      return handles;
    }

    findAncestry(callback) {
      for (const path of this.ancestryPaths) {
        if (callback(path)) {
          return path;
        }
      }
    }

    getChildPath(key) {
      const node = this.node[key];
      ___$romejs$invariant$src$index_ts$default(
      node !== undefined,
      'Attempted to get child path for %s but no such node existed',
      key);

      return new ___$romejs$js_compiler$src$lib$Path_ts$default(node, this.context, {
        parentScope: this.scope,
        ancestryPaths: this.ancestryPaths.concat([this]),
        nodeKey: key});
    }

    getChildPaths(key) {
      const nodes = this.node[key];

      ___$romejs$invariant$src$index_ts$default(
      nodes !== undefined,
      'Attempted to get child paths for %s but no such node existed',
      key);

      ___$romejs$invariant$src$index_ts$default(
      Array.isArray(nodes),
      'Expected child nodes for %s to be an array',
      key);

      const ancestryPaths = this.ancestryPaths.concat([this]);

      return nodes.map((node, i) => {
        return new ___$romejs$js_compiler$src$lib$Path_ts$default(node, this.context, {
          parentScope: this.scope,
          ancestryPaths: ancestryPaths,
          listKey: i,
          nodeKey: key});
      });
    }

    getParent() {
      const {parent: parent} = this;
      if (parent === undefined) {
        throw new Error('Path doesn\'t have a parent');
      }
      return parent;
    }

    getParentPath() {
      const {parentPath: parentPath} = this;
      if (parentPath === undefined) {
        throw new Error('Path doesn\'t have a parent');
      }
      return parentPath;
    }

    getPathKeys() {
      const parts = [];

      let path = this;
      while (path) {
        if (path.listKey !== undefined) {
          parts.push(String(path.listKey));
        }
        if (path.nodeKey !== undefined) {
          parts.push(path.nodeKey);
        }
        path = path.parentPath;
      }

      return parts.reverse();
    }

    fork(newNode) {
      return new ___$romejs$js_compiler$src$lib$Path_ts$default(newNode, this.context, this.getPathOptions(), this.hooks);
    }

    getPathOptions() {
      return Object.assign({}, this.opts, {
        parentScope: this.scope === undefined ? undefined : this.scope.parentScope});
    }

    traverse(name, callback) {
      this.reduce({
        name: name,
        enter(path) {
          callback(path);
          return path.node;
        }});
    }

    reduce(visitors) {
      return ___$romejs$js_compiler$src$methods$reduce_ts$default(
      this.node,
      Array.isArray(visitors) ? visitors : [visitors],
      this.context,
      this.getPathOptions());
    }

    addDiagnostic(opts) {
      return this.context.addNodeDiagnostic(this.node, opts);
    }
  }

  // romejs/js-compiler/src/lib/Record.ts

  class ___$romejs$js_compiler$src$lib$Record_ts$default {}

  // romejs/js-compiler/src/lib/Cache.ts

  class ___$romejs$js_compiler$src$lib$Cache_ts$default {
    constructor() {
      this.cache = new WeakMap();
    }

    static buildQuery(req, options) {
      const {ast: ast, projectConfig: projectConfig} = req;
      const keyParts = [];

      keyParts.push(String(projectConfig.memoryCacheCounter));

      if (options !== undefined && Object.keys(options).length > 0) {
        keyParts.push(JSON.stringify(options));
      }

      return {
        ast: ast,
        key: keyParts.join(';')};
    }

    get(query) {
      const astCache = this.cache.get(query.ast);
      if (astCache) {
        return astCache.get(query.key);
      }
    }

    set(query, value) {
      let astCache = this.cache.get(query.ast);
      if (astCache === undefined) {
        astCache = new Map();
        this.cache.set(query.ast, astCache);
      }
      astCache.set(query.key, value);
    }
  }

  // romejs/js-compiler/src/plugins/lint/undeclaredVariables.ts

  const ___$$priv$romejs$js_compiler$src$plugins$lint$undeclaredVariables_ts$NODE_VARIABLES = ['require', '__dirname', '__filename', 'module', 'exports', 'babelHelpers'];

  const ___$$priv$romejs$js_compiler$src$plugins$lint$undeclaredVariables_ts$BROWSER_VARIABLES = ['fetch', 'document', 'window', 'Worker', 'cancelAnimationFrame', 'requestAnimationFrame', 'WebSocket', 'alert', 'Blob', 'navigator', 'Element', 'Text', 'Document', 'performance'];
  const ___$romejs$js_compiler$src$plugins$lint$undeclaredVariables_ts$default = {
    name: 'undeclaredVariables',
    enter(path) {
      const {node: node, scope: scope} = path;

      if (node.type === 'Identifier' &&
      ___$romejs$js_ast_utils$src$isReferenced_ts$default(path) &&
      !___$romejs$js_ast_utils$src$isInTypeAnnotation_ts$default(path)) {
        const {name: name} = node;
        const binding = scope.getBinding(name);

        const isDefined = binding !== undefined ||
        scope.getRootScope().isGlobal(name) ||
        name in global ||
        ___$$priv$romejs$js_compiler$src$plugins$lint$undeclaredVariables_ts$BROWSER_VARIABLES.includes(name) ||
        ___$$priv$romejs$js_compiler$src$plugins$lint$undeclaredVariables_ts$NODE_VARIABLES.includes(name);

        if (!isDefined) {
          path.context.addNodeDiagnostic(node, {
            category: 'lint/undeclaredVariables',
            message: ___$romejs$string_markup$src$escape_ts$markup`Undeclared variable <emphasis>${name}</emphasis>`});
        }
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/lint/index.ts

  const ___$romejs$js_compiler$src$plugins$lint$index_ts$lintTransforms = [___$romejs$js_compiler$src$plugins$lint$undeclaredVariables_ts$default];

  // romejs/js-generator/src/node/parentheses.ts

  const ___$romejs$js_generator$src$node$parentheses_ts = {
    FlowNullableTypeAnnotation: ___$romejs$js_generator$src$node$parentheses_ts$FlowNullableTypeAnnotation,
    UpdateExpression: ___$romejs$js_generator$src$node$parentheses_ts$UpdateExpression,
    ObjectExpression: ___$romejs$js_generator$src$node$parentheses_ts$ObjectExpression,
    DoExpression: ___$romejs$js_generator$src$node$parentheses_ts$DoExpression,
    LogicalExpression: ___$romejs$js_generator$src$node$parentheses_ts$LogicalExpression,
    BinaryExpression: ___$romejs$js_generator$src$node$parentheses_ts$BinaryExpression,
    SequenceExpression: ___$romejs$js_generator$src$node$parentheses_ts$SequenceExpression,
    YieldExpression: ___$romejs$js_generator$src$node$parentheses_ts$AwaitExpression,
    AwaitExpression: ___$romejs$js_generator$src$node$parentheses_ts$AwaitExpression,
    ClassExpression: ___$romejs$js_generator$src$node$parentheses_ts$ClassExpression,
    UnaryExpression: ___$romejs$js_generator$src$node$parentheses_ts$UnaryExpression,
    SpreadElement: ___$romejs$js_generator$src$node$parentheses_ts$SpreadElement,
    RestProperty: ___$romejs$js_generator$src$node$parentheses_ts$RestProperty,
    SpreadProperty: ___$romejs$js_generator$src$node$parentheses_ts$SpreadProperty,
    FunctionExpression: ___$romejs$js_generator$src$node$parentheses_ts$FunctionExpression,
    ArrowFunctionExpression: ___$romejs$js_generator$src$node$parentheses_ts$ArrowFunctionExpression,
    ConditionalExpression: ___$romejs$js_generator$src$node$parentheses_ts$ConditionalExpression,
    AssignmentExpression: ___$romejs$js_generator$src$node$parentheses_ts$AssignmentExpression,
    FlowUnionTypeAnnotation: ___$romejs$js_generator$src$node$parentheses_ts$FlowIntersectionTypeAnnotation,
    FlowIntersectionTypeAnnotation: ___$romejs$js_generator$src$node$parentheses_ts$FlowIntersectionTypeAnnotation,
    FlowFunctionTypeAnnotation: ___$romejs$js_generator$src$node$parentheses_ts$FlowFunctionTypeAnnotation};
  const ___$$priv$romejs$js_generator$src$node$parentheses_ts$PRECEDENCE = {
    '||': 0,
    '&&': 1,
    '??': 1,
    '|': 2,
    '^': 3,
    '&': 4,
    '==': 5,
    '===': 5,
    '!=': 5,
    '!==': 5,
    '<': 6,
    '>': 6,
    '<=': 6,
    '>=': 6,
    in: 6,
    instanceof: 6,
    '>>': 7,
    '<<': 7,
    '>>>': 7,
    '+': 8,
    '-': 8,
    '*': 9,
    '/': 9,
    '%': 9,
    '**': 10};

  function ___$romejs$js_generator$src$node$parentheses_ts$FlowNullableTypeAnnotation(node, parent) {
    return parent.type === 'FlowArrayTypeAnnotation';
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$UpdateExpression(node, parent) {
    return parent.type === 'MemberExpression' && parent.object === node;
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$ObjectExpression(node, parent, printStack) {
    return ___$$priv$romejs$js_generator$src$node$parentheses_ts$isFirstInStatement(printStack, true, false);
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$DoExpression(node, parent, printStack) {
    return ___$$priv$romejs$js_generator$src$node$parentheses_ts$isFirstInStatement(printStack, false, false);
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$LogicalExpression(node, parent) {
    if (node.operator === '**' &&
    parent.type === 'BinaryExpression' &&
    parent.operator === '**') {
      return parent.left === node;
    }

    if ((parent.type === 'CallExpression' || parent.type === 'NewExpression') &&
    parent.callee === node ||
    ___$romejs$js_ast_utils$src$isUnaryLike_ts$default(parent) ||
    parent.type === 'MemberExpression' && parent.object === node ||
    parent.type === 'AwaitExpression') {
      return true;
    }

    if (___$romejs$js_ast_utils$src$isBinary_ts$default(parent)) {
      const parentOp = parent.operator;

      const parentPos = ___$$priv$romejs$js_generator$src$node$parentheses_ts$PRECEDENCE[parentOp];

      const nodeOp = node.operator;
      const nodePos = ___$$priv$romejs$js_generator$src$node$parentheses_ts$PRECEDENCE[nodeOp];

      if (parentPos === nodePos &&
      parent.right === node &&
      parent.type !== 'LogicalExpression' ||
      parentPos > nodePos) {
        return true;
      }
    }

    return false;
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$BinaryExpression(node, parent) {
    return node.operator === 'in' &&
    (parent.type === 'VariableDeclarator' || ___$romejs$js_ast_utils$src$isFor_ts$default(parent)) ||
    ___$romejs$js_generator$src$node$parentheses_ts$LogicalExpression(node, parent);
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$SequenceExpression(node, parent) {
    if (parent.type === 'ForStatement' ||
    parent.type === 'ThrowStatement' ||
    parent.type === 'ReturnStatement' ||
    parent.type === 'IfStatement' && parent.test === node ||
    parent.type === 'WhileStatement' && parent.test === node ||
    parent.type === 'ForInStatement' && parent.right === node ||
    parent.type === 'SwitchStatement' && parent.discriminant === node ||
    parent.type === 'ExpressionStatement' && parent.expression === node) {
      return false;
    }

    return true;
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$AwaitExpression(node, parent) {
    return ___$romejs$js_ast_utils$src$isBinary_ts$default(parent) ||
    ___$romejs$js_ast_utils$src$isUnaryLike_ts$default(parent) ||
    parent.type === 'CallExpression' ||
    parent.type === 'MemberExpression' ||
    parent.type === 'NewExpression' ||
    parent.type === 'ConditionalExpression' && node === parent.test;
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$ClassExpression(node, parent, printStack) {
    return ___$$priv$romejs$js_generator$src$node$parentheses_ts$isFirstInStatement(printStack, false, true);
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$UnaryExpression(node, parent) {
    return parent.type === 'MemberExpression' && parent.object === node ||
    parent.type === 'CallExpression' && parent.callee === node ||
    parent.type === 'NewExpression' && parent.callee === node ||
    parent.type === 'BinaryExpression' &&
    parent.operator === '**' &&
    parent.left === node;
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$SpreadElement(node, parent) {
    return ___$romejs$js_generator$src$node$parentheses_ts$UnaryExpression(node, parent);
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$RestProperty(node, parent) {
    return ___$romejs$js_generator$src$node$parentheses_ts$UnaryExpression(node, parent);
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$SpreadProperty(node, parent) {
    return ___$romejs$js_generator$src$node$parentheses_ts$UnaryExpression(node, parent);
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$FunctionExpression(node, parent, printStack) {
    return ___$$priv$romejs$js_generator$src$node$parentheses_ts$isFirstInStatement(printStack, false, true);
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$ArrowFunctionExpression(node, parent) {
    return parent.type === 'ExportDeclaration' || ___$romejs$js_generator$src$node$parentheses_ts$ConditionalExpression(node, parent);
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$ConditionalExpression(node, parent) {
    if (___$romejs$js_ast_utils$src$isUnaryLike_ts$default(parent) ||
    ___$romejs$js_ast_utils$src$isBinary_ts$default(parent) ||
    parent.type === 'ConditionalExpression' && parent.test === node ||
    parent.type === 'AwaitExpression' ||
    parent.type === 'TaggedTemplateExpression') {
      return true;
    }

    return ___$romejs$js_generator$src$node$parentheses_ts$UnaryExpression(node, parent);
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$AssignmentExpression(node, parent) {
    if (node.left.type === 'ObjectPattern') {
      return true;
    } else {
      return ___$romejs$js_generator$src$node$parentheses_ts$ConditionalExpression(node, parent);
    }
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$FlowIntersectionTypeAnnotation(node, parent) {
    return parent.type === 'FlowArrayTypeAnnotation' ||
    parent.type === 'FlowNullableTypeAnnotation' ||
    parent.type === 'FlowIntersectionTypeAnnotation' ||
    parent.type === 'FlowUnionTypeAnnotation';
  }

  function ___$romejs$js_generator$src$node$parentheses_ts$FlowFunctionTypeAnnotation(node, parent) {
    return parent.type === 'FlowUnionTypeAnnotation' ||
    parent.type === 'FlowIntersectionTypeAnnotation';
  }

  function ___$$priv$romejs$js_generator$src$node$parentheses_ts$isFirstInStatement(printStack, considerArrow, considerDefaultExports) {
    let i = printStack.length - 1;
    let node = printStack[i];
    i--;
    let parent = printStack[i];
    while (i > 0) {
      if (parent.type === 'ExpressionStatement' && parent.expression === node ||
      parent.type === 'TaggedTemplateExpression' ||
      considerDefaultExports &&
      parent.type === 'ExportDefaultDeclaration' &&
      parent.declaration === node ||
      considerArrow &&
      parent.type === 'ArrowFunctionExpression' && parent.body === node) {
        return true;
      }

      if (parent.type === 'CallExpression' && parent.callee === node ||
      parent.type === 'SequenceExpression' &&
      parent.expressions[0] === node ||
      parent.type === 'MemberExpression' && parent.object === node ||
      ___$romejs$js_ast_utils$src$isConditional_ts$default(parent) && parent.test === node ||
      ___$romejs$js_ast_utils$src$isBinary_ts$default(parent) && parent.left === node ||
      parent.type === 'AssignmentExpression' && parent.left === node) {
        node = parent;
        i--;
        parent = printStack[i];
      } else {
        return false;
      }
    }

    return false;
  }

  // romejs/js-generator/src/node/index.ts

  function ___$$priv$romejs$js_generator$src$node$index_ts$isOrHasCallExpression(node) {
    if (node.type === 'CallExpression') {
      return true;
    }

    if (node.type === 'MemberExpression') {
      return ___$$priv$romejs$js_generator$src$node$index_ts$isOrHasCallExpression(node.object) ||
      !node.computed && ___$$priv$romejs$js_generator$src$node$index_ts$isOrHasCallExpression(node.property);
    } else {
      return false;
    }
  }

  function ___$romejs$js_generator$src$node$index_ts$hasExtraLineBetween(a, b) {
    return ___$romejs$js_generator$src$node$index_ts$getLinesBetween(a, b) > 1;
  }

  function ___$romejs$js_generator$src$node$index_ts$getLinesBetween(a, b) {
    return a && b && a.loc && b.loc ? Math.max(0, b.loc.start.line - a.loc.end.line) : 0;
  }

  function ___$romejs$js_generator$src$node$index_ts$isMultiLine(node) {
    return Boolean(
    node && node.loc ? node.loc.end.line > node.loc.start.line : true);
  }

  function ___$romejs$js_generator$src$node$index_ts$needsParens(node, parent, printStack) {
    if (!parent) {
      return false;
    }

    if (parent.type === 'NewExpression' && parent.callee === node) {
      if (___$$priv$romejs$js_generator$src$node$index_ts$isOrHasCallExpression(node)) {
        return true;
      }
    }

    const fn = ___$romejs$js_generator$src$node$parentheses_ts[node.type];
    return fn ? fn(node, parent, printStack) : undefined;
  }

  // romejs/js-generator/src/generators/core/AssignmentExpression.ts

  const ___$romejs$js_generator$src$generators$core$AssignmentExpression_ts = {
    AssignmentExpression: ___$romejs$js_generator$src$generators$core$AssignmentExpression_ts$AssignmentExpression};
  function ___$romejs$js_generator$src$generators$core$AssignmentExpression_ts$AssignmentExpression(generator, node, parent) {
    const parens = generator.inForStatementInitCounter > 0 &&
    node.operator === 'in' &&
    !___$romejs$js_generator$src$node$index_ts$needsParens(node, parent, []);
    const {left: left, right: right} = node;

    if (parens) {
      generator.token('(');
    }

    generator.print(left, node);

    generator.space();
    if (node.operator === 'in' || node.operator === 'instanceof') {
      generator.word(node.operator);
    } else {
      generator.token(node.operator);
    }
    generator.space();

    const isMultiLine = left.loc !== undefined &&
    right.loc !== undefined &&
    right.loc.start.line > left.loc.end.line;
    if (isMultiLine) {
      generator.newline();
    }

    generator.print(right, node);

    if (parens) {
      generator.token(')');
    }
  }

  // romejs/js-generator/src/generators/core/LogicalExpression.ts

  const ___$romejs$js_generator$src$generators$core$LogicalExpression_ts = {
    LogicalExpression: ___$romejs$js_generator$src$generators$core$LogicalExpression_ts$LogicalExpression};
  function ___$romejs$js_generator$src$generators$core$LogicalExpression_ts$LogicalExpression(generator, node, parent) {
    ___$romejs$js_generator$src$generators$core$AssignmentExpression_ts$AssignmentExpression(generator, node, parent);
  }

  // romejs/js-generator/src/generators/core/TryStatement.ts

  const ___$romejs$js_generator$src$generators$core$TryStatement_ts = {
    TryStatement: ___$romejs$js_generator$src$generators$core$TryStatement_ts$TryStatement};
  function ___$romejs$js_generator$src$generators$core$TryStatement_ts$TryStatement(generator, node) {
    generator.word('try');
    generator.space();
    generator.print(node.block, node);
    generator.space();
    generator.print(node.handler, node);

    if (node.finalizer) {
      generator.space();
      generator.word('finally');
      generator.space();
      generator.print(node.finalizer, node);
    }
  }

  // romejs/js-generator/src/generators/utils.ts

  function ___$romejs$js_generator$src$generators$utils_ts$buildForXStatementGenerator(op) {
    return function(generator, node) {
      generator.word('for');
      generator.space();
      if (op === 'of' && node.type === 'ForOfStatement' && node.await === true) {
        generator.word('await');
        generator.space();
      }
      generator.token('(');
      generator.print(node.left, node);
      generator.space();
      generator.word(op);
      generator.space();
      generator.print(node.right, node);
      generator.token(')');
      generator.printBlock(node);
    };
  }

  function ___$romejs$js_generator$src$generators$utils_ts$buildYieldAwaitGenerator(keyword) {
    return function(generator, node) {
      generator.word(keyword);

      if (node.type === 'YieldExpression' && node.delegate === true) {
        generator.token('*');
      }

      if (node.argument) {
        generator.space();
        const terminatorState = generator.startTerminatorless();
        generator.print(node.argument, node);
        generator.endTerminatorless(terminatorState);
      }
    };
  }

  function ___$romejs$js_generator$src$generators$utils_ts$buildLabelStatementGenerator(prefix) {
    return function(generator, node) {
      generator.word(prefix);

      let arg;
      if ((node.type === 'ContinueStatement' || node.type === 'BreakStatement') &&
      node.label !== undefined) {
        arg = node.label;
      }
      if ((node.type === 'ThrowStatement' || node.type === 'ReturnStatement') &&
      node.argument !== undefined) {
        arg = node.argument;
      }

      if (arg !== undefined) {
        generator.space();

        const terminatorState = generator.startTerminatorless();
        generator.print(arg, node);
        generator.endTerminatorless(terminatorState);
      }

      generator.semicolon();
    };
  }

  function ___$romejs$js_generator$src$generators$utils_ts$printParams(generator, node) {
    generator.print(node.typeParameters, node);
    generator.token('(');
    generator.printCommaList(node.params, node, {
      iterator: node => {
        if (node.optional) {
          generator.token('?');
        }
        generator.print(node.typeAnnotation, node);
      }});
    generator.token(')');

    if (node.returnType) {
      generator.print(node.returnType, node);
    }

    if (node.predicate) {
      if (!node.returnType) {
        generator.token(':');
      }
      generator.space();
      generator.print(node.predicate, node);
    }
  }

  function ___$romejs$js_generator$src$generators$utils_ts$printMethod(generator, node) {
    const kind = node.kind;
    const key = node.key;

    if (kind === 'method' && node.generator === true) {
      generator.token('*');
    }

    if (kind === 'get' || kind === 'set') {
      generator.word(kind);
      generator.space();
    }

    if (node.async === true) {
      generator.word('async');
      generator.space();
    }

    if (node.computed === true) {
      generator.token('[');
      generator.print(key, node);
      generator.token(']');
    } else {
      generator.print(key, node);
    }

    ___$romejs$js_generator$src$generators$utils_ts$printParams(generator, node);
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/src/generators/core/ObjectMethod.ts

  const ___$romejs$js_generator$src$generators$core$ObjectMethod_ts = {
    ObjectMethod: ___$romejs$js_generator$src$generators$core$ObjectMethod_ts$ObjectMethod};
  function ___$romejs$js_generator$src$generators$core$ObjectMethod_ts$ObjectMethod(generator, node) {
    ___$romejs$js_generator$src$generators$utils_ts$printMethod(generator, node);
  }

  // romejs/js-generator/src/generators/core/SwitchCase.ts

  const ___$romejs$js_generator$src$generators$core$SwitchCase_ts = {
    SwitchCase: ___$romejs$js_generator$src$generators$core$SwitchCase_ts$SwitchCase};
  function ___$romejs$js_generator$src$generators$core$SwitchCase_ts$SwitchCase(generator, node) {
    if (node.test) {
      generator.word('case');
      generator.space();
      generator.print(node.test, node);
      generator.token(':');
    } else {
      generator.word('default');
      generator.token(':');
    }

    generator.newline();

    if (node.consequent.length) {
      generator.printStatementList(node.consequent, node, {indent: true});
    }
  }

  // romejs/js-generator/src/generators/core/ExportNamedDeclaration.ts

  const ___$romejs$js_generator$src$generators$core$ExportNamedDeclaration_ts = {
    ExportNamedDeclaration: ___$romejs$js_generator$src$generators$core$ExportNamedDeclaration_ts$ExportNamedDeclaration,
    _ExportDeclaration: ___$romejs$js_generator$src$generators$core$ExportNamedDeclaration_ts$_ExportDeclaration};
  function ___$romejs$js_generator$src$generators$core$ExportNamedDeclaration_ts$ExportNamedDeclaration(generator, node) {
    generator.word('export');
    generator.space();
    ___$romejs$js_generator$src$generators$core$ExportNamedDeclaration_ts$_ExportDeclaration(generator, node);
  }

  function ___$romejs$js_generator$src$generators$core$ExportNamedDeclaration_ts$_ExportDeclaration(generator, node) {
    if (node.declaration) {
      const declar = node.declaration;
      generator.print(declar, node);
      if (!___$romejs$js_ast_utils$src$isStatement_ts$default(declar)) {
        generator.semicolon();
      }
    } else {
      if (node.type !== 'ExportNamedDeclaration') {
        throw new Error('Expected ExportNamedDeclaration');
      }

      if (node.exportKind === 'type') {
        generator.word('type');
        generator.space();
      }

      if (node.specifiers === undefined) {
        throw new Error('Expected specifiers since there was no declaration');
      }

      const specifiers = node.specifiers.slice(0);

      let hasSpecial = false;
      while (true) {
        const first = specifiers[0];
        if (first !== undefined &&
        (first.type === 'ExportDefaultSpecifier' ||
        first.type === 'ExportNamespaceSpecifier')) {
          hasSpecial = true;
          generator.print(specifiers.shift(), node);
          if (specifiers.length) {
            generator.token(',');
            generator.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length || !specifiers.length && !hasSpecial) {
        generator.token('{');
        if (specifiers.length) {
          generator.printCommaList(specifiers, node);
        }
        generator.token('}');
      }

      if (node.source) {
        generator.space();
        generator.word('from');
        generator.space();
        generator.print(node.source, node);
      }

      generator.semicolon();
    }
  }

  // romejs/js-generator/src/generators/core/VariableDeclaration.ts

  const ___$romejs$js_generator$src$generators$core$VariableDeclaration_ts = {
    VariableDeclaration: ___$romejs$js_generator$src$generators$core$VariableDeclaration_ts$VariableDeclaration};
  function ___$romejs$js_generator$src$generators$core$VariableDeclaration_ts$VariableDeclaration(generator, node, parent) {
    generator.word(node.kind);
    generator.space();

    let hasInits = false;

    if (!___$romejs$js_ast_utils$src$isFor_ts$default(parent)) {
      for (const declar of node.declarations) {
        if (declar.init) {
          hasInits = true;
        }
      }
    }

    let separator = ___$$priv$romejs$js_generator$src$generators$core$VariableDeclaration_ts$variableDeclarationNormal;
    if (hasInits) {
      separator =
      node.kind === 'const' ? ___$$priv$romejs$js_generator$src$generators$core$VariableDeclaration_ts$constDeclarationIndent : ___$$priv$romejs$js_generator$src$generators$core$VariableDeclaration_ts$variableDeclarationIndent;
    }

    generator.printJoin(node.declarations, node, {separator: separator});

    if (___$romejs$js_ast_utils$src$isFor_ts$default(parent)) {
      if (parent.left === node || parent.init === node) {
        return undefined;
      }
    }

    generator.semicolon();
  }

  function ___$$priv$romejs$js_generator$src$generators$core$VariableDeclaration_ts$variableDeclarationNormal(generator) {
    generator.token(',');
    generator.space();
  }

  function ___$$priv$romejs$js_generator$src$generators$core$VariableDeclaration_ts$variableDeclarationIndent(generator) {
    generator.token(',');
    generator.newline();
    if (generator.endsWith('\n')) {
      for (let i = 0; i < 4; i++) {
        generator.space();
      }
    }
  }

  function ___$$priv$romejs$js_generator$src$generators$core$VariableDeclaration_ts$constDeclarationIndent(generator) {
    generator.token(',');
    generator.newline();
    if (generator.endsWith('\n')) {
      for (let i = 0; i < 6; i++) {
        generator.space();
      }
    }
  }

  // romejs/js-generator/src/generators/core/ImportDefaultSpecifier.ts

  const ___$romejs$js_generator$src$generators$core$ImportDefaultSpecifier_ts = {
    ImportDefaultSpecifier: ___$romejs$js_generator$src$generators$core$ImportDefaultSpecifier_ts$ImportDefaultSpecifier};
  function ___$romejs$js_generator$src$generators$core$ImportDefaultSpecifier_ts$ImportDefaultSpecifier(generator, node) {
    generator.print(node.local, node);
  }

  // romejs/js-generator/src/generators/core/ClassPrivateProperty.ts

  const ___$romejs$js_generator$src$generators$core$ClassPrivateProperty_ts = {
    ClassPrivateProperty: ___$romejs$js_generator$src$generators$core$ClassPrivateProperty_ts$ClassPrivateProperty};
  function ___$romejs$js_generator$src$generators$core$ClassPrivateProperty_ts$ClassPrivateProperty() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/core/UnaryExpression.ts

  const ___$romejs$js_generator$src$generators$core$UnaryExpression_ts = {
    UnaryExpression: ___$romejs$js_generator$src$generators$core$UnaryExpression_ts$UnaryExpression};
  function ___$romejs$js_generator$src$generators$core$UnaryExpression_ts$UnaryExpression(generator, node) {
    if (node.operator === 'void' ||
    node.operator === 'delete' ||
    node.operator === 'typeof') {
      generator.word(node.operator);
      generator.space();
    } else {
      generator.token(node.operator);
    }

    generator.print(node.argument, node);
  }

  // romejs/js-generator/src/generators/core/ObjectExpression.ts

  const ___$romejs$js_generator$src$generators$core$ObjectExpression_ts = {
    ObjectExpression: ___$romejs$js_generator$src$generators$core$ObjectExpression_ts$ObjectExpression};
  function ___$romejs$js_generator$src$generators$core$ObjectExpression_ts$ObjectExpression(generator, node) {
    const props = node.properties;

    generator.token('{');
    generator.printInnerComments(node);

    if (props.length) {
      generator.printCommaList(props, node, {
        indent: true,
        statement: ___$romejs$js_generator$src$node$index_ts$isMultiLine(node)});
    }

    generator.token('}');
  }

  // romejs/js-generator/src/generators/core/FunctionExpression.ts

  const ___$romejs$js_generator$src$generators$core$FunctionExpression_ts = {
    FunctionExpression: ___$romejs$js_generator$src$generators$core$FunctionExpression_ts$FunctionExpression};
  function ___$romejs$js_generator$src$generators$core$FunctionExpression_ts$FunctionExpression(generator, node) {
    if (node.async === true) {
      generator.word('async');
      generator.space();
    }

    generator.word('function');

    if (node.generator === true) {
      generator.token('*');
    }

    if (node.id) {
      generator.space();
      generator.print(node.id, node);
    }

    ___$romejs$js_generator$src$generators$utils_ts$printParams(generator, node);
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/src/generators/core/FunctionDeclaration.ts

  const ___$romejs$js_generator$src$generators$core$FunctionDeclaration_ts = {
    FunctionDeclaration: ___$romejs$js_generator$src$generators$core$FunctionDeclaration_ts$FunctionDeclaration};
  function ___$romejs$js_generator$src$generators$core$FunctionDeclaration_ts$FunctionDeclaration(generator, node) {
    ___$romejs$js_generator$src$generators$core$FunctionExpression_ts$FunctionExpression(generator, node);
  }

  // romejs/js-generator/src/generators/core/InterpreterDirective.ts

  const ___$romejs$js_generator$src$generators$core$InterpreterDirective_ts = {
    InterpreterDirective: ___$romejs$js_generator$src$generators$core$InterpreterDirective_ts$InterpreterDirective};
  function ___$romejs$js_generator$src$generators$core$InterpreterDirective_ts$InterpreterDirective(generator, node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/core/ClassDeclaration.ts

  const ___$romejs$js_generator$src$generators$core$ClassDeclaration_ts = {
    ClassDeclaration: ___$romejs$js_generator$src$generators$core$ClassDeclaration_ts$ClassDeclaration};
  function ___$romejs$js_generator$src$generators$core$ClassDeclaration_ts$ClassDeclaration(generator, node, parent) {
    generator.word('class');

    if (node.id) {
      generator.space();
      generator.print(node.id, node);
    }

    generator.print(node.typeParameters, node);

    if (node.superClass) {
      generator.space();
      generator.word('extends');
      generator.space();
      generator.print(node.superClass, node);
      generator.print(node.superTypeParameters, node);
    }

    if (node.implements !== undefined && node.implements.length > 0) {
      generator.space();
      generator.word('implements');
      generator.space();
      generator.printCommaList(node.implements, node);
    }

    generator.space();

    generator.token('{');
    generator.printInnerComments(node);
    if (node.body.length === 0) {
      generator.token('}');
    } else {
      generator.newline();

      generator.indent();
      generator.printStatementList(node.body, node);
      generator.dedent();

      if (!generator.endsWith('\n')) {
        generator.newline();
      }

      generator.rightBrace();
    }
  }

  // romejs/js-generator/src/generators/core/NumericLiteral.ts

  const ___$romejs$js_generator$src$generators$core$NumericLiteral_ts = {
    NumericLiteral: ___$romejs$js_generator$src$generators$core$NumericLiteral_ts$NumericLiteral};
  function ___$romejs$js_generator$src$generators$core$NumericLiteral_ts$NumericLiteral(generator, node) {
    const raw = generator.getPossibleRaw(node);
    const value = String(node.value);
    if (raw === undefined) {
      generator.number(value);
    } else {
      generator.number(raw);
    }
  }

  // romejs/js-generator/src/generators/core/ClassMethod.ts

  const ___$romejs$js_generator$src$generators$core$ClassMethod_ts = {
    ClassMethod: ___$romejs$js_generator$src$generators$core$ClassMethod_ts$ClassMethod};
  function ___$romejs$js_generator$src$generators$core$ClassMethod_ts$ClassMethod(generator, node) {
    if (node.static === true) {
      generator.word('static');
      generator.space();
    }

    ___$romejs$js_generator$src$generators$utils_ts$printMethod(generator, node);
  }

  // romejs/js-generator/src/generators/core/WhileStatement.ts

  const ___$romejs$js_generator$src$generators$core$WhileStatement_ts = {
    WhileStatement: ___$romejs$js_generator$src$generators$core$WhileStatement_ts$WhileStatement};
  function ___$romejs$js_generator$src$generators$core$WhileStatement_ts$WhileStatement(generator, node) {
    generator.word('while');
    generator.space();
    generator.token('(');
    generator.print(node.test, node);
    generator.token(')');
    generator.printBlock(node);
  }

  // romejs/js-generator/src/generators/core/AssignmentPattern.ts

  const ___$romejs$js_generator$src$generators$core$AssignmentPattern_ts = {
    AssignmentPattern: ___$romejs$js_generator$src$generators$core$AssignmentPattern_ts$AssignmentPattern};
  function ___$romejs$js_generator$src$generators$core$AssignmentPattern_ts$AssignmentPattern(generator, node) {
    generator.print(node.left, node);
    if (node.left.optional === true) {
      generator.token('?');
    }
    generator.print(node.left.typeAnnotation, node);
    generator.space();
    generator.token('=');
    generator.space();
    generator.print(node.right, node);
  }

  // romejs/js-generator/src/generators/core/StringLiteral.ts

  const ___$romejs$js_generator$src$generators$core$StringLiteral_ts = {
    StringLiteral: ___$romejs$js_generator$src$generators$core$StringLiteral_ts$StringLiteral};
  function ___$romejs$js_generator$src$generators$core$StringLiteral_ts$StringLiteral(generator, node, parent) {
    const quotes = parent.type === 'JSXAttribute' ? '"' : '\'';
    generator.token(
    ___$romejs$string_escape$src$escapeString_ts$default(node.value, {
      quote: quotes}));
  }

  // romejs/js-generator/src/generators/core/DirectiveLiteral.ts

  const ___$romejs$js_generator$src$generators$core$DirectiveLiteral_ts = {
    DirectiveLiteral: ___$romejs$js_generator$src$generators$core$DirectiveLiteral_ts$DirectiveLiteral};
  function ___$romejs$js_generator$src$generators$core$DirectiveLiteral_ts$DirectiveLiteral(generator, node, parent) {
    ___$romejs$js_generator$src$generators$core$StringLiteral_ts$StringLiteral(generator, node, parent);
  }

  // romejs/js-generator/src/generators/core/WithStatement.ts

  const ___$romejs$js_generator$src$generators$core$WithStatement_ts = {
    WithStatement: ___$romejs$js_generator$src$generators$core$WithStatement_ts$WithStatement};
  function ___$romejs$js_generator$src$generators$core$WithStatement_ts$WithStatement(generator, node) {
    generator.word('with');
    generator.space();
    generator.token('(');
    generator.print(node.object, node);
    generator.token(')');
    generator.printBlock(node);
  }

  // romejs/js-generator/src/generators/core/RestProperty.ts

  const ___$romejs$js_generator$src$generators$core$RestProperty_ts = {
    RestProperty: ___$romejs$js_generator$src$generators$core$RestProperty_ts$RestProperty};
  function ___$romejs$js_generator$src$generators$core$RestProperty_ts$RestProperty(generator, node) {
    generator.token('...');
    generator.print(node.argument, node);
  }

  // romejs/js-generator/src/generators/core/RestElement.ts

  const ___$romejs$js_generator$src$generators$core$RestElement_ts = {
    RestElement: ___$romejs$js_generator$src$generators$core$RestElement_ts$RestElement};
  function ___$romejs$js_generator$src$generators$core$RestElement_ts$RestElement(generator, node) {
    ___$romejs$js_generator$src$generators$core$RestProperty_ts$RestProperty(generator, node);
  }

  // romejs/js-generator/src/generators/core/MetaProperty.ts

  const ___$romejs$js_generator$src$generators$core$MetaProperty_ts = {
    MetaProperty: ___$romejs$js_generator$src$generators$core$MetaProperty_ts$MetaProperty};
  function ___$romejs$js_generator$src$generators$core$MetaProperty_ts$MetaProperty(generator, node) {
    generator.print(node.meta, node);
    generator.token('.');
    generator.print(node.property, node);
  }

  // romejs/js-generator/src/generators/core/Import.ts

  const ___$romejs$js_generator$src$generators$core$Import_ts = {
    Import: ___$romejs$js_generator$src$generators$core$Import_ts$Import};
  function ___$romejs$js_generator$src$generators$core$Import_ts$Import(generator) {
    generator.word('import');
  }

  // romejs/js-generator/src/generators/core/ImportDeclaration.ts

  const ___$romejs$js_generator$src$generators$core$ImportDeclaration_ts = {
    ImportDeclaration: ___$romejs$js_generator$src$generators$core$ImportDeclaration_ts$ImportDeclaration};
  function ___$romejs$js_generator$src$generators$core$ImportDeclaration_ts$ImportDeclaration(generator, node) {
    generator.word('import');
    generator.space();

    if (node.importKind === 'type' || node.importKind === 'typeof') {
      generator.word(node.importKind);
      generator.space();
    }

    const specifiers = node.specifiers.slice(0);
    if (specifiers !== undefined) {
      while (specifiers.length > 0) {
        const first = specifiers[0];
        if (first.type === 'ImportDefaultSpecifier' ||
        first.type === 'ImportNamespaceSpecifier') {
          generator.print(specifiers.shift(), node);
          if (specifiers.length) {
            generator.token(',');
            generator.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length > 0) {
        generator.token('{');
        generator.printCommaList(specifiers, node);
        generator.token('}');
      }

      generator.space();
      generator.word('from');
      generator.space();
    }

    generator.print(node.source, node);
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/core/Program.ts

  const ___$romejs$js_generator$src$generators$core$Program_ts = {
    Program: ___$romejs$js_generator$src$generators$core$Program_ts$Program};
  function ___$romejs$js_generator$src$generators$core$Program_ts$Program(generator, node) {
    generator.printInnerComments(node, false);
    generator.printStatementList(node.directives, node);
    if (node.directives && node.directives.length) {
      generator.newline();
    }

    generator.printStatementList(node.body, node);
  }

  // romejs/js-generator/src/generators/core/ForStatement.ts

  const ___$romejs$js_generator$src$generators$core$ForStatement_ts = {
    ForStatement: ___$romejs$js_generator$src$generators$core$ForStatement_ts$ForStatement};
  function ___$romejs$js_generator$src$generators$core$ForStatement_ts$ForStatement(generator, node) {
    generator.word('for');
    generator.space();
    generator.token('(');

    generator.inForStatementInitCounter++;
    generator.print(node.init, node);
    generator.inForStatementInitCounter--;
    generator.token(';');

    if (node.test) {
      generator.space();
      generator.print(node.test, node);
    }
    generator.token(';');

    if (node.update) {
      generator.space();
      generator.print(node.update, node);
    }

    generator.token(')');
    generator.printBlock(node);
  }

  // romejs/js-generator/src/generators/core/BlockStatement.ts

  const ___$romejs$js_generator$src$generators$core$BlockStatement_ts = {
    BlockStatement: ___$romejs$js_generator$src$generators$core$BlockStatement_ts$BlockStatement};
  function ___$romejs$js_generator$src$generators$core$BlockStatement_ts$BlockStatement(generator, node) {
    generator.token('{');
    generator.printInnerComments(node);

    const hasDirectives = Boolean(
    node.directives && node.directives.length > 0);

    if (node.body.length > 0 || hasDirectives) {
      generator.newline();

      generator.printStatementList(node.directives, node, {indent: true});
      if (hasDirectives) {
        generator.newline();
      }

      generator.printStatementList(node.body, node, {indent: true});
      generator.removeTrailingNewline();

      generator.source('end', node.loc);

      if (!generator.endsWith('\n')) {
        generator.newline();
      }

      generator.rightBrace();
    } else {
      generator.source('end', node.loc);
      generator.token('}');
    }
  }

  // romejs/js-generator/src/generators/core/ArrayExpression.ts

  const ___$romejs$js_generator$src$generators$core$ArrayExpression_ts = {
    ArrayExpression: ___$romejs$js_generator$src$generators$core$ArrayExpression_ts$ArrayExpression};
  function ___$romejs$js_generator$src$generators$core$ArrayExpression_ts$ArrayExpression(generator, node) {
    const elems = node.elements;
    const len = elems.length;

    generator.token('[');
    generator.printInnerComments(node);

    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];
      if (elem) {
        if (i > 0) {
          generator.space();
        }
        generator.print(elem, node);
        if (i < len - 1) {
          generator.token(',');
        }
      } else {
        generator.token(',');
      }
    }

    generator.token(']');
  }

  // romejs/js-generator/src/generators/core/ArrayPattern.ts

  const ___$romejs$js_generator$src$generators$core$ArrayPattern_ts = {
    ArrayPattern: ___$romejs$js_generator$src$generators$core$ArrayPattern_ts$ArrayPattern};
  function ___$romejs$js_generator$src$generators$core$ArrayPattern_ts$ArrayPattern(generator, node) {
    ___$romejs$js_generator$src$generators$core$ArrayExpression_ts$ArrayExpression(generator, node);
  }

  // romejs/js-generator/src/generators/core/ThrowStatement.ts

  const ___$romejs$js_generator$src$generators$core$ThrowStatement_ts = {
    get ThrowStatement() {
      return ___$romejs$js_generator$src$generators$core$ThrowStatement_ts$ThrowStatement;
    }};
  const ___$romejs$js_generator$src$generators$core$ThrowStatement_ts$ThrowStatement = ___$romejs$js_generator$src$generators$utils_ts$buildLabelStatementGenerator('throw');

  // romejs/js-generator/src/generators/core/IfStatement.ts

  const ___$romejs$js_generator$src$generators$core$IfStatement_ts = {
    IfStatement: ___$romejs$js_generator$src$generators$core$IfStatement_ts$IfStatement};
  function ___$romejs$js_generator$src$generators$core$IfStatement_ts$IfStatement(generator, node) {
    generator.word('if');
    generator.space();
    generator.token('(');
    generator.print(node.test, node);
    generator.token(')');
    generator.space();

    let needsBlock = false;
    if (node.alternate !== undefined) {
      const lastStatement = ___$$priv$romejs$js_generator$src$generators$core$IfStatement_ts$getLastStatement(node.consequent);
      if (lastStatement !== undefined && lastStatement.type === 'IfStatement') {
        needsBlock = true;
      }
    }
    if (needsBlock) {
      generator.token('{');
      generator.newline();
      generator.indent();
    }

    generator.print(node.consequent, node);

    if (needsBlock) {
      generator.dedent();
      generator.newline();
      generator.token('}');
    }

    if (node.alternate) {
      if (generator.endsWith('}')) {
        generator.space();
      }
      generator.word('else');
      generator.space();
      generator.print(node.alternate, node);
    }
  }

  function ___$$priv$romejs$js_generator$src$generators$core$IfStatement_ts$getLastStatement(statement) {
    if (___$romejs$js_ast_utils$src$isStatement_ts$default(statement.body)) {
      return ___$$priv$romejs$js_generator$src$generators$core$IfStatement_ts$getLastStatement(statement.body);
    } else {
      return statement;
    }
  }

  // romejs/js-generator/src/generators/core/ClassProperty.ts

  const ___$romejs$js_generator$src$generators$core$ClassProperty_ts = {
    ClassProperty: ___$romejs$js_generator$src$generators$core$ClassProperty_ts$ClassProperty};
  function ___$romejs$js_generator$src$generators$core$ClassProperty_ts$ClassProperty(generator, node) {
    if (node.static === true) {
      generator.word('static');
      generator.space();
    }

    if (node.computed === true) {
      generator.token('[');
      generator.print(node.key, node);
      generator.token(']');
    } else {
      generator.print(node.variance, node);
      generator.print(node.key, node);
    }

    generator.print(node.typeAnnotation, node);
    if (node.value) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.value, node);
    }
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/core/AwaitExpression.ts

  const ___$romejs$js_generator$src$generators$core$AwaitExpression_ts = {
    get AwaitExpression() {
      return ___$romejs$js_generator$src$generators$core$AwaitExpression_ts$AwaitExpression;
    }};
  const ___$romejs$js_generator$src$generators$core$AwaitExpression_ts$AwaitExpression = ___$romejs$js_generator$src$generators$utils_ts$buildYieldAwaitGenerator('await');

  // romejs/js-generator/src/generators/core/DebuggerStatement.ts

  const ___$romejs$js_generator$src$generators$core$DebuggerStatement_ts = {
    DebuggerStatement: ___$romejs$js_generator$src$generators$core$DebuggerStatement_ts$DebuggerStatement};
  function ___$romejs$js_generator$src$generators$core$DebuggerStatement_ts$DebuggerStatement(generator) {
    generator.word('debugger');
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/core/CatchClause.ts

  const ___$romejs$js_generator$src$generators$core$CatchClause_ts = {
    CatchClause: ___$romejs$js_generator$src$generators$core$CatchClause_ts$CatchClause};
  function ___$romejs$js_generator$src$generators$core$CatchClause_ts$CatchClause(generator, node) {
    generator.word('catch');
    generator.space();
    generator.token('(');
    generator.print(node.param, node);
    generator.token(')');
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/src/generators/core/UpdateExpression.ts

  const ___$romejs$js_generator$src$generators$core$UpdateExpression_ts = {
    UpdateExpression: ___$romejs$js_generator$src$generators$core$UpdateExpression_ts$UpdateExpression};
  function ___$romejs$js_generator$src$generators$core$UpdateExpression_ts$UpdateExpression(generator, node) {
    if (node.prefix === true) {
      generator.token(node.operator);
      generator.print(node.argument, node);
    } else {
      generator.print(node.argument, node);
      generator.token(node.operator);
    }
  }

  // romejs/js-generator/src/generators/core/ClassExpression.ts

  const ___$romejs$js_generator$src$generators$core$ClassExpression_ts = {
    ClassExpression: ___$romejs$js_generator$src$generators$core$ClassExpression_ts$ClassExpression};
  function ___$romejs$js_generator$src$generators$core$ClassExpression_ts$ClassExpression(generator, node, parent) {
    ___$romejs$js_generator$src$generators$core$ClassDeclaration_ts$ClassDeclaration(generator, node, parent);
  }

  // romejs/js-generator/src/generators/core/ArrowFunctionExpression.ts

  const ___$romejs$js_generator$src$generators$core$ArrowFunctionExpression_ts = {
    ArrowFunctionExpression: ___$romejs$js_generator$src$generators$core$ArrowFunctionExpression_ts$ArrowFunctionExpression};
  function ___$romejs$js_generator$src$generators$core$ArrowFunctionExpression_ts$ArrowFunctionExpression(generator, node) {
    if (node.async === true) {
      generator.word('async');
      generator.space();
    }

    const firstParam = node.params[0];

    if (node.params.length === 1 &&
    firstParam !== undefined &&
    firstParam.type === 'Identifier' &&
    !___$$priv$romejs$js_generator$src$generators$core$ArrowFunctionExpression_ts$hasTypes(node, firstParam)) {
      generator.print(firstParam, node);
    } else {
      ___$romejs$js_generator$src$generators$utils_ts$printParams(generator, node);
    }

    generator.space();
    generator.token('=>');
    generator.space();

    generator.print(node.body, node);
  }

  function ___$$priv$romejs$js_generator$src$generators$core$ArrowFunctionExpression_ts$hasTypes(node, param) {
    return node.typeParameters !== undefined ||
    node.returnType !== undefined ||
    param.typeAnnotation !== undefined ||
    param.optional === true ||
    param.trailingComments !== undefined && param.trailingComments.length > 0;
  }

  // romejs/js-generator/src/generators/core/NewExpression.ts

  const ___$romejs$js_generator$src$generators$core$NewExpression_ts = {
    NewExpression: ___$romejs$js_generator$src$generators$core$NewExpression_ts$NewExpression};
  function ___$romejs$js_generator$src$generators$core$NewExpression_ts$NewExpression(generator, node) {
    generator.word('new');
    generator.space();
    generator.print(node.callee, node);
    generator.print(node.typeArguments, node);
    generator.token('(');
    generator.printCommaList(node.arguments, node);
    generator.token(')');
  }

  // romejs/js-generator/src/generators/core/ForInStatement.ts

  const ___$romejs$js_generator$src$generators$core$ForInStatement_ts = {
    get ForInStatement() {
      return ___$romejs$js_generator$src$generators$core$ForInStatement_ts$ForInStatement;
    }};
  const ___$romejs$js_generator$src$generators$core$ForInStatement_ts$ForInStatement = ___$romejs$js_generator$src$generators$utils_ts$buildForXStatementGenerator('in');

  // romejs/js-generator/src/generators/core/BinaryExpression.ts

  const ___$romejs$js_generator$src$generators$core$BinaryExpression_ts = {
    BinaryExpression: ___$romejs$js_generator$src$generators$core$BinaryExpression_ts$BinaryExpression};
  function ___$romejs$js_generator$src$generators$core$BinaryExpression_ts$BinaryExpression(generator, node, parent) {
    ___$romejs$js_generator$src$generators$core$AssignmentExpression_ts$AssignmentExpression(generator, node, parent);
  }

  // romejs/js-generator/src/generators/core/ContinueStatement.ts

  const ___$romejs$js_generator$src$generators$core$ContinueStatement_ts = {
    get ContinueStatement() {
      return ___$romejs$js_generator$src$generators$core$ContinueStatement_ts$ContinueStatement;
    }};
  const ___$romejs$js_generator$src$generators$core$ContinueStatement_ts$ContinueStatement = ___$romejs$js_generator$src$generators$utils_ts$buildLabelStatementGenerator('continue');

  // romejs/js-generator/src/generators/core/PrivateName.ts

  const ___$romejs$js_generator$src$generators$core$PrivateName_ts = {
    PrivateName: ___$romejs$js_generator$src$generators$core$PrivateName_ts$PrivateName};
  function ___$romejs$js_generator$src$generators$core$PrivateName_ts$PrivateName() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/core/Directive.ts

  const ___$romejs$js_generator$src$generators$core$Directive_ts = {
    Directive: ___$romejs$js_generator$src$generators$core$Directive_ts$Directive};
  function ___$romejs$js_generator$src$generators$core$Directive_ts$Directive(generator, node) {
    generator.print(node.value, node);
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/core/MemberExpression.ts

  const ___$romejs$js_generator$src$generators$core$MemberExpression_ts = {
    MemberExpression: ___$romejs$js_generator$src$generators$core$MemberExpression_ts$MemberExpression};
  function ___$romejs$js_generator$src$generators$core$MemberExpression_ts$MemberExpression(generator, node) {
    generator.print(node.object, node);

    if (node.computed !== true && node.property.type === 'MemberExpression') {
      throw new TypeError('Got a MemberExpression for MemberExpression property');
    }

    let computed = node.computed;
    if (node.property.type === 'NumericLiteral' &&
    typeof node.property.value === 'number') {
      computed = true;
    }

    let isOptional = node.type === 'OptionalMemberExpression';

    if (isOptional) {
      generator.token('?.');
    }

    if (computed === true) {
      generator.token('[');
      generator.print(node.property, node);
      generator.token(']');
    } else {
      if (!isOptional) {
        generator.token('.');
      }
      generator.print(node.property, node);
    }
  }

  // romejs/js-generator/src/generators/core/ExportDefaultSpecifier.ts

  const ___$romejs$js_generator$src$generators$core$ExportDefaultSpecifier_ts = {
    ExportDefaultSpecifier: ___$romejs$js_generator$src$generators$core$ExportDefaultSpecifier_ts$ExportDefaultSpecifier};
  function ___$romejs$js_generator$src$generators$core$ExportDefaultSpecifier_ts$ExportDefaultSpecifier(generator, node) {
    generator.print(node.exported, node);
  }

  // romejs/js-generator/src/generators/core/ThisExpression.ts

  const ___$romejs$js_generator$src$generators$core$ThisExpression_ts = {
    ThisExpression: ___$romejs$js_generator$src$generators$core$ThisExpression_ts$ThisExpression};
  function ___$romejs$js_generator$src$generators$core$ThisExpression_ts$ThisExpression(generator) {
    generator.word('this');
  }

  // romejs/js-generator/src/generators/core/ForOfStatement.ts

  const ___$romejs$js_generator$src$generators$core$ForOfStatement_ts = {
    get ForOfStatement() {
      return ___$romejs$js_generator$src$generators$core$ForOfStatement_ts$ForOfStatement;
    }};
  const ___$romejs$js_generator$src$generators$core$ForOfStatement_ts$ForOfStatement = ___$romejs$js_generator$src$generators$utils_ts$buildForXStatementGenerator('of');

  // romejs/js-generator/src/generators/core/BigIntLiteral.ts

  const ___$romejs$js_generator$src$generators$core$BigIntLiteral_ts = {
    BigIntLiteral: ___$romejs$js_generator$src$generators$core$BigIntLiteral_ts$BigIntLiteral};
  function ___$romejs$js_generator$src$generators$core$BigIntLiteral_ts$BigIntLiteral(generator, node) {
    generator.word(node.value + 'n');
  }

  // romejs/js-generator/src/generators/core/BooleanLiteral.ts

  const ___$romejs$js_generator$src$generators$core$BooleanLiteral_ts = {
    BooleanLiteral: ___$romejs$js_generator$src$generators$core$BooleanLiteral_ts$BooleanLiteral};
  function ___$romejs$js_generator$src$generators$core$BooleanLiteral_ts$BooleanLiteral(generator, node) {
    generator.word(node.value ? 'true' : 'false');
  }

  // romejs/js-generator/src/generators/core/Identifier.ts

  const ___$romejs$js_generator$src$generators$core$Identifier_ts = {
    Identifier: ___$romejs$js_generator$src$generators$core$Identifier_ts$Identifier};
  function ___$romejs$js_generator$src$generators$core$Identifier_ts$Identifier(generator, node) {
    generator.word(node.name);
  }

  // romejs/js-generator/src/generators/core/ExportAllDeclaration.ts

  const ___$romejs$js_generator$src$generators$core$ExportAllDeclaration_ts = {
    ExportAllDeclaration: ___$romejs$js_generator$src$generators$core$ExportAllDeclaration_ts$ExportAllDeclaration};
  function ___$romejs$js_generator$src$generators$core$ExportAllDeclaration_ts$ExportAllDeclaration(generator, node) {
    generator.word('export');
    generator.space();
    generator.token('*');
    generator.space();
    generator.word('from');
    generator.space();
    generator.print(node.source, node);
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/core/ObjectPattern.ts

  const ___$romejs$js_generator$src$generators$core$ObjectPattern_ts = {
    ObjectPattern: ___$romejs$js_generator$src$generators$core$ObjectPattern_ts$ObjectPattern};
  function ___$romejs$js_generator$src$generators$core$ObjectPattern_ts$ObjectPattern(generator, node) {
    ___$romejs$js_generator$src$generators$core$ObjectExpression_ts$ObjectExpression(generator, node);
  }

  // romejs/js-generator/src/generators/core/BreakStatement.ts

  const ___$romejs$js_generator$src$generators$core$BreakStatement_ts = {
    get BreakStatement() {
      return ___$romejs$js_generator$src$generators$core$BreakStatement_ts$BreakStatement;
    }};
  const ___$romejs$js_generator$src$generators$core$BreakStatement_ts$BreakStatement = ___$romejs$js_generator$src$generators$utils_ts$buildLabelStatementGenerator('break');

  // romejs/js-generator/src/generators/core/TemplateElement.ts

  const ___$romejs$js_generator$src$generators$core$TemplateElement_ts = {
    TemplateElement: ___$romejs$js_generator$src$generators$core$TemplateElement_ts$TemplateElement};
  function ___$romejs$js_generator$src$generators$core$TemplateElement_ts$TemplateElement(generator, node, parent) {
    const isFirst = parent.quasis[0] === node;
    const isLast = parent.quasis[parent.quasis.length - 1] === node;

    const value = (isFirst ? '`' : '}') + node.raw + (isLast ? '`' : '${');

    generator.token(value);
  }

  // romejs/js-generator/src/generators/core/ConditionalExpression.ts

  const ___$romejs$js_generator$src$generators$core$ConditionalExpression_ts = {
    ConditionalExpression: ___$romejs$js_generator$src$generators$core$ConditionalExpression_ts$ConditionalExpression};
  function ___$romejs$js_generator$src$generators$core$ConditionalExpression_ts$ConditionalExpression(generator, node) {
    generator.print(node.test, node);
    generator.space();
    generator.token('?');
    generator.space();
    generator.print(node.consequent, node);
    generator.space();
    generator.token(':');
    generator.space();
    generator.print(node.alternate, node);
  }

  // romejs/js-generator/src/generators/core/DoExpression.ts

  const ___$romejs$js_generator$src$generators$core$DoExpression_ts = {
    DoExpression: ___$romejs$js_generator$src$generators$core$DoExpression_ts$DoExpression};
  function ___$romejs$js_generator$src$generators$core$DoExpression_ts$DoExpression(generator, node) {
    generator.word('do');
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/src/generators/core/SwitchStatement.ts

  const ___$romejs$js_generator$src$generators$core$SwitchStatement_ts = {
    SwitchStatement: ___$romejs$js_generator$src$generators$core$SwitchStatement_ts$SwitchStatement};
  function ___$romejs$js_generator$src$generators$core$SwitchStatement_ts$SwitchStatement(generator, node) {
    generator.word('switch');
    generator.space();
    generator.token('(');
    generator.print(node.discriminant, node);
    generator.token(')');
    generator.space();
    generator.token('{');

    generator.printStatementList(node.cases, node, {
      indent: true});

    generator.token('}');
  }

  // romejs/js-generator/src/generators/core/SequenceExpression.ts

  const ___$romejs$js_generator$src$generators$core$SequenceExpression_ts = {
    SequenceExpression: ___$romejs$js_generator$src$generators$core$SequenceExpression_ts$SequenceExpression};
  function ___$romejs$js_generator$src$generators$core$SequenceExpression_ts$SequenceExpression(generator, node) {
    generator.printCommaList(node.expressions, node);
  }

  // romejs/js-generator/src/generators/core/TaggedTemplateExpression.ts

  const ___$romejs$js_generator$src$generators$core$TaggedTemplateExpression_ts = {
    TaggedTemplateExpression: ___$romejs$js_generator$src$generators$core$TaggedTemplateExpression_ts$TaggedTemplateExpression};
  function ___$romejs$js_generator$src$generators$core$TaggedTemplateExpression_ts$TaggedTemplateExpression(generator, node) {
    generator.print(node.tag, node);
    generator.print(node.quasi, node);
  }

  // romejs/js-generator/src/generators/core/VariableDeclarator.ts

  const ___$romejs$js_generator$src$generators$core$VariableDeclarator_ts = {
    VariableDeclarator: ___$romejs$js_generator$src$generators$core$VariableDeclarator_ts$VariableDeclarator};
  function ___$romejs$js_generator$src$generators$core$VariableDeclarator_ts$VariableDeclarator(generator, node) {
    generator.print(node.id, node);
    generator.print(node.id.typeAnnotation, node);
    if (node.init) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.init, node);
    }
  }

  // romejs/js-generator/src/generators/core/EmptyStatement.ts

  const ___$romejs$js_generator$src$generators$core$EmptyStatement_ts = {
    EmptyStatement: ___$romejs$js_generator$src$generators$core$EmptyStatement_ts$EmptyStatement};
  function ___$romejs$js_generator$src$generators$core$EmptyStatement_ts$EmptyStatement(generator) {
    generator.semicolon(true);
  }

  // romejs/js-generator/src/generators/core/CallExpression.ts

  const ___$romejs$js_generator$src$generators$core$CallExpression_ts = {
    CallExpression: ___$romejs$js_generator$src$generators$core$CallExpression_ts$CallExpression};
  function ___$romejs$js_generator$src$generators$core$CallExpression_ts$CallExpression(generator, node) {
    const {callee: callee} = node;
    generator.print(callee, node);

    let isMultiLine = false;
    const firstArg = node.arguments[0];
    if (callee && callee.loc && firstArg && firstArg.loc) {
      isMultiLine = firstArg.loc.start.line > callee.loc.end.line;
    }

    generator.print(node.typeArguments, node);
    generator.token('(');
    generator.printCommaList(node.arguments, node, {
      statement: isMultiLine});
    generator.token(')');
  }

  // romejs/js-generator/src/generators/core/Super.ts

  const ___$romejs$js_generator$src$generators$core$Super_ts = {
    Super: ___$romejs$js_generator$src$generators$core$Super_ts$Super};
  function ___$romejs$js_generator$src$generators$core$Super_ts$Super(generator) {
    generator.word('super');
  }

  // romejs/js-generator/src/generators/core/ImportSpecifier.ts

  const ___$romejs$js_generator$src$generators$core$ImportSpecifier_ts = {
    ImportSpecifier: ___$romejs$js_generator$src$generators$core$ImportSpecifier_ts$ImportSpecifier};
  function ___$romejs$js_generator$src$generators$core$ImportSpecifier_ts$ImportSpecifier(generator, node) {
    if (node.importKind === 'type' || node.importKind === 'typeof') {
      generator.word(node.importKind);
      generator.space();
    }

    generator.print(node.imported, node);
    if (node.local && node.local.name !== node.imported.name) {
      generator.space();
      generator.word('as');
      generator.space();
      generator.print(node.local, node);
    }
  }

  // romejs/js-generator/src/generators/core/ExportSpecifier.ts

  const ___$romejs$js_generator$src$generators$core$ExportSpecifier_ts = {
    ExportSpecifier: ___$romejs$js_generator$src$generators$core$ExportSpecifier_ts$ExportSpecifier};
  function ___$romejs$js_generator$src$generators$core$ExportSpecifier_ts$ExportSpecifier(generator, node) {
    generator.print(node.local, node);
    if (node.exported && node.local.name !== node.exported.name) {
      generator.space();
      generator.word('as');
      generator.space();
      generator.print(node.exported, node);
    }
  }

  // romejs/js-generator/src/generators/core/SpreadProperty.ts

  const ___$romejs$js_generator$src$generators$core$SpreadProperty_ts = {
    SpreadProperty: ___$romejs$js_generator$src$generators$core$SpreadProperty_ts$SpreadProperty};
  function ___$romejs$js_generator$src$generators$core$SpreadProperty_ts$SpreadProperty(generator, node) {
    ___$romejs$js_generator$src$generators$core$RestProperty_ts$RestProperty(generator, node);
  }

  // romejs/js-generator/src/generators/core/ExportDefaultDeclaration.ts

  const ___$romejs$js_generator$src$generators$core$ExportDefaultDeclaration_ts = {
    ExportDefaultDeclaration: ___$romejs$js_generator$src$generators$core$ExportDefaultDeclaration_ts$ExportDefaultDeclaration};
  function ___$romejs$js_generator$src$generators$core$ExportDefaultDeclaration_ts$ExportDefaultDeclaration(generator, node) {
    generator.word('export');
    generator.space();
    generator.word('default');
    generator.space();
    ___$romejs$js_generator$src$generators$core$ExportNamedDeclaration_ts$_ExportDeclaration(generator, node);
  }

  // romejs/js-generator/src/generators/core/ReturnStatement.ts

  const ___$romejs$js_generator$src$generators$core$ReturnStatement_ts = {
    get ReturnStatement() {
      return ___$romejs$js_generator$src$generators$core$ReturnStatement_ts$ReturnStatement;
    }};
  const ___$romejs$js_generator$src$generators$core$ReturnStatement_ts$ReturnStatement = ___$romejs$js_generator$src$generators$utils_ts$buildLabelStatementGenerator('return');

  // romejs/js-generator/src/generators/core/ExportNamespaceSpecifier.ts

  const ___$romejs$js_generator$src$generators$core$ExportNamespaceSpecifier_ts = {
    ExportNamespaceSpecifier: ___$romejs$js_generator$src$generators$core$ExportNamespaceSpecifier_ts$ExportNamespaceSpecifier};
  function ___$romejs$js_generator$src$generators$core$ExportNamespaceSpecifier_ts$ExportNamespaceSpecifier(generator, node) {
    generator.token('*');
    generator.space();
    generator.word('as');
    generator.space();
    generator.print(node.exported, node);
  }

  // romejs/js-generator/src/generators/core/ImportNamespaceSpecifier.ts

  const ___$romejs$js_generator$src$generators$core$ImportNamespaceSpecifier_ts = {
    ImportNamespaceSpecifier: ___$romejs$js_generator$src$generators$core$ImportNamespaceSpecifier_ts$ImportNamespaceSpecifier};
  function ___$romejs$js_generator$src$generators$core$ImportNamespaceSpecifier_ts$ImportNamespaceSpecifier(generator, node) {
    generator.token('*');
    generator.space();
    generator.word('as');
    generator.space();
    generator.print(node.local, node);
  }

  // romejs/js-generator/src/generators/core/DoWhileStatement.ts

  const ___$romejs$js_generator$src$generators$core$DoWhileStatement_ts = {
    DoWhileStatement: ___$romejs$js_generator$src$generators$core$DoWhileStatement_ts$DoWhileStatement};
  function ___$romejs$js_generator$src$generators$core$DoWhileStatement_ts$DoWhileStatement(generator, node) {
    generator.word('do');
    generator.space();
    generator.print(node.body, node);
    generator.space();
    generator.word('while');
    generator.space();
    generator.token('(');
    generator.print(node.test, node);
    generator.token(')');
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/core/ClassPrivateMethod.ts

  const ___$romejs$js_generator$src$generators$core$ClassPrivateMethod_ts = {
    ClassPrivateMethod: ___$romejs$js_generator$src$generators$core$ClassPrivateMethod_ts$ClassPrivateMethod};
  function ___$romejs$js_generator$src$generators$core$ClassPrivateMethod_ts$ClassPrivateMethod() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/core/ExpressionStatement.ts

  const ___$romejs$js_generator$src$generators$core$ExpressionStatement_ts = {
    ExpressionStatement: ___$romejs$js_generator$src$generators$core$ExpressionStatement_ts$ExpressionStatement};
  function ___$romejs$js_generator$src$generators$core$ExpressionStatement_ts$ExpressionStatement(generator, node) {
    generator.print(node.expression, node);
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/core/RegExpLiteral.ts

  const ___$romejs$js_generator$src$generators$core$RegExpLiteral_ts = {
    RegExpLiteral: ___$romejs$js_generator$src$generators$core$RegExpLiteral_ts$RegExpLiteral};
  function ___$romejs$js_generator$src$generators$core$RegExpLiteral_ts$RegExpLiteral(generator, node) {
    const flags = [];

    if (node.global === true) {
      flags.push('g');
    }

    if (node.multiline === true) {
      flags.push('m');
    }

    if (node.sticky === true) {
      flags.push('y');
    }

    if (node.insensitive === true) {
      flags.push('i');
    }

    if (node.noDotNewline === true) {
      flags.push('s');
    }

    if (node.unicode === true) {
      flags.push('u');
    }

    generator.word(`/${node.pattern}/${flags.join('')}`);
  }

  // romejs/js-generator/src/generators/core/TemplateLiteral.ts

  const ___$romejs$js_generator$src$generators$core$TemplateLiteral_ts = {
    TemplateLiteral: ___$romejs$js_generator$src$generators$core$TemplateLiteral_ts$TemplateLiteral};
  function ___$romejs$js_generator$src$generators$core$TemplateLiteral_ts$TemplateLiteral(generator, node) {
    const quasis = node.quasis;

    for (let i = 0; i < quasis.length; i++) {
      generator.print(quasis[i], node);

      if (i + 1 < quasis.length) {
        generator.print(node.expressions[i], node);
      }
    }
  }

  // romejs/js-generator/src/generators/core/LabeledStatement.ts

  const ___$romejs$js_generator$src$generators$core$LabeledStatement_ts = {
    LabeledStatement: ___$romejs$js_generator$src$generators$core$LabeledStatement_ts$LabeledStatement};
  function ___$romejs$js_generator$src$generators$core$LabeledStatement_ts$LabeledStatement(generator, node) {
    generator.print(node.label, node);
    generator.token(':');
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/src/generators/core/YieldExpression.ts

  const ___$romejs$js_generator$src$generators$core$YieldExpression_ts = {
    get YieldExpression() {
      return ___$romejs$js_generator$src$generators$core$YieldExpression_ts$YieldExpression;
    }};
  const ___$romejs$js_generator$src$generators$core$YieldExpression_ts$YieldExpression = ___$romejs$js_generator$src$generators$utils_ts$buildYieldAwaitGenerator('yield');

  // romejs/js-generator/src/generators/core/ObjectProperty.ts

  const ___$romejs$js_generator$src$generators$core$ObjectProperty_ts = {
    ObjectProperty: ___$romejs$js_generator$src$generators$core$ObjectProperty_ts$ObjectProperty};
  function ___$romejs$js_generator$src$generators$core$ObjectProperty_ts$ObjectProperty(generator, node) {
    if (node.computed === true) {
      generator.token('[');
      generator.print(node.key, node);
      generator.token(']');
    } else {
      if (node.value.type === 'AssignmentPattern' &&
      node.key.type === 'Identifier' &&
      node.key.name === node.value.left.name) {
        generator.print(node.value, node);
        return undefined;
      }

      generator.print(node.key, node);

      if (node.shorthand === true &&
      node.key.type === 'Identifier' &&
      node.value.type === 'Identifier' &&
      node.key.name === node.value.name) {
        return undefined;
      }
    }

    generator.token(':');
    generator.space();
    generator.print(node.value, node);
  }

  // romejs/js-generator/src/generators/core/NullLiteral.ts

  const ___$romejs$js_generator$src$generators$core$NullLiteral_ts = {
    NullLiteral: ___$romejs$js_generator$src$generators$core$NullLiteral_ts$NullLiteral};
  function ___$romejs$js_generator$src$generators$core$NullLiteral_ts$NullLiteral(generator) {
    generator.word('null');
  }

  // romejs/js-generator/src/generators/core/SpreadElement.ts

  const ___$romejs$js_generator$src$generators$core$SpreadElement_ts = {
    SpreadElement: ___$romejs$js_generator$src$generators$core$SpreadElement_ts$SpreadElement};
  function ___$romejs$js_generator$src$generators$core$SpreadElement_ts$SpreadElement(generator, node) {
    ___$romejs$js_generator$src$generators$core$RestProperty_ts$RestProperty(generator, node);
  }

  // romejs/js-generator/src/generators/jsx/JSXText.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXText_ts = {
    JSXText: ___$romejs$js_generator$src$generators$jsx$JSXText_ts$JSXText};
  function ___$romejs$js_generator$src$generators$jsx$JSXText_ts$JSXText(generator, node) {
    const raw = generator.getPossibleRaw(node);

    if (raw !== undefined) {
      generator.token(raw);
    } else {
      generator.token(node.value);
    }
  }

  // romejs/js-generator/src/generators/jsx/JSXEmptyExpression.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXEmptyExpression_ts = {
    JSXEmptyExpression: ___$romejs$js_generator$src$generators$jsx$JSXEmptyExpression_ts$JSXEmptyExpression};
  function ___$romejs$js_generator$src$generators$jsx$JSXEmptyExpression_ts$JSXEmptyExpression(generator, node) {
    generator.printInnerComments(node);
  }

  // romejs/js-generator/src/generators/jsx/JSXNamespacedName.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXNamespacedName_ts = {
    JSXNamespacedName: ___$romejs$js_generator$src$generators$jsx$JSXNamespacedName_ts$JSXNamespacedName};
  function ___$romejs$js_generator$src$generators$jsx$JSXNamespacedName_ts$JSXNamespacedName(generator, node) {
    generator.print(node.namespace, node);
    generator.token(':');
    generator.print(node.name, node);
  }

  // romejs/js-generator/src/generators/jsx/JSXIdentifier.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXIdentifier_ts = {
    JSXIdentifier: ___$romejs$js_generator$src$generators$jsx$JSXIdentifier_ts$JSXIdentifier};
  function ___$romejs$js_generator$src$generators$jsx$JSXIdentifier_ts$JSXIdentifier(generator, node) {
    generator.word(node.name);
  }

  // romejs/js-generator/src/generators/jsx/JSXClosingFragment.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXClosingFragment_ts = {
    JSXClosingFragment: ___$romejs$js_generator$src$generators$jsx$JSXClosingFragment_ts$JSXClosingFragment};
  function ___$romejs$js_generator$src$generators$jsx$JSXClosingFragment_ts$JSXClosingFragment(generator) {
    generator.token('</');
    generator.token('>');
  }

  // romejs/js-generator/src/generators/jsx/JSXElement.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXElement_ts = {
    JSXElement: ___$romejs$js_generator$src$generators$jsx$JSXElement_ts$JSXElement};
  function ___$romejs$js_generator$src$generators$jsx$JSXElement_ts$JSXElement(generator, node) {
    const open = node.openingElement;
    generator.print(open, node);
    if (open.selfClosing === true) {
      return undefined;
    }

    generator.indent();
    for (const child of node.children) {
      generator.print(child, node);
    }
    generator.dedent();

    generator.print(node.closingElement, node);
  }

  // romejs/js-generator/src/generators/jsx/JSXOpeningFragment.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXOpeningFragment_ts = {
    JSXOpeningFragment: ___$romejs$js_generator$src$generators$jsx$JSXOpeningFragment_ts$JSXOpeningFragment};
  function ___$romejs$js_generator$src$generators$jsx$JSXOpeningFragment_ts$JSXOpeningFragment(generator) {
    generator.token('<');
    generator.token('>');
  }

  // romejs/js-generator/src/generators/jsx/JSXClosingElement.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXClosingElement_ts = {
    JSXClosingElement: ___$romejs$js_generator$src$generators$jsx$JSXClosingElement_ts$JSXClosingElement};
  function ___$romejs$js_generator$src$generators$jsx$JSXClosingElement_ts$JSXClosingElement(generator, node) {
    generator.token('</');
    generator.print(node.name, node);
    generator.token('>');
  }

  // romejs/js-generator/src/generators/jsx/JSXExpressionContainer.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXExpressionContainer_ts = {
    JSXExpressionContainer: ___$romejs$js_generator$src$generators$jsx$JSXExpressionContainer_ts$JSXExpressionContainer};
  function ___$romejs$js_generator$src$generators$jsx$JSXExpressionContainer_ts$JSXExpressionContainer(generator, node) {
    generator.token('{');
    generator.print(node.expression, node);
    generator.token('}');
  }

  // romejs/js-generator/src/generators/jsx/JSXMemberExpression.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXMemberExpression_ts = {
    JSXMemberExpression: ___$romejs$js_generator$src$generators$jsx$JSXMemberExpression_ts$JSXMemberExpression};
  function ___$romejs$js_generator$src$generators$jsx$JSXMemberExpression_ts$JSXMemberExpression(generator, node) {
    generator.print(node.object, node);
    generator.token('.');
    generator.print(node.property, node);
  }

  // romejs/js-generator/src/generators/jsx/JSXSpreadChild.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXSpreadChild_ts = {
    JSXSpreadChild: ___$romejs$js_generator$src$generators$jsx$JSXSpreadChild_ts$JSXSpreadChild};
  function ___$romejs$js_generator$src$generators$jsx$JSXSpreadChild_ts$JSXSpreadChild(generator, node) {
    generator.token('{');
    generator.token('...');
    generator.print(node.expression, node);
    generator.token('}');
  }

  // romejs/js-generator/src/generators/jsx/JSXSpreadAttribute.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXSpreadAttribute_ts = {
    JSXSpreadAttribute: ___$romejs$js_generator$src$generators$jsx$JSXSpreadAttribute_ts$JSXSpreadAttribute};
  function ___$romejs$js_generator$src$generators$jsx$JSXSpreadAttribute_ts$JSXSpreadAttribute(generator, node) {
    generator.token('{');
    generator.token('...');
    generator.print(node.argument, node);
    generator.token('}');
  }

  // romejs/js-generator/src/generators/jsx/JSXOpeningElement.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXOpeningElement_ts = {
    JSXOpeningElement: ___$romejs$js_generator$src$generators$jsx$JSXOpeningElement_ts$JSXOpeningElement};
  function ___$romejs$js_generator$src$generators$jsx$JSXOpeningElement_ts$JSXOpeningElement(generator, node) {
    generator.token('<');
    generator.print(node.name, node);

    if (node.attributes.length > 0) {
      generator.space();
      generator.printJoin(node.attributes, node, {separator: ___$$priv$romejs$js_generator$src$generators$jsx$JSXOpeningElement_ts$spaceSeparator});
    }

    if (node.selfClosing === true) {
      generator.space();
      generator.token('/>');
    } else {
      generator.token('>');
    }
  }

  function ___$$priv$romejs$js_generator$src$generators$jsx$JSXOpeningElement_ts$spaceSeparator(generator) {
    generator.space();
  }

  // romejs/js-generator/src/generators/jsx/JSXFragment.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXFragment_ts = {
    JSXFragment: ___$romejs$js_generator$src$generators$jsx$JSXFragment_ts$JSXFragment};
  function ___$romejs$js_generator$src$generators$jsx$JSXFragment_ts$JSXFragment(generator, node) {
    generator.print(node.openingFragment, node);

    generator.indent();
    for (const child of node.children) {
      generator.print(child, node);
    }
    generator.dedent();

    generator.print(node.closingFragment, node);
  }

  // romejs/js-generator/src/generators/jsx/JSXAttribute.ts

  const ___$romejs$js_generator$src$generators$jsx$JSXAttribute_ts = {
    JSXAttribute: ___$romejs$js_generator$src$generators$jsx$JSXAttribute_ts$JSXAttribute};
  function ___$romejs$js_generator$src$generators$jsx$JSXAttribute_ts$JSXAttribute(generator, node) {
    generator.print(node.name, node);
    if (node.value) {
      generator.token('=');
      generator.print(node.value, node);
    }
  }

  // romejs/js-generator/src/generators/flow/FlowIntersectionTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowIntersectionTypeAnnotation_ts = {
    FlowIntersectionTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowIntersectionTypeAnnotation_ts$FlowIntersectionTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowIntersectionTypeAnnotation_ts$FlowIntersectionTypeAnnotation(generator, node) {
    generator.printJoin(node.types, node, {separator: ___$$priv$romejs$js_generator$src$generators$flow$FlowIntersectionTypeAnnotation_ts$andSeparator});
  }

  function ___$$priv$romejs$js_generator$src$generators$flow$FlowIntersectionTypeAnnotation_ts$andSeparator(generator) {
    generator.space();
    generator.token('&');
    generator.space();
  }

  // romejs/js-generator/src/generators/flow/FlowAnyTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowAnyTypeAnnotation_ts = {
    FlowAnyTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowAnyTypeAnnotation_ts$FlowAnyTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowAnyTypeAnnotation_ts$FlowAnyTypeAnnotation(generator) {
    generator.word('any');
  }

  // romejs/js-generator/src/generators/flow/FlowInterfaceDeclaration.ts

  const ___$romejs$js_generator$src$generators$flow$FlowInterfaceDeclaration_ts = {
    FlowInterfaceDeclaration: ___$romejs$js_generator$src$generators$flow$FlowInterfaceDeclaration_ts$FlowInterfaceDeclaration,
    _interfaceish: ___$romejs$js_generator$src$generators$flow$FlowInterfaceDeclaration_ts$_interfaceish};
  function ___$romejs$js_generator$src$generators$flow$FlowInterfaceDeclaration_ts$FlowInterfaceDeclaration(generator, node) {
    generator.word('interface');
    generator.space();
    ___$romejs$js_generator$src$generators$flow$FlowInterfaceDeclaration_ts$_interfaceish(generator, node);
  }

  function ___$romejs$js_generator$src$generators$flow$FlowInterfaceDeclaration_ts$_interfaceish(generator, node) {
    generator.print(node.id, node);
    generator.print(node.typeParameters, node);

    if (node.extends.length > 0) {
      generator.space();
      generator.word('extends');
      generator.space();
      generator.printCommaList(node.extends, node);
    }

    if (node.mixins.length > 0) {
      generator.space();
      generator.word('mixins');
      generator.space();
      generator.printCommaList(node.mixins, node);
    }

    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/src/generators/flow/FlowDeclareClass.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclareClass_ts = {
    FlowDeclareClass: ___$romejs$js_generator$src$generators$flow$FlowDeclareClass_ts$FlowDeclareClass};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclareClass_ts$FlowDeclareClass(generator, node, parent) {
    if (parent.type !== 'FlowDeclareExportDeclaration') {
      generator.word('declare');
      generator.space();
    }
    generator.word('class');
    generator.space();
    ___$romejs$js_generator$src$generators$flow$FlowInterfaceDeclaration_ts$_interfaceish(generator, node);
  }

  // romejs/js-generator/src/generators/flow/FlowNumericLiteralTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowNumericLiteralTypeAnnotation_ts = {
    FlowNumericLiteralTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowNumericLiteralTypeAnnotation_ts$FlowNumericLiteralTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowNumericLiteralTypeAnnotation_ts$FlowNumericLiteralTypeAnnotation(generator, node) {
    ___$romejs$js_generator$src$generators$core$NumericLiteral_ts$NumericLiteral(generator, node);
  }

  // romejs/js-generator/src/generators/flow/FlowQualifiedTypeIdentifier.ts

  const ___$romejs$js_generator$src$generators$flow$FlowQualifiedTypeIdentifier_ts = {
    FlowQualifiedTypeIdentifier: ___$romejs$js_generator$src$generators$flow$FlowQualifiedTypeIdentifier_ts$FlowQualifiedTypeIdentifier};
  function ___$romejs$js_generator$src$generators$flow$FlowQualifiedTypeIdentifier_ts$FlowQualifiedTypeIdentifier(generator, node) {
    generator.print(node.qualification, node);
    generator.token('.');
    generator.print(node.id, node);
  }

  // romejs/js-generator/src/generators/flow/FlowDeclareExportAllDeclaration.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclareExportAllDeclaration_ts = {
    FlowDeclareExportAllDeclaration: ___$romejs$js_generator$src$generators$flow$FlowDeclareExportAllDeclaration_ts$FlowDeclareExportAllDeclaration};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclareExportAllDeclaration_ts$FlowDeclareExportAllDeclaration(generator, node) {
    generator.word('declare');
    generator.space();
    generator.word('export');
    generator.space();
    generator.token('*');
    generator.space();
    generator.word('from');
    generator.space();
    generator.print(node.source, node);
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/flow/FlowBooleanTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowBooleanTypeAnnotation_ts = {
    FlowBooleanTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowBooleanTypeAnnotation_ts$FlowBooleanTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowBooleanTypeAnnotation_ts$FlowBooleanTypeAnnotation(generator) {
    generator.word('boolean');
  }

  // romejs/js-generator/src/generators/flow/FlowNullableTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowNullableTypeAnnotation_ts = {
    FlowNullableTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowNullableTypeAnnotation_ts$FlowNullableTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowNullableTypeAnnotation_ts$FlowNullableTypeAnnotation(generator, node) {
    generator.token('?');
    generator.print(node.typeAnnotation, node);
  }

  // romejs/js-generator/src/generators/flow/FlowDeclareVariable.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclareVariable_ts = {
    FlowDeclareVariable: ___$romejs$js_generator$src$generators$flow$FlowDeclareVariable_ts$FlowDeclareVariable};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclareVariable_ts$FlowDeclareVariable(generator, node, parent) {
    if (parent.type !== 'FlowDeclareExportDeclaration') {
      generator.word('declare');
      generator.space();
    }
    generator.word('var');
    generator.space();
    generator.print(node.id, node);
    generator.print(node.id.typeAnnotation, node);
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/flow/FlowInterfaceExtends.ts

  const ___$romejs$js_generator$src$generators$flow$FlowInterfaceExtends_ts = {
    FlowInterfaceExtends: ___$romejs$js_generator$src$generators$flow$FlowInterfaceExtends_ts$FlowInterfaceExtends};
  function ___$romejs$js_generator$src$generators$flow$FlowInterfaceExtends_ts$FlowInterfaceExtends(generator, node) {
    generator.print(node.id, node);
    generator.print(node.typeParameters, node);
  }

  // romejs/js-generator/src/generators/flow/FlowGenericTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowGenericTypeAnnotation_ts = {
    FlowGenericTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowGenericTypeAnnotation_ts$FlowGenericTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowGenericTypeAnnotation_ts$FlowGenericTypeAnnotation(generator, node) {
    ___$romejs$js_generator$src$generators$flow$FlowInterfaceExtends_ts$FlowInterfaceExtends(generator, node);
  }

  // romejs/js-generator/src/generators/flow/FlowDeclareInterface.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclareInterface_ts = {
    FlowDeclareInterface: ___$romejs$js_generator$src$generators$flow$FlowDeclareInterface_ts$FlowDeclareInterface};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclareInterface_ts$FlowDeclareInterface(generator, node) {
    generator.word('declare');
    generator.space();
    ___$romejs$js_generator$src$generators$flow$FlowInterfaceDeclaration_ts$FlowInterfaceDeclaration(generator, node);
  }

  // romejs/js-generator/src/generators/flow/FlowClassImplements.ts

  const ___$romejs$js_generator$src$generators$flow$FlowClassImplements_ts = {
    FlowClassImplements: ___$romejs$js_generator$src$generators$flow$FlowClassImplements_ts$FlowClassImplements};
  function ___$romejs$js_generator$src$generators$flow$FlowClassImplements_ts$FlowClassImplements(generator, node) {
    ___$romejs$js_generator$src$generators$flow$FlowInterfaceExtends_ts$FlowInterfaceExtends(generator, node);
  }

  // romejs/js-generator/src/generators/flow/FlowTypeAlias.ts

  const ___$romejs$js_generator$src$generators$flow$FlowTypeAlias_ts = {
    FlowTypeAlias: ___$romejs$js_generator$src$generators$flow$FlowTypeAlias_ts$FlowTypeAlias};
  function ___$romejs$js_generator$src$generators$flow$FlowTypeAlias_ts$FlowTypeAlias(generator, node) {
    generator.word('type');
    generator.space();
    generator.print(node.id, node);
    generator.print(node.typeParameters, node);
    generator.space();
    generator.token('=');
    generator.space();
    generator.print(node.right, node);
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/flow/FlowThisTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowThisTypeAnnotation_ts = {
    FlowThisTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowThisTypeAnnotation_ts$FlowThisTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowThisTypeAnnotation_ts$FlowThisTypeAnnotation(generator) {
    generator.word('this');
  }

  // romejs/js-generator/src/generators/flow/FlowDeclareModuleExports.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclareModuleExports_ts = {
    FlowDeclareModuleExports: ___$romejs$js_generator$src$generators$flow$FlowDeclareModuleExports_ts$FlowDeclareModuleExports};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclareModuleExports_ts$FlowDeclareModuleExports(generator, node) {
    generator.word('declare');
    generator.space();
    generator.word('module');
    generator.token('.');
    generator.word('exports');
    generator.print(node.typeAnnotation, node);
  }

  // romejs/js-generator/src/generators/flow/FlowVoidTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowVoidTypeAnnotation_ts = {
    FlowVoidTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowVoidTypeAnnotation_ts$FlowVoidTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowVoidTypeAnnotation_ts$FlowVoidTypeAnnotation(generator) {
    generator.word('void');
  }

  // romejs/js-generator/src/generators/flow/FlowDeclareFunction.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclareFunction_ts = {
    FlowDeclareFunction: ___$romejs$js_generator$src$generators$flow$FlowDeclareFunction_ts$FlowDeclareFunction};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclareFunction_ts$FlowDeclareFunction(generator, node, parent) {
    if (parent.type !== 'FlowDeclareExportDeclaration') {
      generator.word('declare');
      generator.space();
    }
    generator.word('function');
    generator.space();

    const {id: id} = node;
    generator.print(id, node);
    if (id.typeAnnotation !== undefined) {
      generator.print(id.typeAnnotation.typeAnnotation, node);
    }

    generator.semicolon();
  }

  // romejs/js-generator/src/generators/flow/FlowTypeParameterInstantiation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowTypeParameterInstantiation_ts = {
    FlowTypeParameterInstantiation: ___$romejs$js_generator$src$generators$flow$FlowTypeParameterInstantiation_ts$FlowTypeParameterInstantiation};
  function ___$romejs$js_generator$src$generators$flow$FlowTypeParameterInstantiation_ts$FlowTypeParameterInstantiation(generator, node) {
    generator.token('<');
    generator.printCommaList(node.params, node);
    generator.token('>');
  }

  // romejs/js-generator/src/generators/flow/FlowDeclareModule.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclareModule_ts = {
    FlowDeclareModule: ___$romejs$js_generator$src$generators$flow$FlowDeclareModule_ts$FlowDeclareModule};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclareModule_ts$FlowDeclareModule(generator, node) {
    generator.word('declare');
    generator.space();
    generator.word('module');
    generator.space();
    generator.print(node.id, node);
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/src/generators/flow/FlowObjectTypeCallProperty.ts

  const ___$romejs$js_generator$src$generators$flow$FlowObjectTypeCallProperty_ts = {
    FlowObjectTypeCallProperty: ___$romejs$js_generator$src$generators$flow$FlowObjectTypeCallProperty_ts$FlowObjectTypeCallProperty};
  function ___$romejs$js_generator$src$generators$flow$FlowObjectTypeCallProperty_ts$FlowObjectTypeCallProperty(generator, node) {
    if (node.static === true) {
      generator.word('static');
      generator.space();
    }
    generator.print(node.value, node);
  }

  // romejs/js-generator/src/generators/flow/FlowVariance.ts

  const ___$romejs$js_generator$src$generators$flow$FlowVariance_ts = {
    FlowVariance: ___$romejs$js_generator$src$generators$flow$FlowVariance_ts$FlowVariance};
  function ___$romejs$js_generator$src$generators$flow$FlowVariance_ts$FlowVariance(generator, node) {
    if (node.kind === 'plus') {
      generator.token('+');
    } else if (node.kind === 'minus') {
      generator.token('-');
    }
  }

  // romejs/js-generator/src/generators/flow/FlowNullLiteralTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowNullLiteralTypeAnnotation_ts = {
    FlowNullLiteralTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowNullLiteralTypeAnnotation_ts$FlowNullLiteralTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowNullLiteralTypeAnnotation_ts$FlowNullLiteralTypeAnnotation(generator) {
    generator.word('null');
  }

  // romejs/js-generator/src/generators/flow/FlowTupleTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowTupleTypeAnnotation_ts = {
    FlowTupleTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowTupleTypeAnnotation_ts$FlowTupleTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowTupleTypeAnnotation_ts$FlowTupleTypeAnnotation(generator, node) {
    generator.token('[');
    generator.printCommaList(node.types, node);
    generator.token(']');
  }

  // romejs/js-generator/src/generators/flow/FlowDeclaredPredicate.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclaredPredicate_ts = {
    FlowDeclaredPredicate: ___$romejs$js_generator$src$generators$flow$FlowDeclaredPredicate_ts$FlowDeclaredPredicate};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclaredPredicate_ts$FlowDeclaredPredicate(generator, node) {
    generator.token('%checks');
    generator.space();
    generator.print(node.value, node);
  }

  // romejs/js-generator/src/generators/flow/FlowTypeParameter.ts

  const ___$romejs$js_generator$src$generators$flow$FlowTypeParameter_ts = {
    FlowTypeParameter: ___$romejs$js_generator$src$generators$flow$FlowTypeParameter_ts$FlowTypeParameter};
  function ___$romejs$js_generator$src$generators$flow$FlowTypeParameter_ts$FlowTypeParameter(generator, node) {
    generator.print(node.variance, node);
    generator.word(node.name);

    if (node.bound) {
      generator.print(node.bound, node);
    }

    if (node.default) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.default, node);
    }
  }

  // romejs/js-generator/src/generators/flow/FlowTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowTypeAnnotation_ts = {
    FlowTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowTypeAnnotation_ts$FlowTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowTypeAnnotation_ts$FlowTypeAnnotation(generator, node) {
    generator.token(':');
    generator.space();
    generator.print(node.typeAnnotation, node);
  }

  // romejs/js-generator/src/generators/flow/FlowOpaqueType.ts

  const ___$romejs$js_generator$src$generators$flow$FlowOpaqueType_ts = {
    FlowOpaqueType: ___$romejs$js_generator$src$generators$flow$FlowOpaqueType_ts$FlowOpaqueType};
  function ___$romejs$js_generator$src$generators$flow$FlowOpaqueType_ts$FlowOpaqueType(generator, node) {
    generator.word('opaque');
    generator.space();
    generator.word('type');
    generator.space();
    generator.print(node.id, node);
    generator.print(node.typeParameters, node);
    if (node.supertype) {
      generator.token(':');
      generator.space();
      generator.print(node.supertype, node);
    }
    if (node.impltype) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.impltype, node);
    }
    generator.semicolon();
  }

  // romejs/js-generator/src/generators/flow/FlowArrayTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowArrayTypeAnnotation_ts = {
    FlowArrayTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowArrayTypeAnnotation_ts$FlowArrayTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowArrayTypeAnnotation_ts$FlowArrayTypeAnnotation(generator, node) {
    generator.print(node.elementType, node);
    generator.token('[');
    generator.token(']');
  }

  // romejs/js-generator/src/generators/flow/FlowStringLiteralTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowStringLiteralTypeAnnotation_ts = {
    FlowStringLiteralTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowStringLiteralTypeAnnotation_ts$FlowStringLiteralTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowStringLiteralTypeAnnotation_ts$FlowStringLiteralTypeAnnotation(generator, node, parent) {
    ___$romejs$js_generator$src$generators$core$StringLiteral_ts$StringLiteral(generator, node, parent);
  }

  // romejs/js-generator/src/generators/flow/FlowObjectTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowObjectTypeAnnotation_ts = {
    FlowObjectTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowObjectTypeAnnotation_ts$FlowObjectTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowObjectTypeAnnotation_ts$FlowObjectTypeAnnotation(generator, node) {
    if (node.exact === true) {
      generator.token('');
    } else {
      generator.token('{');
    }

    const props = node.properties;
    if (props.length) {
      generator.space();

      generator.printJoin(props, node, {
        indent: true,
        iterator: () => {
          if (props.length !== 1) {
            generator.token(',');
            generator.space();
          }
        },
        statement: ___$romejs$js_generator$src$node$index_ts$isMultiLine(node)});

      generator.space();
    }

    if (node.exact === true) {
      generator.token('|}');
    } else {
      generator.token('}');
    }
  }

  // romejs/js-generator/src/generators/flow/FlowTypeParameterDeclaration.ts

  const ___$romejs$js_generator$src$generators$flow$FlowTypeParameterDeclaration_ts = {
    FlowTypeParameterDeclaration: ___$romejs$js_generator$src$generators$flow$FlowTypeParameterDeclaration_ts$FlowTypeParameterDeclaration};
  function ___$romejs$js_generator$src$generators$flow$FlowTypeParameterDeclaration_ts$FlowTypeParameterDeclaration(generator, node) {
    ___$romejs$js_generator$src$generators$flow$FlowTypeParameterInstantiation_ts$FlowTypeParameterInstantiation(generator, node);
  }

  // romejs/js-generator/src/generators/flow/FlowEmptyTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowEmptyTypeAnnotation_ts = {
    FlowEmptyTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowEmptyTypeAnnotation_ts$FlowEmptyTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowEmptyTypeAnnotation_ts$FlowEmptyTypeAnnotation(generator) {
    generator.word('empty');
  }

  // romejs/js-generator/src/generators/flow/FlowInferredPredicate.ts

  const ___$romejs$js_generator$src$generators$flow$FlowInferredPredicate_ts = {
    FlowInferredPredicate: ___$romejs$js_generator$src$generators$flow$FlowInferredPredicate_ts$FlowInferredPredicate};
  function ___$romejs$js_generator$src$generators$flow$FlowInferredPredicate_ts$FlowInferredPredicate(generator) {
    generator.token('%checks');
  }

  // romejs/js-generator/src/generators/flow/FlowDeclareExportDeclaration.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclareExportDeclaration_ts = {
    FlowDeclareExportDeclaration: ___$romejs$js_generator$src$generators$flow$FlowDeclareExportDeclaration_ts$FlowDeclareExportDeclaration};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclareExportDeclaration_ts$FlowDeclareExportDeclaration(generator, node) {
    generator.word('declare');
    generator.space();
    generator.word('export');
    generator.space();

    if (node.default === true) {
      generator.word('default');
      generator.space();
    }

    if (node.declaration) {
      const declar = node.declaration;
      generator.print(declar, node);
      if (!___$romejs$js_ast_utils$src$isStatement_ts$default(declar)) {
        generator.semicolon();
      }
    } else {
      generator.token('{');
      if (node.specifiers !== undefined && node.specifiers.length > 0) {
        generator.space();
        generator.printCommaList(node.specifiers, node);
        generator.space();
      }
      generator.token('}');

      if (node.source) {
        generator.space();
        generator.word('from');
        generator.space();
        generator.print(node.source, node);
      }

      generator.semicolon();
    }
  }

  // romejs/js-generator/src/generators/flow/FlowExistsTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowExistsTypeAnnotation_ts = {
    FlowExistsTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowExistsTypeAnnotation_ts$FlowExistsTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowExistsTypeAnnotation_ts$FlowExistsTypeAnnotation(generator) {
    generator.token('*');
  }

  // romejs/js-generator/src/generators/flow/FlowStringTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowStringTypeAnnotation_ts = {
    FlowStringTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowStringTypeAnnotation_ts$FlowStringTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowStringTypeAnnotation_ts$FlowStringTypeAnnotation(generator) {
    generator.word('string');
  }

  // romejs/js-generator/src/generators/flow/FlowBigIntTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowBigIntTypeAnnotation_ts = {
    FlowBigIntTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowBigIntTypeAnnotation_ts$FlowBigIntTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowBigIntTypeAnnotation_ts$FlowBigIntTypeAnnotation(generator) {
    generator.word('bigint');
  }

  // romejs/js-generator/src/generators/flow/FlowInterface.ts

  const ___$romejs$js_generator$src$generators$flow$FlowInterface_ts = {
    FlowInterface: ___$romejs$js_generator$src$generators$flow$FlowInterface_ts$FlowInterface};
  function ___$romejs$js_generator$src$generators$flow$FlowInterface_ts$FlowInterface() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/flow/FlowUnionTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowUnionTypeAnnotation_ts = {
    FlowUnionTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowUnionTypeAnnotation_ts$FlowUnionTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowUnionTypeAnnotation_ts$FlowUnionTypeAnnotation(generator, node) {
    generator.printJoin(node.types, node, {separator: ___$$priv$romejs$js_generator$src$generators$flow$FlowUnionTypeAnnotation_ts$orSeparator});
  }

  function ___$$priv$romejs$js_generator$src$generators$flow$FlowUnionTypeAnnotation_ts$orSeparator(generator) {
    generator.space();
    generator.token('|');
    generator.space();
  }

  // romejs/js-generator/src/generators/flow/FlowObjectTypeSpreadProperty.ts

  const ___$romejs$js_generator$src$generators$flow$FlowObjectTypeSpreadProperty_ts = {
    FlowObjectTypeSpreadProperty: ___$romejs$js_generator$src$generators$flow$FlowObjectTypeSpreadProperty_ts$FlowObjectTypeSpreadProperty};
  function ___$romejs$js_generator$src$generators$flow$FlowObjectTypeSpreadProperty_ts$FlowObjectTypeSpreadProperty(generator, node) {
    generator.token('...');
    generator.print(node.argument, node);
  }

  // romejs/js-generator/src/generators/flow/FlowMixedTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowMixedTypeAnnotation_ts = {
    FlowMixedTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowMixedTypeAnnotation_ts$FlowMixedTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowMixedTypeAnnotation_ts$FlowMixedTypeAnnotation(generator) {
    generator.word('mixed');
  }

  // romejs/js-generator/src/generators/flow/FlowNumericLiteral.ts

  const ___$romejs$js_generator$src$generators$flow$FlowNumericLiteral_ts = {
    FlowNumericLiteral: ___$romejs$js_generator$src$generators$flow$FlowNumericLiteral_ts$FlowNumericLiteral};
  function ___$romejs$js_generator$src$generators$flow$FlowNumericLiteral_ts$FlowNumericLiteral() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/flow/FlowTypeofTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowTypeofTypeAnnotation_ts = {
    FlowTypeofTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowTypeofTypeAnnotation_ts$FlowTypeofTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowTypeofTypeAnnotation_ts$FlowTypeofTypeAnnotation(generator, node) {
    generator.word('typeof');
    generator.space();
    generator.print(node.argument, node);
  }

  // romejs/js-generator/src/generators/flow/FlowTypeCastExpression.ts

  const ___$romejs$js_generator$src$generators$flow$FlowTypeCastExpression_ts = {
    FlowTypeCastExpression: ___$romejs$js_generator$src$generators$flow$FlowTypeCastExpression_ts$FlowTypeCastExpression};
  function ___$romejs$js_generator$src$generators$flow$FlowTypeCastExpression_ts$FlowTypeCastExpression(generator, node) {
    generator.token('(');
    generator.print(node.expression, node);
    generator.print(node.typeAnnotation, node);
    generator.token(')');
  }

  // romejs/js-generator/src/generators/flow/FlowBooleanLiteralTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowBooleanLiteralTypeAnnotation_ts = {
    FlowBooleanLiteralTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowBooleanLiteralTypeAnnotation_ts$FlowBooleanLiteralTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowBooleanLiteralTypeAnnotation_ts$FlowBooleanLiteralTypeAnnotation(generator, node) {
    generator.word(node.value ? 'true' : 'false');
  }

  // romejs/js-generator/src/generators/flow/FlowObjectTypeIndexer.ts

  const ___$romejs$js_generator$src$generators$flow$FlowObjectTypeIndexer_ts = {
    FlowObjectTypeIndexer: ___$romejs$js_generator$src$generators$flow$FlowObjectTypeIndexer_ts$FlowObjectTypeIndexer};
  function ___$romejs$js_generator$src$generators$flow$FlowObjectTypeIndexer_ts$FlowObjectTypeIndexer(generator, node) {
    if (node.static === true) {
      generator.word('static');
      generator.space();
    }
    generator.print(node.variance, node);
    generator.token('[');
    generator.print(node.id, node);
    generator.token(':');
    generator.space();
    generator.print(node.key, node);
    generator.token(']');
    generator.token(':');
    generator.space();
    generator.print(node.value, node);
  }

  // romejs/js-generator/src/generators/flow/FlowFunctionTypeParam.ts

  const ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeParam_ts = {
    FlowFunctionTypeParam: ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeParam_ts$FlowFunctionTypeParam};
  function ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeParam_ts$FlowFunctionTypeParam(generator, node) {
    if (node.name) {
      generator.print(node.name, node);
      if (node.optional === true) {
        generator.token('?');
      }
      generator.token(':');
      generator.space();
    }
    generator.print(node.typeAnnotation, node);
  }

  // romejs/js-generator/src/generators/flow/FlowFunctionTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeAnnotation_ts = {
    FlowFunctionTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeAnnotation_ts$FlowFunctionTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeAnnotation_ts$FlowFunctionTypeAnnotation(generator, node, parent) {
    generator.print(node.typeParameters, node);
    generator.token('(');
    generator.printCommaList(node.params, node);
    generator.token(')');

    if (parent.type === 'FlowObjectTypeCallProperty' ||
    parent.type === 'FlowDeclareFunction') {
      generator.token(':');
    } else {
      generator.space();
      generator.token('=>');
    }

    generator.space();
    generator.print(node.returnType, node);
  }

  // romejs/js-generator/src/generators/flow/FlowDeclareTypeAlias.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclareTypeAlias_ts = {
    FlowDeclareTypeAlias: ___$romejs$js_generator$src$generators$flow$FlowDeclareTypeAlias_ts$FlowDeclareTypeAlias};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclareTypeAlias_ts$FlowDeclareTypeAlias(generator, node) {
    generator.word('declare');
    generator.space();
    ___$romejs$js_generator$src$generators$flow$FlowTypeAlias_ts$FlowTypeAlias(generator, node);
  }

  // romejs/js-generator/src/generators/flow/FlowObjectTypeProperty.ts

  const ___$romejs$js_generator$src$generators$flow$FlowObjectTypeProperty_ts = {
    FlowObjectTypeProperty: ___$romejs$js_generator$src$generators$flow$FlowObjectTypeProperty_ts$FlowObjectTypeProperty};
  function ___$romejs$js_generator$src$generators$flow$FlowObjectTypeProperty_ts$FlowObjectTypeProperty(generator, node) {
    if (node.static === true) {
      generator.word('static');
      generator.space();
    }
    generator.print(node.variance, node);
    generator.print(node.key, node);
    if (node.optional === true) {
      generator.token('?');
    }
    generator.token(':');
    generator.space();
    generator.print(node.value, node);
  }

  // romejs/js-generator/src/generators/flow/FlowNumberTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowNumberTypeAnnotation_ts = {
    FlowNumberTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowNumberTypeAnnotation_ts$FlowNumberTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowNumberTypeAnnotation_ts$FlowNumberTypeAnnotation(generator) {
    generator.word('number');
  }

  // romejs/js-generator/src/generators/flow/FlowDeclareOpaqueType.ts

  const ___$romejs$js_generator$src$generators$flow$FlowDeclareOpaqueType_ts = {
    FlowDeclareOpaqueType: ___$romejs$js_generator$src$generators$flow$FlowDeclareOpaqueType_ts$FlowDeclareOpaqueType};
  function ___$romejs$js_generator$src$generators$flow$FlowDeclareOpaqueType_ts$FlowDeclareOpaqueType(generator, node) {
    generator.word('declare');
    generator.word('opaque');
    generator.word('type');
    generator.print(node.id, node);
  }

  // romejs/js-generator/src/generators/flow/FlowInterfaceTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$flow$FlowInterfaceTypeAnnotation_ts = {
    FlowInterfaceTypeAnnotation: ___$romejs$js_generator$src$generators$flow$FlowInterfaceTypeAnnotation_ts$FlowInterfaceTypeAnnotation};
  function ___$romejs$js_generator$src$generators$flow$FlowInterfaceTypeAnnotation_ts$FlowInterfaceTypeAnnotation() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/flow/FlowObjectTypeInternalSlot.ts

  const ___$romejs$js_generator$src$generators$flow$FlowObjectTypeInternalSlot_ts = {
    FlowObjectTypeInternalSlot: ___$romejs$js_generator$src$generators$flow$FlowObjectTypeInternalSlot_ts$FlowObjectTypeInternalSlot};
  function ___$romejs$js_generator$src$generators$flow$FlowObjectTypeInternalSlot_ts$FlowObjectTypeInternalSlot() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/flow/FlowFunctionTypeParamRest.ts

  const ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeParamRest_ts = {
    FlowFunctionTypeParamRest: ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeParamRest_ts$FlowFunctionTypeParamRest};
  function ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeParamRest_ts$FlowFunctionTypeParamRest(generator, node) {
    generator.token('...');
    generator.print(node.param, node);
  }

  // romejs/js-generator/src/generators/typescript/TSUnknownKeyword.ts

  const ___$romejs$js_generator$src$generators$typescript$TSUnknownKeyword_ts = {
    TSUnknownKeyword: ___$romejs$js_generator$src$generators$typescript$TSUnknownKeyword_ts$TSUnknownKeyword};
  function ___$romejs$js_generator$src$generators$typescript$TSUnknownKeyword_ts$TSUnknownKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSImportType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSImportType_ts = {
    TSImportType: ___$romejs$js_generator$src$generators$typescript$TSImportType_ts$TSImportType};
  function ___$romejs$js_generator$src$generators$typescript$TSImportType_ts$TSImportType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSQualifiedName.ts

  const ___$romejs$js_generator$src$generators$typescript$TSQualifiedName_ts = {
    TSQualifiedName: ___$romejs$js_generator$src$generators$typescript$TSQualifiedName_ts$TSQualifiedName};
  function ___$romejs$js_generator$src$generators$typescript$TSQualifiedName_ts$TSQualifiedName(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypeReference.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypeReference_ts = {
    TSTypeReference: ___$romejs$js_generator$src$generators$typescript$TSTypeReference_ts$TSTypeReference};
  function ___$romejs$js_generator$src$generators$typescript$TSTypeReference_ts$TSTypeReference(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypePredicate.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypePredicate_ts = {
    TSTypePredicate: ___$romejs$js_generator$src$generators$typescript$TSTypePredicate_ts$TSTypePredicate};
  function ___$romejs$js_generator$src$generators$typescript$TSTypePredicate_ts$TSTypePredicate(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSThisType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSThisType_ts = {
    TSThisType: ___$romejs$js_generator$src$generators$typescript$TSThisType_ts$TSThisType};
  function ___$romejs$js_generator$src$generators$typescript$TSThisType_ts$TSThisType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypeQuery.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypeQuery_ts = {
    TSTypeQuery: ___$romejs$js_generator$src$generators$typescript$TSTypeQuery_ts$TSTypeQuery};
  function ___$romejs$js_generator$src$generators$typescript$TSTypeQuery_ts$TSTypeQuery(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypeParameter.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypeParameter_ts = {
    TSTypeParameter: ___$romejs$js_generator$src$generators$typescript$TSTypeParameter_ts$TSTypeParameter};
  function ___$romejs$js_generator$src$generators$typescript$TSTypeParameter_ts$TSTypeParameter(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypeParameterDeclaration.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypeParameterDeclaration_ts = {
    TSTypeParameterDeclaration: ___$romejs$js_generator$src$generators$typescript$TSTypeParameterDeclaration_ts$TSTypeParameterDeclaration};
  function ___$romejs$js_generator$src$generators$typescript$TSTypeParameterDeclaration_ts$TSTypeParameterDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSIndexSignature.ts

  const ___$romejs$js_generator$src$generators$typescript$TSIndexSignature_ts = {
    TSIndexSignature: ___$romejs$js_generator$src$generators$typescript$TSIndexSignature_ts$TSIndexSignature};
  function ___$romejs$js_generator$src$generators$typescript$TSIndexSignature_ts$TSIndexSignature(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSMethodSignature.ts

  const ___$romejs$js_generator$src$generators$typescript$TSMethodSignature_ts = {
    TSMethodSignature: ___$romejs$js_generator$src$generators$typescript$TSMethodSignature_ts$TSMethodSignature};
  function ___$romejs$js_generator$src$generators$typescript$TSMethodSignature_ts$TSMethodSignature(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSPropertySignature.ts

  const ___$romejs$js_generator$src$generators$typescript$TSPropertySignature_ts = {
    TSPropertySignature: ___$romejs$js_generator$src$generators$typescript$TSPropertySignature_ts$TSPropertySignature};
  function ___$romejs$js_generator$src$generators$typescript$TSPropertySignature_ts$TSPropertySignature(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypeLiteral.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypeLiteral_ts = {
    TSTypeLiteral: ___$romejs$js_generator$src$generators$typescript$TSTypeLiteral_ts$TSTypeLiteral};
  function ___$romejs$js_generator$src$generators$typescript$TSTypeLiteral_ts$TSTypeLiteral(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSMappedType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSMappedType_ts = {
    TSMappedType: ___$romejs$js_generator$src$generators$typescript$TSMappedType_ts$TSMappedType};
  function ___$romejs$js_generator$src$generators$typescript$TSMappedType_ts$TSMappedType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTupleType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTupleType_ts = {
    TSTupleType: ___$romejs$js_generator$src$generators$typescript$TSTupleType_ts$TSTupleType};
  function ___$romejs$js_generator$src$generators$typescript$TSTupleType_ts$TSTupleType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSRestType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSRestType_ts = {
    TSRestType: ___$romejs$js_generator$src$generators$typescript$TSRestType_ts$TSRestType};
  function ___$romejs$js_generator$src$generators$typescript$TSRestType_ts$TSRestType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSOptionalType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSOptionalType_ts = {
    TSOptionalType: ___$romejs$js_generator$src$generators$typescript$TSOptionalType_ts$TSOptionalType};
  function ___$romejs$js_generator$src$generators$typescript$TSOptionalType_ts$TSOptionalType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSParenthesizedType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSParenthesizedType_ts = {
    TSParenthesizedType: ___$romejs$js_generator$src$generators$typescript$TSParenthesizedType_ts$TSParenthesizedType};
  function ___$romejs$js_generator$src$generators$typescript$TSParenthesizedType_ts$TSParenthesizedType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSFunctionType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSFunctionType_ts = {
    TSFunctionType: ___$romejs$js_generator$src$generators$typescript$TSFunctionType_ts$TSFunctionType};
  function ___$romejs$js_generator$src$generators$typescript$TSFunctionType_ts$TSFunctionType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSConstructorType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSConstructorType_ts = {
    TSConstructorType: ___$romejs$js_generator$src$generators$typescript$TSConstructorType_ts$TSConstructorType};
  function ___$romejs$js_generator$src$generators$typescript$TSConstructorType_ts$TSConstructorType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSLiteralType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSLiteralType_ts = {
    TSLiteralType: ___$romejs$js_generator$src$generators$typescript$TSLiteralType_ts$TSLiteralType};
  function ___$romejs$js_generator$src$generators$typescript$TSLiteralType_ts$TSLiteralType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSArrayType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSArrayType_ts = {
    TSArrayType: ___$romejs$js_generator$src$generators$typescript$TSArrayType_ts$TSArrayType};
  function ___$romejs$js_generator$src$generators$typescript$TSArrayType_ts$TSArrayType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSIndexedAccessType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSIndexedAccessType_ts = {
    TSIndexedAccessType: ___$romejs$js_generator$src$generators$typescript$TSIndexedAccessType_ts$TSIndexedAccessType};
  function ___$romejs$js_generator$src$generators$typescript$TSIndexedAccessType_ts$TSIndexedAccessType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypeOperator.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypeOperator_ts = {
    TSTypeOperator: ___$romejs$js_generator$src$generators$typescript$TSTypeOperator_ts$TSTypeOperator};
  function ___$romejs$js_generator$src$generators$typescript$TSTypeOperator_ts$TSTypeOperator(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSInferType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSInferType_ts = {
    TSInferType: ___$romejs$js_generator$src$generators$typescript$TSInferType_ts$TSInferType};
  function ___$romejs$js_generator$src$generators$typescript$TSInferType_ts$TSInferType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypeAnnotation.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypeAnnotation_ts = {
    TSTypeAnnotation: ___$romejs$js_generator$src$generators$typescript$TSTypeAnnotation_ts$TSTypeAnnotation};
  function ___$romejs$js_generator$src$generators$typescript$TSTypeAnnotation_ts$TSTypeAnnotation(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSConditionalType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSConditionalType_ts = {
    TSConditionalType: ___$romejs$js_generator$src$generators$typescript$TSConditionalType_ts$TSConditionalType};
  function ___$romejs$js_generator$src$generators$typescript$TSConditionalType_ts$TSConditionalType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypeAssertion.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypeAssertion_ts = {
    TSTypeAssertion: ___$romejs$js_generator$src$generators$typescript$TSTypeAssertion_ts$TSTypeAssertion};
  function ___$romejs$js_generator$src$generators$typescript$TSTypeAssertion_ts$TSTypeAssertion(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSExpressionWithTypeArguments.ts

  const ___$romejs$js_generator$src$generators$typescript$TSExpressionWithTypeArguments_ts = {
    TSExpressionWithTypeArguments: ___$romejs$js_generator$src$generators$typescript$TSExpressionWithTypeArguments_ts$TSExpressionWithTypeArguments};
  function ___$romejs$js_generator$src$generators$typescript$TSExpressionWithTypeArguments_ts$TSExpressionWithTypeArguments(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSInterfaceBody.ts

  const ___$romejs$js_generator$src$generators$typescript$TSInterfaceBody_ts = {
    TSInterfaceBody: ___$romejs$js_generator$src$generators$typescript$TSInterfaceBody_ts$TSInterfaceBody};
  function ___$romejs$js_generator$src$generators$typescript$TSInterfaceBody_ts$TSInterfaceBody(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSInterfaceDeclaration.ts

  const ___$romejs$js_generator$src$generators$typescript$TSInterfaceDeclaration_ts = {
    TSInterfaceDeclaration: ___$romejs$js_generator$src$generators$typescript$TSInterfaceDeclaration_ts$TSInterfaceDeclaration};
  function ___$romejs$js_generator$src$generators$typescript$TSInterfaceDeclaration_ts$TSInterfaceDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypeAliasDeclaration.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypeAliasDeclaration_ts = {
    TSTypeAliasDeclaration: ___$romejs$js_generator$src$generators$typescript$TSTypeAliasDeclaration_ts$TSTypeAliasDeclaration};
  function ___$romejs$js_generator$src$generators$typescript$TSTypeAliasDeclaration_ts$TSTypeAliasDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSEnumMember.ts

  const ___$romejs$js_generator$src$generators$typescript$TSEnumMember_ts = {
    TSEnumMember: ___$romejs$js_generator$src$generators$typescript$TSEnumMember_ts$TSEnumMember};
  function ___$romejs$js_generator$src$generators$typescript$TSEnumMember_ts$TSEnumMember(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSEnumDeclaration.ts

  const ___$romejs$js_generator$src$generators$typescript$TSEnumDeclaration_ts = {
    TSEnumDeclaration: ___$romejs$js_generator$src$generators$typescript$TSEnumDeclaration_ts$TSEnumDeclaration};
  function ___$romejs$js_generator$src$generators$typescript$TSEnumDeclaration_ts$TSEnumDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSModuleBlock.ts

  const ___$romejs$js_generator$src$generators$typescript$TSModuleBlock_ts = {
    TSModuleBlock: ___$romejs$js_generator$src$generators$typescript$TSModuleBlock_ts$TSModuleBlock};
  function ___$romejs$js_generator$src$generators$typescript$TSModuleBlock_ts$TSModuleBlock(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSModuleDeclaration.ts

  const ___$romejs$js_generator$src$generators$typescript$TSModuleDeclaration_ts = {
    TSModuleDeclaration: ___$romejs$js_generator$src$generators$typescript$TSModuleDeclaration_ts$TSModuleDeclaration};
  function ___$romejs$js_generator$src$generators$typescript$TSModuleDeclaration_ts$TSModuleDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSImportEqualsDeclaration.ts

  const ___$romejs$js_generator$src$generators$typescript$TSImportEqualsDeclaration_ts = {
    TSImportEqualsDeclaration: ___$romejs$js_generator$src$generators$typescript$TSImportEqualsDeclaration_ts$TSImportEqualsDeclaration};
  function ___$romejs$js_generator$src$generators$typescript$TSImportEqualsDeclaration_ts$TSImportEqualsDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSExternalModuleReference.ts

  const ___$romejs$js_generator$src$generators$typescript$TSExternalModuleReference_ts = {
    TSExternalModuleReference: ___$romejs$js_generator$src$generators$typescript$TSExternalModuleReference_ts$TSExternalModuleReference};
  function ___$romejs$js_generator$src$generators$typescript$TSExternalModuleReference_ts$TSExternalModuleReference(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSTypeParameterInstantiation.ts

  const ___$romejs$js_generator$src$generators$typescript$TSTypeParameterInstantiation_ts = {
    TSTypeParameterInstantiation: ___$romejs$js_generator$src$generators$typescript$TSTypeParameterInstantiation_ts$TSTypeParameterInstantiation};
  function ___$romejs$js_generator$src$generators$typescript$TSTypeParameterInstantiation_ts$TSTypeParameterInstantiation(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSExportAssignment.ts

  const ___$romejs$js_generator$src$generators$typescript$TSExportAssignment_ts = {
    TSExportAssignment: ___$romejs$js_generator$src$generators$typescript$TSExportAssignment_ts$TSExportAssignment};
  function ___$romejs$js_generator$src$generators$typescript$TSExportAssignment_ts$TSExportAssignment(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSNamespaceExportDeclaration.ts

  const ___$romejs$js_generator$src$generators$typescript$TSNamespaceExportDeclaration_ts = {
    TSNamespaceExportDeclaration: ___$romejs$js_generator$src$generators$typescript$TSNamespaceExportDeclaration_ts$TSNamespaceExportDeclaration};
  function ___$romejs$js_generator$src$generators$typescript$TSNamespaceExportDeclaration_ts$TSNamespaceExportDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSDeclareFunction.ts

  const ___$romejs$js_generator$src$generators$typescript$TSDeclareFunction_ts = {
    TSDeclareFunction: ___$romejs$js_generator$src$generators$typescript$TSDeclareFunction_ts$TSDeclareFunction};
  function ___$romejs$js_generator$src$generators$typescript$TSDeclareFunction_ts$TSDeclareFunction(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSDeclareMethod.ts

  const ___$romejs$js_generator$src$generators$typescript$TSDeclareMethod_ts = {
    TSDeclareMethod: ___$romejs$js_generator$src$generators$typescript$TSDeclareMethod_ts$TSDeclareMethod};
  function ___$romejs$js_generator$src$generators$typescript$TSDeclareMethod_ts$TSDeclareMethod(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSCallSignatureDeclaration.ts

  const ___$romejs$js_generator$src$generators$typescript$TSCallSignatureDeclaration_ts = {
    TSCallSignatureDeclaration: ___$romejs$js_generator$src$generators$typescript$TSCallSignatureDeclaration_ts$TSCallSignatureDeclaration};
  function ___$romejs$js_generator$src$generators$typescript$TSCallSignatureDeclaration_ts$TSCallSignatureDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSConstructSignatureDeclaration.ts

  const ___$romejs$js_generator$src$generators$typescript$TSConstructSignatureDeclaration_ts = {
    TSConstructSignatureDeclaration: ___$romejs$js_generator$src$generators$typescript$TSConstructSignatureDeclaration_ts$TSConstructSignatureDeclaration};
  function ___$romejs$js_generator$src$generators$typescript$TSConstructSignatureDeclaration_ts$TSConstructSignatureDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSAnyKeyword.ts

  const ___$romejs$js_generator$src$generators$typescript$TSAnyKeyword_ts = {
    TSAnyKeyword: ___$romejs$js_generator$src$generators$typescript$TSAnyKeyword_ts$TSAnyKeyword};
  function ___$romejs$js_generator$src$generators$typescript$TSAnyKeyword_ts$TSAnyKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSBooleanKeyword.ts

  const ___$romejs$js_generator$src$generators$typescript$TSBooleanKeyword_ts = {
    TSBooleanKeyword: ___$romejs$js_generator$src$generators$typescript$TSBooleanKeyword_ts$TSBooleanKeyword};
  function ___$romejs$js_generator$src$generators$typescript$TSBooleanKeyword_ts$TSBooleanKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSBigIntKeyword.ts

  const ___$romejs$js_generator$src$generators$typescript$TSBigIntKeyword_ts = {
    TSBigIntKeyword: ___$romejs$js_generator$src$generators$typescript$TSBigIntKeyword_ts$TSBigIntKeyword};
  function ___$romejs$js_generator$src$generators$typescript$TSBigIntKeyword_ts$TSBigIntKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSNeverKeyword.ts

  const ___$romejs$js_generator$src$generators$typescript$TSNeverKeyword_ts = {
    TSNeverKeyword: ___$romejs$js_generator$src$generators$typescript$TSNeverKeyword_ts$TSNeverKeyword};
  function ___$romejs$js_generator$src$generators$typescript$TSNeverKeyword_ts$TSNeverKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSNumberKeyword.ts

  const ___$romejs$js_generator$src$generators$typescript$TSNumberKeyword_ts = {
    TSNumberKeyword: ___$romejs$js_generator$src$generators$typescript$TSNumberKeyword_ts$TSNumberKeyword};
  function ___$romejs$js_generator$src$generators$typescript$TSNumberKeyword_ts$TSNumberKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSObjectKeyword.ts

  const ___$romejs$js_generator$src$generators$typescript$TSObjectKeyword_ts = {
    TSObjectKeyword: ___$romejs$js_generator$src$generators$typescript$TSObjectKeyword_ts$TSObjectKeyword};
  function ___$romejs$js_generator$src$generators$typescript$TSObjectKeyword_ts$TSObjectKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSStringKeyword.ts

  const ___$romejs$js_generator$src$generators$typescript$TSStringKeyword_ts = {
    TSStringKeyword: ___$romejs$js_generator$src$generators$typescript$TSStringKeyword_ts$TSStringKeyword};
  function ___$romejs$js_generator$src$generators$typescript$TSStringKeyword_ts$TSStringKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSSymbolKeyword.ts

  const ___$romejs$js_generator$src$generators$typescript$TSSymbolKeyword_ts = {
    TSSymbolKeyword: ___$romejs$js_generator$src$generators$typescript$TSSymbolKeyword_ts$TSSymbolKeyword};
  function ___$romejs$js_generator$src$generators$typescript$TSSymbolKeyword_ts$TSSymbolKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSUndefinedKeyword.ts

  const ___$romejs$js_generator$src$generators$typescript$TSUndefinedKeyword_ts = {
    TSUndefinedKeyword: ___$romejs$js_generator$src$generators$typescript$TSUndefinedKeyword_ts$TSUndefinedKeyword};
  function ___$romejs$js_generator$src$generators$typescript$TSUndefinedKeyword_ts$TSUndefinedKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/core/Unknown.ts

  const ___$romejs$js_generator$src$generators$core$Unknown_ts = {
    Unknown: ___$romejs$js_generator$src$generators$core$Unknown_ts$Unknown};
  function ___$romejs$js_generator$src$generators$core$Unknown_ts$Unknown(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/core/OptionalMemberExpression.ts

  const ___$romejs$js_generator$src$generators$core$OptionalMemberExpression_ts = {
    OptionalMemberExpression: ___$romejs$js_generator$src$generators$core$OptionalMemberExpression_ts$OptionalMemberExpression};
  function ___$romejs$js_generator$src$generators$core$OptionalMemberExpression_ts$OptionalMemberExpression(generator, node) {
    ___$romejs$js_generator$src$generators$core$MemberExpression_ts$MemberExpression(generator, node);
  }

  // romejs/js-generator/src/generators/core/OptionalCallExpression.ts

  const ___$romejs$js_generator$src$generators$core$OptionalCallExpression_ts = {
    OptionalCallExpression: ___$romejs$js_generator$src$generators$core$OptionalCallExpression_ts$OptionalCallExpression};
  function ___$romejs$js_generator$src$generators$core$OptionalCallExpression_ts$OptionalCallExpression(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSNonNullExpression.ts

  const ___$romejs$js_generator$src$generators$typescript$TSNonNullExpression_ts = {
    TSNonNullExpression: ___$romejs$js_generator$src$generators$typescript$TSNonNullExpression_ts$TSNonNullExpression};
  function ___$romejs$js_generator$src$generators$typescript$TSNonNullExpression_ts$TSNonNullExpression(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSAsExpression.ts

  const ___$romejs$js_generator$src$generators$typescript$TSAsExpression_ts = {
    TSAsExpression: ___$romejs$js_generator$src$generators$typescript$TSAsExpression_ts$TSAsExpression};
  function ___$romejs$js_generator$src$generators$typescript$TSAsExpression_ts$TSAsExpression(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSUnionType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSUnionType_ts = {
    TSUnionType: ___$romejs$js_generator$src$generators$typescript$TSUnionType_ts$TSUnionType};
  function ___$romejs$js_generator$src$generators$typescript$TSUnionType_ts$TSUnionType(node) {
    node;
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/typescript/TSIntersectionType.ts

  const ___$romejs$js_generator$src$generators$typescript$TSIntersectionType_ts = {
    TSIntersectionType: ___$romejs$js_generator$src$generators$typescript$TSIntersectionType_ts$TSIntersectionType};
  function ___$romejs$js_generator$src$generators$typescript$TSIntersectionType_ts$TSIntersectionType(node) {
    node;
    throw new Error('unimplemented');
  }

  // romejs/js-generator/src/generators/index.ts

  const ___$romejs$js_generator$src$generators$index_ts = {};
  Object.keys(___$romejs$js_generator$src$generators$core$LogicalExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$LogicalExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$TryStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$TryStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ObjectMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ObjectMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$SwitchCase_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$SwitchCase_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ExportNamedDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ExportNamedDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$VariableDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$VariableDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ImportDefaultSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ImportDefaultSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ClassPrivateProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ClassPrivateProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$UnaryExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$UnaryExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ObjectExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ObjectExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$FunctionDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$FunctionDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$InterpreterDirective_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$InterpreterDirective_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ClassDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ClassDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$NumericLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$NumericLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ClassMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ClassMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$WhileStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$WhileStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$AssignmentPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$AssignmentPattern_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$DirectiveLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$DirectiveLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$WithStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$WithStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$RestElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$RestElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$AssignmentExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$AssignmentExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$MetaProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$MetaProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$Import_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$Import_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ImportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ImportDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$Program_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$Program_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ForStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ForStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$FunctionExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$FunctionExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$BlockStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$BlockStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ArrayPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ArrayPattern_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ThrowStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ThrowStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$IfStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$IfStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ClassProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ClassProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$AwaitExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$AwaitExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$DebuggerStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$DebuggerStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$CatchClause_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$CatchClause_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$UpdateExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$UpdateExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ClassExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ClassExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ArrowFunctionExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ArrowFunctionExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$NewExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$NewExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ForInStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ForInStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$BinaryExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$BinaryExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ContinueStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ContinueStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$PrivateName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$PrivateName_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$Directive_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$Directive_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$StringLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$StringLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$MemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$MemberExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ExportDefaultSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ExportDefaultSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ThisExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ThisExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ForOfStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ForOfStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$BigIntLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$BigIntLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$BooleanLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$BooleanLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$Identifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$Identifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ExportAllDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ExportAllDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ObjectPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ObjectPattern_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$BreakStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$BreakStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$TemplateElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$TemplateElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$RestProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$RestProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ConditionalExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ConditionalExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$DoExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$DoExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$SwitchStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$SwitchStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$SequenceExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$SequenceExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$TaggedTemplateExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$TaggedTemplateExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$VariableDeclarator_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$VariableDeclarator_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$EmptyStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$EmptyStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$CallExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$CallExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$Super_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$Super_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ImportSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ImportSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ArrayExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ArrayExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ExportSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ExportSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$SpreadProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$SpreadProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ExportDefaultDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ExportDefaultDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ReturnStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ReturnStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ExportNamespaceSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ExportNamespaceSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ImportNamespaceSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ImportNamespaceSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$DoWhileStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$DoWhileStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ClassPrivateMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ClassPrivateMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ExpressionStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ExpressionStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$RegExpLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$RegExpLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$TemplateLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$TemplateLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$LabeledStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$LabeledStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$YieldExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$YieldExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$ObjectProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$ObjectProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$NullLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$NullLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$SpreadElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$SpreadElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXText_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXText_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXEmptyExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXEmptyExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXNamespacedName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXNamespacedName_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXIdentifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXClosingFragment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXClosingFragment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXOpeningFragment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXOpeningFragment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXClosingElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXClosingElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXExpressionContainer_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXExpressionContainer_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXMemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXMemberExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXSpreadChild_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXSpreadChild_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXSpreadAttribute_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXSpreadAttribute_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXOpeningElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXOpeningElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXFragment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXFragment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$jsx$JSXAttribute_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$jsx$JSXAttribute_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowIntersectionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowIntersectionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowAnyTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowAnyTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclareClass_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclareClass_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowNumericLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowNumericLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowQualifiedTypeIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowQualifiedTypeIdentifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclareExportAllDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclareExportAllDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowBooleanTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowBooleanTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowNullableTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowNullableTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclareVariable_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclareVariable_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowGenericTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowGenericTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclareInterface_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclareInterface_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowClassImplements_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowClassImplements_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowTypeAlias_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowTypeAlias_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowThisTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowThisTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclareModuleExports_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclareModuleExports_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowVoidTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowVoidTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclareFunction_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclareFunction_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowTypeParameterInstantiation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowTypeParameterInstantiation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclareModule_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclareModule_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowObjectTypeCallProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowObjectTypeCallProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowVariance_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowVariance_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowNullLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowNullLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowTupleTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowTupleTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclaredPredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclaredPredicate_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowTypeParameter_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowTypeParameter_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowOpaqueType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowOpaqueType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowArrayTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowArrayTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowStringLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowStringLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowObjectTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowObjectTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowTypeParameterDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowTypeParameterDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowInterfaceExtends_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowInterfaceExtends_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowEmptyTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowEmptyTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowInferredPredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowInferredPredicate_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowInterfaceDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowInterfaceDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclareExportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclareExportDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowExistsTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowExistsTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowStringTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowStringTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowBigIntTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowBigIntTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowInterface_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowInterface_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowUnionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowUnionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowObjectTypeSpreadProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowObjectTypeSpreadProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowMixedTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowMixedTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowNumericLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowNumericLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowTypeofTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowTypeofTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowTypeCastExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowTypeCastExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowBooleanLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowBooleanLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowObjectTypeIndexer_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowObjectTypeIndexer_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowFunctionTypeParam_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeParam_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowFunctionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclareTypeAlias_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclareTypeAlias_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowObjectTypeProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowObjectTypeProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowNumberTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowNumberTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowDeclareOpaqueType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowDeclareOpaqueType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowInterfaceTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowInterfaceTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowObjectTypeInternalSlot_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowObjectTypeInternalSlot_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$flow$FlowFunctionTypeParamRest_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$flow$FlowFunctionTypeParamRest_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSUnknownKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSUnknownKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSImportType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSImportType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSQualifiedName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSQualifiedName_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypeReference_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypeReference_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypePredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypePredicate_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSThisType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSThisType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypeQuery_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypeQuery_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypeParameter_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypeParameter_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypeParameterDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypeParameterDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSIndexSignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSIndexSignature_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSMethodSignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSMethodSignature_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSPropertySignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSPropertySignature_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypeLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypeLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSMappedType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSMappedType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTupleType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTupleType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSRestType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSRestType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSOptionalType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSOptionalType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSParenthesizedType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSParenthesizedType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSFunctionType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSFunctionType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSConstructorType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSConstructorType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSLiteralType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSLiteralType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSArrayType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSArrayType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSIndexedAccessType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSIndexedAccessType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypeOperator_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypeOperator_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSInferType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSInferType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSConditionalType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSConditionalType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypeAssertion_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypeAssertion_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSExpressionWithTypeArguments_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSExpressionWithTypeArguments_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSInterfaceBody_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSInterfaceBody_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSInterfaceDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSInterfaceDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypeAliasDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypeAliasDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSEnumMember_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSEnumMember_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSEnumDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSEnumDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSModuleBlock_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSModuleBlock_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSModuleDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSModuleDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSImportEqualsDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSImportEqualsDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSExternalModuleReference_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSExternalModuleReference_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSTypeParameterInstantiation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSTypeParameterInstantiation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSExportAssignment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSExportAssignment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSNamespaceExportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSNamespaceExportDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSDeclareFunction_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSDeclareFunction_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSDeclareMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSDeclareMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSCallSignatureDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSCallSignatureDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSConstructSignatureDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSConstructSignatureDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSAnyKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSAnyKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSBooleanKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSBooleanKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSBigIntKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSBigIntKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSNeverKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSNeverKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSNumberKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSNumberKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSObjectKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSObjectKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSStringKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSStringKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSSymbolKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSSymbolKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSUndefinedKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSUndefinedKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$Unknown_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$Unknown_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$OptionalMemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$OptionalMemberExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$core$OptionalCallExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$core$OptionalCallExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSNonNullExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSNonNullExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSAsExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSAsExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSUnionType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSUnionType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_generator$src$generators$typescript$TSIntersectionType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_generator$src$generators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_generator$src$generators$typescript$TSIntersectionType_ts[key];
      }});
  });

  // romejs/js-generator/src/Buffer.ts

  const ___$$priv$romejs$js_generator$src$Buffer_ts$SPACES_RE = /^[ \t]+$/;

  class ___$romejs$js_generator$src$Buffer_ts$default {
    constructor(opts, code) {
      this.originalCode = code;
      this.opts = opts;
      this.mappings = [];

      this.buf = [];
      this.last = '';
      this._queue = [];

      this.position = {
        index: -1,
        column: 0,
        line: 1};

      this.sourcePosition = {
        column: undefined,
        filename: undefined,
        identifierName: undefined,
        line: undefined};
    }

    getSourceMap() {
      const {opts: opts} = this;

      const map = new ___$romejs$codec_source_map$src$SourceMapGenerator_ts$default({
        file: opts.sourceMapTarget,
        sourceRoot: opts.sourceRoot});

      if (opts.sourceFileName !== undefined) {
        map.setSourceContent(opts.sourceFileName, this.originalCode);
      }

      for (const mapping of this.mappings) {
        map.addMapping(mapping);
      }

      return map.toJSON();
    }

    getMappings() {
      return this.mappings.slice();
    }

    mark(generatedLine, generatedColumn, originalLine, originalColumn, identifierName, filename = this.opts.sourceFileName) {
      if (originalLine === undefined || originalColumn === undefined) {
        return undefined;
      }

      if (this.lastGenLine === generatedLine &&
      this.lastSourceLine === originalLine &&
      this.lastSourceColumn === originalColumn) {
        return undefined;
      }

      this.lastGenLine = generatedLine;
      this.lastSourceLine = originalLine;
      this.lastSourceColumn = originalColumn;

      const name = identifierName === undefined ? undefined : identifierName;
      const source = filename;

      this.mappings.push({
        generatedLine: generatedLine,
        generatedColumn: generatedColumn,
        originalLine: originalLine,
        originalColumn: originalColumn,
        name: name,
        source: source});
    }

    getCode() {
      this.flush();
      return this.buf.join('').trimRight();
    }

    append(str) {
      this.flush();
      const {column: column, filename: filename, identifierName: identifierName, line: line} = this.sourcePosition;
      this._append(str, line, column, identifierName, filename);
    }

    queue(str) {
      if (str === '\n') {
        while (this._queue.length > 0 && ___$$priv$romejs$js_generator$src$Buffer_ts$SPACES_RE.test(this._queue[0][0])) {
          this._queue.shift();
        }
      }

      const {column: column, filename: filename, identifierName: identifierName, line: line} = this.sourcePosition;
      this._queue.unshift([str, line, column, identifierName, filename]);
    }

    flush() {
      let item;
      while (item = this._queue.pop()) {
        this._append(...item);
      }
    }

    _append(str, line, column, identifierName, filename) {
      if (str[0] !== '\n') {
        this.mark(
        this.position.line,
        this.position.column,
        line,
        column,
        identifierName,
        filename);
      }

      this.buf.push(str);
      this.last = str[str.length - 1];

      for (let i = 0; i < str.length; i++) {
        this.position.index++;

        if (str[i] === '\n') {
          this.position.line++;
          this.position.column = 0;
        } else {
          this.position.column++;
        }
      }
    }

    removeTrailingNewline() {
      if (this._queue.length > 0 && this._queue[0][0] === '\n') {
        this._queue.shift();
      }
    }

    removeLastSemicolon() {
      if (this._queue.length > 0 && this._queue[0][0] === ';') {
        this._queue.shift();
      }
    }

    endsWith(suffix) {
      if (suffix.length === 1) {
        let last;
        if (this._queue.length > 0) {
          const str = this._queue[0][0];
          last = str[str.length - 1];
        } else {
          last = this.last;
        }

        return last === suffix;
      }

      const end = this.last + this._queue.reduce((acc, item) => item[0] + acc, '');
      if (suffix.length <= end.length) {
        return end.slice(-suffix.length) === suffix;
      }

      return false;
    }

    hasContent() {
      return this._queue.length > 0 || Boolean(this.last);
    }

    source(prop, loc) {
      if (prop && !loc) {
        return undefined;
      }

      const pos = loc ? loc[prop] : undefined;

      this.sourcePosition.identifierName =
      loc && loc.identifierName || undefined;
      this.sourcePosition.line = pos ? pos.line : undefined;
      this.sourcePosition.column = pos ? pos.column : undefined;
      this.sourcePosition.filename = loc && loc.filename || undefined;
    }

    withSource(prop, loc, cb) {
      const originalLine = this.sourcePosition.line;
      const originalColumn = this.sourcePosition.column;
      const originalFilename = this.sourcePosition.filename;
      const originalIdentifierName = this.sourcePosition.identifierName;

      this.source(prop, loc);

      cb();

      this.sourcePosition.line = originalLine;
      this.sourcePosition.column = originalColumn;
      this.sourcePosition.filename = originalFilename;
      this.sourcePosition.identifierName = originalIdentifierName;
    }

    getCurrentColumn() {
      const extra = this._queue.reduce((acc, item) => item[0] + acc, '');
      const lastIndex = extra.lastIndexOf('\n');

      return lastIndex === -1 ? this.position.column + extra.length : extra.length - 1 - lastIndex;
    }

    getCurrentLine() {
      const extra = this._queue.reduce((acc, item) => item[0] + acc, '');

      let count = 0;
      for (let i = 0; i < extra.length; i++) {
        if (extra[i] === '\n') {
          count++;
        }
      }

      return this.position.line + count;
    }
  }

  // romejs/js-generator/src/Generator.ts

  ___$romejs$js_ast$src$utils_ts$assertNodeTypeSet(Object.keys(___$romejs$js_generator$src$generators$index_ts));

  const ___$$priv$romejs$js_generator$src$Generator_ts$SCIENTIFIC_NOTATION = /e/i;
  const ___$$priv$romejs$js_generator$src$Generator_ts$ZERO_DECIMAL_INTEGER = /\.0+$/;
  const ___$$priv$romejs$js_generator$src$Generator_ts$NON_DECIMAL_LITERAL = /^0[box]/;

  class ___$romejs$js_generator$src$Generator_ts$default {
    constructor(opts, code) {
      this.buf = new ___$romejs$js_generator$src$Buffer_ts$default(opts, code);
      this.currentIndentLevel = opts.indent === undefined ? 0 : opts.indent;

      this.inForStatementInitCounter = 0;
      this.printedCommentStarts = new Set();
      this.printedComments = new Set();
      this.printStack = [];
      this.parenPushNewlineState = undefined;
      this.endsWithInteger = false;
      this.endsWithWord = false;
    }

    indent() {
      this.currentIndentLevel++;
    }

    dedent() {
      this.currentIndentLevel--;
    }

    semicolon(force = false) {
      this.append(';', !force);
    }

    rightBrace() {
      this.token('}');
    }

    space(force = false) {
      if (this.buf.hasContent() && !this.endsWith(' ') && !this.endsWith('\n') ||
      force) {
        this._space();
      }
    }

    word(str) {
      if (this.endsWithWord) {
        this.space();
      }

      this.append(str);

      this.endsWithWord = true;
    }

    number(str) {
      this.word(str);

      this.endsWithInteger =
      Number.isInteger(Number(str)) &&
      !___$$priv$romejs$js_generator$src$Generator_ts$NON_DECIMAL_LITERAL.test(str) &&
      !___$$priv$romejs$js_generator$src$Generator_ts$SCIENTIFIC_NOTATION.test(str) &&
      !___$$priv$romejs$js_generator$src$Generator_ts$ZERO_DECIMAL_INTEGER.test(str) &&
      str[str.length - 1] !== '.';
    }

    token(str) {
      if (str === '--' && this.endsWith('!') ||
      str[0] === '+' && this.endsWith('+') ||
      str[0] === '-' && this.endsWith('-') ||
      str[0] === '.' && this.endsWithInteger) {
        this.space();
      }

      this.append(str);
    }

    endsWith(str) {
      return this.buf.endsWith(str);
    }

    removeTrailingNewline() {
      this.buf.removeTrailingNewline();
    }

    source(prop, loc) {
      this.buf.source(prop, loc);
    }

    _space() {
      this.append(' ', true);
    }

    newline() {
      if (this.endsWith('\n\n')) {
        return undefined;
      }

      if (this.endsWith('{\n') || this.endsWith(':\n')) {
        return undefined;
      }

      this.append('\n', true);
    }

    newlineX(num) {
      for (let i = 0; i < num && i < 2; i++) {
        this.newline();
      }
    }

    append(str, queue = false) {
      this.maybeAddParen(str);
      this.maybeIndent(str);

      if (queue) {
        this.buf.queue(str);
      } else {
        this.buf.append(str);
      }

      this.endsWithWord = false;
      this.endsWithInteger = false;
    }

    maybeIndent(str) {
      if (this.currentIndentLevel > 0 && this.endsWith('\n') && str[0] !== '\n') {
        this.buf.queue(this.getIndent());
      }
    }

    maybeAddParen(str) {
      const parenPushNewlineState = this.parenPushNewlineState;
      if (!parenPushNewlineState) {
        return undefined;
      }
      this.parenPushNewlineState = undefined;

      let i;
      for (i = 0; i < str.length && str[i] === ' '; i++) {
        continue;
      }
      if (i === str.length) {
        return undefined;
      }

      const cha = str[i];
      if (cha === '\n' || cha === '/') {
        this.token('(');
        this.indent();
        parenPushNewlineState.printed = true;
      }
    }

    getIndent() {
      return '  '.repeat(this.currentIndentLevel);
    }

    startTerminatorless() {
      return this.parenPushNewlineState = {
        printed: false};
    }

    endTerminatorless(state) {
      if (state.printed) {
        this.dedent();
        this.newline();
        this.token(')');
      }
    }

    print(node, parent) {
      if (!node) {
        return undefined;
      }

      const printMethod = ___$romejs$js_generator$src$generators$index_ts[node.type];
      ___$romejs$invariant$src$index_ts$default(
      printMethod !== undefined,
      'No known generator for node %s with parent %s',
      node,
      parent);

      this.printStack.push(node);

      const needsParens = ___$romejs$js_generator$src$node$index_ts$needsParens(node, parent, this.printStack);

      if (needsParens === true) {
        this.token('(');
      }

      const loc = node.type === 'Program' ? undefined : node.loc;

      const leadingComments = this.getComments(true, node);
      this.printComments(leadingComments);

      const lastComment = leadingComments && leadingComments[leadingComments.length - 1];
      this.newlineX(___$romejs$js_generator$src$node$index_ts$getLinesBetween(lastComment, node) - 1);

      this.buf.withSource('start', loc, () => {
        printMethod(this, node, parent);
      });

      const trailingComments = this.getComments(false, node);
      this.newlineX(
      ___$romejs$js_generator$src$node$index_ts$getLinesBetween(trailingComments && trailingComments[0], node));
      this.printComments(trailingComments);

      if (needsParens === true) {
        this.token(')');
      }

      this.printStack.pop();
    }

    getPossibleRaw(node) {
      const extra = node.extra;
      if (extra &&
      extra.raw !== undefined &&
      extra.rawValue !== undefined &&
      node.value === extra.rawValue) {
        return extra.raw;
      }
    }

    getStatementList(nodes) {
      const allNodes = new Set();

      for (const node of nodes) {
        this.getStatementList_addComments(allNodes, this.getComments(true, node));
        allNodes.add(node);
        this.getStatementList_addComments(
        allNodes,
        this.getComments(false, node));
      }

      return Array.from(allNodes);
    }

    getStatementList_addComments(allNodes, comments) {
      if (!comments) {
        return undefined;
      }

      for (const comment of comments) {
        this.printedComments.add(comment);
        allNodes.add(comment);
      }
    }

    printJoin(nodes, parent, opts = {}) {
      if (!nodes || !nodes.length) {
        return undefined;
      }

      if (opts.indent === true) {
        this.indent();
      }

      if (opts.statement === true) {
        this.newline();
      }

      let interleavedNodes = nodes;
      if (opts.statement === true) {
        interleavedNodes = this.getStatementList(nodes);
      }

      for (let i = 0; i < interleavedNodes.length; i++) {
        const node = interleavedNodes[i];
        if (!node) {
          continue;
        }

        const isComment = node.type === 'CommentBlock' || node.type === 'CommentLine';
        const isLastNode = node === nodes[nodes.length - 1];
        if (isComment) {
          this.printComment(node);
        } else {
          this.print(node, parent);

          if (opts.iterator) {
            opts.iterator(node, i);
          }

          const shouldPrintSep = !isLastNode;
          if (opts.separator && shouldPrintSep) {
            opts.separator(this);
          }
        }

        if (opts.statement === true) {
          const nextNode = interleavedNodes[i + 1];
          if (nextNode) {
            if (node.loc && nextNode.loc) {
              let linesBetween = ___$romejs$js_generator$src$node$index_ts$getLinesBetween(node, nextNode);
              if (node.type === 'CommentLine') {
                linesBetween--;
              }
              this.newlineX(linesBetween);
            } else {
              this.newline();
            }
          }
        }
      }

      if (opts.indent === true) {
        this.dedent();
      }
    }

    printBlock(parent) {
      const node = parent.body;

      if (node.type !== 'EmptyStatement') {
        this.space();
      }

      this.print(node, parent);
    }

    printStatementList(nodes, parent, opts = {}) {
      return this.printJoin(nodes, parent, Object.assign({}, opts, {
        statement: true}));
    }

    printCommaList(items, parent, opts = {}) {
      if (!items || !items.length) {
        return undefined;
      }

      this.printJoin(items, parent, Object.assign({}, opts, {
        separator: opts.separator || ___$$priv$romejs$js_generator$src$Generator_ts$commaSeparator}));
    }

    printInnerComments(node, indent = true) {
      if (!node.innerComments) {
        return undefined;
      }

      if (indent) {
        this.indent();
      }

      this.printComments(node.innerComments);

      if (indent) {
        this.dedent();
      }
    }

    printComments(comments) {
      if (!comments || !comments.length) {
        return undefined;
      }

      for (let i = 0; i < comments.length; i++) {
        const comment = comments[i];
        this.printComment(comment);

        const nextComment = comments[i + 1];
        if (nextComment) {
          if (comment.type === 'CommentBlock' &&
          ___$romejs$js_generator$src$node$index_ts$getLinesBetween(comment, nextComment) > 0) {
            this.newline();
          }

          if (___$romejs$js_generator$src$node$index_ts$hasExtraLineBetween(comment, nextComment)) {
            this.newline();
          }
        }
      }
    }

    getComments(leading, node) {
      if (!node) {
        return undefined;
      }

      const comments = leading ? node.leadingComments : node.trailingComments;
      if (!comments) {
        return undefined;
      }

      return comments.filter(comment => {
        return !this.hasPrintedComment(comment);
      });
    }

    hasPrintedComment(comment) {
      if (!comment) {
        return true;
      }

      if (this.printedComments.has(comment)) {
        return true;
      }

      if (comment.loc !== undefined &&
      this.printedCommentStarts.has(comment.loc.start.index)) {
        return true;
      }

      return false;
    }

    printComment(comment) {
      this.printedComments.add(comment);

      if (comment.loc !== undefined) {
        this.printedCommentStarts.add(comment.loc.start.index);
      }

      const isBlockComment = comment.type === 'CommentBlock';
      const val = isBlockComment ? `/*${comment.value}*/` : `//${comment.value}\n`;

      if (!this.endsWith('[') && !this.endsWith('{')) {
        this.space();
      }

      if (this.endsWith('/')) {
        this.space();
      }

      this.buf.withSource('start', comment.loc, () => {
        this.append(val);
      });
    }
  }

  function ___$$priv$romejs$js_generator$src$Generator_ts$commaSeparator(generator) {
    generator.token(',');
    generator.space();
  }

  // romejs/js-generator/src/index.ts

  class ___$$priv$romejs$js_generator$src$index_ts$GeneratorPublic {
    constructor(ast, opts = {}, code = '') {
      const generator = new ___$romejs$js_generator$src$Generator_ts$default(opts, code);
      generator.print(ast);
      this.generator = generator;
    }

    getCode() {
      return this.generator.buf.getCode();
    }

    getSourceMap() {
      return this.generator.buf.getSourceMap();
    }

    getMappings() {
      return this.generator.buf.getMappings();
    }
  }

  function ___$romejs$js_generator$src$index_ts$default(ast, opts = {}, code = '') {
    return new ___$$priv$romejs$js_generator$src$index_ts$GeneratorPublic(ast, opts, code);
  }

  // romejs/js-compiler/src/api/lint.ts

  const ___$$priv$romejs$js_compiler$src$api$lint_ts$lintCache = new ___$romejs$js_compiler$src$lib$Cache_ts$default();

  async function ___$romejs$js_compiler$src$api$lint_ts$default(req) {
    const {ast: ast, src: src, projectConfig: projectConfig} = req;

    const query = ___$romejs$js_compiler$src$lib$Cache_ts$default.buildQuery(req);
    const cached = ___$$priv$romejs$js_compiler$src$api$lint_ts$lintCache.get(query);
    if (cached) {
      return cached;
    }

    const context = new ___$romejs$js_compiler$src$lib$Context_ts$default({
      ast: ast,
      projectConfig: projectConfig,
      origin: 'Linting'});
    const newAst = ___$romejs$js_ast$src$core$Program_ts$program.assert(context.reduce(ast, ___$romejs$js_compiler$src$plugins$lint$index_ts$lintTransforms));

    let formattedCode = src;
    if (projectConfig.format.enabled) {
      const generated = ___$romejs$js_generator$src$index_ts$default(newAst, {}, src);
      formattedCode = generated.getCode() + '\n';
    }

    const result = {
      ast: newAst,
      diagnostics: [...ast.diagnostics, ...context.diagnostics],
      src: formattedCode};
    ___$$priv$romejs$js_compiler$src$api$lint_ts$lintCache.set(query, result);
    return result;
  }

  // romejs/js-compiler/src/plugins/compile/stripTypeAnnotations.ts

  const ___$romejs$js_compiler$src$plugins$compile$stripTypeAnnotations_ts$default = {
    name: 'stripTypeAnnotations',
    enter(path) {
      const {node: node} = path;

      if (node.type === 'ClassProperty' &&
      (node.variance || node.typeAnnotation)) {
        if (node.value) {
          return Object.assign({}, node, {
            type: 'ClassProperty',
            typeAnnotation: undefined,
            variance: undefined});
        } else {
          return null;
        }
      }

      if (node.type === 'AssignmentPattern' && node.left.optional) {
        return Object.assign({}, node, {
          left: Object.assign({}, node.left, {
            optional: undefined})});
      }

      if (node.type === 'CallExpression' || node.type === 'NewExpression') {
        if (node.typeArguments !== undefined) {
          return Object.assign({}, node, {
            typeArguments: undefined});
        }
      }

      if (___$romejs$js_ast_utils$src$isFunctionNode_ts$default(node)) {
        let hasOptional = false;
        for (const param of node.params) {
          if (param.optional) {
            hasOptional = true;
            break;
          }
        }
        if (hasOptional) {
          return Object.assign({}, node, {
            params: node.params.map(param => {
              return Object.assign({}, param, {
                optional: undefined});
            })});
        }
      }

      if (node.type === 'FlowTypeCastExpression' ||
      node.type === 'TSAsExpression') {
        return node.expression;
      }

      if (___$romejs$js_ast_utils$src$isTypeNode_ts$default(node)) {
        return null;
      }

      if (node.type === 'Program') {
        let typeExportSpecifiers = new Set();
        for (const bodyNode of node.body) {
          if (bodyNode.type === 'ExportNamedDeclaration' &&
          bodyNode.specifiers !== undefined) {
            for (const specifier of bodyNode.specifiers) {
              if (specifier.type === 'ExportSpecifier') {
                const localName = specifier.local.name;
                const binding = path.scope.getBinding(localName);
                if (binding !== undefined && binding instanceof ___$romejs$js_compiler$src$scope$bindings_ts$TypeBinding) {
                  typeExportSpecifiers.add(specifier);
                }
              }
            }
          }
        }
        if (typeExportSpecifiers.size === 0) {
          return node;
        }

        const body = [];
        for (const bodyNode of node.body) {
          if (bodyNode.type === 'ExportNamedDeclaration' &&
          bodyNode.specifiers !== undefined &&
          bodyNode.specifiers.length > 0) {
            const specifiers = [];

            for (const specifier of bodyNode.specifiers) {
              if (!typeExportSpecifiers.has(specifier)) {
                specifiers.push(specifier);
              }
            }

            if (specifiers.length === 0) {
              continue;
            }

            body.push(Object.assign({}, bodyNode, {
              specifiers: specifiers}));
          } else {
            body.push(bodyNode);
          }
        }
        return Object.assign({}, node, {
          body: body});
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/compile/transpile/classProperties.ts

  function ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$hasClassProps(node) {
    for (const bodyNode of node.body) {
      if (bodyNode.type === 'ClassProperty') {
        return true;
      }
    }

    return false;
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$createConstructor(params, body) {
    return ___$romejs$js_ast$src$core$ClassMethod_ts$classMethod.create({
      kind: 'constructor',
      key: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: 'constructor'}),
      params: params,
      body: ___$romejs$js_ast$src$core$BlockStatement_ts$blockStatement.create({body: body})});
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$toExpressionStatements(expressions) {
    return expressions.map(expr => {
      return ___$romejs$js_ast$src$core$ExpressionStatement_ts$expressionStatement.create({expression: expr});
    });
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$isSuperCall(node) {
    return node.type === 'CallExpression' && node.callee.type === 'Super';
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$transformClass(node, scope, context) {
    const bodyReplacements = [];
    const constructorAssignments = [];
    const className = node.id === undefined ? scope.generateUid('class') : node.id.name;

    let constructor = undefined;
    const filteredClassBody = [];
    for (const bodyNode of node.body) {
      if (bodyNode.type === 'ClassMethod' && bodyNode.kind === 'constructor') {
        constructor = bodyNode;
      } else if (bodyNode.type === 'ClassProperty') {
        if (bodyNode.value === undefined) {
          continue;
        }

        if (bodyNode.computed === true) {
          if (bodyNode.static === true) {
            bodyReplacements.push(
            ___$romejs$js_ast_utils$src$template_ts$default.statement`${className}[${bodyNode.key}] = ${bodyNode.value};`);
          } else {
            constructorAssignments.push(
            ___$romejs$js_ast_utils$src$template_ts$default.expression`this[${bodyNode.key}] = ${bodyNode.value};`);
          }
        } else {
          if (bodyNode.static === true) {
            bodyReplacements.push(
            ___$romejs$js_ast_utils$src$template_ts$default.statement`${className}.${bodyNode.key} = ${bodyNode.value};`);
          } else {
            constructorAssignments.push(
            ___$romejs$js_ast_utils$src$template_ts$default.expression`this.${bodyNode.key} = ${bodyNode.value};`);
          }
        }
      } else {
        filteredClassBody.push(bodyNode);
      }
    }

    if (constructorAssignments.length) {
      if (node.superClass !== undefined) {
        if (constructor) {
          const visited = new Set();

          const reducedConstructor = context.reduce(constructor, [{
            name: 'classPropertiesInjector',
            enter(path) {
              const {node: node} = path;

              if (visited.has(node)) {
                return node;
              }

              if (___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$isSuperCall(node) &&
              path.getParent().type !== 'ExpressionStatement') {
                visited.add(node);

                return ___$romejs$js_ast$src$core$SequenceExpression_ts$sequenceExpression.create({
                  expressions: [node, ...constructorAssignments]});
              }

              if (node.type === 'ExpressionStatement' &&
              ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$isSuperCall(node.expression)) {
                visited.add(node);

                return [node, ...___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments)];
              }

              return node;
            }}]);
          constructor = ___$romejs$js_ast$src$core$ClassMethod_ts$classMethod.assert(reducedConstructor);
        } else {
          constructor = ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$createConstructor(
          [___$romejs$js_ast$src$core$RestElement_ts$restElement.create({argument: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: 'args'})})],
          [___$romejs$js_ast_utils$src$template_ts$default.statement`super(...args);`, ...___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments)]);
        }
      } else {
        if (constructor) {
          constructor = Object.assign({}, constructor, {
            body: Object.assign({}, constructor.body, {
              body: [...constructor.body.body, ...___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments)]})});
        } else {
          constructor = ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$createConstructor(
          [],
          ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments));
        }
      }
    }

    if (constructor !== undefined) {
      filteredClassBody.unshift(constructor);
    }

    const newClass = Object.assign({}, node, {
      id: node.id !== undefined && node.id.name === className ? node.id : ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
        name: className,
        loc: ___$romejs$js_ast_utils$src$inheritLoc_ts$default(node.id, className)}),
      body: filteredClassBody});

    return {
      newClass: newClass,
      className: className,
      declarations: bodyReplacements};
  }
  const ___$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$default = {
    name: 'classProperties',
    enter(path) {
      const {node: node, scope: scope, context: context} = path;

      const isExport = node.type === 'ExportNamedDeclaration' ||
      node.type === 'ExportDefaultDeclaration';
      const isExportClass = isExport &&
      node.declaration !== undefined &&
      node.declaration.type === 'ClassDeclaration';
      if (isExportClass && ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$hasClassProps(node.declaration)) {
        const {newClass: newClass, declarations: declarations} = ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$transformClass(
        node.declaration,
        scope,
        context);
        return [Object.assign({}, node, {
          declaration: newClass}), ...declarations];
      }

      if (node.type === 'ClassExpression' && ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$hasClassProps(node)) {
        const className = node.id === undefined ? scope.generateUid('class') : node.id.name;

        return ___$romejs$js_ast$src$core$CallExpression_ts$callExpression.create({
          callee: ___$romejs$js_ast$src$core$ArrowFunctionExpression_ts$arrowFunctionExpression.create({
            params: [],
            body: ___$romejs$js_ast$src$core$BlockStatement_ts$blockStatement.create({
              body: [Object.assign({}, node, {
                type: 'ClassDeclaration',
                id: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: className})}), ___$romejs$js_ast$src$core$ReturnStatement_ts$returnStatement.create({
                argument: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: className})})]})}),
          arguments: []});
      }

      if (node.type === 'ClassDeclaration' && ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$hasClassProps(node)) {
        const {newClass: newClass, declarations: declarations} = ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$transformClass(node, scope, context);
        return [newClass, ...declarations];
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/compile/transpile/objectSpread.ts

  function ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$last(arr) {
    return arr[arr.length - 1];
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$hasSpreadProperty(props) {
    for (const prop of props) {
      if (prop.type === 'SpreadProperty') {
        return true;
      }
    }
    return false;
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$getRestProperty(node) {
    if (node === undefined) {
      return undefined;
    }

    switch (node.type) {
      case 'VariableDeclaration':
        for (const declarator of node.declarations) {
          const rest = ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$getRestProperty(declarator);
          if (rest !== undefined) {
            return rest;
          }
        }
        return undefined;

      case 'VariableDeclarator':
        return ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$getRestProperty(node.id);

      case 'RestProperty':
        return node;

      case 'ObjectPattern':
        const prop = ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$getRestProperty(
        ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$last(node.properties));
        if (prop !== undefined) {
          return prop;
        }}
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$transformSpreadProperty(path) {
    const {node: node} = path;

    let props = [];
    const assignArgs = [];

    function pushProps() {
      if (props.length === 0 && assignArgs.length > 0) {
        return undefined;
      }

      assignArgs.push(___$romejs$js_ast$src$core$ObjectExpression_ts$objectExpression.create({properties: props}));

      props = [];
    }

    for (const prop of node.properties) {
      if (prop.type === 'SpreadProperty') {
        pushProps();
        assignArgs.push(prop.argument);
      } else {
        props.push(prop);
      }
    }

    pushProps();

    return ___$romejs$js_ast$src$core$CallExpression_ts$callExpression.create({
      callee: ___$romejs$js_ast_utils$src$template_ts$default.expression`Object.assign`,
      arguments: assignArgs});
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$transformRestProperty(path) {
    const {node: node} = path;

    const nodes = [];

    for (const declarator of node.declarations) {
      const restElem = ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$getRestProperty(declarator);
      if (restElem !== undefined) {
        const uid = path.scope.generateUid();

        nodes.push(
        ___$romejs$js_ast$src$core$VariableDeclaration_ts$variableDeclaration.create({
          kind: node.kind,
          declarations: [___$romejs$js_ast$src$core$VariableDeclarator_ts$variableDeclarator.create({
            id: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
              name: uid}),
            init: declarator.init})]}));

        const removeProps = [];
        for (const prop of declarator.id.properties) {
          if (prop.type === 'ObjectProperty') {
            if (prop.computed) {} else {
              removeProps.push(prop.key.name);
            }
          }
        }

        const restName = restElem.argument.name;
        nodes.push(
        ___$romejs$js_ast$src$core$VariableDeclaration_ts$variableDeclaration.create({
          kind: node.kind,
          declarations: [___$romejs$js_ast$src$core$VariableDeclarator_ts$variableDeclarator.create({
            id: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: restName}),
            init: ___$romejs$js_ast_utils$src$template_ts$default.expression`Object.assign({}, ${uid})`})]}));

        for (const name of removeProps) {
          nodes.push(___$romejs$js_ast_utils$src$template_ts$default.statement`delete ${restName}.${name};`);
        }

        nodes.push(
        ___$romejs$js_ast$src$core$VariableDeclaration_ts$variableDeclaration.create({
          kind: node.kind,
          declarations: [___$romejs$js_ast$src$core$VariableDeclarator_ts$variableDeclarator.create({
            id: ___$romejs$js_ast$src$core$ObjectPattern_ts$objectPattern.create({
              properties: declarator.id.properties.slice(0, -1)}),
            init: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: uid})})]}));
      } else {
        nodes.push(
        ___$romejs$js_ast$src$core$VariableDeclaration_ts$variableDeclaration.create({
          kind: node.kind,
          declarations: [declarator]}));
      }
    }

    return nodes;
  }
  const ___$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$default = {
    name: 'objectSpread',
    enter(path) {
      const {node: node} = path;

      if (node.type === 'VariableDeclaration' &&
      ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$getRestProperty(node) !== undefined) {
        return ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$transformRestProperty(path);
      }

      if (node.type === 'ObjectExpression' &&
      ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$hasSpreadProperty(node.properties)) {
        return ___$$priv$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$transformSpreadProperty(path);
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/compile/validation/optimizeImports.ts

  function ___$$priv$romejs$js_compiler$src$plugins$compile$validation$optimizeImports_ts$getName(node) {
    const {property: property, computed: computed} = node;

    if (computed === true) {
      if (property.type === 'StringLiteral') {
        return property.value;
      }
    } else {
      if (property.type === 'Identifier') {
        return property.name;
      }
    }
  }
  const ___$romejs$js_compiler$src$plugins$compile$validation$optimizeImports_ts$default = {
    name: 'optimizeImports',
    enter(path) {
      const {node: node} = path;

      if (node.type !== 'Program') {
        return node;
      }

      const wildcardImports = new Map();
      const wildcardImportNodeToLocal = new Map();
      for (const child of node.body) {
        if (child.type === 'ImportDeclaration') {
          for (const specifier of child.specifiers) {
            if (specifier.type === 'ImportNamespaceSpecifier') {
              if (!path.scope.getBinding(specifier.local.name)) {
                path.scope.dump();
                console.log('');
              }
              wildcardImports.set(specifier.local.name, {
                binding: path.scope.getBindingAssert(specifier.local.name),
                names: new Set(),
                mappings: new Map(),
                references: new Set()});
              wildcardImportNodeToLocal.set(child, specifier.local.name);
            }
          }
        }
      }
      if (wildcardImports.size === 0) {
        return node;
      }

      path.traverse('optimizeImportsWildcardCollector', path => {
        const {node: node, parent: parent} = path;
        if (node.type !== 'Identifier') {
          return undefined;
        }

        const wildcardInfo = wildcardImports.get(node.name);
        if (wildcardInfo === undefined || !___$romejs$js_ast_utils$src$isReferenced_ts$default(path)) {
          return undefined;
        }

        if (path.scope.getBinding(node.name) !== wildcardInfo.binding) {
          return undefined;
        }

        if (parent === undefined) {
          return undefined;
        }

        const isComputed = parent.type === 'MemberExpression' &&
        parent.object === node &&
        ___$$priv$romejs$js_compiler$src$plugins$compile$validation$optimizeImports_ts$getName(parent) === undefined;
        const isUnboxed = parent.type !== 'MemberExpression';

        if (isComputed || isUnboxed) {
          wildcardImports.delete(node.name);
        } else {
          const name = ___$$priv$romejs$js_compiler$src$plugins$compile$validation$optimizeImports_ts$getName(parent);
          if (name === undefined) {
            throw new Error('Expected name');
          }
          wildcardInfo.names.add(name);
          wildcardInfo.references.add(parent);
        }
      });
      if (wildcardImports.size === 0) {
        return node;
      }

      for (const info of wildcardImports.values()) {
        for (const name of info.names) {
          info.mappings.set(name, path.scope.generateUid(name));
        }
      }

      return path.reduce({
        name: 'optimizeImportWilcards',
        enter(path) {
          const {node: node} = path;

          if (node.type === 'MemberExpression' &&
          node.object.type === 'Identifier') {
            const wildcardInfo = wildcardImports.get(node.object.name);
            if (wildcardInfo !== undefined && wildcardInfo.references.has(node)) {
              const name = ___$$priv$romejs$js_compiler$src$plugins$compile$validation$optimizeImports_ts$getName(node);
              if (name === undefined) {
                throw new Error('Expected name');
              }

              const newName = wildcardInfo.mappings.get(name);
              if (newName === undefined) {
                throw new Error('Expected newName');
              }

              return ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: newName});
            }
          }

          if (node.type === 'ImportDeclaration' &&
          wildcardImportNodeToLocal.has(node)) {
            const local = wildcardImportNodeToLocal.get(node);
            if (local === undefined) {
              throw new Error('Expected local');
            }

            const wildcardInfo = wildcardImports.get(local);
            if (wildcardInfo === undefined) {
              return node;
            }

            const specifiers = node.specifiers.filter(
            specifier => {
              if (specifier.type === 'ImportNamespaceSpecifier' &&
              specifier.local.name === local) {
                return false;
              } else {
                return true;
              }
            });

            for (const [imported, local] of wildcardInfo.mappings) {
              specifiers.push(
              ___$romejs$js_ast$src$core$ImportSpecifier_ts$importSpecifier.create({
                imported: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: imported}),
                local: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: local})}));
            }

            return ___$romejs$js_ast$src$core$ImportDeclaration_ts$importDeclaration.create({specifiers: specifiers, source: node.source});
          }

          return node;
        }});
    }};

  // romejs/js-compiler/src/plugins/compile/validation/optimizeExports.ts

  const ___$romejs$js_compiler$src$plugins$compile$validation$optimizeExports_ts$default = {
    name: 'optimizeExports',
    enter(path) {
      const {node: node} = path;

      if (node.type === 'ExportNamedDeclaration' &&
      node.exportKind === 'value' &&
      node.source === undefined &&
      node.declaration === undefined) {
        const nodes = [];
        const specifiers = [];

        for (const specifier of node.specifiers) {
          if (specifier.type === 'ExportSpecifier') {
            const binding = path.scope.getBinding(specifier.local.name);
            if (binding !== undefined &&
            binding instanceof ___$romejs$js_compiler$src$scope$bindings_ts$ImportBinding &&
            binding.meta.type === 'name') {
              nodes.push(
              ___$romejs$js_ast$src$core$ExportNamedDeclaration_ts$exportNamedDeclaration.create({
                specifiers: [___$romejs$js_ast$src$core$ExportSpecifier_ts$exportSpecifier.create({
                  local: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: binding.meta.imported}),
                  exported: specifier.exported})],
                source: ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral.create({value: binding.meta.source})}));
            } else {
              specifiers.push(specifier);
            }
          } else {
            specifiers.push(specifier);
          }
        }

        if (specifiers.length === node.specifiers.length && nodes.length === 0) {
          return node;
        }

        if (specifiers.length !== 0) {
          nodes.push(___$romejs$js_ast$src$core$ExportNamedDeclaration_ts$exportNamedDeclaration.create({specifiers: specifiers}));
        }

        return nodes;
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/compile/jsx.ts

  function ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$isCompatTag(tagName) {
    return tagName !== undefined ? /^[a-z]|-/.test(tagName) : false;
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$convertJSXIdentifier(path) {
    const {node: node} = path;

    if (node.type === 'JSXIdentifier') {
      if (node.name === 'this' && ___$romejs$js_ast_utils$src$isReferenced_ts$default(path)) {
        return ___$romejs$js_ast$src$core$ThisExpression_ts$thisExpression.create({});
      } else if (___$romejs$js_ast_utils$src$isValidIdentifierName_ts$default(node.name)) {
        return ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
          name: node.name,
          loc: ___$romejs$js_ast_utils$src$inheritLoc_ts$default(node)});
      } else {
        return ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral.create({value: node.name});
      }
    } else if (node.type === 'JSXMemberExpression') {
      return ___$romejs$js_ast$src$core$MemberExpression_ts$memberExpression.create({
        object: ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$convertJSXIdentifier(path.getChildPath('object')),
        property: ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$convertJSXIdentifier(path.getChildPath('property'))});
    } else if (node.type === 'JSXNamespacedName') {
      return node;
    } else {
      throw new Error(`Received a node of type ${node.type}, the only node types that should be in this position are JSXIdentifier and JSXMemberExpression`);
    }
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$convertAttributeValue(node) {
    if (node.type === 'JSXExpressionContainer') {
      return node.expression;
    } else {
      return node;
    }
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$extractName(node) {
    if (node.type === 'JSXNamespacedName') {
      throw new Error('JSX is not XML blah blah blah');
    } else {
      return ___$romejs$js_ast$src$jsx$JSXIdentifier_ts$jsxIdentifier.assert(node).name;
    }
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$convertAttribute(node) {
    let valueNode = ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$convertAttributeValue(
    node.value || ___$romejs$js_ast$src$core$BooleanLiteral_ts$booleanLiteral.create({value: true}));
    if (valueNode.type === 'StringLiteral' &&
    (!node.value || node.value.type !== 'JSXExpressionContainer')) {
      valueNode = ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral.create({
        value: valueNode.value.replace(/\n\s+/g, ' ')});
    }

    const name = ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$extractName(node.name);
    let nameNode;
    if (___$romejs$js_ast_utils$src$isValidIdentifierName_ts$default(name)) {
      nameNode = ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
        name: name,
        loc: ___$romejs$js_ast_utils$src$inheritLoc_ts$default(node)});
    } else {
      nameNode = ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral.create({value: name});
    }

    return ___$romejs$js_ast$src$core$ObjectProperty_ts$objectProperty.create({
      key: nameNode,
      value: valueNode});
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$pushProps(_props, objs) {
    if (!_props.length) {
      return _props;
    }

    objs.push(___$romejs$js_ast$src$core$ObjectExpression_ts$objectExpression.create({properties: _props}));
    return [];
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$buildOpeningElementAttributes(attribs) {
    let _props = [];
    const objs = [];

    while (attribs.length) {
      const prop = attribs.shift();
      if (prop.type === 'JSXSpreadAttribute') {
        _props = ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$pushProps(_props, objs);
        objs.push(prop.argument);
      } else {
        _props.push(___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$convertAttribute(prop));
      }
    }

    ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$pushProps(_props, objs);

    let ret;
    if (objs.length === 1) {
      ret = objs[0];
    } else {
      if (objs[0].type !== 'ObjectExpression') {
        objs.unshift(___$romejs$js_ast$src$core$ObjectExpression_ts$objectExpression.create({properties: []}));
      }

      ret = ___$romejs$js_ast$src$core$CallExpression_ts$callExpression.create({
        callee: ___$romejs$js_ast_utils$src$template_ts$default.expression`Object.assign`,
        arguments: objs});
    }

    return ret;
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$cleanJSXElementLiteralChild(value) {
    const lines = value.split(/\r\n|\n|\r/);

    let lastNonEmptyLine = 0;

    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }

    let str = '';

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;

      let trimmedLine = line.replace(/\t/g, ' ');

      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, '');
      }

      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, '');
      }

      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += ' ';
        }

        str += trimmedLine;
      }
    }

    if (str != '') {
      return ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral.create({value: str});
    }
  }

  function ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$buildChildren(children) {
    const elems = [];

    for (let child of children) {
      if (child.type === 'JSXText') {
        child = ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$cleanJSXElementLiteralChild(child.value);
      }

      if (child === undefined) {
        continue;
      }

      if (child.type === 'JSXExpressionContainer') {
        child = child.expression;
      }

      if (child.type === 'JSXEmptyExpression') {
        continue;
      }

      if (child !== undefined) {
        elems.push(child);
      }
    }

    return elems;
  }
  const ___$romejs$js_compiler$src$plugins$compile$jsx_ts$default = {
    name: 'jsx',
    enter(path) {
      const {node: node} = path;

      if (node.type === 'JSXElement') {
        let type = ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$convertJSXIdentifier(
        path.getChildPath('openingElement').getChildPath('name'));

        if (type.type === 'JSXNamespacedName') {}

        if (type.type === 'Identifier' && ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$isCompatTag(type.name)) {
          type = ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral.create({value: type.name});
        }

        let attribs = node.openingElement.attributes;
        if (attribs.length) {
          attribs = ___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$buildOpeningElementAttributes(attribs);
        } else {
          attribs = ___$romejs$js_ast$src$core$NullLiteral_ts$nullLiteral.create({});
        }

        return ___$romejs$js_ast$src$core$CallExpression_ts$callExpression.create({
          callee: ___$romejs$js_ast_utils$src$template_ts$default.expression`React.createElement`,
          arguments: [type, attribs, ...___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$buildChildren(node.children)]});
      }

      if (node.type === 'JSXFragment') {
        const type = ___$romejs$js_ast_utils$src$template_ts$default.expression`React.Fragment`;
        const attribs = ___$romejs$js_ast_utils$src$template_ts$default.expression`null`;
        return ___$romejs$js_ast$src$core$CallExpression_ts$callExpression.create({
          callee: ___$romejs$js_ast_utils$src$template_ts$default.expression`React.createElement`,
          arguments: [type, attribs, ...___$$priv$romejs$js_compiler$src$plugins$compile$jsx_ts$buildChildren(node.children)]});
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/compileForBundle/_utils.ts

  function ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getOptions(context) {
    const opts = context.options.bundle;
    if (opts === undefined) {
      throw new Error('No bundle options found');
    }
    return opts;
  }

  function ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrivateName(name, moduleId) {
    return `${___$romejs$js_compiler$src$constants_ts$SCOPE_PRIVATE_PREFIX}$priv$${___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$normalizeModuleId(moduleId)}$${name}`;
  }

  function ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$normalizeModuleId(id) {
    return id.replace(/[\\\/]/g, '$').replace(/[-\.]/g, '_');
  }

  function ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName(name, moduleId, opts) {
    const forwarded = opts.resolvedImports[`${moduleId}:${name}`];
    if (forwarded !== undefined) {
      moduleId = forwarded.id;
      name = forwarded.name;
    }

    return `${___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$normalizeModuleId(moduleId))}$${name}`;
  }

  function ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId) {
    return `${___$romejs$js_compiler$src$constants_ts$SCOPE_PRIVATE_PREFIX}${___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$normalizeModuleId(moduleId)}`;
  }

  function ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getModuleId(source, opts) {
    const {relativeSourcesToModuleId: relativeSourcesToModuleId} = opts;
    ___$romejs$invariant$src$index_ts$default(
    relativeSourcesToModuleId !== undefined,
    'expected relativeSourcesToModuleId');

    const moduleId = relativeSourcesToModuleId[source];
    return moduleId;
  }

  // romejs/js-compiler/src/plugins/compileForBundle/asyncImportTransform.ts

  const ___$romejs$js_compiler$src$plugins$compileForBundle$asyncImportTransform_ts$default = {
    name: 'asyncImportTransform',
    enter(path) {
      const {node: node, context: context} = path;
      const opts = ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getOptions(context);

      if (node.type !== 'CallExpression') {
        return node;
      }

      if (node.callee.type === 'Import') {
        const id = ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral.create({
          value: ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getModuleId(node.arguments[0].value, opts)});
        return ___$romejs$js_ast_utils$src$template_ts$default.expression`Rome.import(${id})`;
      }

      if (node.callee.type === 'Identifier' &&
      (node.callee.name === 'requireLazy' || node.callee.name === 'requireWeak')) {
        return ___$romejs$js_ast_utils$src$template_ts$default.expression`Bootloader.loadModules([${node.arguments[0]}], ${node.arguments[1]});`;
      }

      if (___$romejs$js_ast_utils$src$doesNodeMatchPattern_ts$default(node.callee, 'Bootloader.loadModules')) {
        const [sources, callback] = node.arguments;

        if (sources.type !== 'ArrayExpression') {
          return node;
        }

        const promises = [];
        for (const source of sources.elements) {
          if (source.type !== 'StringLiteral') {
            continue;
          }

          const id = ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral.create({
            value: ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getModuleId(source.value, opts)});
          promises.push(___$romejs$js_ast_utils$src$template_ts$default.expression`Rome.import(${id})`);
        }

        return ___$romejs$js_ast_utils$src$template_ts$default.expression`Promise.all(${___$romejs$js_ast$src$core$ArrayExpression_ts$arrayExpression.create({
          elements: promises})}).then(${callback});`;
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/compileForBundle/cjsRootTransform.ts

  const ___$romejs$js_compiler$src$plugins$compileForBundle$cjsRootTransform_ts$default = {
    name: 'cjsRootTransform',
    enter(path) {
      const {node: node, scope: scope, context: context} = path;

      const {moduleId: moduleId} = ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getOptions(context);

      if (node.type === 'Program') {
        const mappings = new Map();

        for (const [name] of path.scope.bindings) {
          mappings.set(name, ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrivateName(name, moduleId));
        }

        if (scope.hasBinding('exports') === false) {
          mappings.set('exports', ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId));
        }

        const newProgram = ___$romejs$js_ast_utils$src$renameBindings_ts$default(path, mappings);
        return newProgram;
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/compileForBundle/esToRefTransform.ts

  const ___$romejs$js_compiler$src$plugins$compileForBundle$esToRefTransform_ts$default = {
    name: 'esToRefTransform',
    enter(path) {
      const {node: node, scope: scope, context: context} = path;

      const opts = ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getOptions(context);

      if (node.type === 'Program') {
        const mappings = new Map();

        for (const [name] of path.scope.bindings) {
          mappings.set(name, ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrivateName(name, opts.moduleId));
        }

        for (const child of node.body) {
          if (child.type === 'ImportDeclaration' &&
          child.importKind !== 'type' &&
          child.importKind !== 'typeof') {
            const moduleId = ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getModuleId(child.source.value, opts);
            if (moduleId === undefined) {
              continue;
            }

            for (const specifier of child.specifiers) {
              if (specifier.type === 'ImportSpecifier') {
                mappings.set(
                specifier.local.name,
                ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName(specifier.imported.name, moduleId, opts));
              } else if (specifier.type === 'ImportNamespaceSpecifier') {
                mappings.set(
                specifier.local.name,
                ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId));
              } else if (specifier.type === 'ImportDefaultSpecifier') {
                mappings.set(
                specifier.local.name,
                ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName('default', moduleId, opts));
              } else {
                throw new Error('unexpected');
              }
            }
          }

          if (child.type === 'ExportNamedDeclaration' &&
          child.source === undefined) {
            for (const {name: name} of ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(child)) {
              mappings.set(name, ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName(name, opts.moduleId, opts));
            }

            if (child.specifiers !== undefined) {
              for (const specifier of child.specifiers) {
                const local = specifier.local.name;
                if (scope.getBindingAssert(local) instanceof ___$romejs$js_compiler$src$scope$bindings_ts$ImportBinding) {
                  continue;
                }

                mappings.set(
                local,
                ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName(specifier.exported.name, opts.moduleId, opts));
              }
            }
          }

          if (child.type === 'ExportDefaultDeclaration') {
            const {declaration: decl} = child;
            if ((decl.type === 'FunctionDeclaration' ||
            decl.type === 'ClassDeclaration') &&
            decl.id !== undefined) {
              mappings.set(
              decl.id.name,
              ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName('default', opts.moduleId, opts));
            }
          }
        }

        const newProgram = ___$romejs$js_ast$src$core$Program_ts$program.assert(___$romejs$js_ast_utils$src$renameBindings_ts$default(path, mappings));

        const newScope = scope.getRootScope().evaluate(newProgram, undefined, true);

        if (opts.moduleAll === true) {
          const exportNames = new Map();
          for (const child of newProgram.body) {
            if (child.type === 'ExportDefaultDeclaration') {
              exportNames.set(
              'default',
              ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName('default', opts.moduleId, opts));
            }

            if (child.type === 'ExportNamedDeclaration') {
              const {declaration: declaration, specifiers: specifiers} = child;

              if (declaration !== undefined) {
                throw new Error('No export declarations should be here as they have been removed by renameBindings');
              }

              if (specifiers !== undefined) {
                for (const specifier of specifiers) {
                  if (specifier.type === 'ExportSpecifier') {
                    let local = specifier.local.name;

                    if (child.source !== undefined) {
                      local = ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName(
                      local,
                      ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getModuleId(child.source.value, opts),
                      opts);
                    }

                    exportNames.set(specifier.exported.name, local);
                  } else {}
                }
              }
            }
          }

          const exportObjProps = [];

          for (const [exported, local] of exportNames) {
            const binding = newScope.getBinding(local);
            if (binding !== undefined) {
              if (binding instanceof ___$romejs$js_compiler$src$scope$bindings_ts$TypeBinding) {
                continue;
              }

              if (binding instanceof ___$romejs$js_compiler$src$scope$bindings_ts$FunctionBinding) {
                exportObjProps.push(
                ___$romejs$js_ast$src$core$ObjectProperty_ts$objectProperty.create({
                  key: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: exported}),
                  value: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: local})}));
                continue;
              }
            }

            exportObjProps.push(
            ___$romejs$js_ast$src$core$ObjectMethod_ts$objectMethod.create({
              kind: 'get',
              key: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: exported}),
              params: [],
              body: ___$romejs$js_ast$src$core$BlockStatement_ts$blockStatement.create({
                body: [___$romejs$js_ast$src$core$ReturnStatement_ts$returnStatement.create({
                  argument: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
                    name: local})})]})}));
          }
          const exportObj = ___$romejs$js_ast$src$core$ObjectExpression_ts$objectExpression.create({properties: exportObjProps});

          return Object.assign({}, newProgram, {
            type: 'Program',
            body: [___$romejs$js_ast$src$core$VariableDeclaration_ts$variableDeclaration.create({
              kind: 'const',
              declarations: [___$romejs$js_ast$src$core$VariableDeclarator_ts$variableDeclarator.create({
                id: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
                  name: ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(opts.moduleId)}),
                init: exportObj})]}), ...newProgram.body]});
        } else {
          return newProgram;
        }
      }

      if (node.type === 'ImportDeclaration') {
        return null;
      }

      if (node.type === 'ExportDefaultDeclaration') {
        const {declaration: declaration} = node;
        if (declaration.type === 'FunctionDeclaration' ||
        declaration.type === 'ClassDeclaration') {
          if (declaration.id === undefined) {
            return Object.assign({}, node, {
              declaration: Object.assign({}, declaration, {
                id: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
                  name: ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName('default', opts.moduleId, opts)})})});
          } else {
            return declaration;
          }
        } else {
          return ___$romejs$js_ast_utils$src$template_ts$default.statement`const ${___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName(
          'default',
          opts.moduleId,
          opts)} = ${declaration};`;
        }
      }

      if (node.type === 'ExportNamedDeclaration') {
        if (node.source !== undefined) {
          return null;
        }

        const {declaration: declaration, specifiers: specifiers} = node;

        if (specifiers === undefined) {
          ___$romejs$invariant$src$index_ts$default(
          declaration !== undefined,
          'no specifiers or declaration existed, if there\'s no specifiers then there should be a declaration');
          return declaration;
        } else {
          const nodes = [];

          for (const specifier of specifiers) {
            if (specifier.type === 'ExportSpecifier') {
              const binding = path.scope.getBinding(specifier.local.name);

              if (binding === undefined || binding instanceof ___$romejs$js_compiler$src$scope$bindings_ts$ImportBinding) {
                nodes.push(
                ___$romejs$js_ast$src$core$VariableDeclaration_ts$variableDeclaration.create({
                  kind: 'const',
                  declarations: [___$romejs$js_ast$src$core$VariableDeclarator_ts$variableDeclarator.create({
                    id: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
                      name: ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedName(
                      specifier.exported.name,
                      opts.moduleId,
                      opts)}),
                    init: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({name: specifier.local.name})})]}));
              }
            } else {}
          }

          if (nodes.length === 0) {
            return null;
          } else {
            return nodes;
          }
        }
      }

      if (node.type === 'ExportAllDeclaration' && opts.moduleAll === true) {
        const theirNamespace = ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(
        ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getModuleId(node.source.value, opts));
        const ourNamespace = ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(opts.moduleId);
        return ___$romejs$js_ast_utils$src$template_ts$default.statement`
        Object.keys(${theirNamespace}).forEach(function (key) {
          if (key === 'default') return undefined;
          Object.defineProperty(${ourNamespace}, key, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return ${theirNamespace}[key];
            }
          });
        });
      `;
      }

      if (node.type === 'ExportAllDeclaration' && opts.moduleAll !== true) {
        return null;
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/compileForBundle/requireRewriteTransform.ts

  const ___$romejs$js_compiler$src$plugins$compileForBundle$requireRewriteTransform_ts$default = {
    name: 'requireRewriteTransform',
    enter(path) {
      const {node: node, context: context} = path;

      const {relativeSourcesToModuleId: relativeSourcesToModuleId, moduleId: moduleId} = ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getOptions(context);

      if (node.type === 'MemberExpression' &&
      ___$romejs$js_ast_utils$src$isReferenced_ts$default(path) &&
      ___$romejs$js_ast_utils$src$doesNodeMatchPattern_ts$default(node, 'module.exports')) {
        return ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
          name: ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId),
          loc: ___$romejs$js_ast_utils$src$inheritLoc_ts$default(node, 'module.exports')});
      }

      if (node.type === 'AssignmentExpression' &&
      ___$romejs$js_ast_utils$src$doesNodeMatchPattern_ts$default(node.left, 'module.exports')) {
        return ___$romejs$js_ast$src$core$AssignmentExpression_ts$assignmentExpression.create({
          operator: node.operator,
          left: ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
            name: ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId),
            loc: ___$romejs$js_ast_utils$src$inheritLoc_ts$default(node, 'module.exports')}),
          right: node.right});
      }

      if (node.type === 'TSImportEqualsDeclaration' &&
      node.moduleReference.type === 'TSExternalModuleReference') {
        return ___$romejs$js_ast_utils$src$template_ts$default.statement`const ${node.id} = require(${node.moduleReference.expression});`;
      }

      if (node.type !== 'CallExpression') {
        return node;
      }

      const {callee: callee} = node;
      if (callee.type !== 'Identifier' || callee.name !== 'require') {
        return node;
      }

      const sourceArg = node.arguments[0];
      if (sourceArg.type !== 'StringLiteral') {
        return node;
      }

      if (path.scope.hasBinding('require')) {
        return node;
      }

      const replacement = relativeSourcesToModuleId[sourceArg.value];
      if (typeof replacement === 'string') {
        return ___$romejs$js_ast$src$core$Identifier_ts$identifier.create({
          name: ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(replacement)});
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/compileForBundle/magicCJSTransform.ts

  const ___$romejs$js_compiler$src$plugins$compileForBundle$magicCJSTransform_ts$default = {
    name: 'magicCJSTransform',
    enter(path) {
      const {node: node, scope: scope, context: context} = path;
      const options = ___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getOptions(context);

      if (node.type === 'CallExpression' &&
      node.callee.type === 'Identifier' &&
      node.callee.name === 'require' &&
      scope.getBinding('require') === undefined) {
        const args = node.arguments;

        if (args.length !== 1) {
          return node;
        }

        const arg = args[0];

        if (arg.type !== 'StringLiteral') {
          return node;
        }

        const source = arg.value;

        if (Object.prototype.hasOwnProperty.call(
        options.relativeSourcesToModuleId,
        source)) {
          const resolved = options.relativeSourcesToModuleId[source];
          const sourceNode = ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral.create({
            value: resolved});
          return ___$romejs$js_ast_utils$src$template_ts$default.expression`Rome.require(${sourceNode})`;
        }
      }

      if (node.type === 'Program') {
        const source = ___$romejs$js_ast$src$core$StringLiteral_ts$stringLiteral.create({
          value: options.moduleId});

        const body = ___$romejs$js_ast$src$core$BlockStatement_ts$blockStatement.create({
          directives: node.directives,
          body: node.body});

        const factory = Object.assign({}, ___$romejs$js_ast$src$core$FunctionExpression_ts$functionExpression.assert(
        ___$romejs$js_ast_utils$src$template_ts$default.expression`(function(module, exports) {})`), {
          body: body});

        const wrapper = ___$romejs$js_ast_utils$src$template_ts$default.statement`Rome.declare(${source}, ${factory})`;

        return Object.assign({}, node, {
          directives: [],
          body: [wrapper]});
      }

      return node;
    }};

  // romejs/js-compiler/src/plugins/index.ts

  const ___$romejs$js_compiler$src$plugins$index_ts$stageOrder = ['pre', 'compile', 'compileForBundle'];

  const ___$romejs$js_compiler$src$plugins$index_ts$stageTransforms = {
    pre: () => [___$romejs$js_compiler$src$plugins$compile$validation$optimizeImports_ts$default, ___$romejs$js_compiler$src$plugins$compile$validation$optimizeExports_ts$default, ___$romejs$js_compiler$src$plugins$compile$jsx_ts$default],
    compile: () => [___$romejs$js_compiler$src$plugins$compile$transpile$objectSpread_ts$default, ___$romejs$js_compiler$src$plugins$compile$transpile$classProperties_ts$default],
    compileForBundle: (projectConfig, options) => {
      const opts = options.bundle;
      if (opts === undefined) {
        throw new Error('Expected bundle options for compileForBundle stage');
      }

      if (opts.mode === 'flat') {
        return [___$romejs$js_compiler$src$plugins$compileForBundle$requireRewriteTransform_ts$default, ___$romejs$js_compiler$src$plugins$compileForBundle$asyncImportTransform_ts$default, opts.moduleType === 'cjs' ? ___$romejs$js_compiler$src$plugins$compileForBundle$cjsRootTransform_ts$default : ___$romejs$js_compiler$src$plugins$compileForBundle$esToRefTransform_ts$default, ___$romejs$js_compiler$src$plugins$compile$stripTypeAnnotations_ts$default];
      } else {
        return [___$romejs$js_compiler$src$plugins$compileForBundle$magicCJSTransform_ts$default, ___$romejs$js_compiler$src$plugins$compile$stripTypeAnnotations_ts$default];
      }
    }};

  // romejs/js-compiler/src/methods/transform.ts

  const ___$$priv$romejs$js_compiler$src$methods$transform_ts$transformCaches = ___$romejs$js_compiler$src$plugins$index_ts$stageOrder.map(
  () => new ___$romejs$js_compiler$src$lib$Cache_ts$default());

  async function ___$romejs$js_compiler$src$methods$transform_ts$default(req) {
    const stage = req.stage === undefined ? 'compile' : req.stage;

    const {options: options, projectConfig: projectConfig} = req;
    let ast = req.ast;

    const cacheQuery = ___$romejs$js_compiler$src$lib$Cache_ts$default.buildQuery(req);

    const stageNo = ___$romejs$js_compiler$src$plugins$index_ts$stageOrder.indexOf(stage);

    const stageCache = ___$$priv$romejs$js_compiler$src$methods$transform_ts$transformCaches[stageNo];
    const cached = stageCache.get(cacheQuery);
    if (cached !== undefined) {
      return cached;
    }

    let prevStageDiagnostics = [];
    let prevStageCacheDeps = [];

    if (stageNo > 0) {
      const prevStage = await ___$romejs$js_compiler$src$methods$transform_ts$default(Object.assign({}, req, {
        stage: ___$romejs$js_compiler$src$plugins$index_ts$stageOrder[stageNo - 1]}));
      prevStageDiagnostics = prevStage.diagnostics;
      prevStageCacheDeps = prevStage.cacheDependencies;
      ast = prevStage.ast;
    }

    const context = new ___$romejs$js_compiler$src$lib$Context_ts$default({
      ast: ast,
      projectConfig: projectConfig,
      options: options,
      origin: 'Transforming'});

    const transformFactory = ___$romejs$js_compiler$src$plugins$index_ts$stageTransforms[stage];
    const transforms = transformFactory(projectConfig, options);
    const visitors = await context.normalizeTransforms(transforms);
    const compiledAst = ___$romejs$js_ast$src$core$Program_ts$program.assert(context.reduce(ast, visitors));

    const res = {
      diagnostics: [...prevStageDiagnostics, ...context.diagnostics],
      cacheDependencies: [...prevStageCacheDeps, ...context.getCacheDependencies()],
      ast: compiledAst};
    stageCache.set(cacheQuery, res);
    return res;
  }

  // romejs/js-compiler/src/api/compile.ts

  const ___$$priv$romejs$js_compiler$src$api$compile_ts$compileCache = new ___$romejs$js_compiler$src$lib$Cache_ts$default();

  async function ___$romejs$js_compiler$src$api$compile_ts$default(req) {
    const {ast: ast, src: src} = req;

    const query = ___$romejs$js_compiler$src$lib$Cache_ts$default.buildQuery(req);
    const cached = ___$$priv$romejs$js_compiler$src$api$compile_ts$compileCache.get(query);
    if (cached) {
      return cached;
    }

    const {filename: filename} = ast;
    const {ast: transformedAst, diagnostics: diagnostics, cacheDependencies: cacheDependencies} = await ___$romejs$js_compiler$src$methods$transform_ts$default(
    req);
    const generator = ___$romejs$js_generator$src$index_ts$default(
    transformedAst,
    {
      indent: req.stage === 'compileForBundle' ? 1 : 0,
      sourceMapTarget: filename,
      sourceFileName: filename},
    src);
    const res = {
      code: generator.getCode(),
      mappings: generator.getMappings(),
      src: src,
      diagnostics: [...ast.diagnostics, ...diagnostics],
      cacheDependencies: cacheDependencies};
    ___$$priv$romejs$js_compiler$src$api$compile_ts$compileCache.set(query, res);
    return res;
  }

  // romejs/js-compiler/src/api/analyzeDependencies.ts

  const ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$analyzeCache = new ___$romejs$js_compiler$src$lib$Cache_ts$default();

  class ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportRecord extends ___$romejs$js_compiler$src$lib$Record_ts$default {
    constructor(data) {
      super();
      this.data = data;
    }
  }

  class ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ExportRecord extends ___$romejs$js_compiler$src$lib$Record_ts$default {
    constructor(data) {
      super();
      this.data = data;
    }
  }

  class ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$CJSExportRecord extends ___$romejs$js_compiler$src$lib$Record_ts$default {
    constructor(node) {
      super();
      this.node = node;
    }
  }

  class ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ESExportRecord extends ___$romejs$js_compiler$src$lib$Record_ts$default {
    constructor(kind, node) {
      super();
      this.node = node;
      this.kind = kind;
    }
  }

  class ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$TopLevelAwaitRecord extends ___$romejs$js_compiler$src$lib$Record_ts$default {
    constructor(loc) {
      super();
      this.loc = loc;
    }
  }

  class ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportUsageRecord extends ___$romejs$js_compiler$src$lib$Record_ts$default {
    constructor(inFunction, data) {
      super();
      this.inFunction = inFunction;
      this.data = data;
    }
  }

  function ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$isOptional(path) {
    for (const {node: node} of path.ancestryPaths) {
      if (node.type === 'TryStatement') {
        return true;
      }
    }

    return false;
  }

  function ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$isTypeKind(kind) {
    return kind === 'type' || kind === 'typeof';
  }

  function ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKind(kind) {
    return ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$isTypeKind(kind) ? 'type' : 'value';
  }

  function ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKindWithSpecifiers(rawKind, specifierKinds) {
    const kind = ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKind(rawKind);
    if (___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$isTypeKind(kind) || specifierKinds.length === 0) {
      return kind;
    }

    for (const specifierKind of specifierKinds) {
      if (specifierKind === 'value') {
        return 'value';
      }
    }
    return 'type';
  }

  const ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$analyzeVisitor = function(path) {
    const {node: node, scope: scope, context: context} = path;

    if (node.type === 'CallExpression') {
      const {callee: callee, arguments: args} = node;

      const isRequire = callee.type === 'Identifier' &&
      callee.name === 'require' &&
      path.scope.hasBinding('require') === false;
      const sourceArg = args[0];

      if (isRequire && args.length === 1 && sourceArg.type === 'StringLiteral') {
        context.record(
        new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportRecord({
          type: 'cjs',
          kind: 'value',
          optional: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$isOptional(path),
          loc: node.loc,
          source: sourceArg.value,
          names: [],
          all: true,
          async: false}));
      }
    }

    if (node.type === 'CallExpression' && node.callee.type === 'Import') {
      const args = node.arguments;
      const sourceArg = args[0];
      if (args.length === 1 && sourceArg.type === 'StringLiteral') {
        context.record(
        new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportRecord({
          type: 'es',
          async: true,
          kind: 'value',
          names: [],
          loc: sourceArg.loc,
          source: sourceArg.value,
          optional: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$isOptional(path),
          all: true}));
      }
    }

    if (node.type === 'ExportNamedDeclaration' && node.source === undefined) {
      const hoisted = node.declaration !== undefined &&
      node.declaration.type === 'FunctionDeclaration';
      for (const {name: name, loc: loc} of ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(node)) {
        context.record(
        new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ExportRecord({
          type: 'local',
          hoisted: hoisted,
          kind: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKind(node.exportKind),
          loc: loc,
          name: name}));
      }

      if (node.specifiers !== undefined) {
        for (const specifier of node.specifiers) {
          const binding = scope.getBinding(specifier.local.name);

          let kind = ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKind(
          specifier.exportKind || node.exportKind);
          if (kind === 'value' && binding instanceof ___$romejs$js_compiler$src$scope$bindings_ts$TypeBinding) {
            kind = 'type';
          }

          context.record(
          new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ExportRecord({
            type: 'local',
            loc: specifier.loc,
            hoisted: binding instanceof ___$romejs$js_compiler$src$scope$bindings_ts$FunctionBinding,
            kind: kind,
            name: specifier.exported.name}));
        }
      }
    }

    if (node.type === 'ExportDefaultDeclaration') {
      context.record(
      new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ExportRecord({
        type: 'local',
        loc: node.declaration.loc,
        hoisted: node.declaration.type === 'FunctionDeclaration',
        kind: 'value',
        name: 'default'}));
    }

    if (node.type === 'ExportNamedDeclaration') {
      const {source: source} = node;
      if (source !== undefined) {
        const specifiersKinds = [];
        const exportedNames = [];

        if (node.specifiers !== undefined) {
          for (const specifier of node.specifiers) {
            const kind = ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKind(specifier.exportKind || node.exportKind);
            specifiersKinds.push(kind);

            exportedNames.push({
              name: specifier.local.name,
              kind: kind,
              loc: specifier.loc});

            context.record(
            new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ExportRecord({
              type: 'external',
              kind: kind,
              loc: specifier.loc,
              imported: specifier.local.name,
              exported: specifier.exported.name,
              source: source.value}));
          }
        }

        context.record(
        new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportRecord({
          type: 'es',
          async: false,
          kind: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKindWithSpecifiers(node.exportKind, specifiersKinds),
          names: exportedNames,
          loc: source.loc,
          source: source.value,
          optional: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$isOptional(path),
          all: false}));
      }
    }

    if (node.type === 'TSImportEqualsDeclaration' &&
    node.moduleReference.type === 'TSExternalModuleReference') {
      context.record(
      new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportRecord({
        type: 'cjs',
        kind: 'value',
        optional: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$isOptional(path),
        loc: node.loc,
        source: node.moduleReference.expression.value,
        names: [],
        all: true,
        async: false}));
    }

    if (node.type === 'ExportAllDeclaration') {
      context.record(
      new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportRecord({
        type: 'es',
        async: false,
        kind: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKind(node.exportKind),
        optional: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$isOptional(path),
        loc: node.source.loc,
        names: [],
        source: node.source.value,
        all: true}));

      context.record(
      new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ExportRecord({
        type: 'externalAll',
        loc: node.loc,
        kind: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKind(node.exportKind),
        source: node.source.value}));
    }

    if (node.type === 'ExportAllDeclaration' ||
    node.type === 'ExportDefaultDeclaration' ||
    node.type === 'ExportNamedDeclaration') {
      context.record(new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ESExportRecord(___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKind(node.exportKind), node));
    }

    if (node.type === 'ImportDeclaration') {
      let hasNamespaceSpecifier = false;
      const specifierKinds = [];
      const names = [];

      for (const specifier of node.specifiers) {
        if (specifier.type === 'ImportNamespaceSpecifier') {
          hasNamespaceSpecifier = true;
          break;
        }

        const kind = ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKind(
        specifier.importKind || node.importKind);
        specifierKinds.push(kind);

        if (specifier.type === 'ImportDefaultSpecifier') {
          names.push({
            kind: kind,
            loc: specifier.loc,
            name: 'default'});
        }

        if (specifier.type === 'ImportSpecifier') {
          names.push({
            kind: kind,
            loc: specifier.loc,
            name: specifier.imported.name});
        }
      }

      context.record(
      new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportRecord({
        type: 'es',
        async: false,
        kind: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKindWithSpecifiers(node.importKind, specifierKinds),
        loc: node.source.loc,
        optional: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$isOptional(path),
        source: node.source.value,
        all: hasNamespaceSpecifier,
        names: names}));
    }

    if (node.type === 'AssignmentExpression') {
      const isModuleExports = path.scope.getBinding('module') === undefined &&
      ___$romejs$js_ast_utils$src$doesNodeMatchPattern_ts$default(node.left, 'module.exports', true);
      const isExports = path.scope.getBinding('exports') === undefined &&
      ___$romejs$js_ast_utils$src$doesNodeMatchPattern_ts$default(node.left, 'exports', true);

      if (isModuleExports || isExports) {
        context.record(new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$CJSExportRecord(node));
      }
    }

    if (node.type === 'AwaitExpression' &&
    path.findAncestry(path => ___$romejs$js_ast_utils$src$isFunctionNode_ts$default(path.node)) === undefined) {
      context.record(new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$TopLevelAwaitRecord(node.loc));
    }

    if (node.type === 'Identifier' && ___$romejs$js_ast_utils$src$isReferenced_ts$default(path)) {
      const binding = path.scope.getBinding(node.name);
      if (binding !== undefined && binding instanceof ___$romejs$js_compiler$src$scope$bindings_ts$ImportBinding) {
        const {meta: meta} = binding;

        if (meta.type !== 'name') {
          return node;
        }

        const parentFunction = path.findAncestry(path => ___$romejs$js_ast_utils$src$isFunctionNode_ts$default(path.node));

        let kind = ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$getKind(meta.kind);

        if (___$romejs$js_ast_utils$src$isTypeNode_ts$default(path.parent) ||
        path.parentPath !== undefined && ___$romejs$js_ast_utils$src$isTypeNode_ts$default(path.parentPath.parent)) {
          kind = 'type';
        }

        context.record(
        new ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportUsageRecord(parentFunction !== undefined, {
          kind: kind,
          loc: node.loc,
          local: node.name,
          imported: meta.imported,
          source: meta.source}));
      }
    }

    return node;
  };

  async function ___$romejs$js_compiler$src$api$analyzeDependencies_ts$default(req) {
    const {ast: ast, projectConfig: projectConfig} = req;

    const query = ___$romejs$js_compiler$src$lib$Cache_ts$default.buildQuery(req);
    const cached = ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$analyzeCache.get(query);
    if (cached) {
      return cached;
    }

    const context = new ___$romejs$js_compiler$src$lib$Context_ts$default({
      ast: ast,
      projectConfig: projectConfig,
      origin: 'Analyzing dependencies'});
    const {ast: transformedAst} = await ___$romejs$js_compiler$src$methods$transform_ts$default(Object.assign({}, req, {
      stage: 'pre'}));
    context.reduce(transformedAst, [{name: 'analyzeDependencies', enter: ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$analyzeVisitor}]);

    const importFirstUsage = [];
    const seenImportFirstUsage = new Set();

    const exports = [];
    const dependenciesBySource = new Map();

    const esValueExports = [];
    const cjsExports = [];
    let firstTopAwaitLocation;

    const sourcesUsedAsType = new Set();
    const sourcesUsedAsValue = new Set();
    for (const record of context.records) {
      if (record instanceof ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ExportRecord || record instanceof ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportUsageRecord) {
        if (record instanceof ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ExportRecord && record.data.type === 'local') {
          continue;
        }

        const {kind: kind, source: source} = record.data;
        if (kind === 'type') {
          sourcesUsedAsType.add(source);
        } else {
          sourcesUsedAsValue.add(source);
        }
      }
    }
    for (const source of sourcesUsedAsValue) {
      sourcesUsedAsType.delete(source);
    }

    for (const record of context.records) {
      if (record instanceof ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportRecord) {
        let {data: data} = record;

        if (data.kind === 'value' && sourcesUsedAsType.has(data.source)) {
          const names = [];

          for (const name of names) {
            names.push(Object.assign({}, name, {
              kind: 'type'}));
          }

          data = Object.assign({}, data, {
            kind: 'type', names: names});
        }

        const existing = dependenciesBySource.get(data.source);
        if (existing === undefined) {
          dependenciesBySource.set(data.source, data);
        } else {
          let kind;
          if (data.kind === existing.kind) {
            kind = data.kind;
          } else {
            kind = 'value';
          }

          const combinedRecord = {
            type: data.type === 'es' && existing.type === 'es' ? 'es' : 'cjs',
            kind: kind,
            optional: existing.optional && data.optional,
            async: existing.async || data.async,
            source: data.source,
            all: existing.all || data.all,
            names: [...existing.names, ...data.names],
            loc: existing.loc || data.loc};

          if (existing.kind === 'type' && data.kind === 'value') {
            dependenciesBySource.delete(data.source);
          }

          dependenciesBySource.set(data.source, combinedRecord);
        }
      } else if (record instanceof ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ExportRecord) {
        exports.push(record.data);
      } else if (record instanceof ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$CJSExportRecord) {
        cjsExports.push(record.node);
      } else if (record instanceof ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ESExportRecord) {
        if (record.kind === 'value') {
          esValueExports.push(record.node);
        }
      } else if (record instanceof ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$TopLevelAwaitRecord) {
        if (firstTopAwaitLocation === undefined) {
          firstTopAwaitLocation = record.loc;
        }
      } else if (record instanceof ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$ImportUsageRecord &&
      !record.inFunction &&
      record.data.kind === 'value') {
        const {data: data} = record;
        const key = `${data.source}:${data.imported}`;
        if (seenImportFirstUsage.has(key)) {
          continue;
        }

        seenImportFirstUsage.add(key);
        importFirstUsage.push(data);
      }
    }

    if (cjsExports.length > 0 && esValueExports.length > 0) {
      for (const node of cjsExports) {
        context.addNodeDiagnostic(node, {
          category: 'analyzeDependencies',
          message: 'You cannot use CommonJS exports in a file that has also has ES module exports'});
      }
    }

    const dependencies = Array.from(
    dependenciesBySource.values());

    let type = 'unknown';
    if (cjsExports.length > 0) {
      type = 'cjs';
    } else if (esValueExports.length > 0) {
      type = 'es';
    }

    const res = {
      type: type,
      firstTopAwaitLocation: firstTopAwaitLocation,
      exports: exports,
      dependencies: dependencies,
      importFirstUsage: importFirstUsage,
      syntax: ast.syntax,
      diagnostics: [...ast.diagnostics, ...context.diagnostics]};
    ___$$priv$romejs$js_compiler$src$api$analyzeDependencies_ts$analyzeCache.set(query, res);
    return res;
  }

  // romejs/js-compiler/src/scope/bindings.ts

  const ___$romejs$js_compiler$src$scope$bindings_ts = {
    get Binding() {
      return ___$romejs$js_compiler$src$scope$bindings_ts$Binding;
    },
    get ConstBinding() {
      return ___$romejs$js_compiler$src$scope$bindings_ts$ConstBinding;
    },
    get LetBinding() {
      return ___$romejs$js_compiler$src$scope$bindings_ts$LetBinding;
    },
    get VarBinding() {
      return ___$romejs$js_compiler$src$scope$bindings_ts$VarBinding;
    },
    get ImportBinding() {
      return ___$romejs$js_compiler$src$scope$bindings_ts$ImportBinding;
    },
    get ArgumentsBinding() {
      return ___$romejs$js_compiler$src$scope$bindings_ts$ArgumentsBinding;
    },
    get FunctionBinding() {
      return ___$romejs$js_compiler$src$scope$bindings_ts$FunctionBinding;
    },
    get TypeBinding() {
      return ___$romejs$js_compiler$src$scope$bindings_ts$TypeBinding;
    },
    get ClassBinding() {
      return ___$romejs$js_compiler$src$scope$bindings_ts$ClassBinding;
    }};
  let ___$$priv$romejs$js_compiler$src$scope$bindings_ts$id = 0;

  class ___$romejs$js_compiler$src$scope$bindings_ts$Binding {
    constructor(opts) {
      this.isExported = false;
      this.scope = opts.scope;
      this.name = opts.name;
      this.node = opts.node;
      this.id = ___$$priv$romejs$js_compiler$src$scope$bindings_ts$id++;
    }

    setExported(isExported) {
      this.isExported = isExported;
    }
  }

  class ___$romejs$js_compiler$src$scope$bindings_ts$ConstBinding extends ___$romejs$js_compiler$src$scope$bindings_ts$Binding {}

  class ___$romejs$js_compiler$src$scope$bindings_ts$LetBinding extends ___$romejs$js_compiler$src$scope$bindings_ts$Binding {}

  class ___$romejs$js_compiler$src$scope$bindings_ts$VarBinding extends ___$romejs$js_compiler$src$scope$bindings_ts$Binding {}

  class ___$romejs$js_compiler$src$scope$bindings_ts$ImportBinding extends ___$romejs$js_compiler$src$scope$bindings_ts$Binding {
    constructor(opts, meta) {
      super(opts);
      this.meta = meta;
    }
  }

  class ___$romejs$js_compiler$src$scope$bindings_ts$ArgumentsBinding extends ___$romejs$js_compiler$src$scope$bindings_ts$Binding {}

  class ___$romejs$js_compiler$src$scope$bindings_ts$FunctionBinding extends ___$romejs$js_compiler$src$scope$bindings_ts$Binding {}

  class ___$romejs$js_compiler$src$scope$bindings_ts$TypeBinding extends ___$romejs$js_compiler$src$scope$bindings_ts$Binding {}

  class ___$romejs$js_compiler$src$scope$bindings_ts$ClassBinding extends ___$romejs$js_compiler$src$scope$bindings_ts$Binding {}

  // romejs/js-compiler/src/types.ts

  const ___$romejs$js_compiler$src$types_ts = {};

  // romejs/js-compiler/src/index.ts


  // romejs/js-analysis/src/Graph.ts

  class ___$romejs$js_analysis$src$Graph_ts$default {
    constructor() {
      this.nodes = [];
      this.nodesByValue = new Map();
    }

    addNode(value) {
      if (this.find(value)) {
        return undefined;
      }

      const node = {lines: [], value: value};
      this.nodesByValue.set(value, node);
      this.nodes.push(node);
    }

    find(value) {
      return this.nodesByValue.get(value);
    }

    hasConnections(value) {
      const node = this.nodesByValue.get(value);
      return node !== undefined && node.lines.length > 0;
    }

    addLine(startValue, endValue) {
      const startNode = this.find(startValue);
      const endNode = this.find(endValue);

      if (!startNode || !endNode) {
        throw new Error('Both nodes need to exist');
      }

      startNode.lines.push(endNode);
    }
  }

  // romejs/js-analysis/src/types/T.ts

  let ___$$priv$romejs$js_analysis$src$types$T_ts$counter = 0;

  class ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode) {
      this.human = undefined;
      this.scope = scope;

      const {hub: hub} = scope;
      this.hub = hub;
      this.utils = hub.utils;
      this.evaluator = hub.evaluator;
      this.originEvaluator = scope.evaluator.evaluatingType;

      this.graph = scope.evaluator.graph;
      this.graph.addNode(this);

      this.originNode = originNode;
      this.originLoc = originNode === undefined ? undefined : originNode.loc;
      this.id = `${String(process.pid)}:${String(___$$priv$romejs$js_analysis$src$types$T_ts$counter++)}`;

      this.compatibilityCache = new Map();
    }

    getConstructor() {
      return this.constructor;
    }

    setHuman(human) {
      this.human = human;
    }

    shouldMatch(type) {
      this.hub.assertOpen();
      this.graph.addLine(this, type);
    }

    hasConnections() {
      return this.graph.hasConnections(this);
    }

    explodeUnion() {
      return [this];
    }

    compatibleWith(otherType) {
      return otherType instanceof this.constructor;
    }

    clone() {
      const idsToType = new Map();

      const addType = type => {
        const reduced = this.utils.reduce(type);
        idsToType.set(type.id, type);
        return reduced.id;
      };

      const data = this.serialize(addType);

      const getType = id => {
        if (typeof id !== 'string') {
          throw new Error('Expected id to be a string');
        }

        const type = idsToType.get(id);
        if (type === undefined) {
          throw new Error('Expected type');
        }
        return type;
      };

      return this.getConstructor().hydrate(
      this.scope,
      this.originNode,
      data,
      getType);
    }

    static hydrate(scope, originNode, data, getType) {
      throw new Error(`Unimplemented ${this.type}.hydrate`);
    }

    serialize(addType) {
      throw new Error(`Unimplemented ${this.getConstructor().type}.prototype.serialize`);
    }

    reduce() {
      return this;
    }

    humanize(builder) {
      const reduced = this.utils.reduce(this);
      if (reduced === this) {
        throw new Error('unimplemented');
      } else {
        return builder.humanize(reduced);
      }
    }

    inspect() {
      return this.utils.inspect(this);
    }
  }
  ___$romejs$js_analysis$src$types$T_ts$default.type = 'T';

  // romejs/js-analysis/src/types/UnknownT.ts

  class ___$romejs$js_analysis$src$types$UnknownT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___$romejs$js_analysis$src$types$UnknownT_ts$default(scope, originNode);
    }

    humanize() {
      return 'unknown';
    }

    compatibleWith() {
      return false;
    }
  }
  ___$romejs$js_analysis$src$types$UnknownT_ts$default.type = 'UnknownT';

  // romejs/js-analysis/src/types/OpenT.ts

  class ___$romejs$js_analysis$src$types$OpenT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    humanize(builder) {
      const type = this.utils.reduce(this);
      if (type === this) {
        return 'open';
      } else {
        return builder.humanize(type);
      }
    }

    reduce() {
      const node = this.graph.find(this);
      if (node === undefined) {
        return new ___$romejs$js_analysis$src$types$UnknownT_ts$default(this.scope, this.originLoc);
      }

      const values = node.lines.map(line => this.utils.reduce(line.value));
      return this.scope.createUnion(values, this.originNode);
    }
  }
  ___$romejs$js_analysis$src$types$OpenT_ts$default.type = 'OpenT';

  // romejs/js-analysis/src/types/OpenIntrinsicT.ts

  class ___$romejs$js_analysis$src$types$OpenIntrinsicT_ts$default extends ___$romejs$js_analysis$src$types$OpenT_ts$default {
    constructor(scope, originNode, name) {
      super(scope, originNode);
      this.name = name;
    }

    serialize() {
      return {
        name: this.name};
    }

    static hydrate(scope, originNode, data) {
      return scope.intrinsics.get(String(data.name));
    }

    humanize() {
      return 'open intrinsic';
    }
  }
  ___$romejs$js_analysis$src$types$OpenIntrinsicT_ts$default.type = 'OpenIntrinsicT';

  // romejs/js-analysis/src/Intrinsics.ts

  class ___$romejs$js_analysis$src$Intrinsics_ts$default {
    constructor(scope) {
      this.scope = scope;

      this.intrinsicByName = new Map();

      this.NumberPrototype = this.createOpenT('NumberPrototype');
      this.Number = this.createOpenT('Number');

      this.StringPrototype = this.createOpenT('StringPrototype');
      this.String = this.createOpenT('String');

      this.ObjectPrototype = this.createOpenT('ObjectPrototype');
      this.Object = this.createOpenT('Object');

      this.ArrayPrototype = this.createOpenT('ArrayPrototype');
      this.Array = this.createOpenT('Array');

      this.RegExpPrototype = this.createOpenT('RegExpPrototype');
      this.RegExp = this.createOpenT('RegExp');
    }

    get(name) {
      const t = this.intrinsicByName.get(name);
      if (t === undefined) {
        throw new Error(`No intrinsic found for ${name}`);
      }
      return t;
    }

    createOpenT(name) {
      const t = new ___$romejs$js_analysis$src$types$OpenIntrinsicT_ts$default(this.scope, undefined, name);
      this.intrinsicByName.set(name, t);
      return t;
    }

    link() {
      this.String.shouldMatch(this.scope.query(['String']));
      this.StringPrototype.shouldMatch(this.scope.query(['String', 'prototype']));

      this.Object.shouldMatch(this.scope.query(['Object']));
      this.ObjectPrototype.shouldMatch(this.scope.query(['Object', 'prototype']));

      this.Array.shouldMatch(this.scope.query(['Array']));
      this.ArrayPrototype.shouldMatch(this.scope.query(['Array', 'prototype']));

      this.RegExp.shouldMatch(this.scope.query(['RegExp']));
      this.RegExpPrototype.shouldMatch(this.scope.query(['RegExp', 'prototype']));

      this.Number.shouldMatch(this.scope.query(['Number']));
      this.NumberPrototype.shouldMatch(this.scope.query(['Number', 'prototype']));
    }
  }

  // romejs/js-analysis/src/types/AnyT.ts

  class ___$romejs$js_analysis$src$types$AnyT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___$romejs$js_analysis$src$types$AnyT_ts$default(scope, originNode);
    }

    compatibleWith() {
      return true;
    }

    humanize() {
      return 'any';
    }
  }
  ___$romejs$js_analysis$src$types$AnyT_ts$default.type = 'AnyT';

  // romejs/js-analysis/src/types/BooleanLiteralT.ts

  class ___$romejs$js_analysis$src$types$BooleanLiteralT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, value) {
      super(scope, originNode);
      this.value = value;
    }

    serialize() {
      return {value: this.value};
    }

    static hydrate(scope, originNode, data) {
      return new ___$romejs$js_analysis$src$types$BooleanLiteralT_ts$default(scope, originNode, Boolean(data.value));
    }

    humanize() {
      if (this.value === true) {
        return 'true';
      } else {
        return 'false';
      }
    }

    compatibleWith(type) {
      return type instanceof ___$romejs$js_analysis$src$types$BooleanLiteralT_ts$default && type.value === this.value;
    }
  }
  ___$romejs$js_analysis$src$types$BooleanLiteralT_ts$default.type = 'BooleanLiteralT';

  // romejs/js-analysis/src/types/BooleanT.ts

  class ___$romejs$js_analysis$src$types$BooleanT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___$romejs$js_analysis$src$types$BooleanT_ts$default(scope, originNode);
    }

    humanize() {
      return 'boolean';
    }

    compatibleWith(type) {
      return type instanceof ___$romejs$js_analysis$src$types$BooleanT_ts$default || type instanceof ___$romejs$js_analysis$src$types$BooleanLiteralT_ts$default;
    }
  }
  ___$romejs$js_analysis$src$types$BooleanT_ts$default.type = 'BooleanT';

  // romejs/js-analysis/src/types/errors/E.ts

  class ___$romejs$js_analysis$src$types$errors$E_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    static hydrate(scope, originNode) {
      return new ___$romejs$js_analysis$src$types$AnyT_ts$default(scope, originNode);
    }

    humanize() {
      return this.getError().message;
    }

    getError() {
      throw new Error('unimplemented');
    }

    compatibleWith() {
      return false;
    }
  }
  ___$romejs$js_analysis$src$types$errors$E_ts$default.type = 'E';

  // romejs/js-analysis/src/types/errors/NotCallableE.ts

  class ___$romejs$js_analysis$src$types$errors$NotCallableE_ts$default extends ___$romejs$js_analysis$src$types$errors$E_ts$default {
    constructor(scope, originNode, callee) {
      super(scope, originNode);
      this.callee = callee;
    }

    getError() {
      return {
        message: `This type isn't callable`,
        lowerTarget: this.callee};
    }
  }
  ___$romejs$js_analysis$src$types$errors$NotCallableE_ts$default.type = 'NotCallableE';

  // romejs/js-analysis/src/types/ObjPropT.ts

  class ___$romejs$js_analysis$src$types$ObjPropT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, key, value) {
      super(scope, originNode);
      this.key = key;
      this.value = value;
    }

    serialize(addType) {
      return {
        key: this.key,
        value: addType(this.value)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$ObjPropT_ts$default(scope, originNode, String(data.key), getType(data.value));
    }

    compatibleWith(otherType) {
      if (otherType instanceof ___$romejs$js_analysis$src$types$ObjPropT_ts$default && otherType.key === this.key) {
        return this.utils.checkCompability(this.value, otherType.value);
      } else {
        return false;
      }
    }

    humanize(builder) {
      return `${this.key}: ${builder.humanize(this.value)}`;
    }
  }
  ___$romejs$js_analysis$src$types$ObjPropT_ts$default.type = 'ObjPropT';

  // romejs/js-analysis/src/types/ObjT.ts

  class ___$romejs$js_analysis$src$types$ObjT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.calls = opts.calls === undefined ? [] : opts.calls;
      this.props = opts.props === undefined ? [] : opts.props;
      this.proto = opts.proto;
    }

    serialize(addType) {
      ___$romejs$invariant$src$index_ts$default(
      this.constructor === ___$romejs$js_analysis$src$types$ObjT_ts$default,
      'expected ObjT to be constructor, youve likely forgot to define this method in the type subclass');
      return {
        calls: this.calls.map(type => addType(type)),
        proto: this.proto === undefined ? null : addType(this.proto),
        props: this.props.map(type => addType(type))};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$ObjT_ts$default(scope, originNode, {
        props: Array(data.props).map(id => getType(id)),
        proto: data.proto === undefined ? undefined : getType(data.proto),
        calls: Array(data.calls).map(id => getType(id))});
    }

    compatibleWith(otherType) {
      if (!(otherType instanceof ___$romejs$js_analysis$src$types$ObjT_ts$default)) {
        return false;
      }

      const ourProps = this.props;
      const theirProps = otherType.props;

      for (const ourPropRaw of ourProps) {
        const ourProp = this.utils.reduce(ourPropRaw);
        let key;
        if (ourProp instanceof ___$romejs$js_analysis$src$types$ObjPropT_ts$default) {
          key = ourProp.key;
        } else {
          continue;
        }

        let theirProp;
        for (const theirPropRaw of theirProps) {
          const maybeTheirProp = this.utils.reduce(theirPropRaw);
          if (maybeTheirProp instanceof ___$romejs$js_analysis$src$types$ObjPropT_ts$default && maybeTheirProp.key === key) {
            theirProp = maybeTheirProp;
            break;
          }
        }

        if (!ourProp || !theirProp) {
          return false;
        }

        const compatibility = this.utils.checkCompability(ourProp, theirProp);
        if (compatibility.type === 'incompatible') {
          return compatibility;
        }
      }

      return true;
    }

    humanize(builder) {
      if (this.props.length === 0) {
        return '{}';
      } else {
        return ['{', ...this.props.map(prop => {
          const val = builder.humanize(prop);
          let lines = val.split('\n');
          lines = lines.map(line => '  ' + line);
          return lines.join('\n') + ',';
        }), '}'].join('\n');
      }
    }
  }
  ___$romejs$js_analysis$src$types$ObjT_ts$default.type = 'ObjT';

  // romejs/js-analysis/src/types/FunctionT.ts

  class ___$romejs$js_analysis$src$types$FunctionT_ts$default extends ___$romejs$js_analysis$src$types$ObjT_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode, {
        props: opts.props,
        proto: opts.proto,
        calls: []});
      this.params = opts.params;
      this.rest = opts.rest;
      this.returns = opts.returns;
      this.body = opts.body;
    }

    serialize(addType) {
      return {
        params: this.params.map(type => addType(type)),
        rest: this.rest ? addType(this.rest) : undefined,
        returns: addType(this.returns),
        proto: this.proto === undefined ? null : addType(this.proto),
        body: this.body === undefined ? null : addType(this.body),
        props: this.props.map(type => addType(type))};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$FunctionT_ts$default(scope, originNode, {
        params: Array(data.params).map(id => getType(id)),
        rest: data.rest === undefined ? undefined : getType(data.rest),
        returns: getType(data.returns),
        props: Array(data.props).map(id => getType(id)),
        proto: data.proto === undefined ? undefined : getType(data.proto),
        body: data.body === undefined ? undefined : getType(data.body)});
    }

    humanize(builder) {
      return `(${this.params.map(param => builder.humanize(param)).join(', ')}) => ${builder.humanize(this.returns)}`;
    }

    reduce() {
      const {body: body} = this;
      if (body === undefined) {
        return this;
      }

      const reducedBody = this.utils.reduce(body);
      if (reducedBody !== body) {
        return new ___$romejs$js_analysis$src$types$FunctionT_ts$default(this.scope, this.originNode, {
          params: this.params,
          rest: this.rest,
          returns: this.returns,
          props: this.props,
          proto: this.proto,
          body: reducedBody});
      }

      return this;
    }
  }
  ___$romejs$js_analysis$src$types$FunctionT_ts$default.type = 'FunctionT';

  // romejs/js-analysis/src/types/CallT.ts

  class ___$romejs$js_analysis$src$types$CallT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, callee, args) {
      super(scope, originNode);
      this.callee = callee;
      this.args = args;
    }

    reduce() {
      let callee = this.utils.reduce(this.callee);
      if (callee instanceof ___$romejs$js_analysis$src$types$ObjT_ts$default && callee.calls.length) {
        callee = this.utils.reduce(callee.calls[0]);
      }

      if (callee instanceof ___$romejs$js_analysis$src$types$AnyT_ts$default || callee instanceof ___$romejs$js_analysis$src$types$errors$E_ts$default) {
        return new ___$romejs$js_analysis$src$types$AnyT_ts$default(this.scope, this.originNode);
      } else if (callee instanceof ___$romejs$js_analysis$src$types$FunctionT_ts$default) {
        return this.utils.reduce(callee.returns);
      } else {
        return new ___$romejs$js_analysis$src$types$errors$NotCallableE_ts$default(this.scope, this.originNode, this.callee);
      }
    }
  }
  ___$romejs$js_analysis$src$types$CallT_ts$default.type = 'CallT';

  // romejs/js-analysis/src/types/StringLiteralT.ts

  class ___$romejs$js_analysis$src$types$StringLiteralT_ts$default extends ___$romejs$js_analysis$src$types$ObjT_ts$default {
    constructor(scope, originNode, value) {
      super(scope, originNode, {
        props: [],
        proto: scope.intrinsics.StringPrototype,
        calls: []});
      this.value = value;
    }

    serialize() {
      return {value: this.value};
    }

    static hydrate(scope, originNode, data) {
      return new ___$romejs$js_analysis$src$types$StringLiteralT_ts$default(scope, originNode, String(data.value));
    }

    humanize() {
      let str = JSON.stringify(this.value);
      if (this.value.includes('\'')) {
        return str;
      } else {
        return `'${str.slice(1, -1)}'`;
      }
    }

    compatibleWith(type) {
      return type instanceof ___$romejs$js_analysis$src$types$StringLiteralT_ts$default && type.value === this.value;
    }
  }
  ___$romejs$js_analysis$src$types$StringLiteralT_ts$default.type = 'StringLiteralT';

  // romejs/js-analysis/src/utils/findClosestStringMatch.ts

  function ___$romejs$js_analysis$src$utils$findClosestStringMatch_ts$default(key, matches) {
    if (matches.length === 0) {
      return undefined;
    }

    if (matches.length === 1) {
      return matches[0];
    }

    const ratings = ___$romejs$string_utils$src$orderBySimilarity_ts$orderBySimilarity(key, matches);
    const bestMatch = ratings[0];

    if (bestMatch.rating > 0) {
      return undefined;
    } else {
      return bestMatch.target;
    }
  }

  // romejs/js-analysis/src/types/errors/UnknownPropE.ts

  class ___$romejs$js_analysis$src$types$errors$UnknownPropE_ts$default extends ___$romejs$js_analysis$src$types$errors$E_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.thisKeys = opts.thisKeys;
      this.protoKeys = opts.protoKeys;
      this.allProps = [...this.thisKeys, ...this.protoKeys];
      this.key = opts.key;
      this.object = opts.object;
      this.property = opts.property;
    }

    sortProps(props) {
      if (props.length === 0) {
        return props;
      }

      const ratings = ___$romejs$string_utils$src$orderBySimilarity_ts$orderBySimilarity(this.key, props);
      const sortedProps = ratings.map(prop => prop.target);
      return sortedProps;
    }

    getError() {
      let message = `Property '${this.key}' not found in`;

      const suggestion = ___$romejs$js_analysis$src$utils$findClosestStringMatch_ts$default(this.key, this.allProps);

      let infoMessage = '';
      let infoList = undefined;

      if (suggestion === undefined && this.allProps.length > 0) {
        infoMessage = 'Possible object properties are';

        infoList = [...this.sortProps(this.thisKeys), ...this.sortProps(this.protoKeys)];
      } else if (suggestion !== undefined) {
        infoMessage = `Did you mean '${suggestion}'?`;
      } else {
        infoMessage = 'There are no properties.';
      }

      const advice = [{
        type: 'log',
        category: 'info',
        message: infoMessage}];

      if (infoList !== undefined) {
        advice.push({
          type: 'list',
          list: infoList});
      }

      return {
        message: message,
        advice: advice,
        lowerTarget: this.property,
        upperTarget: this.object};
    }
  }
  ___$romejs$js_analysis$src$types$errors$UnknownPropE_ts$default.type = 'UnknownPropE';

  // romejs/js-analysis/src/types/ObjIndexPropT.ts

  class ___$romejs$js_analysis$src$types$ObjIndexPropT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, key, value) {
      super(scope, originNode);
      this.key = key;
      this.value = value;
    }

    serialize(addType) {
      return {
        key: addType(this.key),
        value: addType(this.value)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$ObjIndexPropT_ts$default(scope, originNode, getType(data.key), getType(data.value));
    }

    humanize(builder) {
      return `[${builder.humanize(this.key)}]: ${builder.humanize(this.value)}`;
    }
  }
  ___$romejs$js_analysis$src$types$ObjIndexPropT_ts$default.type = 'ObjIndexPropT';

  // romejs/js-analysis/src/types/GetPropT.ts

  class ___$romejs$js_analysis$src$types$GetPropT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, object, property) {
      super(scope, originNode);
      this.object = object;
      this.property = property;
    }

    serialize(addType) {
      return {
        object: addType(this.object),
        property: addType(this.property)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$GetPropT_ts$default(scope, originNode, getType(data.object), getType(data.property));
    }

    lookup(object, property, opts = {}) {
      object = this.utils.reduce(object);
      property = this.utils.reduce(property);

      const thisKeys = new Set();

      const protoKeys = opts.protoKeys === undefined ? [] : opts.protoKeys;
      const topObject = opts.topObject === undefined ? object : opts.topObject;

      let key;
      if (property instanceof ___$romejs$js_analysis$src$types$StringLiteralT_ts$default) {
        key = property.value;
      }

      if (key !== undefined && object instanceof ___$romejs$js_analysis$src$types$ObjT_ts$default) {
        const indexers = [];
        for (const maybePropRaw of object.props) {
          const maybeProp = this.utils.reduce(maybePropRaw);
          if (maybeProp instanceof ___$romejs$js_analysis$src$types$ObjPropT_ts$default) {
            if (maybeProp.key === key) {
              return this.utils.reduce(maybeProp.value);
            } else {
              thisKeys.add(maybeProp.key);
            }
          } else if (maybeProp instanceof ___$romejs$js_analysis$src$types$ObjIndexPropT_ts$default) {
            indexers.push(maybeProp);
          }
        }

        for (const indexer of indexers) {
          if (this.utils.isCompatibleWith(indexer.key, property)) {
            return this.utils.reduce(indexer.value);
          }
        }

        if (object.proto) {
          return this.lookup(object.proto, property, {
            topObject: topObject,
            protoKeys: [...protoKeys, ...thisKeys]});
        }
      }

      if (object instanceof ___$romejs$js_analysis$src$types$AnyT_ts$default || object instanceof ___$romejs$js_analysis$src$types$errors$E_ts$default) {
        return new ___$romejs$js_analysis$src$types$AnyT_ts$default(this.scope, this.originNode);
      }

      if (typeof key === 'string') {
        return new ___$romejs$js_analysis$src$types$errors$UnknownPropE_ts$default(this.scope, this.originNode, {
          object: topObject,
          property: property,
          key: key,
          thisKeys: Array.from(thisKeys),
          protoKeys: protoKeys});
      } else {
        return new ___$romejs$js_analysis$src$types$UnknownT_ts$default(this.scope, this.originNode);
      }
    }

    reduce() {
      return this.lookup(this.object, this.property);
    }
  }
  ___$romejs$js_analysis$src$types$GetPropT_ts$default.type = 'GetPropT';

  // romejs/js-analysis/src/types/ClassT.ts

  class ___$romejs$js_analysis$src$types$ClassT_ts$default extends ___$romejs$js_analysis$src$types$ObjT_ts$default {
    constructor(scope, originNode, opts) {
      let protoProp = undefined;
      if (opts.extends) {
        const originNode = opts.extends.originNode;
        protoProp = new ___$romejs$js_analysis$src$types$GetPropT_ts$default(scope, originNode, opts.extends, new ___$romejs$js_analysis$src$types$StringLiteralT_ts$default(scope, originNode, 'prototype'));
      }

      const constructorOpen = new ___$romejs$js_analysis$src$types$OpenT_ts$default(scope, undefined);
      const constructorProp = new ___$romejs$js_analysis$src$types$ObjPropT_ts$default(scope, null, 'constructor', constructorOpen);
      const instances = [...opts.instances, constructorProp];

      const protoObj = new ___$romejs$js_analysis$src$types$ObjT_ts$default(scope, originNode, {
        props: instances,
        proto: protoProp,
        calls: []});

      super(scope, originNode, {
        props: [...opts.statics, new ___$romejs$js_analysis$src$types$ObjPropT_ts$default(scope, originNode, 'prototype', protoObj)],
        proto: opts.extends,
        calls: opts.calls === undefined ? [] : opts.calls});

      constructorOpen.shouldMatch(this);

      this._constructor = opts.constructor;
      this._statics = opts.statics;
      this._instances = opts.instances;
      this._extends = opts.extends;
    }

    serialize(addType) {
      return {
        constructor: this._constructor === undefined ? null : addType(this._constructor),
        statics: this._statics.map(type => addType(type)),
        instances: this._instances.map(type => addType(type)),
        extends: this._extends === undefined ? null : addType(this._extends)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$ClassT_ts$default(scope, originNode, {
        constructor: data.constructor === undefined ? undefined : getType(data.constructor),
        statics: Array(data.statics).map(id => getType(id)),
        instances: Array(data.instances).map(id => getType(id)),
        extends: data.extends === undefined ? undefined : getType(data.extends)});
    }
  }
  ___$romejs$js_analysis$src$types$ClassT_ts$default.type = 'ClassT';

  // romejs/js-analysis/src/types/VoidT.ts

  class ___$romejs$js_analysis$src$types$VoidT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___$romejs$js_analysis$src$types$VoidT_ts$default(scope, originNode);
    }

    humanize() {
      return 'void';
    }
  }
  ___$romejs$js_analysis$src$types$VoidT_ts$default.type = 'VoidT';

  // romejs/js-analysis/src/types/EmptyT.ts

  class ___$romejs$js_analysis$src$types$EmptyT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___$romejs$js_analysis$src$types$EmptyT_ts$default(scope, originNode);
    }

    humanize() {
      return 'empty';
    }

    compatibleWith(otherType) {
      return otherType instanceof ___$romejs$js_analysis$src$types$EmptyT_ts$default || otherType instanceof ___$romejs$js_analysis$src$types$VoidT_ts$default;
    }
  }
  ___$romejs$js_analysis$src$types$EmptyT_ts$default.type = 'EmptyT';

  // romejs/js-analysis/src/types/IntersectionT.ts

  class ___$romejs$js_analysis$src$types$IntersectionT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, types) {
      super(scope, originNode);
      this.types = types;
    }

    serialize(addType) {
      return {
        types: this.types.map(type => addType(type))};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$IntersectionT_ts$default(scope, originNode, Array(data.types).map(id => getType(id)));
    }

    compatibleWith(otherType) {
      for (const type of this.types) {
        const compatibility = this.utils.checkCompability(type, otherType);
        if (compatibility.type === 'incompatible') {
          return compatibility;
        }
      }
      return true;
    }

    humanize(builder) {
      return this.types.map(type => builder.humanize(type)).join(' & ');
    }
  }
  ___$romejs$js_analysis$src$types$IntersectionT_ts$default.type = 'IntersectionT';

  // romejs/js-analysis/src/types/NullT.ts

  class ___$romejs$js_analysis$src$types$NullT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___$romejs$js_analysis$src$types$NullT_ts$default(scope, originNode);
    }

    humanize() {
      return 'null';
    }
  }
  ___$romejs$js_analysis$src$types$NullT_ts$default.type = 'NullT';

  // romejs/js-analysis/src/types/MaybeT.ts

  class ___$romejs$js_analysis$src$types$MaybeT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, parent) {
      super(scope, originNode);
      this.parent = parent;
    }

    serialize(addType) {
      return {
        parent: addType(this.parent)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$MaybeT_ts$default(scope, originNode, getType(data.parent));
    }

    humanize(builder) {
      return `?${builder.humanize(this.parent)}`;
    }

    explodeUnion() {
      return [new ___$romejs$js_analysis$src$types$VoidT_ts$default(this.scope, this.originNode), new ___$romejs$js_analysis$src$types$NullT_ts$default(this.scope, this.originNode), ...this.utils.explodeUnion(this.parent)];
    }

    compatibleWith(otherType) {
      if (otherType instanceof ___$romejs$js_analysis$src$types$MaybeT_ts$default) {
        return this.utils.checkCompability(this.parent, otherType.parent);
      } else {
        return otherType instanceof ___$romejs$js_analysis$src$types$VoidT_ts$default ||
        otherType instanceof ___$romejs$js_analysis$src$types$NullT_ts$default ||
        this.utils.checkCompability(this.parent, otherType);
      }
    }
  }
  ___$romejs$js_analysis$src$types$MaybeT_ts$default.type = 'MaybeT';

  // romejs/js-analysis/src/types/MixedT.ts

  class ___$romejs$js_analysis$src$types$MixedT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___$romejs$js_analysis$src$types$MixedT_ts$default(scope, originNode);
    }

    compatibleWith() {
      return false;
    }

    humanize() {
      return 'mixed';
    }
  }
  ___$romejs$js_analysis$src$types$MixedT_ts$default.type = 'MixedT';

  // romejs/js-analysis/src/types/NumericT.ts

  class ___$romejs$js_analysis$src$types$NumericT_ts$default extends ___$romejs$js_analysis$src$types$ObjT_ts$default {
    constructor(scope, originNode) {
      super(scope, originNode, {
        props: [],
        proto: scope.intrinsics.NumberPrototype,
        calls: []});
    }

    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___$romejs$js_analysis$src$types$NumericT_ts$default(scope, originNode);
    }

    humanize() {
      return 'number';
    }

    compatibleWith(type) {
      return type instanceof ___$romejs$js_analysis$src$types$NumericT_ts$default || type instanceof ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default;
    }
  }
  ___$romejs$js_analysis$src$types$NumericT_ts$default.type = 'NumericT';

  // romejs/js-analysis/src/types/NumericLiteralT.ts

  class ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default extends ___$romejs$js_analysis$src$types$ObjT_ts$default {
    constructor(scope, originNode, value) {
      super(scope, originNode, {
        props: [],
        proto: scope.intrinsics.NumberPrototype,
        calls: []});
      this.value = value;
    }

    serialize() {
      return {value: this.value};
    }

    static hydrate(scope, originNode, data) {
      return new ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default(scope, originNode, Number(data.value));
    }

    humanize() {
      return String(this.value);
    }

    compatibleWith(type) {
      return type instanceof ___$romejs$js_analysis$src$types$NumericT_ts$default ||
      type instanceof ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default && type.value === this.value;
    }
  }
  ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default.type = 'NumericLiteralT';

  // romejs/js-analysis/src/types/ImportT.ts

  class ___$romejs$js_analysis$src$types$ImportT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.importedName = opts.importedName;
      this.relative =
      opts.relative === undefined ? scope.evaluator.filename : opts.relative;
      this.source = opts.source;
      this.absolute = undefined;
      this.resolvedType = undefined;
      scope.evaluator.addImport(this, {
        importedName: this.importedName,
        relative: this.relative,
        source: this.source});
    }

    setAbsolute(absolute) {
      this.absolute = absolute;
    }

    setResolvedType(resolvedType) {
      this.resolvedType = resolvedType;
    }

    serialize() {
      return {
        importedName: this.importedName,
        relative: this.relative,
        source: this.source};
    }

    static hydrate(scope, originNode, data) {
      return new ___$romejs$js_analysis$src$types$ImportT_ts$default(scope, originNode, {
        importedName: String(data.importedName),
        source: String(data.source),
        relative: String(data.relative)});
    }

    humanize(builder) {
      let object;
      if (this.resolvedType !== undefined) {
        object = builder.humanize(this.resolvedType);
      } else if (this.absolute === undefined) {
        object = `$Exports<"${this.source}", "${this.relative}">`;
      } else {
        object = `$Exports<"${this.absolute}">`;
      }

      if (this.importedName === undefined) {
        return object;
      } else {
        return `${object}.${this.importedName}`;
      }
    }

    reduce() {
      if (this.resolvedType === undefined) {
        return this;
      } else {
        return this.resolvedType;
      }
    }
  }
  ___$romejs$js_analysis$src$types$ImportT_ts$default.type = 'ImportT';

  // romejs/js-analysis/src/types/StringT.ts

  class ___$romejs$js_analysis$src$types$StringT_ts$default extends ___$romejs$js_analysis$src$types$ObjT_ts$default {
    constructor(scope, originNode) {
      super(scope, originNode, {
        props: [],
        proto: scope.intrinsics.StringPrototype,
        calls: []});
    }

    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___$romejs$js_analysis$src$types$StringT_ts$default(scope, originNode);
    }

    humanize() {
      return 'string';
    }

    compatibleWith(type) {
      return type instanceof ___$romejs$js_analysis$src$types$StringT_ts$default || type instanceof ___$romejs$js_analysis$src$types$StringLiteralT_ts$default;
    }
  }
  ___$romejs$js_analysis$src$types$StringT_ts$default.type = 'StringT';

  // romejs/js-analysis/src/types/UnionT.ts

  class ___$romejs$js_analysis$src$types$UnionT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, types) {
      super(scope, originNode);
      this.types = [...new Set(types)];
    }

    serialize(addType) {
      return {
        types: this.types.map(type => addType(type))};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$UnionT_ts$default(scope, originNode, Array(data.types).map(id => getType(id)));
    }

    reduce() {
      const uniqTypes = [];
      const types = this.explodeUnion();

      for (const type of types) {
        let foundMatch = false;
        for (const compareType of uniqTypes) {
          const isCompatible = this.utils.isCompatibleWith(compareType, type);
          if (isCompatible) {
            foundMatch = true;
            break;
          }
        }
        if (foundMatch === false) {
          uniqTypes.push(type);
        }
      }

      if (uniqTypes.length === types.length) {
        return this;
      } else if (uniqTypes.length === 1) {
        return uniqTypes[0];
      } else {
        return new ___$romejs$js_analysis$src$types$UnionT_ts$default(this.scope, this.originNode, uniqTypes);
      }
    }

    explodeUnion() {
      let types = [];
      const visited = new Set([this]);

      for (const type of this.types) {
        const reduced = this.utils.reduce(type);
        if (visited.has(reduced)) {
          continue;
        } else {
          visited.add(reduced);
        }

        types = types.concat(this.utils.explodeUnion(type));
      }

      return types;
    }

    compatibleWith(otherType) {
      const ourTypes = this.utils.explodeUnion(this);

      if (ourTypes.includes(otherType)) {
        return true;
      }

      const otherTypes = this.utils.explodeUnion(otherType);
      const missing = [];

      for (const type of ourTypes) {
        let compatible = false;

        for (const otherType of otherTypes) {
          if (this.utils.isCompatibleWith(type, otherType)) {
            compatible = true;
          }
        }

        if (compatible === false) {
          missing.push(type);
        }
      }

      if (missing.length === 0) {
        return true;
      } else {
        return false;
      }
    }

    humanize(builder) {
      return this.types.map(type => builder.humanize(type)).join(' | ');
    }
  }
  ___$romejs$js_analysis$src$types$UnionT_ts$default.type = 'UnionT';

  // romejs/js-analysis/src/types/ExhaustiveT.ts

  class ___$$priv$romejs$js_analysis$src$types$ExhaustiveT_ts$ENotExhaustive extends ___$romejs$js_analysis$src$types$errors$E_ts$default {
    constructor(scope, originNode, target, only, extraenous) {
      super(scope, originNode);
      this.target = target;
      this.only = only;
      this.extraenous = extraenous;
    }

    getError() {
      let message = `Expected only a ${this.utils.humanize(
      this.only)} but got ${this.utils.humanize(this.target)}`;

      return {
        message: message,
        lowerTarget: this.target};
    }
  }
  ___$$priv$romejs$js_analysis$src$types$ExhaustiveT_ts$ENotExhaustive.type = 'ENotExhaustive';
  class ___$romejs$js_analysis$src$types$ExhaustiveT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, target, only) {
      super(scope, originNode);
      this.target = target;
      this.only = only;
    }

    serialize(addType) {
      return {
        target: addType(this.target),
        only: addType(this.only)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$ExhaustiveT_ts$default(scope, originNode, getType(data.target), getType(data.only));
    }

    reduce() {
      const target = this.utils.reduce(this.target);
      const only = this.utils.reduce(this.only);
      if (target instanceof ___$romejs$js_analysis$src$types$AnyT_ts$default || only instanceof ___$romejs$js_analysis$src$types$AnyT_ts$default) {
        return this.only;
      }

      const targetCandidates = this.utils.explodeUnion(target);
      const onlyCandidates = this.utils.explodeUnion(only);

      const extraneous = [];
      for (const possible of targetCandidates) {
        let compatible = false;

        for (const otherType of onlyCandidates) {
          if (this.utils.isCompatibleWith(possible, otherType)) {
            compatible = true;
          }
        }

        if (compatible === false) {
          extraneous.push(possible);
        }
      }

      if (extraneous.length === 0) {
        return target;
      } else {
        return new ___$$priv$romejs$js_analysis$src$types$ExhaustiveT_ts$ENotExhaustive(this.scope, this.originNode, this.target, this.only, extraneous);
      }
    }

    humanize(builder) {
      return `exhaustive ${builder.humanize(
      this.target)} should only match ${builder.humanize(this.target)}`;
    }
  }
  ___$romejs$js_analysis$src$types$ExhaustiveT_ts$default.type = 'ExhaustiveT';

  // romejs/js-analysis/src/types/InstanceT.ts

  class ___$romejs$js_analysis$src$types$InstanceT_ts$default extends ___$romejs$js_analysis$src$types$ObjT_ts$default {
    constructor(scope, originNode, target, typeParameters) {
      const prototype = new ___$romejs$js_analysis$src$types$GetPropT_ts$default(scope, originNode, target, new ___$romejs$js_analysis$src$types$StringLiteralT_ts$default(scope, originNode, 'prototype'));
      super(scope, originNode, {
        props: [],
        proto: prototype,
        calls: []});

      this.typeParameters = typeParameters;
      this.target = target;
    }

    serialize(addType) {
      return {
        target: addType(this.target),
        params: this.typeParameters.map(type => addType(type))};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$InstanceT_ts$default(scope, originNode, getType(data.target), Array(data.params).map(id => getType(id)));
    }

    humanize(builder) {
      const name = builder.humanize(this.target);
      const typeParams = this.typeParameters;
      if (typeParams.length === 0) {
        return name;
      } else {
        return `${name}<${typeParams.map(param => builder.humanize(param)).join(', ')}>`;
      }
    }

    compatibleWith(otherType) {
      return otherType instanceof ___$romejs$js_analysis$src$types$InstanceT_ts$default &&
      this.utils.checkCompability(this.target, otherType.target);
    }
  }
  ___$romejs$js_analysis$src$types$InstanceT_ts$default.type = 'InstanceT';

  // romejs/js-analysis/src/types/GenericT.ts

  class ___$romejs$js_analysis$src$types$GenericT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, name, type) {
      super(scope, originNode);
      this.name = name;
      this.type = type;
    }

    serialize(addType) {
      return {
        name: this.name,
        type: addType(this.type)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$GenericT_ts$default(scope, originNode, String(data.name), getType(data.type));
    }

    humanize() {
      return this.name;
    }

    reduce() {
      const type = this.utils.reduce(this.type);
      if (type instanceof ___$romejs$js_analysis$src$types$ClassT_ts$default) {
        return new ___$romejs$js_analysis$src$types$InstanceT_ts$default(this.scope, this.originNode, this.type, []);
      } else {
        return type;
      }
    }
  }
  ___$romejs$js_analysis$src$types$GenericT_ts$default.type = 'GenericT';

  // romejs/js-analysis/src/types/BinaryOpT.ts

  function ___$$priv$romejs$js_analysis$src$types$BinaryOpT_ts$isNumber(t) {
    return t instanceof ___$romejs$js_analysis$src$types$NumericT_ts$default || t instanceof ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default;
  }

  class ___$romejs$js_analysis$src$types$BinaryOpT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, left, operator, right) {
      super(scope, originNode);
      this.operator = operator;
      this.left = left;
      this.right = right;
    }

    serialize(addType) {
      return {
        left: addType(this.left),
        right: addType(this.right)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___$romejs$js_analysis$src$types$BinaryOpT_ts$default(scope, originNode, getType(data.left), String(data.operator), getType(data.right));
    }

    reduce() {
      const left = this.utils.reduce(this.left);
      const right = this.utils.reduce(this.right);
      const {scope: scope, originNode: originNode, operator: operator} = this;

      switch (operator) {
        case '===':
        case '==':
        case '!=':
        case '!==':
        case '<':
        case '<=':
        case '>':
        case '>=':
        case 'in':
        case 'instanceof':
          return new ___$romejs$js_analysis$src$types$BooleanT_ts$default(scope, originNode);

        case '+':
          if (left instanceof ___$romejs$js_analysis$src$types$AnyT_ts$default || right instanceof ___$romejs$js_analysis$src$types$AnyT_ts$default) {
            return new ___$romejs$js_analysis$src$types$AnyT_ts$default(scope, originNode);
          } else if (left instanceof ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default &&
          right instanceof ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default) {
            return new ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default(scope, originNode, left.value + right.value);
          } else if (___$$priv$romejs$js_analysis$src$types$BinaryOpT_ts$isNumber(left) && ___$$priv$romejs$js_analysis$src$types$BinaryOpT_ts$isNumber(right)) {
            return new ___$romejs$js_analysis$src$types$NumericT_ts$default(scope, originNode);
          } else if (left instanceof ___$romejs$js_analysis$src$types$StringLiteralT_ts$default &&
          right instanceof ___$romejs$js_analysis$src$types$StringLiteralT_ts$default) {
            return new ___$romejs$js_analysis$src$types$StringLiteralT_ts$default(scope, originNode, left.value + right.value);
          } else {
            return new ___$romejs$js_analysis$src$types$StringT_ts$default(scope, originNode);
          }

        case '<<':
        case '>>':
        case '>>>':
        case '-':
        case '*':
        case '/':
        case '%':
        case '**':
        case '|':
        case '^':
        case '&':
          return new ___$romejs$js_analysis$src$types$NumericT_ts$default(scope, originNode);

        default:
          throw new Error('Unknown operator');}
    }
  }
  ___$romejs$js_analysis$src$types$BinaryOpT_ts$default.type = 'BinaryOpT';

  // romejs/js-analysis/src/types/errors/MissingUnionE.ts

  class ___$romejs$js_analysis$src$types$errors$MissingUnionE_ts$default extends ___$romejs$js_analysis$src$types$errors$E_ts$default {
    constructor(scope, originNode, target, union, missing) {
      super(scope, originNode);
      this.target = target;
      this.union = union;
      this.missing = missing;
    }

    getError() {
      return {
        message: `Missing the conditions ${this.missing.map(type => this.utils.humanize(type)).join(', ')}`,
        lowerTarget: this.target};
    }
  }
  ___$romejs$js_analysis$src$types$errors$MissingUnionE_ts$default.type = 'MissingUnionE';

  // romejs/js-analysis/src/types/RefinedT.ts

  class ___$romejs$js_analysis$src$types$RefinedT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, root, remove) {
      super(scope, originNode);
      this.root = root;
      this.remove = remove;
    }

    reduce() {
      const {root: root} = this;

      const exploded = this.utils.explodeUnion(root);
      const removeTypes = this.utils.explodeUnion(this.remove);

      const clean = [];
      const removed = [];

      for (const type of exploded) {
        let compatible = false;

        for (const remove of removeTypes) {
          if (this.utils.isCompatibleWith(type, remove)) {
            compatible = true;
          }
        }

        if (compatible === false) {
          clean.push(type);
        } else {
          removed.push(type);
        }
      }

      if (removed.length === 0) {
        return new ___$romejs$js_analysis$src$types$errors$MissingUnionE_ts$default(root.scope, root.originNode, root, this.remove, removed);
      } else {
        return root.scope.createUnion(clean, root.originNode);
      }
    }
  }
  ___$romejs$js_analysis$src$types$RefinedT_ts$default.type = 'RefinedT';

  // romejs/js-analysis/src/types/RefineTypeofT.ts

  class ___$romejs$js_analysis$src$types$RefineTypeofT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, node, str, fallback) {
      super(scope, node);
      this.str = str;
      this.fallback = fallback;
    }

    reduce() {
      const {fallback: fallback, utils: utils} = this;
      const str = utils.reduce(this.str);

      if (str instanceof ___$romejs$js_analysis$src$types$StringLiteralT_ts$default) {
        let val;

        switch (str.value) {
          case 'string':
            val = new ___$romejs$js_analysis$src$types$StringT_ts$default(this.scope, undefined);
            break;

          case 'number':
            val = new ___$romejs$js_analysis$src$types$NumericT_ts$default(this.scope, undefined);
            break;

          case 'undefined':
            val = new ___$romejs$js_analysis$src$types$VoidT_ts$default(this.scope, undefined);
            break;

          case 'boolean':
            val = new ___$romejs$js_analysis$src$types$BooleanT_ts$default(this.scope, undefined);
            break;

          case 'symbol':
          case 'function':
          case 'object':
            return utils.reduce(fallback);

          default:
            return utils.reduce(fallback);}

        const types = utils.explodeUnion(fallback);
        for (const type of types) {
          if (utils.isCompatibleWith(type, val)) {
            return utils.reduce(type);
          }
        }

        return utils.reduce(fallback);
      }

      return utils.reduce(fallback);
    }
  }
  ___$romejs$js_analysis$src$types$RefineTypeofT_ts$default.type = 'RefineTypeofT';

  // romejs/js-analysis/src/types/TypeofT.ts

  class ___$romejs$js_analysis$src$types$TypeofT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, node, obj) {
      super(scope, node);
      this.obj = obj;
    }

    reduce() {
      const types = this.utils.explodeUnion(this.obj);

      const possibleTypes = [];
      for (const rawType of types) {
        const type = this.utils.reduce(rawType);
        let typeStr;

        if (type instanceof ___$romejs$js_analysis$src$types$StringT_ts$default || type instanceof ___$romejs$js_analysis$src$types$StringLiteralT_ts$default) {
          typeStr = 'string';
        }

        if (type instanceof ___$romejs$js_analysis$src$types$NumericT_ts$default || type instanceof ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default) {
          typeStr = 'number';
        }

        if (type instanceof ___$romejs$js_analysis$src$types$BooleanT_ts$default || type instanceof ___$romejs$js_analysis$src$types$BooleanLiteralT_ts$default) {
          typeStr = 'boolean';
        }

        if (type instanceof ___$romejs$js_analysis$src$types$VoidT_ts$default) {
          typeStr = 'undefined';
        }

        if (type instanceof ___$romejs$js_analysis$src$types$ObjT_ts$default) {
          if (type.calls.length === 0) {
            typeStr = 'object';
          } else {
            typeStr = 'function';
          }
        }

        if (type instanceof ___$romejs$js_analysis$src$types$NullT_ts$default) {
          typeStr = 'object';
        }

        if (typeStr !== undefined) {
          possibleTypes.push(
          new ___$romejs$js_analysis$src$types$StringLiteralT_ts$default(this.scope, this.originNode, typeStr));
        }
      }

      if (possibleTypes.length === 0) {
        return new ___$romejs$js_analysis$src$types$StringT_ts$default(this.scope, this.originNode);
      } else {
        return this.scope.createUnion(possibleTypes, this.originNode);
      }
    }
  }
  ___$romejs$js_analysis$src$types$TypeofT_ts$default.type = 'TypeofT';

  // romejs/js-analysis/src/types/SideEffectT.ts

  class ___$romejs$js_analysis$src$types$SideEffectT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, actualType) {
      super(scope, originNode);
      this.actualType = actualType;
    }

    reduce() {
      return this.utils.reduce(this.actualType);
    }
  }
  ___$romejs$js_analysis$src$types$SideEffectT_ts$default.type = 'SideEffectT';

  // romejs/js-analysis/src/types/BlockT.ts

  class ___$romejs$js_analysis$src$types$BlockT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, body) {
      super(scope, originNode);
      this.body = body;
    }

    reduce() {
      const body = [];
      let changed = false;

      for (const type of this.body) {
        const reduced = this.utils.reduce(type);
        body.push(reduced);
        if (reduced !== type) {
          changed = true;
        }
      }

      if (changed) {
        return new ___$romejs$js_analysis$src$types$BlockT_ts$default(this.scope, this.originNode, body);
      } else {
        return this;
      }
    }

    humanize() {
      return '{}';
    }
  }
  ___$romejs$js_analysis$src$types$BlockT_ts$default.type = 'BlockT';

  // romejs/js-analysis/src/types/errors/UndeclaredVarE.ts

  class ___$romejs$js_analysis$src$types$errors$UndeclaredVarE_ts$default extends ___$romejs$js_analysis$src$types$errors$E_ts$default {
    constructor(scope, originNode, name) {
      super(scope, originNode);
      this.name = name;
    }

    getError() {
      const possibleNames = this.scope.getBindingNames();
      const suggestion = ___$romejs$js_analysis$src$utils$findClosestStringMatch_ts$default(this.name, possibleNames);

      let infoMessage = undefined;
      let infoList = undefined;

      if (suggestion === undefined) {
        infoMessage = 'This could be a module you forgot to import.';
        infoList = possibleNames;
      } else {
        infoMessage = `Did you mean '${suggestion}'?`;
      }

      const advice = [{
        type: 'log',
        category: 'info',
        message: infoMessage}];

      if (infoList !== undefined) {
        advice.push({
          type: 'list',
          list: infoList});
      }

      return {
        message: `Undeclared variable '${this.name}'`,
        advice: advice,
        lowerTarget: this};
    }
  }
  ___$romejs$js_analysis$src$types$errors$UndeclaredVarE_ts$default.type = 'UndeclaredVarE';

  // romejs/js-analysis/src/types/errors/UnknownImportE.ts

  class ___$romejs$js_analysis$src$types$errors$UnknownImportE_ts$default extends ___$romejs$js_analysis$src$types$errors$E_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.possibleNames = opts.possibleNames;
      this.importedName = opts.importedName;
      this.source = opts.source;
    }

    getError() {
      const {possibleNames: possibleNames} = this;
      const suggestion = ___$romejs$js_analysis$src$utils$findClosestStringMatch_ts$default(this.importedName, possibleNames);

      let infoMessage = undefined;
      let infoList = undefined;

      if (possibleNames.length === 0) {
        infoMessage = 'This file contains no exports.';
      } else {
        if (suggestion === undefined) {
          infoList = this.possibleNames;
          infoMessage = 'Did you mean one of these?';
        } else {
          infoMessage = `Did you mean '${suggestion}'?`;
        }
      }

      const advice = [{
        type: 'log',
        category: 'info',
        message: infoMessage}];
      if (infoList !== undefined) {
        advice.push({
          type: 'list',
          list: infoList});
      }

      return {
        message: `Unknown import '${this.importedName}' in '${this.source}'`,
        advice: advice,
        lowerTarget: this};
    }
  }
  ___$romejs$js_analysis$src$types$errors$UnknownImportE_ts$default.type = 'UnknownImportE';

  // romejs/js-analysis/src/types/index.ts

  const ___$romejs$js_analysis$src$types$index_ts = {
    get T() {
      return ___$romejs$js_analysis$src$types$T_ts$default;
    },
    get AnyT() {
      return ___$romejs$js_analysis$src$types$AnyT_ts$default;
    },
    get BooleanLiteralT() {
      return ___$romejs$js_analysis$src$types$BooleanLiteralT_ts$default;
    },
    get BooleanT() {
      return ___$romejs$js_analysis$src$types$BooleanT_ts$default;
    },
    get CallT() {
      return ___$romejs$js_analysis$src$types$CallT_ts$default;
    },
    get ClassT() {
      return ___$romejs$js_analysis$src$types$ClassT_ts$default;
    },
    get EmptyT() {
      return ___$romejs$js_analysis$src$types$EmptyT_ts$default;
    },
    get FunctionT() {
      return ___$romejs$js_analysis$src$types$FunctionT_ts$default;
    },
    get GetPropT() {
      return ___$romejs$js_analysis$src$types$GetPropT_ts$default;
    },
    get IntersectionT() {
      return ___$romejs$js_analysis$src$types$IntersectionT_ts$default;
    },
    get MaybeT() {
      return ___$romejs$js_analysis$src$types$MaybeT_ts$default;
    },
    get MixedT() {
      return ___$romejs$js_analysis$src$types$MixedT_ts$default;
    },
    get NullT() {
      return ___$romejs$js_analysis$src$types$NullT_ts$default;
    },
    get NumericLiteralT() {
      return ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default;
    },
    get NumericT() {
      return ___$romejs$js_analysis$src$types$NumericT_ts$default;
    },
    get ObjPropT() {
      return ___$romejs$js_analysis$src$types$ObjPropT_ts$default;
    },
    get ObjT() {
      return ___$romejs$js_analysis$src$types$ObjT_ts$default;
    },
    get OpenIntrinsicT() {
      return ___$romejs$js_analysis$src$types$OpenIntrinsicT_ts$default;
    },
    get ImportT() {
      return ___$romejs$js_analysis$src$types$ImportT_ts$default;
    },
    get OpenT() {
      return ___$romejs$js_analysis$src$types$OpenT_ts$default;
    },
    get StringLiteralT() {
      return ___$romejs$js_analysis$src$types$StringLiteralT_ts$default;
    },
    get StringT() {
      return ___$romejs$js_analysis$src$types$StringT_ts$default;
    },
    get UnionT() {
      return ___$romejs$js_analysis$src$types$UnionT_ts$default;
    },
    get UnknownT() {
      return ___$romejs$js_analysis$src$types$UnknownT_ts$default;
    },
    get VoidT() {
      return ___$romejs$js_analysis$src$types$VoidT_ts$default;
    },
    get ExhaustiveT() {
      return ___$romejs$js_analysis$src$types$ExhaustiveT_ts$default;
    },
    get InstanceT() {
      return ___$romejs$js_analysis$src$types$InstanceT_ts$default;
    },
    get GenericT() {
      return ___$romejs$js_analysis$src$types$GenericT_ts$default;
    },
    get ObjIndexPropT() {
      return ___$romejs$js_analysis$src$types$ObjIndexPropT_ts$default;
    },
    get BinaryOpT() {
      return ___$romejs$js_analysis$src$types$BinaryOpT_ts$default;
    },
    get RefinedT() {
      return ___$romejs$js_analysis$src$types$RefinedT_ts$default;
    },
    get RefineTypeofT() {
      return ___$romejs$js_analysis$src$types$RefineTypeofT_ts$default;
    },
    get TypeofT() {
      return ___$romejs$js_analysis$src$types$TypeofT_ts$default;
    },
    get SideEffectT() {
      return ___$romejs$js_analysis$src$types$SideEffectT_ts$default;
    },
    get BlockT() {
      return ___$romejs$js_analysis$src$types$BlockT_ts$default;
    },
    get E() {
      return ___$romejs$js_analysis$src$types$errors$E_ts$default;
    },
    get NotCallableE() {
      return ___$romejs$js_analysis$src$types$errors$NotCallableE_ts$default;
    },
    get UndeclaredVarE() {
      return ___$romejs$js_analysis$src$types$errors$UndeclaredVarE_ts$default;
    },
    get UnknownPropE() {
      return ___$romejs$js_analysis$src$types$errors$UnknownPropE_ts$default;
    },
    get UnknownImportE() {
      return ___$romejs$js_analysis$src$types$errors$UnknownImportE_ts$default;
    },
    get MissingUnionE() {
      return ___$romejs$js_analysis$src$types$errors$MissingUnionE_ts$default;
    }};

  // romejs/js-analysis/src/scopes.ts

  class ___$romejs$js_analysis$src$scopes_ts$Scope {
    constructor(opts) {
      let {evaluator: evaluator, parentScope: parentScope} = opts;
      if (evaluator === undefined && parentScope !== undefined) {
        evaluator = parentScope.evaluator;
      }

      if (evaluator === undefined) {
        throw new Error('No evaluator was passed or inferred');
      }

      this.intrinsics = evaluator.intrinsics;
      this.evaluator = evaluator;
      this.hub = evaluator.hub;
      this.parentScope = parentScope;

      this.bindings = new Map();
    }

    getBinding(name) {
      let scope = this;
      while (scope) {
        const binding = scope.bindings.get(name);
        if (binding) {
          return binding.type;
        }
        scope = scope.parentScope;
      }
    }

    getBindingAssert(name) {
      const binding = this.getBinding(name);
      if (binding === undefined) {
        throw new Error(`Expected binding ${name}`);
      }
      return binding;
    }

    query(paths) {
      let initial = this.getBinding(paths[0]);
      if (initial === undefined) {
        throw new Error(`Expected "${paths[0]}" binding, found ${JSON.stringify(
        this.getBindingNames())} ${this.evaluator.filename}`);
      }

      for (let i = 1; i < paths.length; i++) {
        initial = new ___$romejs$js_analysis$src$types$GetPropT_ts$default(this, null, initial, new ___$romejs$js_analysis$src$types$StringLiteralT_ts$default(this, undefined, paths[i]));
      }

      return initial;
    }

    declareBinding(name, originNode) {
      ___$romejs$invariant$src$index_ts$default(name !== undefined, 'expected name');
      this.bindings.set(name, {
        type: new ___$romejs$js_analysis$src$types$OpenT_ts$default(this, originNode),
        status: 'declared'});
    }

    addBinding(name, type) {
      ___$romejs$invariant$src$index_ts$default(name !== undefined, 'expected name');

      const existingBinding = this.bindings.get(name);
      if (existingBinding !== undefined &&
      existingBinding.status === 'declared') {
        ___$romejs$invariant$src$index_ts$default(existingBinding.type instanceof ___$romejs$js_analysis$src$types$OpenT_ts$default, 'expected OpenT');
        existingBinding.type.shouldMatch(type);
      }

      this.bindings.set(name, {
        type: type,
        status: 'initialized'});
    }

    getBindingNames() {
      const names = new Set(this.parentScope ? this.parentScope.getBindingNames() : []);

      for (const [name] of this.bindings) {
        names.add(name);
      }

      return Array.from(names);
    }

    getOwnBindingNames() {
      return Array.from(this.bindings.keys());
    }

    createUnion(types, originNode) {
      if (types.length === 0) {
        return new ___$romejs$js_analysis$src$types$UnknownT_ts$default(this, originNode);
      } else if (types.length === 1) {
        return types[0];
      } else {
        return new ___$romejs$js_analysis$src$types$UnionT_ts$default(this, originNode, types);
      }
    }

    fork() {
      return new ___$romejs$js_analysis$src$scopes_ts$Scope({evaluator: this.evaluator, parentScope: this});
    }

    find(klass) {
      const scope = this.findOptional(klass);
      if (scope === undefined) {
        throw new Error('Failed to find class');
      } else {
        return scope;
      }
    }

    findOptional(klass) {
      let scope = this;

      do {
        if (scope instanceof klass) {
          return scope;
        }

        scope = scope.parentScope;
      } while (scope !== undefined);
    }

    refine() {
      return new ___$romejs$js_analysis$src$scopes_ts$RefineScope({evaluator: this.evaluator, parentScope: this});
    }

    evaluate(node) {
      return this.evaluator.evaluate(node, this);
    }
  }

  class ___$romejs$js_analysis$src$scopes_ts$RefineScope extends ___$romejs$js_analysis$src$scopes_ts$Scope {}

  class ___$romejs$js_analysis$src$scopes_ts$ClassScope extends ___$romejs$js_analysis$src$scopes_ts$Scope {
    constructor(opts, meta) {
      super(opts);
      this.meta = meta;
    }
  }

  class ___$romejs$js_analysis$src$scopes_ts$ThisScope extends ___$romejs$js_analysis$src$scopes_ts$Scope {
    constructor(opts, context) {
      super(opts);
      this.context = context;
    }
  }

  class ___$romejs$js_analysis$src$scopes_ts$FunctionScope extends ___$romejs$js_analysis$src$scopes_ts$ThisScope {
    constructor(opts, meta) {
      super(opts, meta.thisContext);
      this.meta = meta;
    }
  }

  // romejs/js-analysis/src/evaluators/core/LogicalExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$LogicalExpression_ts = {
    LogicalExpression: ___$romejs$js_analysis$src$evaluators$core$LogicalExpression_ts$LogicalExpression};
  function ___$$priv$romejs$js_analysis$src$evaluators$core$LogicalExpression_ts$uniq(args) {
    return [...new Set(args)];
  }

  function ___$romejs$js_analysis$src$evaluators$core$LogicalExpression_ts$LogicalExpression(node, scope) {
    switch (node.operator) {
      case '||':
        {
          const left = scope.refine().evaluate(node.left);
          const right = scope.refine().evaluate(node.right);

          const refinedScope = scope.refine();
          const refinedNames = ___$$priv$romejs$js_analysis$src$evaluators$core$LogicalExpression_ts$uniq([...left.scope.getOwnBindingNames(), ...right.scope.getOwnBindingNames()]);
          const mergeScopes = [left.scope, right.scope];
          for (const name of refinedNames) {
            const rawTypes = new Set();
            for (const scope of mergeScopes) {
              const binding = scope.getBinding(name);
              if (binding !== undefined) {
                rawTypes.add(binding);
              }
            }

            const types = Array.from(rawTypes);
            refinedScope.addBinding(name, refinedScope.createUnion(types));
          }

          return new ___$romejs$js_analysis$src$types$UnionT_ts$default(refinedScope, node, [left, right]);
        }

      case '&&':
        {
          const left = scope.evaluate(node.left);
          const right = left.scope.evaluate(node.right);
          return new ___$romejs$js_analysis$src$types$UnionT_ts$default(right.scope, node, [left, right]);
        }

      default:
        throw new Error('Unknown operator');}
  }

  // romejs/js-analysis/src/evaluators/core/TryStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$TryStatement_ts = {
    TryStatement: ___$romejs$js_analysis$src$evaluators$core$TryStatement_ts$TryStatement};
  function ___$romejs$js_analysis$src$evaluators$core$TryStatement_ts$TryStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ObjectMethod.ts

  const ___$romejs$js_analysis$src$evaluators$core$ObjectMethod_ts = {
    ObjectMethod: ___$romejs$js_analysis$src$evaluators$core$ObjectMethod_ts$ObjectMethod};
  function ___$romejs$js_analysis$src$evaluators$core$ObjectMethod_ts$ObjectMethod(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/SwitchCase.ts

  const ___$romejs$js_analysis$src$evaluators$core$SwitchCase_ts = {
    SwitchCase: ___$romejs$js_analysis$src$evaluators$core$SwitchCase_ts$SwitchCase};
  function ___$romejs$js_analysis$src$evaluators$core$SwitchCase_ts$SwitchCase(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ExportNamedDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$core$ExportNamedDeclaration_ts = {
    ExportNamedDeclaration: ___$romejs$js_analysis$src$evaluators$core$ExportNamedDeclaration_ts$ExportNamedDeclaration};
  function ___$romejs$js_analysis$src$evaluators$core$ExportNamedDeclaration_ts$ExportNamedDeclaration(node, scope, {evaluator: evaluator}) {
    const decl = node.declaration;
    if (decl !== undefined) {
      const declType = scope.evaluate(decl);

      switch (decl.type) {
        case 'FunctionDeclaration':
        case 'ClassDeclaration':
          if (decl.id === undefined) {
            throw new Error(`Expected id`);
          }
          evaluator.addExport(decl.id.name, declType);
          break;

        case 'VariableDeclaration':
          for (const id of ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(decl)) {
            const type = scope.getBinding(id.name);
            if (type === undefined) {
              throw new Error(`Couldn't find binding type for ${id.name}`);
            }
            evaluator.addExport(id.name, type);
          }
          break;

        case 'FlowTypeAlias':
        case 'TSTypeAliasDeclaration':
          const type = scope.getBinding(decl.id.name);
          if (type === undefined) {
            throw new Error(`Couldn't find binding type for ${decl.id.name}`);
          }
          evaluator.addExport(decl.id.name, type);
          break;}

      return declType;
    }

    const source = node.source === undefined ? undefined : node.source.value;
    const {specifiers: specifiers} = node;
    if (specifiers !== undefined) {
      for (const specifier of specifiers) {
        if (specifier.type === 'ExportSpecifier') {
          let type;
          if (source === undefined) {
            type = scope.evaluate(specifier.local);
          } else {
            type = new ___$romejs$js_analysis$src$types$ImportT_ts$default(scope, node, {
              importedName: specifier.local.name,
              source: source});
          }
          evaluator.addExport(specifier.exported.name, type);
        }
      }
    }
  }

  // romejs/js-analysis/src/utils/executeAtom.ts

  function ___$romejs$js_analysis$src$utils$executeAtom_ts$default(leftNode, rightType, scope) {
    switch (leftNode.type) {
      case 'Identifier':
        scope.addBinding(leftNode.name, rightType);
        break;

      case 'ObjectPattern':
        for (const prop of leftNode.properties) {
          ___$romejs$js_analysis$src$utils$executeAtom_ts$default(prop, rightType, scope);
        }
        break;

      case 'ObjectProperty':
        const propKey = new ___$romejs$js_analysis$src$types$StringLiteralT_ts$default(scope, leftNode.key, leftNode.key.name);
        const getProp = new ___$romejs$js_analysis$src$types$GetPropT_ts$default(scope, leftNode, rightType, propKey);
        ___$romejs$js_analysis$src$utils$executeAtom_ts$default(leftNode.value, getProp, scope);
        break;

      case 'ArrayPattern':
        for (let i = 0; i < leftNode.elements.length; i++) {
          const elem = leftNode.elements[i];
          if (elem === undefined) {
            continue;
          }

          const propKey = new ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default(scope, elem, i);
          const getProp = new ___$romejs$js_analysis$src$types$GetPropT_ts$default(scope, leftNode, rightType, propKey);
          ___$romejs$js_analysis$src$utils$executeAtom_ts$default(elem, getProp, scope);
        }
        break;

      case 'AssignmentPattern':
        ___$romejs$js_analysis$src$utils$executeAtom_ts$default(leftNode.left, rightType, scope);
        break;}
  }

  // romejs/js-analysis/src/evaluators/core/VariableDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$core$VariableDeclaration_ts = {
    VariableDeclaration: ___$romejs$js_analysis$src$evaluators$core$VariableDeclaration_ts$VariableDeclaration};
  function ___$romejs$js_analysis$src$evaluators$core$VariableDeclaration_ts$VariableDeclaration(node, scope) {
    for (const declarator of node.declarations) {
      const {id: id, init: init} = declarator;
      let inferredType;

      if (init === undefined) {
        inferredType = new ___$romejs$js_analysis$src$types$OpenT_ts$default(scope, declarator);
        inferredType.shouldMatch(new ___$romejs$js_analysis$src$types$VoidT_ts$default(scope, declarator));
      } else {
        inferredType = scope.evaluate(init);
      }

      let actualType = inferredType;

      if (id.typeAnnotation) {
        const annotatedType = scope.evaluate(id.typeAnnotation);
        inferredType.shouldMatch(annotatedType);
        actualType = annotatedType;
      }

      ___$romejs$js_analysis$src$utils$executeAtom_ts$default(id, actualType, scope);
    }
  }

  // romejs/js-analysis/src/evaluators/core/InterpreterDirective.ts

  const ___$romejs$js_analysis$src$evaluators$core$InterpreterDirective_ts = {
    InterpreterDirective: ___$romejs$js_analysis$src$evaluators$core$InterpreterDirective_ts$InterpreterDirective};
  function ___$romejs$js_analysis$src$evaluators$core$InterpreterDirective_ts$InterpreterDirective(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ImportDefaultSpecifier.ts

  const ___$romejs$js_analysis$src$evaluators$core$ImportDefaultSpecifier_ts = {
    ImportDefaultSpecifier: ___$romejs$js_analysis$src$evaluators$core$ImportDefaultSpecifier_ts$ImportDefaultSpecifier};
  function ___$romejs$js_analysis$src$evaluators$core$ImportDefaultSpecifier_ts$ImportDefaultSpecifier(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ClassPrivateProperty.ts

  const ___$romejs$js_analysis$src$evaluators$core$ClassPrivateProperty_ts = {
    ClassPrivateProperty: ___$romejs$js_analysis$src$evaluators$core$ClassPrivateProperty_ts$ClassPrivateProperty};
  function ___$romejs$js_analysis$src$evaluators$core$ClassPrivateProperty_ts$ClassPrivateProperty(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/UnaryExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$UnaryExpression_ts = {
    UnaryExpression: ___$romejs$js_analysis$src$evaluators$core$UnaryExpression_ts$UnaryExpression};
  function ___$romejs$js_analysis$src$evaluators$core$UnaryExpression_ts$UnaryExpression(node, scope) {
    const argType = scope.evaluate(node.argument);

    switch (node.operator) {
      case 'delete':
      case '!':
        return new ___$romejs$js_analysis$src$types$BooleanT_ts$default(scope, node);

      case '+':
      case '-':
      case '~':
        return new ___$romejs$js_analysis$src$types$NumericT_ts$default(scope, node);

      case 'typeof':
        return new ___$romejs$js_analysis$src$types$TypeofT_ts$default(scope, node, argType);

      case 'void':
        return new ___$romejs$js_analysis$src$types$VoidT_ts$default(scope, node);

      case 'throw':
        break;}
  }

  // romejs/js-analysis/src/evaluators/core/ObjectExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$ObjectExpression_ts = {
    ObjectExpression: ___$romejs$js_analysis$src$evaluators$core$ObjectExpression_ts$ObjectExpression};
  function ___$romejs$js_analysis$src$evaluators$core$ObjectExpression_ts$ObjectExpression(node, scope) {
    const props = [];

    for (const prop of node.properties) {
      if (prop.type === 'SpreadProperty') {} else if (prop.type === 'ObjectProperty') {
        if (prop.computed === true) {} else {
          const {key: key, value: value} = prop;

          let keyStr;
          if (key.type === 'Identifier') {
            keyStr = key.name;
          } else {
            continue;
          }

          ___$romejs$invariant$src$index_ts$default(keyStr !== undefined, 'expected keyStr');
          props.push(new ___$romejs$js_analysis$src$types$ObjPropT_ts$default(scope, prop, keyStr, scope.evaluate(value)));
        }
      } else {}
    }

    return new ___$romejs$js_analysis$src$types$ObjT_ts$default(scope, node, {
      calls: [],
      props: props,
      proto: scope.intrinsics.ObjectPrototype});
  }

  // romejs/js-analysis/src/utils/executeFunction.ts

  function ___$romejs$js_analysis$src$utils$executeFunction_ts$default(node, scope, bindId, thisContext) {
    const returns = new ___$romejs$js_analysis$src$types$OpenT_ts$default(scope, node.returnType ? node.returnType : node);

    const bodyScope = new ___$romejs$js_analysis$src$scopes_ts$FunctionScope({
      parentScope: scope}, {
      thisContext: thisContext ? thisContext : new ___$romejs$js_analysis$src$types$VoidT_ts$default(scope, undefined),
      returnType: returns});
    if (node.typeParameters) {
      bodyScope.evaluate(node.typeParameters);
    }

    const params = [];
    let rest;
    for (let paramNode of node.params) {
      let optional = paramNode.optional === true;
      if (paramNode.type === 'AssignmentPattern') {
        optional = false;
        paramNode = paramNode.left;
      }

      let paramType;
      if (paramNode.typeAnnotation) {
        paramType = scope.evaluate(paramNode.typeAnnotation);
      } else {
        paramType = new ___$romejs$js_analysis$src$types$OpenT_ts$default(scope, paramNode);
      }

      if (optional) {
        paramType = new ___$romejs$js_analysis$src$types$MaybeT_ts$default(scope, paramNode, paramType);
      }

      if (paramNode.type === 'RestElement') {
        rest = paramType;
      } else {
        params.push(paramType);
      }
    }

    for (let i = 0; i < node.params.length; i++) {
      ___$romejs$js_analysis$src$utils$executeAtom_ts$default(node.params[i], params[i], scope);
    }
    const block = bodyScope.evaluate(node.body);

    if (returns.hasConnections() === false) {}

    if (node.returnType) {
      returns.shouldMatch(scope.evaluate(node.returnType));
    }

    const func = new ___$romejs$js_analysis$src$types$FunctionT_ts$default(scope, node, {params: params, rest: rest, returns: returns, body: block});
    return func;
  }

  // romejs/js-analysis/src/evaluators/core/FunctionDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$core$FunctionDeclaration_ts = {
    FunctionDeclaration: ___$romejs$js_analysis$src$evaluators$core$FunctionDeclaration_ts$FunctionDeclaration};
  function ___$romejs$js_analysis$src$evaluators$core$FunctionDeclaration_ts$FunctionDeclaration(node, scope) {
    const func = ___$romejs$js_analysis$src$utils$executeFunction_ts$default(node, scope, false);
    if (node.id !== undefined) {
      scope.addBinding(node.id.name, func);
    }
    return func;
  }

  // romejs/js-analysis/src/evaluators/core/ClassExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$ClassExpression_ts = {
    ClassExpression: ___$romejs$js_analysis$src$evaluators$core$ClassExpression_ts$ClassExpression};
  function ___$romejs$js_analysis$src$evaluators$core$ClassExpression_ts$ClassExpression(node, scope) {
    const instances = [];
    const statics = [];

    const classInstance = new ___$romejs$js_analysis$src$types$OpenT_ts$default(scope, node);
    const classId = new ___$romejs$js_analysis$src$types$OpenT_ts$default(scope, node);

    const bodyScope = new ___$romejs$js_analysis$src$scopes_ts$ClassScope({parentScope: scope}, {
      instance: classInstance,
      static: classId});
    if (node.id) {
      bodyScope.addBinding(node.id.name, classId);
    }
    if (node.typeParameters) {
      bodyScope.evaluate(node.typeParameters);
    }

    let constructor = undefined;

    for (const bodyNode of node.body) {
      const type = bodyScope.evaluate(bodyNode);
      if (bodyNode.type === 'Unknown') {
        continue;
      }

      if (bodyNode.type === 'ClassMethod' && bodyNode.kind === 'constructor') {
        constructor = type;
      } else {
        if (bodyNode.type !== 'TSIndexSignature' && bodyNode.static === true) {
          statics.push(type);
        } else {
          instances.push(type);
        }
      }
    }

    const classOrigin = node.id ? node.id : node;
    let type = new ___$romejs$js_analysis$src$types$ClassT_ts$default(scope, classOrigin, {
      constructor: constructor,
      instances: instances,
      statics: statics,
      extends: node.superClass ? scope.evaluate(node.superClass) : undefined});
    if (node.id) {
      type.setHuman(node.id.name);
    }

    classId.shouldMatch(type);

    const instance = new ___$romejs$js_analysis$src$types$InstanceT_ts$default(scope, classOrigin, type, []);
    classInstance.shouldMatch(instance);

    return type;
  }

  // romejs/js-analysis/src/evaluators/core/ClassDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$core$ClassDeclaration_ts = {
    ClassDeclaration: ___$romejs$js_analysis$src$evaluators$core$ClassDeclaration_ts$ClassDeclaration};
  function ___$romejs$js_analysis$src$evaluators$core$ClassDeclaration_ts$ClassDeclaration(node, scope) {
    const type = ___$romejs$js_analysis$src$evaluators$core$ClassExpression_ts$ClassExpression(node, scope);
    if (node.id) {
      scope.addBinding(node.id.name, type);
    }
    return type;
  }

  // romejs/js-analysis/src/evaluators/core/NumericLiteral.ts

  const ___$romejs$js_analysis$src$evaluators$core$NumericLiteral_ts = {
    NumericLiteral: ___$romejs$js_analysis$src$evaluators$core$NumericLiteral_ts$NumericLiteral};
  function ___$romejs$js_analysis$src$evaluators$core$NumericLiteral_ts$NumericLiteral(node, scope) {
    return new ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default(scope, node, node.value);
  }

  // romejs/js-analysis/src/evaluators/core/ClassMethod.ts

  const ___$romejs$js_analysis$src$evaluators$core$ClassMethod_ts = {
    ClassMethod: ___$romejs$js_analysis$src$evaluators$core$ClassMethod_ts$ClassMethod};
  function ___$romejs$js_analysis$src$evaluators$core$ClassMethod_ts$ClassMethod(node, scope) {
    if (node.computed === true) {
      return undefined;
    }

    const classScope = scope.find(___$romejs$js_analysis$src$scopes_ts$ClassScope);
    const thisContext = node.static === true ? classScope.meta.static : classScope.meta.instance;
    const func = ___$romejs$js_analysis$src$utils$executeFunction_ts$default(node, scope, false, thisContext);

    ___$romejs$invariant$src$index_ts$default(node.key.type === 'Identifier', 'Expected only an identifier key');
    return new ___$romejs$js_analysis$src$types$ObjPropT_ts$default(scope, node, node.key.name, func);
  }

  // romejs/js-analysis/src/evaluators/core/WhileStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$WhileStatement_ts = {
    WhileStatement: ___$romejs$js_analysis$src$evaluators$core$WhileStatement_ts$WhileStatement};
  function ___$romejs$js_analysis$src$evaluators$core$WhileStatement_ts$WhileStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/AssignmentPattern.ts

  const ___$romejs$js_analysis$src$evaluators$core$AssignmentPattern_ts = {
    AssignmentPattern: ___$romejs$js_analysis$src$evaluators$core$AssignmentPattern_ts$AssignmentPattern};
  function ___$romejs$js_analysis$src$evaluators$core$AssignmentPattern_ts$AssignmentPattern(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/DirectiveLiteral.ts

  const ___$romejs$js_analysis$src$evaluators$core$DirectiveLiteral_ts = {
    DirectiveLiteral: ___$romejs$js_analysis$src$evaluators$core$DirectiveLiteral_ts$DirectiveLiteral};
  function ___$romejs$js_analysis$src$evaluators$core$DirectiveLiteral_ts$DirectiveLiteral(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/WithStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$WithStatement_ts = {
    WithStatement: ___$romejs$js_analysis$src$evaluators$core$WithStatement_ts$WithStatement};
  function ___$romejs$js_analysis$src$evaluators$core$WithStatement_ts$WithStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/RestElement.ts

  const ___$romejs$js_analysis$src$evaluators$core$RestElement_ts = {
    RestElement: ___$romejs$js_analysis$src$evaluators$core$RestElement_ts$RestElement};
  function ___$romejs$js_analysis$src$evaluators$core$RestElement_ts$RestElement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/AssignmentExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$AssignmentExpression_ts = {
    AssignmentExpression: ___$romejs$js_analysis$src$evaluators$core$AssignmentExpression_ts$AssignmentExpression};
  function ___$romejs$js_analysis$src$evaluators$core$AssignmentExpression_ts$AssignmentExpression(node, scope) {
    const {left: left, right: right, operator: operator} = node;

    if (operator === '=') {
      const rightType = scope.evaluate(right);
      const leftType = scope.evaluate(left);
      leftType.shouldMatch(rightType);
      return new ___$romejs$js_analysis$src$types$SideEffectT_ts$default(scope, node, rightType);
    } else {}
  }

  // romejs/js-analysis/src/evaluators/core/MetaProperty.ts

  const ___$romejs$js_analysis$src$evaluators$core$MetaProperty_ts = {
    MetaProperty: ___$romejs$js_analysis$src$evaluators$core$MetaProperty_ts$MetaProperty};
  function ___$romejs$js_analysis$src$evaluators$core$MetaProperty_ts$MetaProperty(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/Import.ts

  const ___$romejs$js_analysis$src$evaluators$core$Import_ts = {
    Import: ___$romejs$js_analysis$src$evaluators$core$Import_ts$Import};
  function ___$romejs$js_analysis$src$evaluators$core$Import_ts$Import(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ImportDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$core$ImportDeclaration_ts = {
    ImportDeclaration: ___$romejs$js_analysis$src$evaluators$core$ImportDeclaration_ts$ImportDeclaration};
  function ___$romejs$js_analysis$src$evaluators$core$ImportDeclaration_ts$ImportDeclaration(node, scope) {
    const source = node.source.value;

    for (const specifier of node.specifiers) {
      if (specifier.type === 'ImportSpecifier') {
        const localName = specifier.local.name;
        const importedName = specifier.imported.name;

        const open = new ___$romejs$js_analysis$src$types$ImportT_ts$default(scope, specifier, {
          importedName: importedName,
          source: source});
        scope.addBinding(localName, open);
      } else if (specifier.type === 'ImportDefaultSpecifier') {
        const localName = specifier.local.name;
        const open = new ___$romejs$js_analysis$src$types$ImportT_ts$default(scope, specifier, {
          importedName: 'default',
          source: source});
        scope.addBinding(localName, open);
      } else if (specifier.type === 'ImportNamespaceSpecifier') {
        const localName = specifier.local.name;
        const open = new ___$romejs$js_analysis$src$types$ImportT_ts$default(scope, specifier, {
          importedName: undefined,
          source: source});
        scope.addBinding(localName, open);
      } else {}
    }
  }

  // romejs/js-analysis/src/evaluators/core/BlockStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$BlockStatement_ts = {
    BlockStatement: ___$romejs$js_analysis$src$evaluators$core$BlockStatement_ts$BlockStatement};
  function ___$$priv$romejs$js_analysis$src$evaluators$core$BlockStatement_ts$shouldHoistExecute(node) {
    if (node === undefined) {
      return false;
    }

    if (node.type === 'FunctionDeclaration' || ___$romejs$js_ast_utils$src$isTypeNode_ts$default(node)) {
      return true;
    }

    if (node.type === 'ExportNamedDeclaration' ||
    node.type === 'ExportDefaultDeclaration') {
      return ___$$priv$romejs$js_analysis$src$evaluators$core$BlockStatement_ts$shouldHoistExecute(node.declaration);
    }

    return false;
  }

  function ___$romejs$js_analysis$src$evaluators$core$BlockStatement_ts$BlockStatement(node, scope) {
    for (const child of node.body) {
      if (child.type === 'ImportDeclaration') {
        scope.evaluate(child);
      }

      const declarations = ___$romejs$js_ast_utils$src$getBindingIdentifiers_ts$default(child);
      for (const id of declarations) {
        scope.declareBinding(id.name, id);
      }
    }

    const types = [];

    const body = [];
    for (const child of node.body) {
      if (child.type === 'ImportDeclaration') {} else if (___$$priv$romejs$js_analysis$src$evaluators$core$BlockStatement_ts$shouldHoistExecute(child)) {
        types.push(scope.evaluate(child));
      } else {
        body.push(child);
      }
    }

    for (const child of body) {
      types.push(scope.evaluate(child));
    }

    return new ___$romejs$js_analysis$src$types$BlockT_ts$default(scope, node, types);
  }

  // romejs/js-analysis/src/evaluators/core/Program.ts

  const ___$romejs$js_analysis$src$evaluators$core$Program_ts = {
    Program: ___$romejs$js_analysis$src$evaluators$core$Program_ts$Program};
  function ___$romejs$js_analysis$src$evaluators$core$Program_ts$Program(node, scope) {
    ___$romejs$js_analysis$src$evaluators$core$BlockStatement_ts$BlockStatement(node, scope);
  }

  // romejs/js-analysis/src/evaluators/core/ForStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$ForStatement_ts = {
    ForStatement: ___$romejs$js_analysis$src$evaluators$core$ForStatement_ts$ForStatement};
  function ___$romejs$js_analysis$src$evaluators$core$ForStatement_ts$ForStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/FunctionExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$FunctionExpression_ts = {
    FunctionExpression: ___$romejs$js_analysis$src$evaluators$core$FunctionExpression_ts$FunctionExpression};
  function ___$romejs$js_analysis$src$evaluators$core$FunctionExpression_ts$FunctionExpression(node, scope) {
    return ___$romejs$js_analysis$src$utils$executeFunction_ts$default(node, scope, true);
  }

  // romejs/js-analysis/src/evaluators/core/ArrayPattern.ts

  const ___$romejs$js_analysis$src$evaluators$core$ArrayPattern_ts = {
    ArrayPattern: ___$romejs$js_analysis$src$evaluators$core$ArrayPattern_ts$ArrayPattern};
  function ___$romejs$js_analysis$src$evaluators$core$ArrayPattern_ts$ArrayPattern(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ThrowStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$ThrowStatement_ts = {
    ThrowStatement: ___$romejs$js_analysis$src$evaluators$core$ThrowStatement_ts$ThrowStatement};
  function ___$romejs$js_analysis$src$evaluators$core$ThrowStatement_ts$ThrowStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/IfStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$IfStatement_ts = {
    IfStatement: ___$romejs$js_analysis$src$evaluators$core$IfStatement_ts$IfStatement};
  function ___$romejs$js_analysis$src$evaluators$core$IfStatement_ts$IfStatement(node, scope) {
    const test = scope.evaluate(node.test);
    new ___$romejs$js_analysis$src$types$ExhaustiveT_ts$default(scope, node, test, new ___$romejs$js_analysis$src$types$BooleanT_ts$default(scope, undefined));

    const hasRefinedTest = test.scope instanceof ___$romejs$js_analysis$src$scopes_ts$RefineScope;

    const consequentScope = hasRefinedTest ? test.scope : scope;
    const consequent = consequentScope.evaluate(node.consequent);

    if (node.alternate === undefined) {
      return consequent;
    } else {
      const alternateScope = scope.fork();

      return new ___$romejs$js_analysis$src$types$UnionT_ts$default(scope, undefined, [consequent, alternateScope.evaluate(node.alternate)]);
    }
  }

  // romejs/js-analysis/src/evaluators/core/ClassProperty.ts

  const ___$romejs$js_analysis$src$evaluators$core$ClassProperty_ts = {
    ClassProperty: ___$romejs$js_analysis$src$evaluators$core$ClassProperty_ts$ClassProperty};
  function ___$romejs$js_analysis$src$evaluators$core$ClassProperty_ts$ClassProperty(node, scope) {
    if (node.computed === true) {
      return undefined;
    }

    const classScope = scope.find(___$romejs$js_analysis$src$scopes_ts$ClassScope);
    const funcScope = new ___$romejs$js_analysis$src$scopes_ts$ThisScope({parentScope: scope}, classScope.meta.instance);

    let annotatedType;
    let inferredType;

    if (node.typeAnnotation) {
      annotatedType = funcScope.evaluate(node.typeAnnotation);
    }

    if (node.value) {
      inferredType = funcScope.evaluate(node.value);

      if (annotatedType !== undefined) {
        inferredType.shouldMatch(annotatedType);
      }
    }

    if (annotatedType === undefined && inferredType === undefined) {
      inferredType = new ___$romejs$js_analysis$src$types$AnyT_ts$default(scope, node);
    }

    const actualValue = annotatedType === undefined ? inferredType : annotatedType;
    if (actualValue === undefined) {
      throw new Error('Expected actual value');
    }

    if (node.key.type !== 'Identifier') {
      throw new Error('Expected only an identifier key');
    }

    return new ___$romejs$js_analysis$src$types$ObjPropT_ts$default(scope, node, node.key.name, actualValue);
  }

  // romejs/js-analysis/src/evaluators/core/AwaitExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$AwaitExpression_ts = {
    AwaitExpression: ___$romejs$js_analysis$src$evaluators$core$AwaitExpression_ts$AwaitExpression};
  function ___$romejs$js_analysis$src$evaluators$core$AwaitExpression_ts$AwaitExpression(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/DebuggerStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$DebuggerStatement_ts = {
    DebuggerStatement: ___$romejs$js_analysis$src$evaluators$core$DebuggerStatement_ts$DebuggerStatement};
  function ___$romejs$js_analysis$src$evaluators$core$DebuggerStatement_ts$DebuggerStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/CatchClause.ts

  const ___$romejs$js_analysis$src$evaluators$core$CatchClause_ts = {
    CatchClause: ___$romejs$js_analysis$src$evaluators$core$CatchClause_ts$CatchClause};
  function ___$romejs$js_analysis$src$evaluators$core$CatchClause_ts$CatchClause(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/UpdateExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$UpdateExpression_ts = {
    UpdateExpression: ___$romejs$js_analysis$src$evaluators$core$UpdateExpression_ts$UpdateExpression};
  function ___$romejs$js_analysis$src$evaluators$core$UpdateExpression_ts$UpdateExpression(node, scope) {
    const type = new ___$romejs$js_analysis$src$types$NumericT_ts$default(scope, node);
    new ___$romejs$js_analysis$src$types$ExhaustiveT_ts$default(scope, node.argument, scope.evaluate(node.argument), type);
    return type;
  }

  // romejs/js-analysis/src/evaluators/core/ArrowFunctionExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$ArrowFunctionExpression_ts = {
    ArrowFunctionExpression: ___$romejs$js_analysis$src$evaluators$core$ArrowFunctionExpression_ts$ArrowFunctionExpression};
  function ___$romejs$js_analysis$src$evaluators$core$ArrowFunctionExpression_ts$ArrowFunctionExpression(node, scope) {
    let thisContext;
    const funcScope = scope.findOptional(___$romejs$js_analysis$src$scopes_ts$FunctionScope);
    if (funcScope !== undefined) {
      thisContext = funcScope.meta.thisContext;
    }

    return ___$romejs$js_analysis$src$utils$executeFunction_ts$default(node, scope, true, thisContext);
  }

  // romejs/js-analysis/src/evaluators/core/NewExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$NewExpression_ts = {
    NewExpression: ___$romejs$js_analysis$src$evaluators$core$NewExpression_ts$NewExpression};
  function ___$romejs$js_analysis$src$evaluators$core$NewExpression_ts$NewExpression(node, scope) {
    return new ___$romejs$js_analysis$src$types$InstanceT_ts$default(scope, node, scope.evaluate(node.callee), []);
  }

  // romejs/js-analysis/src/evaluators/core/ForInStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$ForInStatement_ts = {
    ForInStatement: ___$romejs$js_analysis$src$evaluators$core$ForInStatement_ts$ForInStatement};
  function ___$romejs$js_analysis$src$evaluators$core$ForInStatement_ts$ForInStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/BinaryExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$BinaryExpression_ts = {
    BinaryExpression: ___$romejs$js_analysis$src$evaluators$core$BinaryExpression_ts$BinaryExpression};
  function ___$$priv$romejs$js_analysis$src$evaluators$core$BinaryExpression_ts$maybeRefine(node, left, right, scope) {
    const evaluator = scope.evaluator;

    if (left.type === 'Identifier') {
      scope.addBinding(left.name, evaluator.getTypeFromEvaluatedNode(right));
      return true;
    }

    if (left.type === 'UnaryExpression' &&
    left.operator === 'typeof' &&
    left.argument.type === 'Identifier') {
      const name = left.argument.name;
      const binding = scope.getBinding(name);
      if (binding !== undefined) {
        const type = new ___$romejs$js_analysis$src$types$RefineTypeofT_ts$default(scope, node, evaluator.getTypeFromEvaluatedNode(right), binding);
        scope.addBinding(name, type);
        return true;
      }
    }

    return false;
  }

  function ___$romejs$js_analysis$src$evaluators$core$BinaryExpression_ts$BinaryExpression(node, scope) {
    const left = scope.evaluate(node.left);
    const right = scope.evaluate(node.right);

    switch (node.operator) {
      case '<<':
      case '>>':
      case '>>>':
      case '-':
      case '*':
      case '/':
      case '%':
      case '**':
      case '|':
      case '^':
      case '&':
      case '<':
      case '<=':
      case '>':
      case '>=':
        const num = new ___$romejs$js_analysis$src$types$NumericT_ts$default(scope, undefined);
        new ___$romejs$js_analysis$src$types$ExhaustiveT_ts$default(scope, node, left, num);
        new ___$romejs$js_analysis$src$types$ExhaustiveT_ts$default(scope, node, right, num);
        break;}

    let refinedScope = scope;
    if (node.operator === '===') {
      refinedScope = scope.refine();
      ___$$priv$romejs$js_analysis$src$evaluators$core$BinaryExpression_ts$maybeRefine(node, node.left, node.right, refinedScope) ||
      ___$$priv$romejs$js_analysis$src$evaluators$core$BinaryExpression_ts$maybeRefine(node, node.right, node.left, refinedScope);
    }

    return new ___$romejs$js_analysis$src$types$BinaryOpT_ts$default(refinedScope, node, left, node.operator, right);
  }

  // romejs/js-analysis/src/evaluators/core/ContinueStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$ContinueStatement_ts = {
    ContinueStatement: ___$romejs$js_analysis$src$evaluators$core$ContinueStatement_ts$ContinueStatement};
  function ___$romejs$js_analysis$src$evaluators$core$ContinueStatement_ts$ContinueStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/PrivateName.ts

  const ___$romejs$js_analysis$src$evaluators$core$PrivateName_ts = {
    PrivateName: ___$romejs$js_analysis$src$evaluators$core$PrivateName_ts$PrivateName};
  function ___$romejs$js_analysis$src$evaluators$core$PrivateName_ts$PrivateName(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/Directive.ts

  const ___$romejs$js_analysis$src$evaluators$core$Directive_ts = {
    Directive: ___$romejs$js_analysis$src$evaluators$core$Directive_ts$Directive};
  function ___$romejs$js_analysis$src$evaluators$core$Directive_ts$Directive(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/StringLiteral.ts

  const ___$romejs$js_analysis$src$evaluators$core$StringLiteral_ts = {
    StringLiteral: ___$romejs$js_analysis$src$evaluators$core$StringLiteral_ts$StringLiteral};
  function ___$romejs$js_analysis$src$evaluators$core$StringLiteral_ts$StringLiteral(node, scope) {
    return new ___$romejs$js_analysis$src$types$StringLiteralT_ts$default(scope, node, node.value);
  }

  // romejs/js-analysis/src/evaluators/core/MemberExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$MemberExpression_ts = {
    MemberExpression: ___$romejs$js_analysis$src$evaluators$core$MemberExpression_ts$MemberExpression};
  function ___$romejs$js_analysis$src$evaluators$core$MemberExpression_ts$MemberExpression(node, scope) {
    let prop;
    if (node.computed === true) {
      prop = scope.evaluate(node.property);
    } else {
      const {property: property} = node;
      if (property.type === 'Identifier') {
        prop = new ___$romejs$js_analysis$src$types$StringLiteralT_ts$default(scope, property, property.name);
      } else {
        throw new Error('Unknown property');
      }
    }
    return new ___$romejs$js_analysis$src$types$GetPropT_ts$default(scope, node, scope.evaluate(node.object), prop);
  }

  // romejs/js-analysis/src/evaluators/core/ExportDefaultSpecifier.ts

  const ___$romejs$js_analysis$src$evaluators$core$ExportDefaultSpecifier_ts = {
    ExportDefaultSpecifier: ___$romejs$js_analysis$src$evaluators$core$ExportDefaultSpecifier_ts$ExportDefaultSpecifier};
  function ___$romejs$js_analysis$src$evaluators$core$ExportDefaultSpecifier_ts$ExportDefaultSpecifier(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ThisExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$ThisExpression_ts = {
    ThisExpression: ___$romejs$js_analysis$src$evaluators$core$ThisExpression_ts$ThisExpression};
  function ___$romejs$js_analysis$src$evaluators$core$ThisExpression_ts$ThisExpression(node, scope) {
    const thisScope = scope.find(___$romejs$js_analysis$src$scopes_ts$ThisScope);
    if (thisScope === undefined) {} else {
      const type = new ___$romejs$js_analysis$src$types$OpenT_ts$default(scope, node);
      type.shouldMatch(thisScope.context);
      return type;
    }
  }

  // romejs/js-analysis/src/evaluators/core/ForOfStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$ForOfStatement_ts = {
    ForOfStatement: ___$romejs$js_analysis$src$evaluators$core$ForOfStatement_ts$ForOfStatement};
  function ___$romejs$js_analysis$src$evaluators$core$ForOfStatement_ts$ForOfStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/BigIntLiteral.ts

  const ___$romejs$js_analysis$src$evaluators$core$BigIntLiteral_ts = {
    BigIntLiteral: ___$romejs$js_analysis$src$evaluators$core$BigIntLiteral_ts$BigIntLiteral};
  function ___$romejs$js_analysis$src$evaluators$core$BigIntLiteral_ts$BigIntLiteral(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/BooleanLiteral.ts

  const ___$romejs$js_analysis$src$evaluators$core$BooleanLiteral_ts = {
    BooleanLiteral: ___$romejs$js_analysis$src$evaluators$core$BooleanLiteral_ts$BooleanLiteral};
  function ___$romejs$js_analysis$src$evaluators$core$BooleanLiteral_ts$BooleanLiteral(node, scope) {
    return new ___$romejs$js_analysis$src$types$BooleanLiteralT_ts$default(scope, node, node.value);
  }

  // romejs/js-analysis/src/evaluators/core/Identifier.ts

  const ___$romejs$js_analysis$src$evaluators$core$Identifier_ts = {
    Identifier: ___$romejs$js_analysis$src$evaluators$core$Identifier_ts$Identifier};
  function ___$romejs$js_analysis$src$evaluators$core$Identifier_ts$Identifier(node, scope) {
    const binding = scope.getBinding(node.name);
    if (binding) {
      const type = new ___$romejs$js_analysis$src$types$OpenT_ts$default(scope, node);
      type.shouldMatch(binding);
      return type;
    } else {
      switch (node.name) {
        case 'React$PropType$Primitive':
        case 'React$PropType$ArrayOf':
        case 'React$PropType$InstanceOf':
        case 'React$PropType$ObjectOf':
        case 'React$PropType$OneOf':
        case 'React$PropType$OneOfType':
        case 'React$PropTypePartial':
        case 'React$ElementProps':
        case 'React$ElementRef':
        case '$Exact':
        case 'Partial':
        case '$Keys':
        case 'Object$Assign':
        case 'Object$GetPrototypeOf':
        case 'Object$SetPrototypeOf':
        case '$CharSet':
        case 'Class':
        case '$Compose':
        case '$ComposeReverse':
        case '$Subtype':
        case 'Function$Prototype$Apply':
        case 'Function$Prototype$Bind':
        case 'Function$Prototype$Call':
        case '$Exports':
          return new ___$romejs$js_analysis$src$types$AnyT_ts$default(scope, node);

        default:
          return new ___$romejs$js_analysis$src$types$errors$UndeclaredVarE_ts$default(scope, node, node.name);}
    }
  }

  // romejs/js-analysis/src/evaluators/core/ExportAllDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$core$ExportAllDeclaration_ts = {
    ExportAllDeclaration: ___$romejs$js_analysis$src$evaluators$core$ExportAllDeclaration_ts$ExportAllDeclaration};
  function ___$romejs$js_analysis$src$evaluators$core$ExportAllDeclaration_ts$ExportAllDeclaration(node, scope, {evaluator: evaluator}) {
    evaluator.addExportAll(node.source.value);
  }

  // romejs/js-analysis/src/evaluators/core/ObjectPattern.ts

  const ___$romejs$js_analysis$src$evaluators$core$ObjectPattern_ts = {
    ObjectPattern: ___$romejs$js_analysis$src$evaluators$core$ObjectPattern_ts$ObjectPattern};
  function ___$romejs$js_analysis$src$evaluators$core$ObjectPattern_ts$ObjectPattern(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/BreakStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$BreakStatement_ts = {
    BreakStatement: ___$romejs$js_analysis$src$evaluators$core$BreakStatement_ts$BreakStatement};
  function ___$romejs$js_analysis$src$evaluators$core$BreakStatement_ts$BreakStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/TemplateElement.ts

  const ___$romejs$js_analysis$src$evaluators$core$TemplateElement_ts = {
    TemplateElement: ___$romejs$js_analysis$src$evaluators$core$TemplateElement_ts$TemplateElement};
  function ___$romejs$js_analysis$src$evaluators$core$TemplateElement_ts$TemplateElement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/RestProperty.ts

  const ___$romejs$js_analysis$src$evaluators$core$RestProperty_ts = {
    RestProperty: ___$romejs$js_analysis$src$evaluators$core$RestProperty_ts$RestProperty};
  function ___$romejs$js_analysis$src$evaluators$core$RestProperty_ts$RestProperty(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ConditionalExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$ConditionalExpression_ts = {
    ConditionalExpression: ___$romejs$js_analysis$src$evaluators$core$ConditionalExpression_ts$ConditionalExpression};
  function ___$romejs$js_analysis$src$evaluators$core$ConditionalExpression_ts$ConditionalExpression(node, scope) {
    return ___$romejs$js_analysis$src$evaluators$core$IfStatement_ts$IfStatement(node, scope);
  }

  // romejs/js-analysis/src/evaluators/core/DoExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$DoExpression_ts = {
    DoExpression: ___$romejs$js_analysis$src$evaluators$core$DoExpression_ts$DoExpression};
  function ___$romejs$js_analysis$src$evaluators$core$DoExpression_ts$DoExpression(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/SwitchStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$SwitchStatement_ts = {
    SwitchStatement: ___$romejs$js_analysis$src$evaluators$core$SwitchStatement_ts$SwitchStatement};
  function ___$romejs$js_analysis$src$evaluators$core$SwitchStatement_ts$SwitchStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/SequenceExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$SequenceExpression_ts = {
    SequenceExpression: ___$romejs$js_analysis$src$evaluators$core$SequenceExpression_ts$SequenceExpression};
  function ___$romejs$js_analysis$src$evaluators$core$SequenceExpression_ts$SequenceExpression(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/TaggedTemplateExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$TaggedTemplateExpression_ts = {
    TaggedTemplateExpression: ___$romejs$js_analysis$src$evaluators$core$TaggedTemplateExpression_ts$TaggedTemplateExpression};
  function ___$romejs$js_analysis$src$evaluators$core$TaggedTemplateExpression_ts$TaggedTemplateExpression(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/VariableDeclarator.ts

  const ___$romejs$js_analysis$src$evaluators$core$VariableDeclarator_ts = {
    VariableDeclarator: ___$romejs$js_analysis$src$evaluators$core$VariableDeclarator_ts$VariableDeclarator};
  function ___$romejs$js_analysis$src$evaluators$core$VariableDeclarator_ts$VariableDeclarator(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/EmptyStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$EmptyStatement_ts = {
    EmptyStatement: ___$romejs$js_analysis$src$evaluators$core$EmptyStatement_ts$EmptyStatement};
  function ___$romejs$js_analysis$src$evaluators$core$EmptyStatement_ts$EmptyStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/CallExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$CallExpression_ts = {
    CallExpression: ___$romejs$js_analysis$src$evaluators$core$CallExpression_ts$CallExpression};
  function ___$romejs$js_analysis$src$evaluators$core$CallExpression_ts$CallExpression(node, scope) {
    return new ___$romejs$js_analysis$src$types$CallT_ts$default(scope, node, scope.evaluate(node.callee), node.arguments.map(arg => {
      return scope.evaluate(arg);
    }));
  }

  // romejs/js-analysis/src/evaluators/core/Super.ts

  const ___$romejs$js_analysis$src$evaluators$core$Super_ts = {
    Super: ___$romejs$js_analysis$src$evaluators$core$Super_ts$Super};
  function ___$romejs$js_analysis$src$evaluators$core$Super_ts$Super(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ImportSpecifier.ts

  const ___$romejs$js_analysis$src$evaluators$core$ImportSpecifier_ts = {
    ImportSpecifier: ___$romejs$js_analysis$src$evaluators$core$ImportSpecifier_ts$ImportSpecifier};
  function ___$romejs$js_analysis$src$evaluators$core$ImportSpecifier_ts$ImportSpecifier(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ArrayExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$ArrayExpression_ts = {
    ArrayExpression: ___$romejs$js_analysis$src$evaluators$core$ArrayExpression_ts$ArrayExpression};
  function ___$romejs$js_analysis$src$evaluators$core$ArrayExpression_ts$ArrayExpression(node, scope) {
    const elems = [];

    for (const expr of node.elements) {
      if (expr === undefined) {} else {
        elems.push(scope.evaluate(expr));
      }
    }

    let value;
    if (elems.length === 0) {
      value = new ___$romejs$js_analysis$src$types$OpenT_ts$default(scope, node);
    } else {
      value = scope.createUnion(elems, node);
    }
    return new ___$romejs$js_analysis$src$types$InstanceT_ts$default(scope, node, scope.intrinsics.Array, [value]);
  }

  // romejs/js-analysis/src/evaluators/core/ExportSpecifier.ts

  const ___$romejs$js_analysis$src$evaluators$core$ExportSpecifier_ts = {
    ExportSpecifier: ___$romejs$js_analysis$src$evaluators$core$ExportSpecifier_ts$ExportSpecifier};
  function ___$romejs$js_analysis$src$evaluators$core$ExportSpecifier_ts$ExportSpecifier(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/SpreadProperty.ts

  const ___$romejs$js_analysis$src$evaluators$core$SpreadProperty_ts = {
    SpreadProperty: ___$romejs$js_analysis$src$evaluators$core$SpreadProperty_ts$SpreadProperty};
  function ___$romejs$js_analysis$src$evaluators$core$SpreadProperty_ts$SpreadProperty(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ExportDefaultDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$core$ExportDefaultDeclaration_ts = {
    ExportDefaultDeclaration: ___$romejs$js_analysis$src$evaluators$core$ExportDefaultDeclaration_ts$ExportDefaultDeclaration};
  function ___$romejs$js_analysis$src$evaluators$core$ExportDefaultDeclaration_ts$ExportDefaultDeclaration(node, scope, {evaluator: evaluator}) {
    const decl = node.declaration;
    const declType = scope.evaluate(decl);
    evaluator.addExport('default', declType);
    return declType;
  }

  // romejs/js-analysis/src/evaluators/core/ReturnStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$ReturnStatement_ts = {
    ReturnStatement: ___$romejs$js_analysis$src$evaluators$core$ReturnStatement_ts$ReturnStatement};
  function ___$romejs$js_analysis$src$evaluators$core$ReturnStatement_ts$ReturnStatement(node, scope) {
    const funcScope = scope.find(___$romejs$js_analysis$src$scopes_ts$FunctionScope);
    if (node.argument === undefined) {} else {
      const type = scope.evaluate(node.argument);
      funcScope.meta.returnType.shouldMatch(type);
    }
  }

  // romejs/js-analysis/src/evaluators/core/ExportNamespaceSpecifier.ts

  const ___$romejs$js_analysis$src$evaluators$core$ExportNamespaceSpecifier_ts = {
    ExportNamespaceSpecifier: ___$romejs$js_analysis$src$evaluators$core$ExportNamespaceSpecifier_ts$ExportNamespaceSpecifier};
  function ___$romejs$js_analysis$src$evaluators$core$ExportNamespaceSpecifier_ts$ExportNamespaceSpecifier(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ImportNamespaceSpecifier.ts

  const ___$romejs$js_analysis$src$evaluators$core$ImportNamespaceSpecifier_ts = {
    ImportNamespaceSpecifier: ___$romejs$js_analysis$src$evaluators$core$ImportNamespaceSpecifier_ts$ImportNamespaceSpecifier};
  function ___$romejs$js_analysis$src$evaluators$core$ImportNamespaceSpecifier_ts$ImportNamespaceSpecifier(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/DoWhileStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$DoWhileStatement_ts = {
    DoWhileStatement: ___$romejs$js_analysis$src$evaluators$core$DoWhileStatement_ts$DoWhileStatement};
  function ___$romejs$js_analysis$src$evaluators$core$DoWhileStatement_ts$DoWhileStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ClassPrivateMethod.ts

  const ___$romejs$js_analysis$src$evaluators$core$ClassPrivateMethod_ts = {
    ClassPrivateMethod: ___$romejs$js_analysis$src$evaluators$core$ClassPrivateMethod_ts$ClassPrivateMethod};
  function ___$romejs$js_analysis$src$evaluators$core$ClassPrivateMethod_ts$ClassPrivateMethod(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ExpressionStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$ExpressionStatement_ts = {
    ExpressionStatement: ___$romejs$js_analysis$src$evaluators$core$ExpressionStatement_ts$ExpressionStatement};
  function ___$romejs$js_analysis$src$evaluators$core$ExpressionStatement_ts$ExpressionStatement(node, scope) {
    return scope.evaluate(node.expression);
  }

  // romejs/js-analysis/src/evaluators/core/RegExpLiteral.ts

  const ___$romejs$js_analysis$src$evaluators$core$RegExpLiteral_ts = {
    RegExpLiteral: ___$romejs$js_analysis$src$evaluators$core$RegExpLiteral_ts$RegExpLiteral};
  function ___$romejs$js_analysis$src$evaluators$core$RegExpLiteral_ts$RegExpLiteral(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/TemplateLiteral.ts

  const ___$romejs$js_analysis$src$evaluators$core$TemplateLiteral_ts = {
    TemplateLiteral: ___$romejs$js_analysis$src$evaluators$core$TemplateLiteral_ts$TemplateLiteral};
  function ___$romejs$js_analysis$src$evaluators$core$TemplateLiteral_ts$TemplateLiteral(node, scope) {
    for (const expr of node.expressions) {
      new ___$romejs$js_analysis$src$types$ExhaustiveT_ts$default(scope, expr, scope.evaluate(expr), new ___$romejs$js_analysis$src$types$StringT_ts$default(scope, undefined));
    }
    return new ___$romejs$js_analysis$src$types$StringT_ts$default(scope, node);
  }

  // romejs/js-analysis/src/evaluators/core/LabeledStatement.ts

  const ___$romejs$js_analysis$src$evaluators$core$LabeledStatement_ts = {
    LabeledStatement: ___$romejs$js_analysis$src$evaluators$core$LabeledStatement_ts$LabeledStatement};
  function ___$romejs$js_analysis$src$evaluators$core$LabeledStatement_ts$LabeledStatement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/YieldExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$YieldExpression_ts = {
    YieldExpression: ___$romejs$js_analysis$src$evaluators$core$YieldExpression_ts$YieldExpression};
  function ___$romejs$js_analysis$src$evaluators$core$YieldExpression_ts$YieldExpression(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/ObjectProperty.ts

  const ___$romejs$js_analysis$src$evaluators$core$ObjectProperty_ts = {
    ObjectProperty: ___$romejs$js_analysis$src$evaluators$core$ObjectProperty_ts$ObjectProperty};
  function ___$romejs$js_analysis$src$evaluators$core$ObjectProperty_ts$ObjectProperty(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/NullLiteral.ts

  const ___$romejs$js_analysis$src$evaluators$core$NullLiteral_ts = {
    NullLiteral: ___$romejs$js_analysis$src$evaluators$core$NullLiteral_ts$NullLiteral};
  function ___$romejs$js_analysis$src$evaluators$core$NullLiteral_ts$NullLiteral(node, scope) {
    return new ___$romejs$js_analysis$src$types$NullT_ts$default(scope, node);
  }

  // romejs/js-analysis/src/evaluators/core/SpreadElement.ts

  const ___$romejs$js_analysis$src$evaluators$core$SpreadElement_ts = {
    SpreadElement: ___$romejs$js_analysis$src$evaluators$core$SpreadElement_ts$SpreadElement};
  function ___$romejs$js_analysis$src$evaluators$core$SpreadElement_ts$SpreadElement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXText.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXText_ts = {
    JSXText: ___$romejs$js_analysis$src$evaluators$jsx$JSXText_ts$JSXText};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXText_ts$JSXText(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXEmptyExpression.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXEmptyExpression_ts = {
    JSXEmptyExpression: ___$romejs$js_analysis$src$evaluators$jsx$JSXEmptyExpression_ts$JSXEmptyExpression};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXEmptyExpression_ts$JSXEmptyExpression(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXNamespacedName.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXNamespacedName_ts = {
    JSXNamespacedName: ___$romejs$js_analysis$src$evaluators$jsx$JSXNamespacedName_ts$JSXNamespacedName};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXNamespacedName_ts$JSXNamespacedName(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXIdentifier.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXIdentifier_ts = {
    JSXIdentifier: ___$romejs$js_analysis$src$evaluators$jsx$JSXIdentifier_ts$JSXIdentifier};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXIdentifier_ts$JSXIdentifier(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXClosingFragment.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXClosingFragment_ts = {
    JSXClosingFragment: ___$romejs$js_analysis$src$evaluators$jsx$JSXClosingFragment_ts$JSXClosingFragment};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXClosingFragment_ts$JSXClosingFragment(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXElement.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXElement_ts = {
    JSXElement: ___$romejs$js_analysis$src$evaluators$jsx$JSXElement_ts$JSXElement};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXElement_ts$JSXElement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXOpeningFragment.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXOpeningFragment_ts = {
    JSXOpeningFragment: ___$romejs$js_analysis$src$evaluators$jsx$JSXOpeningFragment_ts$JSXOpeningFragment};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXOpeningFragment_ts$JSXOpeningFragment(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXClosingElement.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXClosingElement_ts = {
    JSXClosingElement: ___$romejs$js_analysis$src$evaluators$jsx$JSXClosingElement_ts$JSXClosingElement};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXClosingElement_ts$JSXClosingElement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXExpressionContainer.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXExpressionContainer_ts = {
    JSXExpressionContainer: ___$romejs$js_analysis$src$evaluators$jsx$JSXExpressionContainer_ts$JSXExpressionContainer};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXExpressionContainer_ts$JSXExpressionContainer(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXMemberExpression.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXMemberExpression_ts = {
    JSXMemberExpression: ___$romejs$js_analysis$src$evaluators$jsx$JSXMemberExpression_ts$JSXMemberExpression};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXMemberExpression_ts$JSXMemberExpression(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXSpreadChild.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXSpreadChild_ts = {
    JSXSpreadChild: ___$romejs$js_analysis$src$evaluators$jsx$JSXSpreadChild_ts$JSXSpreadChild};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXSpreadChild_ts$JSXSpreadChild(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXSpreadAttribute.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXSpreadAttribute_ts = {
    JSXSpreadAttribute: ___$romejs$js_analysis$src$evaluators$jsx$JSXSpreadAttribute_ts$JSXSpreadAttribute};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXSpreadAttribute_ts$JSXSpreadAttribute(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXOpeningElement.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXOpeningElement_ts = {
    JSXOpeningElement: ___$romejs$js_analysis$src$evaluators$jsx$JSXOpeningElement_ts$JSXOpeningElement};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXOpeningElement_ts$JSXOpeningElement(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXFragment.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXFragment_ts = {
    JSXFragment: ___$romejs$js_analysis$src$evaluators$jsx$JSXFragment_ts$JSXFragment};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXFragment_ts$JSXFragment(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/jsx/JSXAttribute.ts

  const ___$romejs$js_analysis$src$evaluators$jsx$JSXAttribute_ts = {
    JSXAttribute: ___$romejs$js_analysis$src$evaluators$jsx$JSXAttribute_ts$JSXAttribute};
  function ___$romejs$js_analysis$src$evaluators$jsx$JSXAttribute_ts$JSXAttribute(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowIntersectionTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowIntersectionTypeAnnotation_ts = {
    FlowIntersectionTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowIntersectionTypeAnnotation_ts$FlowIntersectionTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowIntersectionTypeAnnotation_ts$FlowIntersectionTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$IntersectionT_ts$default(scope, node, node.types.map(type => {
      return scope.evaluate(type);
    }));
  }

  // romejs/js-analysis/src/evaluators/flow/FlowAnyTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowAnyTypeAnnotation_ts = {
    FlowAnyTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowAnyTypeAnnotation_ts$FlowAnyTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowAnyTypeAnnotation_ts$FlowAnyTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$AnyT_ts$default(scope, node);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowDeclareClass.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareClass_ts = {
    FlowDeclareClass: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareClass_ts$FlowDeclareClass};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareClass_ts$FlowDeclareClass(node, scope) {
    const bodyScope = scope.fork();
    if (node.typeParameters) {
      bodyScope.evaluate(node.typeParameters);
    }

    const calls = [];
    const instances = [];
    const statics = [];

    for (const propNode of node.body.properties) {
      const prop = bodyScope.evaluate(propNode);
      if (propNode.type !== 'FlowObjectTypeSpreadProperty' &&
      propNode.static === true) {
        statics.push(prop);
      } else if (propNode.type === 'FlowObjectTypeCallProperty') {
        calls.push(scope.evaluate(propNode));
      } else {
        instances.push(prop);
      }
    }

    let xtends = undefined;
    if (node.extends.length > 0) {
      xtends = scope.evaluate(node.extends[0]);
    }

    const type = new ___$romejs$js_analysis$src$types$ClassT_ts$default(bodyScope, node.id, {
      constructor: undefined,
      instances: instances,
      statics: statics,
      extends: xtends,
      calls: calls});
    scope.addBinding(node.id.name, type);
    type.setHuman(node.id.name);
    return type;
  }

  // romejs/js-analysis/src/evaluators/flow/FlowNumericLiteralTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowNumericLiteralTypeAnnotation_ts = {
    FlowNumericLiteralTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowNumericLiteralTypeAnnotation_ts$FlowNumericLiteralTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowNumericLiteralTypeAnnotation_ts$FlowNumericLiteralTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$NumericLiteralT_ts$default(scope, node, node.value);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowQualifiedTypeIdentifier.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowQualifiedTypeIdentifier_ts = {
    FlowQualifiedTypeIdentifier: ___$romejs$js_analysis$src$evaluators$flow$FlowQualifiedTypeIdentifier_ts$FlowQualifiedTypeIdentifier};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowQualifiedTypeIdentifier_ts$FlowQualifiedTypeIdentifier(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowDeclareExportAllDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareExportAllDeclaration_ts = {
    FlowDeclareExportAllDeclaration: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareExportAllDeclaration_ts$FlowDeclareExportAllDeclaration};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareExportAllDeclaration_ts$FlowDeclareExportAllDeclaration(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowBooleanTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowBooleanTypeAnnotation_ts = {
    FlowBooleanTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowBooleanTypeAnnotation_ts$FlowBooleanTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowBooleanTypeAnnotation_ts$FlowBooleanTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$BooleanT_ts$default(scope, node);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowNullableTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowNullableTypeAnnotation_ts = {
    FlowNullableTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowNullableTypeAnnotation_ts$FlowNullableTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowNullableTypeAnnotation_ts$FlowNullableTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$MaybeT_ts$default(scope, node, scope.evaluate(node.typeAnnotation));
  }

  // romejs/js-analysis/src/evaluators/flow/FlowDeclareVariable.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareVariable_ts = {
    FlowDeclareVariable: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareVariable_ts$FlowDeclareVariable};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareVariable_ts$FlowDeclareVariable(node, scope) {
    const type = scope.evaluate(node.id.typeAnnotation);
    scope.addBinding(node.id.name, type);
    return type;
  }

  // romejs/js-analysis/src/evaluators/flow/FlowGenericTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowGenericTypeAnnotation_ts = {
    FlowGenericTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowGenericTypeAnnotation_ts$FlowGenericTypeAnnotation};
  function ___$$priv$romejs$js_analysis$src$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node) {
    if (node.type === 'Identifier') {
      return node.name;
    } else {
      return `${___$$priv$romejs$js_analysis$src$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node.id)}.${___$$priv$romejs$js_analysis$src$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node.qualification)}`;
    }
  }

  function ___$romejs$js_analysis$src$evaluators$flow$FlowGenericTypeAnnotation_ts$FlowGenericTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$GenericT_ts$default(scope, node, ___$$priv$romejs$js_analysis$src$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node.id), scope.evaluate(node.id));
  }

  // romejs/js-analysis/src/evaluators/flow/FlowInterfaceDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceDeclaration_ts = {
    FlowInterfaceDeclaration: ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceDeclaration_ts$FlowInterfaceDeclaration};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceDeclaration_ts$FlowInterfaceDeclaration(node, scope) {
    const typeScope = scope.fork();
    if (node.typeParameters) {
      typeScope.evaluate(node.typeParameters);
    }

    const body = typeScope.evaluate(node.body);
    scope.addBinding(node.id.name, body);
    return body;
  }

  // romejs/js-analysis/src/evaluators/flow/FlowDeclareInterface.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareInterface_ts = {
    FlowDeclareInterface: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareInterface_ts$FlowDeclareInterface};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareInterface_ts$FlowDeclareInterface(node, scope) {
    return ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceDeclaration_ts$FlowInterfaceDeclaration(node, scope);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowClassImplements.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowClassImplements_ts = {
    FlowClassImplements: ___$romejs$js_analysis$src$evaluators$flow$FlowClassImplements_ts$FlowClassImplements};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowClassImplements_ts$FlowClassImplements(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowTypeAlias.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowTypeAlias_ts = {
    FlowTypeAlias: ___$romejs$js_analysis$src$evaluators$flow$FlowTypeAlias_ts$FlowTypeAlias};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowTypeAlias_ts$FlowTypeAlias(node, scope) {
    const typeScope = scope.fork();
    if (node.typeParameters) {
      typeScope.evaluate(node.typeParameters);
    }

    const right = typeScope.evaluate(node.right);
    scope.addBinding(node.id.name, right);
    return right;
  }

  // romejs/js-analysis/src/evaluators/flow/FlowThisTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowThisTypeAnnotation_ts = {
    FlowThisTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowThisTypeAnnotation_ts$FlowThisTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowThisTypeAnnotation_ts$FlowThisTypeAnnotation(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowDeclareModuleExports.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareModuleExports_ts = {
    FlowDeclareModuleExports: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareModuleExports_ts$FlowDeclareModuleExports};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareModuleExports_ts$FlowDeclareModuleExports(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowVoidTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowVoidTypeAnnotation_ts = {
    FlowVoidTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowVoidTypeAnnotation_ts$FlowVoidTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowVoidTypeAnnotation_ts$FlowVoidTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$VoidT_ts$default(scope, node);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowDeclareFunction.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareFunction_ts = {
    FlowDeclareFunction: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareFunction_ts$FlowDeclareFunction};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareFunction_ts$FlowDeclareFunction(node, scope) {
    return scope.addBinding(node.id.name, scope.evaluate(node.id.typeAnnotation));
  }

  // romejs/js-analysis/src/evaluators/flow/FlowTypeParameterInstantiation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameterInstantiation_ts = {
    FlowTypeParameterInstantiation: ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameterInstantiation_ts$FlowTypeParameterInstantiation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameterInstantiation_ts$FlowTypeParameterInstantiation(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowDeclareModule.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareModule_ts = {
    FlowDeclareModule: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareModule_ts$FlowDeclareModule};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareModule_ts$FlowDeclareModule(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowObjectTypeCallProperty.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeCallProperty_ts = {
    FlowObjectTypeCallProperty: ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeCallProperty_ts$FlowObjectTypeCallProperty};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeCallProperty_ts$FlowObjectTypeCallProperty(node, scope) {
    return scope.evaluate(node.value);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowVariance.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowVariance_ts = {
    FlowVariance: ___$romejs$js_analysis$src$evaluators$flow$FlowVariance_ts$FlowVariance};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowVariance_ts$FlowVariance(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowNullLiteralTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowNullLiteralTypeAnnotation_ts = {
    FlowNullLiteralTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowNullLiteralTypeAnnotation_ts$FlowNullLiteralTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowNullLiteralTypeAnnotation_ts$FlowNullLiteralTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$NullT_ts$default(scope, node);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowTupleTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowTupleTypeAnnotation_ts = {
    FlowTupleTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowTupleTypeAnnotation_ts$FlowTupleTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowTupleTypeAnnotation_ts$FlowTupleTypeAnnotation(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowDeclaredPredicate.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclaredPredicate_ts = {
    FlowDeclaredPredicate: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclaredPredicate_ts$FlowDeclaredPredicate};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclaredPredicate_ts$FlowDeclaredPredicate(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowTypeParameter.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameter_ts = {
    FlowTypeParameter: ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameter_ts$FlowTypeParameter};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameter_ts$FlowTypeParameter(node, scope) {
    const type = new ___$romejs$js_analysis$src$types$AnyT_ts$default(scope, node);
    scope.addBinding(node.name, type);
    return type;
  }

  // romejs/js-analysis/src/evaluators/flow/FlowTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowTypeAnnotation_ts = {
    FlowTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowTypeAnnotation_ts$FlowTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowTypeAnnotation_ts$FlowTypeAnnotation(node, scope) {
    return scope.evaluate(node.typeAnnotation);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowOpaqueType.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowOpaqueType_ts = {
    FlowOpaqueType: ___$romejs$js_analysis$src$evaluators$flow$FlowOpaqueType_ts$FlowOpaqueType};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowOpaqueType_ts$FlowOpaqueType(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowArrayTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowArrayTypeAnnotation_ts = {
    FlowArrayTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowArrayTypeAnnotation_ts$FlowArrayTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowArrayTypeAnnotation_ts$FlowArrayTypeAnnotation(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowStringLiteralTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowStringLiteralTypeAnnotation_ts = {
    FlowStringLiteralTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowStringLiteralTypeAnnotation_ts$FlowStringLiteralTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowStringLiteralTypeAnnotation_ts$FlowStringLiteralTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$StringLiteralT_ts$default(scope, node, node.value);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowObjectTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeAnnotation_ts = {
    FlowObjectTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeAnnotation_ts$FlowObjectTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeAnnotation_ts$FlowObjectTypeAnnotation(node, scope) {
    const props = [];
    const calls = [];

    for (const prop of node.properties) {
      props.push(scope.evaluate(prop));
    }

    return new ___$romejs$js_analysis$src$types$ObjT_ts$default(scope, node, {
      props: props,
      proto: scope.intrinsics.ObjectPrototype,
      calls: calls});
  }

  // romejs/js-analysis/src/evaluators/flow/FlowTypeParameterDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameterDeclaration_ts = {
    FlowTypeParameterDeclaration: ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameterDeclaration_ts$FlowTypeParameterDeclaration};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameterDeclaration_ts$FlowTypeParameterDeclaration(node, scope) {
    for (const param of node.params) {
      scope.evaluate(param);
    }
  }

  // romejs/js-analysis/src/evaluators/flow/FlowInterfaceExtends.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceExtends_ts = {
    FlowInterfaceExtends: ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceExtends_ts$FlowInterfaceExtends};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceExtends_ts$FlowInterfaceExtends(node, scope) {
    return scope.evaluate(node.id);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowEmptyTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowEmptyTypeAnnotation_ts = {
    FlowEmptyTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowEmptyTypeAnnotation_ts$FlowEmptyTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowEmptyTypeAnnotation_ts$FlowEmptyTypeAnnotation(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowInferredPredicate.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowInferredPredicate_ts = {
    FlowInferredPredicate: ___$romejs$js_analysis$src$evaluators$flow$FlowInferredPredicate_ts$FlowInferredPredicate};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowInferredPredicate_ts$FlowInferredPredicate(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowDeclareExportDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareExportDeclaration_ts = {
    FlowDeclareExportDeclaration: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareExportDeclaration_ts$FlowDeclareExportDeclaration};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareExportDeclaration_ts$FlowDeclareExportDeclaration(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowExistsTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowExistsTypeAnnotation_ts = {
    FlowExistsTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowExistsTypeAnnotation_ts$FlowExistsTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowExistsTypeAnnotation_ts$FlowExistsTypeAnnotation(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowStringTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowStringTypeAnnotation_ts = {
    FlowStringTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowStringTypeAnnotation_ts$FlowStringTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowStringTypeAnnotation_ts$FlowStringTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$StringT_ts$default(scope, node);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowBigIntTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowBigIntTypeAnnotation_ts = {
    FlowBigIntTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowBigIntTypeAnnotation_ts$FlowBigIntTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowBigIntTypeAnnotation_ts$FlowBigIntTypeAnnotation(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowInterface.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowInterface_ts = {
    FlowInterface: ___$romejs$js_analysis$src$evaluators$flow$FlowInterface_ts$FlowInterface};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowInterface_ts$FlowInterface(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowUnionTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowUnionTypeAnnotation_ts = {
    FlowUnionTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowUnionTypeAnnotation_ts$FlowUnionTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowUnionTypeAnnotation_ts$FlowUnionTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$UnionT_ts$default(scope, node, node.types.map(type => {
      return scope.evaluate(type);
    }));
  }

  // romejs/js-analysis/src/evaluators/flow/FlowObjectTypeSpreadProperty.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeSpreadProperty_ts = {
    FlowObjectTypeSpreadProperty: ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeSpreadProperty_ts$FlowObjectTypeSpreadProperty};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeSpreadProperty_ts$FlowObjectTypeSpreadProperty(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowMixedTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowMixedTypeAnnotation_ts = {
    FlowMixedTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowMixedTypeAnnotation_ts$FlowMixedTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowMixedTypeAnnotation_ts$FlowMixedTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$MixedT_ts$default(scope, node);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowNumericLiteral.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowNumericLiteral_ts = {
    FlowNumericLiteral: ___$romejs$js_analysis$src$evaluators$flow$FlowNumericLiteral_ts$FlowNumericLiteral};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowNumericLiteral_ts$FlowNumericLiteral(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowTypeofTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowTypeofTypeAnnotation_ts = {
    FlowTypeofTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowTypeofTypeAnnotation_ts$FlowTypeofTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowTypeofTypeAnnotation_ts$FlowTypeofTypeAnnotation(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowTypeCastExpression.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowTypeCastExpression_ts = {
    FlowTypeCastExpression: ___$romejs$js_analysis$src$evaluators$flow$FlowTypeCastExpression_ts$FlowTypeCastExpression};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowTypeCastExpression_ts$FlowTypeCastExpression(node, scope) {
    const expressionType = scope.evaluate(node.expression);
    const assertedType = scope.evaluate(node.typeAnnotation);
    new ___$romejs$js_analysis$src$types$ExhaustiveT_ts$default(scope, node, expressionType, assertedType);
    return assertedType;
  }

  // romejs/js-analysis/src/evaluators/flow/FlowBooleanLiteralTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowBooleanLiteralTypeAnnotation_ts = {
    FlowBooleanLiteralTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowBooleanLiteralTypeAnnotation_ts$FlowBooleanLiteralTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowBooleanLiteralTypeAnnotation_ts$FlowBooleanLiteralTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$BooleanLiteralT_ts$default(scope, node, node.value);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowObjectTypeIndexer.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeIndexer_ts = {
    FlowObjectTypeIndexer: ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeIndexer_ts$FlowObjectTypeIndexer};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeIndexer_ts$FlowObjectTypeIndexer(node, scope) {
    return new ___$romejs$js_analysis$src$types$ObjIndexPropT_ts$default(scope, node, scope.evaluate(node.key), scope.evaluate(node.value));
  }

  // romejs/js-analysis/src/evaluators/flow/FlowFunctionTypeParam.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeParam_ts = {
    FlowFunctionTypeParam: ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeParam_ts$FlowFunctionTypeParam};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeParam_ts$FlowFunctionTypeParam(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowFunctionTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeAnnotation_ts = {
    FlowFunctionTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeAnnotation_ts$FlowFunctionTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeAnnotation_ts$FlowFunctionTypeAnnotation(node, scope) {
    const bodyScope = scope.fork();
    if (node.typeParameters) {
      bodyScope.evaluate(node.typeParameters);
    }

    const params = [];
    let rest;
    for (const paramNode of node.params) {
      if (paramNode.type === 'FlowFunctionTypeParamRest') {
        rest = bodyScope.evaluate(paramNode.param.typeAnnotation);
      } else {
        let paramType = bodyScope.evaluate(paramNode.typeAnnotation);
        if (paramNode.optional === true) {
          paramType = new ___$romejs$js_analysis$src$types$MaybeT_ts$default(scope, paramNode, paramType);
        }
        params.push(paramType);
      }
    }

    const returns = bodyScope.evaluate(node.returnType);

    return new ___$romejs$js_analysis$src$types$FunctionT_ts$default(scope, node, {params: params, rest: rest, returns: returns, body: undefined});
  }

  // romejs/js-analysis/src/evaluators/flow/FlowDeclareTypeAlias.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareTypeAlias_ts = {
    FlowDeclareTypeAlias: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareTypeAlias_ts$FlowDeclareTypeAlias};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareTypeAlias_ts$FlowDeclareTypeAlias(node, scope) {
    return ___$romejs$js_analysis$src$evaluators$flow$FlowTypeAlias_ts$FlowTypeAlias(node, scope);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowObjectTypeProperty.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeProperty_ts = {
    FlowObjectTypeProperty: ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeProperty_ts$FlowObjectTypeProperty};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeProperty_ts$FlowObjectTypeProperty(node, scope) {
    const {key: key, value: value} = node;

    let keyStr;
    if (key.type === 'Identifier') {
      keyStr = key.name;
    } else if (key.type === 'StringLiteral') {
      keyStr = key.value;
    } else {
      throw new Error('Unknown property key');
    }

    return new ___$romejs$js_analysis$src$types$ObjPropT_ts$default(scope, node, keyStr, scope.evaluate(value));
  }

  // romejs/js-analysis/src/evaluators/flow/FlowNumberTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowNumberTypeAnnotation_ts = {
    FlowNumberTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowNumberTypeAnnotation_ts$FlowNumberTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowNumberTypeAnnotation_ts$FlowNumberTypeAnnotation(node, scope) {
    return new ___$romejs$js_analysis$src$types$NumericT_ts$default(scope, node);
  }

  // romejs/js-analysis/src/types/OpaqueT.ts

  class ___$romejs$js_analysis$src$types$OpaqueT_ts$default extends ___$romejs$js_analysis$src$types$T_ts$default {
    constructor(scope, originNode, name) {
      super(scope, originNode);
      this.name = name;
    }

    serialize() {
      return {name: this.name};
    }

    static hydrate(scope, originNode, data) {
      return new ___$romejs$js_analysis$src$types$OpaqueT_ts$default(scope, originNode, String(data.name));
    }

    humanize() {
      return `opaque ${this.name}`;
    }

    compatibleWith(otherType) {
      return otherType === this;
    }
  }
  ___$romejs$js_analysis$src$types$OpaqueT_ts$default.type = 'OpaqueT';

  // romejs/js-analysis/src/evaluators/flow/FlowDeclareOpaqueType.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareOpaqueType_ts = {
    FlowDeclareOpaqueType: ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareOpaqueType_ts$FlowDeclareOpaqueType};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareOpaqueType_ts$FlowDeclareOpaqueType(node, scope) {
    return new ___$romejs$js_analysis$src$types$OpaqueT_ts$default(scope, node.id, node.id.name);
  }

  // romejs/js-analysis/src/evaluators/flow/FlowInterfaceTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceTypeAnnotation_ts = {
    FlowInterfaceTypeAnnotation: ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceTypeAnnotation_ts$FlowInterfaceTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceTypeAnnotation_ts$FlowInterfaceTypeAnnotation() {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowObjectTypeInternalSlot.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeInternalSlot_ts = {
    FlowObjectTypeInternalSlot: ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeInternalSlot_ts$FlowObjectTypeInternalSlot};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeInternalSlot_ts$FlowObjectTypeInternalSlot() {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/flow/FlowFunctionTypeParamRest.ts

  const ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeParamRest_ts = {
    FlowFunctionTypeParamRest: ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeParamRest_ts$FlowFunctionTypeParamRest};
  function ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeParamRest_ts$FlowFunctionTypeParamRest(node, scope) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSUnknownKeyword.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSUnknownKeyword_ts = {
    TSUnknownKeyword: ___$romejs$js_analysis$src$evaluators$typescript$TSUnknownKeyword_ts$TSUnknownKeyword};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSUnknownKeyword_ts$TSUnknownKeyword(node, scope) {
    node;
    scope;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSImportType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSImportType_ts = {
    TSImportType: ___$romejs$js_analysis$src$evaluators$typescript$TSImportType_ts$TSImportType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSImportType_ts$TSImportType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSQualifiedName.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSQualifiedName_ts = {
    TSQualifiedName: ___$romejs$js_analysis$src$evaluators$typescript$TSQualifiedName_ts$TSQualifiedName};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSQualifiedName_ts$TSQualifiedName(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypeReference.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypeReference_ts = {
    TSTypeReference: ___$romejs$js_analysis$src$evaluators$typescript$TSTypeReference_ts$TSTypeReference};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypeReference_ts$TSTypeReference(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypePredicate.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypePredicate_ts = {
    TSTypePredicate: ___$romejs$js_analysis$src$evaluators$typescript$TSTypePredicate_ts$TSTypePredicate};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypePredicate_ts$TSTypePredicate(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSThisType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSThisType_ts = {
    TSThisType: ___$romejs$js_analysis$src$evaluators$typescript$TSThisType_ts$TSThisType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSThisType_ts$TSThisType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypeQuery.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypeQuery_ts = {
    TSTypeQuery: ___$romejs$js_analysis$src$evaluators$typescript$TSTypeQuery_ts$TSTypeQuery};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypeQuery_ts$TSTypeQuery(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypeParameter.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameter_ts = {
    TSTypeParameter: ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameter_ts$TSTypeParameter};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameter_ts$TSTypeParameter(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypeParameterDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameterDeclaration_ts = {
    TSTypeParameterDeclaration: ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameterDeclaration_ts$TSTypeParameterDeclaration};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameterDeclaration_ts$TSTypeParameterDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSIndexSignature.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSIndexSignature_ts = {
    TSIndexSignature: ___$romejs$js_analysis$src$evaluators$typescript$TSIndexSignature_ts$TSIndexSignature};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSIndexSignature_ts$TSIndexSignature(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSMethodSignature.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSMethodSignature_ts = {
    TSMethodSignature: ___$romejs$js_analysis$src$evaluators$typescript$TSMethodSignature_ts$TSMethodSignature};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSMethodSignature_ts$TSMethodSignature(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSPropertySignature.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSPropertySignature_ts = {
    TSPropertySignature: ___$romejs$js_analysis$src$evaluators$typescript$TSPropertySignature_ts$TSPropertySignature};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSPropertySignature_ts$TSPropertySignature(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypeLiteral.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypeLiteral_ts = {
    TSTypeLiteral: ___$romejs$js_analysis$src$evaluators$typescript$TSTypeLiteral_ts$TSTypeLiteral};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypeLiteral_ts$TSTypeLiteral(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSMappedType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSMappedType_ts = {
    TSMappedType: ___$romejs$js_analysis$src$evaluators$typescript$TSMappedType_ts$TSMappedType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSMappedType_ts$TSMappedType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTupleType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTupleType_ts = {
    TSTupleType: ___$romejs$js_analysis$src$evaluators$typescript$TSTupleType_ts$TSTupleType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTupleType_ts$TSTupleType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSRestType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSRestType_ts = {
    TSRestType: ___$romejs$js_analysis$src$evaluators$typescript$TSRestType_ts$TSRestType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSRestType_ts$TSRestType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSOptionalType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSOptionalType_ts = {
    TSOptionalType: ___$romejs$js_analysis$src$evaluators$typescript$TSOptionalType_ts$TSOptionalType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSOptionalType_ts$TSOptionalType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSParenthesizedType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSParenthesizedType_ts = {
    TSParenthesizedType: ___$romejs$js_analysis$src$evaluators$typescript$TSParenthesizedType_ts$TSParenthesizedType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSParenthesizedType_ts$TSParenthesizedType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSFunctionType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSFunctionType_ts = {
    TSFunctionType: ___$romejs$js_analysis$src$evaluators$typescript$TSFunctionType_ts$TSFunctionType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSFunctionType_ts$TSFunctionType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSConstructorType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSConstructorType_ts = {
    TSConstructorType: ___$romejs$js_analysis$src$evaluators$typescript$TSConstructorType_ts$TSConstructorType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSConstructorType_ts$TSConstructorType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSLiteralType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSLiteralType_ts = {
    TSLiteralType: ___$romejs$js_analysis$src$evaluators$typescript$TSLiteralType_ts$TSLiteralType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSLiteralType_ts$TSLiteralType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSArrayType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSArrayType_ts = {
    TSArrayType: ___$romejs$js_analysis$src$evaluators$typescript$TSArrayType_ts$TSArrayType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSArrayType_ts$TSArrayType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSIndexedAccessType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSIndexedAccessType_ts = {
    TSIndexedAccessType: ___$romejs$js_analysis$src$evaluators$typescript$TSIndexedAccessType_ts$TSIndexedAccessType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSIndexedAccessType_ts$TSIndexedAccessType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypeOperator.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypeOperator_ts = {
    TSTypeOperator: ___$romejs$js_analysis$src$evaluators$typescript$TSTypeOperator_ts$TSTypeOperator};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypeOperator_ts$TSTypeOperator(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSInferType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSInferType_ts = {
    TSInferType: ___$romejs$js_analysis$src$evaluators$typescript$TSInferType_ts$TSInferType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSInferType_ts$TSInferType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypeAnnotation.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAnnotation_ts = {
    TSTypeAnnotation: ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAnnotation_ts$TSTypeAnnotation};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAnnotation_ts$TSTypeAnnotation(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSConditionalType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSConditionalType_ts = {
    TSConditionalType: ___$romejs$js_analysis$src$evaluators$typescript$TSConditionalType_ts$TSConditionalType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSConditionalType_ts$TSConditionalType(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypeAssertion.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAssertion_ts = {
    TSTypeAssertion: ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAssertion_ts$TSTypeAssertion};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAssertion_ts$TSTypeAssertion(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSExpressionWithTypeArguments.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSExpressionWithTypeArguments_ts = {
    TSExpressionWithTypeArguments: ___$romejs$js_analysis$src$evaluators$typescript$TSExpressionWithTypeArguments_ts$TSExpressionWithTypeArguments};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSExpressionWithTypeArguments_ts$TSExpressionWithTypeArguments(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSInterfaceBody.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSInterfaceBody_ts = {
    TSInterfaceBody: ___$romejs$js_analysis$src$evaluators$typescript$TSInterfaceBody_ts$TSInterfaceBody};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSInterfaceBody_ts$TSInterfaceBody(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSInterfaceDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSInterfaceDeclaration_ts = {
    TSInterfaceDeclaration: ___$romejs$js_analysis$src$evaluators$typescript$TSInterfaceDeclaration_ts$TSInterfaceDeclaration};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSInterfaceDeclaration_ts$TSInterfaceDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypeAliasDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAliasDeclaration_ts = {
    TSTypeAliasDeclaration: ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAliasDeclaration_ts$TSTypeAliasDeclaration};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAliasDeclaration_ts$TSTypeAliasDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSEnumMember.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSEnumMember_ts = {
    TSEnumMember: ___$romejs$js_analysis$src$evaluators$typescript$TSEnumMember_ts$TSEnumMember};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSEnumMember_ts$TSEnumMember(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSEnumDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSEnumDeclaration_ts = {
    TSEnumDeclaration: ___$romejs$js_analysis$src$evaluators$typescript$TSEnumDeclaration_ts$TSEnumDeclaration};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSEnumDeclaration_ts$TSEnumDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSModuleBlock.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSModuleBlock_ts = {
    TSModuleBlock: ___$romejs$js_analysis$src$evaluators$typescript$TSModuleBlock_ts$TSModuleBlock};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSModuleBlock_ts$TSModuleBlock(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSModuleDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSModuleDeclaration_ts = {
    TSModuleDeclaration: ___$romejs$js_analysis$src$evaluators$typescript$TSModuleDeclaration_ts$TSModuleDeclaration};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSModuleDeclaration_ts$TSModuleDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSImportEqualsDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSImportEqualsDeclaration_ts = {
    TSImportEqualsDeclaration: ___$romejs$js_analysis$src$evaluators$typescript$TSImportEqualsDeclaration_ts$TSImportEqualsDeclaration};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSImportEqualsDeclaration_ts$TSImportEqualsDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSExternalModuleReference.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSExternalModuleReference_ts = {
    TSExternalModuleReference: ___$romejs$js_analysis$src$evaluators$typescript$TSExternalModuleReference_ts$TSExternalModuleReference};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSExternalModuleReference_ts$TSExternalModuleReference(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSTypeParameterInstantiation.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameterInstantiation_ts = {
    TSTypeParameterInstantiation: ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameterInstantiation_ts$TSTypeParameterInstantiation};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameterInstantiation_ts$TSTypeParameterInstantiation(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSExportAssignment.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSExportAssignment_ts = {
    TSExportAssignment: ___$romejs$js_analysis$src$evaluators$typescript$TSExportAssignment_ts$TSExportAssignment};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSExportAssignment_ts$TSExportAssignment(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSNamespaceExportDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSNamespaceExportDeclaration_ts = {
    TSNamespaceExportDeclaration: ___$romejs$js_analysis$src$evaluators$typescript$TSNamespaceExportDeclaration_ts$TSNamespaceExportDeclaration};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSNamespaceExportDeclaration_ts$TSNamespaceExportDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSDeclareFunction.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSDeclareFunction_ts = {
    TSDeclareFunction: ___$romejs$js_analysis$src$evaluators$typescript$TSDeclareFunction_ts$TSDeclareFunction};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSDeclareFunction_ts$TSDeclareFunction(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSDeclareMethod.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSDeclareMethod_ts = {
    TSDeclareMethod: ___$romejs$js_analysis$src$evaluators$typescript$TSDeclareMethod_ts$TSDeclareMethod};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSDeclareMethod_ts$TSDeclareMethod(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSCallSignatureDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSCallSignatureDeclaration_ts = {
    TSCallSignatureDeclaration: ___$romejs$js_analysis$src$evaluators$typescript$TSCallSignatureDeclaration_ts$TSCallSignatureDeclaration};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSCallSignatureDeclaration_ts$TSCallSignatureDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSConstructSignatureDeclaration.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSConstructSignatureDeclaration_ts = {
    TSConstructSignatureDeclaration: ___$romejs$js_analysis$src$evaluators$typescript$TSConstructSignatureDeclaration_ts$TSConstructSignatureDeclaration};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSConstructSignatureDeclaration_ts$TSConstructSignatureDeclaration(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSAnyKeyword.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSAnyKeyword_ts = {
    TSAnyKeyword: ___$romejs$js_analysis$src$evaluators$typescript$TSAnyKeyword_ts$TSAnyKeyword};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSAnyKeyword_ts$TSAnyKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSBooleanKeyword.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSBooleanKeyword_ts = {
    TSBooleanKeyword: ___$romejs$js_analysis$src$evaluators$typescript$TSBooleanKeyword_ts$TSBooleanKeyword};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSBooleanKeyword_ts$TSBooleanKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSBigIntKeyword.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSBigIntKeyword_ts = {
    TSBigIntKeyword: ___$romejs$js_analysis$src$evaluators$typescript$TSBigIntKeyword_ts$TSBigIntKeyword};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSBigIntKeyword_ts$TSBigIntKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSNeverKeyword.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSNeverKeyword_ts = {
    TSNeverKeyword: ___$romejs$js_analysis$src$evaluators$typescript$TSNeverKeyword_ts$TSNeverKeyword};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSNeverKeyword_ts$TSNeverKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSNumberKeyword.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSNumberKeyword_ts = {
    TSNumberKeyword: ___$romejs$js_analysis$src$evaluators$typescript$TSNumberKeyword_ts$TSNumberKeyword};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSNumberKeyword_ts$TSNumberKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSObjectKeyword.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSObjectKeyword_ts = {
    TSObjectKeyword: ___$romejs$js_analysis$src$evaluators$typescript$TSObjectKeyword_ts$TSObjectKeyword};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSObjectKeyword_ts$TSObjectKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSStringKeyword.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSStringKeyword_ts = {
    TSStringKeyword: ___$romejs$js_analysis$src$evaluators$typescript$TSStringKeyword_ts$TSStringKeyword};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSStringKeyword_ts$TSStringKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSSymbolKeyword.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSSymbolKeyword_ts = {
    TSSymbolKeyword: ___$romejs$js_analysis$src$evaluators$typescript$TSSymbolKeyword_ts$TSSymbolKeyword};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSSymbolKeyword_ts$TSSymbolKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSUndefinedKeyword.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSUndefinedKeyword_ts = {
    TSUndefinedKeyword: ___$romejs$js_analysis$src$evaluators$typescript$TSUndefinedKeyword_ts$TSUndefinedKeyword};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSUndefinedKeyword_ts$TSUndefinedKeyword(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/Unknown.ts

  const ___$romejs$js_analysis$src$evaluators$core$Unknown_ts = {
    Unknown: ___$romejs$js_analysis$src$evaluators$core$Unknown_ts$Unknown};
  function ___$romejs$js_analysis$src$evaluators$core$Unknown_ts$Unknown(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/OptionalMemberExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$OptionalMemberExpression_ts = {
    OptionalMemberExpression: ___$romejs$js_analysis$src$evaluators$core$OptionalMemberExpression_ts$OptionalMemberExpression};
  function ___$romejs$js_analysis$src$evaluators$core$OptionalMemberExpression_ts$OptionalMemberExpression(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/core/OptionalCallExpression.ts

  const ___$romejs$js_analysis$src$evaluators$core$OptionalCallExpression_ts = {
    OptionalCallExpression: ___$romejs$js_analysis$src$evaluators$core$OptionalCallExpression_ts$OptionalCallExpression};
  function ___$romejs$js_analysis$src$evaluators$core$OptionalCallExpression_ts$OptionalCallExpression(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSNonNullExpression.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSNonNullExpression_ts = {
    TSNonNullExpression: ___$romejs$js_analysis$src$evaluators$typescript$TSNonNullExpression_ts$TSNonNullExpression};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSNonNullExpression_ts$TSNonNullExpression(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSAsExpression.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSAsExpression_ts = {
    TSAsExpression: ___$romejs$js_analysis$src$evaluators$typescript$TSAsExpression_ts$TSAsExpression};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSAsExpression_ts$TSAsExpression(node) {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSUnionType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSUnionType_ts = {
    TSUnionType: ___$romejs$js_analysis$src$evaluators$typescript$TSUnionType_ts$TSUnionType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSUnionType_ts$TSUnionType(node) {
    node;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/typescript/TSIntersectionType.ts

  const ___$romejs$js_analysis$src$evaluators$typescript$TSIntersectionType_ts = {
    TSIntersectionType: ___$romejs$js_analysis$src$evaluators$typescript$TSIntersectionType_ts$TSIntersectionType};
  function ___$romejs$js_analysis$src$evaluators$typescript$TSIntersectionType_ts$TSIntersectionType(node) {
    node;
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/src/evaluators/index.ts

  const ___$romejs$js_analysis$src$evaluators$index_ts = {};
  Object.keys(___$romejs$js_analysis$src$evaluators$core$LogicalExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$LogicalExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$TryStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$TryStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ObjectMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ObjectMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$SwitchCase_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$SwitchCase_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ExportNamedDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ExportNamedDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$VariableDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$VariableDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$InterpreterDirective_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$InterpreterDirective_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ImportDefaultSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ImportDefaultSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ClassPrivateProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ClassPrivateProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$UnaryExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$UnaryExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ObjectExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ObjectExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$FunctionDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$FunctionDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ClassDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ClassDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$NumericLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$NumericLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ClassMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ClassMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$WhileStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$WhileStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$AssignmentPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$AssignmentPattern_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$DirectiveLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$DirectiveLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$WithStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$WithStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$RestElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$RestElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$AssignmentExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$AssignmentExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$MetaProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$MetaProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$Import_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$Import_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ImportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ImportDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$Program_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$Program_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ForStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ForStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$FunctionExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$FunctionExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$BlockStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$BlockStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ArrayPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ArrayPattern_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ThrowStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ThrowStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$IfStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$IfStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ClassProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ClassProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$AwaitExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$AwaitExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$DebuggerStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$DebuggerStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$CatchClause_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$CatchClause_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$UpdateExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$UpdateExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ClassExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ClassExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ArrowFunctionExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ArrowFunctionExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$NewExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$NewExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ForInStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ForInStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$BinaryExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$BinaryExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ContinueStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ContinueStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$PrivateName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$PrivateName_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$Directive_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$Directive_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$StringLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$StringLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$MemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$MemberExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ExportDefaultSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ExportDefaultSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ThisExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ThisExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ForOfStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ForOfStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$BigIntLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$BigIntLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$BooleanLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$BooleanLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$Identifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$Identifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ExportAllDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ExportAllDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ObjectPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ObjectPattern_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$BreakStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$BreakStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$TemplateElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$TemplateElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$RestProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$RestProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ConditionalExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ConditionalExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$DoExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$DoExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$SwitchStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$SwitchStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$SequenceExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$SequenceExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$TaggedTemplateExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$TaggedTemplateExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$VariableDeclarator_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$VariableDeclarator_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$EmptyStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$EmptyStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$CallExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$CallExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$Super_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$Super_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ImportSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ImportSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ArrayExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ArrayExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ExportSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ExportSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$SpreadProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$SpreadProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ExportDefaultDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ExportDefaultDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ReturnStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ReturnStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ExportNamespaceSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ExportNamespaceSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ImportNamespaceSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ImportNamespaceSpecifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$DoWhileStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$DoWhileStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ClassPrivateMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ClassPrivateMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ExpressionStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ExpressionStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$RegExpLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$RegExpLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$TemplateLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$TemplateLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$LabeledStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$LabeledStatement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$YieldExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$YieldExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$ObjectProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$ObjectProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$NullLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$NullLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$SpreadElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$SpreadElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXText_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXText_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXEmptyExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXEmptyExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXNamespacedName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXNamespacedName_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXIdentifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXClosingFragment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXClosingFragment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXOpeningFragment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXOpeningFragment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXClosingElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXClosingElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXExpressionContainer_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXExpressionContainer_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXMemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXMemberExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXSpreadChild_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXSpreadChild_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXSpreadAttribute_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXSpreadAttribute_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXOpeningElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXOpeningElement_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXFragment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXFragment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$jsx$JSXAttribute_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$jsx$JSXAttribute_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowIntersectionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowIntersectionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowAnyTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowAnyTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclareClass_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareClass_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowNumericLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowNumericLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowQualifiedTypeIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowQualifiedTypeIdentifier_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclareExportAllDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareExportAllDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowBooleanTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowBooleanTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowNullableTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowNullableTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclareVariable_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareVariable_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowGenericTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowGenericTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclareInterface_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareInterface_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowClassImplements_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowClassImplements_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowTypeAlias_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowTypeAlias_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowThisTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowThisTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclareModuleExports_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareModuleExports_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowVoidTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowVoidTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclareFunction_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareFunction_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameterInstantiation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameterInstantiation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclareModule_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareModule_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeCallProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeCallProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowVariance_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowVariance_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowNullLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowNullLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowTupleTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowTupleTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclaredPredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclaredPredicate_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameter_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameter_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowOpaqueType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowOpaqueType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowArrayTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowArrayTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowStringLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowStringLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameterDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowTypeParameterDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceExtends_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceExtends_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowEmptyTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowEmptyTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowInferredPredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowInferredPredicate_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclareExportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareExportDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowExistsTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowExistsTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowStringTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowStringTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowBigIntTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowBigIntTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowInterface_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowInterface_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowUnionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowUnionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeSpreadProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeSpreadProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowMixedTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowMixedTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowNumericLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowNumericLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowTypeofTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowTypeofTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowTypeCastExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowTypeCastExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowBooleanLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowBooleanLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeIndexer_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeIndexer_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeParam_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeParam_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclareTypeAlias_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareTypeAlias_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeProperty_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowNumberTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowNumberTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowDeclareOpaqueType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowDeclareOpaqueType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowInterfaceTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeInternalSlot_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowObjectTypeInternalSlot_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeParamRest_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$flow$FlowFunctionTypeParamRest_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSUnknownKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSUnknownKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSImportType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSImportType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSQualifiedName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSQualifiedName_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypeReference_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypeReference_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypePredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypePredicate_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSThisType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSThisType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypeQuery_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypeQuery_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameter_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameter_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameterDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameterDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSIndexSignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSIndexSignature_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSMethodSignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSMethodSignature_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSPropertySignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSPropertySignature_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypeLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypeLiteral_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSMappedType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSMappedType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTupleType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTupleType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSRestType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSRestType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSOptionalType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSOptionalType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSParenthesizedType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSParenthesizedType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSFunctionType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSFunctionType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSConstructorType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSConstructorType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSLiteralType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSLiteralType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSArrayType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSArrayType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSIndexedAccessType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSIndexedAccessType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypeOperator_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypeOperator_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSInferType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSInferType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSConditionalType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSConditionalType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypeAssertion_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAssertion_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSExpressionWithTypeArguments_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSExpressionWithTypeArguments_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSInterfaceBody_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSInterfaceBody_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSInterfaceDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSInterfaceDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypeAliasDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypeAliasDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSEnumMember_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSEnumMember_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSEnumDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSEnumDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSModuleBlock_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSModuleBlock_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSModuleDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSModuleDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSImportEqualsDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSImportEqualsDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSExternalModuleReference_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSExternalModuleReference_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameterInstantiation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSTypeParameterInstantiation_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSExportAssignment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSExportAssignment_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSNamespaceExportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSNamespaceExportDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSDeclareFunction_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSDeclareFunction_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSDeclareMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSDeclareMethod_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSCallSignatureDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSCallSignatureDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSConstructSignatureDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSConstructSignatureDeclaration_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSAnyKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSAnyKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSBooleanKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSBooleanKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSBigIntKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSBigIntKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSNeverKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSNeverKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSNumberKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSNumberKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSObjectKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSObjectKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSStringKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSStringKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSSymbolKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSSymbolKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSUndefinedKeyword_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSUndefinedKeyword_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$Unknown_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$Unknown_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$OptionalMemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$OptionalMemberExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$core$OptionalCallExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$core$OptionalCallExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSNonNullExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSNonNullExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSAsExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSAsExpression_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSUnionType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSUnionType_ts[key];
      }});
  });
  Object.keys(___$romejs$js_analysis$src$evaluators$typescript$TSIntersectionType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___$romejs$js_analysis$src$evaluators$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___$romejs$js_analysis$src$evaluators$typescript$TSIntersectionType_ts[key];
      }});
  });

  // romejs/js-analysis/src/Evaluator.ts

  ___$romejs$js_ast$src$utils_ts$assertNodeTypeSet(Object.keys(___$romejs$js_analysis$src$evaluators$index_ts));

  class ___$romejs$js_analysis$src$Evaluator_ts$ModuleSignatureManager {
    constructor(graph, getModuleSignature, topScope) {
      this.topScope = topScope;
      this.getModuleSignature = getModuleSignature;
      this.graph = graph;
      this.openTypes = new Map();
      this.filename = graph.filename;

      this.exportNamesToTypeId = new Map();
    }

    addAll(manager) {
      for (const [name, id] of manager.exportNamesToTypeId) {
        if (name === 'default') {
          continue;
        }

        this.exportNamesToTypeId.set(name, id);

        const openType = manager.openTypes.get(id);
        if (openType === undefined) {
          throw new Error('Expected an open type');
        }
        this.openTypes.set(id, openType);
      }
    }

    async init() {
      const {graph: graph, openTypes: openTypes} = this;

      for (const id in graph.types) {
        const open = new ___$romejs$js_analysis$src$types$OpenT_ts$default(this.topScope, undefined);
        openTypes.set(id, open);
      }

      let currGetType;

      const getType = id => {
        if (id === undefined) {
          throw new Error('expected id');
        }

        if (typeof id !== 'string') {
          throw new Error('expected string id');
        }

        const type = openTypes.get(id);

        if (type === undefined) {
          throw new Error(`${graph.filename}: Expected type of id ${id} but it doesn't exist, serialized data: ${String(
          JSON.stringify(currGetType))}`);
        }

        return type;
      };

      await Promise.all(
      graph.exports.map(def => {
        if (def.type === 'all') {
          return this.getModuleSignature(def.source, graph.filename);
        } else {
          return undefined;
        }
      }));

      for (const def of graph.exports) {
        if (def.type === 'all') {
          const manager = await this.getModuleSignature(
          def.source,
          graph.filename);
          if (manager !== undefined) {
            this.addAll(manager);
          }
        } else {
          this.exportNamesToTypeId.set(def.name, def.value);
        }
      }

      for (const id in graph.types) {
        const node = graph.types[id];
        const {origin: origin, type: type, data: data, human: human} = node;
        currGetType = node;

        const openT = openTypes.get(id);
        if (openT === undefined) {
          throw new Error('Expected an open type');
        }

        const TConstructor = ___$romejs$js_analysis$src$types$index_ts[type];
        ___$romejs$invariant$src$index_ts$default(
        TConstructor,
        'expected a valid internal type constructor name');

        const realT = TConstructor.hydrate(
        this.topScope,
        {loc: origin},
        data,
        getType);

        realT.setHuman(human);

        openT.shouldMatch(realT);
      }
    }

    link(importedName, type) {
      const graph = this.graph;

      const maybeExportId = this.exportNamesToTypeId.get(importedName);
      if (maybeExportId === undefined) {
        const error = new ___$romejs$js_analysis$src$types$errors$UnknownImportE_ts$default(this.topScope, type.originNode, {
          possibleNames: Array.from(this.exportNamesToTypeId.keys()),
          importedName: importedName,
          source: graph.filename});
        error.shouldMatch(type);
        return undefined;
      }

      const openT = this.openTypes.get(maybeExportId);
      if (openT === undefined) {
        throw new Error('Expected an open type');
      }

      type.setResolvedType(openT);
    }
  }

  class ___$romejs$js_analysis$src$Evaluator_ts$default {
    constructor(hub, filename) {
      this.filename = filename;
      this.nodeToType = new Map();
      this.exports = [];
      this.imports = [];
      this.hub = hub;
      this.graph = hub.graph;

      this.topScope = new ___$romejs$js_analysis$src$scopes_ts$Scope({evaluator: this});
      this.intrinsics = this.topScope.intrinsics = new ___$romejs$js_analysis$src$Intrinsics_ts$default(this.topScope);
      this.evaluatingType = undefined;
    }

    initModuleSignature(graph, getModuleSignature) {
      return new ___$romejs$js_analysis$src$Evaluator_ts$ModuleSignatureManager(graph, getModuleSignature, this.topScope);
    }

    seed(ast) {
      return this.evaluate(ast, this.topScope);
    }

    evaluate(node, scope) {
      if (node === undefined) {
        throw new Error('Expected node but received undefined');
      }

      const evaluator = ___$romejs$js_analysis$src$evaluators$index_ts[node.type];
      if (evaluator) {
        const oldEvaluatingType = this.evaluatingType;
        this.evaluatingType = node.type;
        let type = evaluator(node, scope, this.hub);
        if (type === undefined) {
          type = new ___$romejs$js_analysis$src$types$EmptyT_ts$default(scope, node);
        }
        this.evaluatingType = oldEvaluatingType;
        this.nodeToType.set(node, type);
        return type;
      } else {
        throw new Error('what is this? ' + node.type);
      }
    }

    getTypeFromEvaluatedNode(node) {
      const type = this.nodeToType.get(node);
      if (type === undefined) {
        throw new Error('getTypeFromEvaluatedNode() called on a node that has not been validated yet');
      } else {
        return type;
      }
    }

    addExport(name, type) {
      this.exports.push({
        type: 'local',
        name: name,
        value: type});
    }

    addExportAll(source) {
      this.exports.push({
        type: 'all',
        source: source});
    }

    addImport(t, opts) {
      this.imports.push({
        relative: opts.relative,
        importedName: opts.importedName,
        source: opts.source,
        type: t});
    }
  }

  // romejs/js-analysis/src/Utils.ts

  class ___$$priv$romejs$js_analysis$src$Utils_ts$ReduceRecursionError extends Error {}

  const ___$$priv$romejs$js_analysis$src$Utils_ts$TYPE_COMPATIBLE = {type: 'compatible'};

  const ___$$priv$romejs$js_analysis$src$Utils_ts$MAX_DEPTH = 100;

  class ___$romejs$js_analysis$src$Utils_ts$HumanBuilder {
    constructor() {
      this.stack = new Set();
      this.usedAliases = new Set();
      this.aliases = new Map();
    }

    isRecursive(t) {
      if (t.human !== undefined) {
        return false;
      }

      if (this.aliases.has(t)) {
        return true;
      }

      if (this.stack.has(t)) {
        return true;
      }

      return false;
    }

    humanize(type) {
      if (type.human !== undefined) {
        return type.human;
      }

      if (this.aliases.has(type)) {
        const alias = this.aliases.get(type);
        if (alias === undefined) {
          throw new Error('Expected alias');
        }
        return alias;
      }

      if (this.isRecursive(type)) {
        const alias = `Alias${type.id}`;
        this.aliases.set(type, alias);
        return alias;
      }

      this.stack.add(type);
      try {
        let humanized = type.humanize(this);

        const alias = this.aliases.get(type);
        if (alias !== undefined) {
          humanized = `${alias} = ${humanized}`;
        }
        return humanized;
      } finally {
        this.stack.delete(type);
      }
    }
  }

  class ___$romejs$js_analysis$src$Utils_ts$default {
    constructor(hub) {
      this.reduceCatchers = new Set();
      this.reduceCache = new Map();
      this.reduceStack = new Set();
      this.compatibilityDepth = 0;
      this.hub = hub;
      this.debug = false;
    }

    inspect(t, safe = false) {
      const prevDebug = this.debug;
      this.debug = true;

      const data = new Map();
      data.set('id', String(t.id));

      const {originLoc: originLoc, originEvaluator: originEvaluator} = t;
      if (originLoc === undefined) {
        data.set('origin', 'unknown');
      } else {
        data.set(
        'origin',
        `${String(originLoc.filename)}:${String(originLoc.start.line)}:${String(
        originLoc.start.column)}`);
      }
      if (originEvaluator !== undefined) {
        data.set('evaluator', originEvaluator);
      }

      const dataStr = Array.from(data.keys()).map(key => `${key}: ${String(data.get(key))}`).join(', ');

      let info = `${t.getConstructor().type}<`;
      if (safe === false) {
        info += `${this.humanize(t)}, `;
      }
      info += `${dataStr}>`;

      this.debug = prevDebug;
      return info;
    }

    assertClosed() {
      if (this.debug === false) {
        this.hub.assertClosed();
      }
    }

    explodeUnion(type) {
      return Array.from(new Set(this.reduce(type).explodeUnion()));
    }

    isCompatibleWith(a, b) {
      return this.checkCompability(a, b).type === 'compatible';
    }

    checkCompability(a, b) {
      this.assertClosed();

      const lower = this.reduce(a);
      const upper = this.reduce(b);

      if (lower === upper) {
        return ___$$priv$romejs$js_analysis$src$Utils_ts$TYPE_COMPATIBLE;
      }

      if (lower instanceof ___$romejs$js_analysis$src$types$AnyT_ts$default || upper instanceof ___$romejs$js_analysis$src$types$AnyT_ts$default) {
        return ___$$priv$romejs$js_analysis$src$Utils_ts$TYPE_COMPATIBLE;
      }

      if (this.compatibilityDepth > ___$$priv$romejs$js_analysis$src$Utils_ts$MAX_DEPTH) {
        throw new Error(`Max depth exceeded when checking compatibility of ${lower.inspect()} to ${upper.inspect()}`);
      }

      const cached = lower.compatibilityCache.get(upper);
      if (cached === undefined) {
        lower.compatibilityCache.set(upper, {
          type: 'incompatible',
          lower: lower,
          upper: upper});
      } else {
        return cached;
      }

      this.compatibilityDepth++;
      let ret;
      try {
        ret = lower.compatibleWith(upper);
      } catch (err) {
        if (err instanceof ___$$priv$romejs$js_analysis$src$Utils_ts$ReduceRecursionError) {
          ret = ___$$priv$romejs$js_analysis$src$Utils_ts$TYPE_COMPATIBLE;
        } else {
          throw err;
        }
      } finally {
        this.compatibilityDepth--;
      }
      let res;
      if (ret === true) {
        res = ___$$priv$romejs$js_analysis$src$Utils_ts$TYPE_COMPATIBLE;
      } else if (ret === false) {
        res = {type: 'incompatible', lower: a, upper: b};
      } else if (ret instanceof ___$romejs$js_analysis$src$types$errors$E_ts$default) {
        res = {type: 'incompatible', lower: a, upper: ret};
      } else {
        res = ret;
      }
      lower.compatibilityCache.set(upper, res);

      return res;
    }

    humanize(type) {
      this.assertClosed();

      return new ___$romejs$js_analysis$src$Utils_ts$HumanBuilder().humanize(type);
    }

    reduce(type) {
      this.assertClosed();

      const cached = this.reduceCache.get(type);
      if (cached !== undefined) {
        return cached;
      }

      if (this.reduceStack.has(type)) {
        return new ___$romejs$js_analysis$src$types$UnknownT_ts$default(type.scope, type.originNode);
      }

      if (this.reduceStack.size > ___$$priv$romejs$js_analysis$src$Utils_ts$MAX_DEPTH) {
        throw new Error('Max depth exceeded when reducing');
      }

      this.reduceStack.add(type);

      if (this.reduceCatchers.size) {
        for (const set of this.reduceCatchers) {
          set.add(type);
        }
      }

      try {
        const reduced = type.reduce();

        if (reduced === undefined) {
          throw new Error(`The reduce() method for ${this.inspect(type, true)} returned null`);
        }

        if (reduced.getConstructor().type === 'OpenT') {
          throw new Error(`The reduce() method for ${this.inspect(
          type,
          true)} returned an OpenT. This should never be possible. It likely forgot to return utils.reduce() on it.`);
        }

        if (this.debug === false) {
          this.reduceCache.set(type, reduced);
        }

        return reduced;
      } finally {
        this.reduceStack.delete(type);
      }
    }

    reduceCatch(type) {
      const involved = new Set();
      this.reduceCatchers.add(involved);

      const final = this.reduce(type);
      this.reduceCatchers.delete(involved);

      return {final: final, involved: involved};
    }
  }

  // romejs/js-analysis/src/Hub.ts

  const ___$$priv$romejs$js_analysis$src$Hub_ts$statuses = {
    OPEN: 0,
    CLOSING: 1,
    CLOSED: 2};

  class ___$romejs$js_analysis$src$Hub_ts$default {
    constructor(filename, projectConfig, ast) {
      this.context = new ___$romejs$js_compiler$src$lib$Context_ts$default({
        ast: ast,
        projectConfig: projectConfig,
        origin: 'Type checking'});
      this.utils = new ___$romejs$js_analysis$src$Utils_ts$default(this);
      this.graph = new ___$romejs$js_analysis$src$Graph_ts$default();
      this.evaluator = new ___$romejs$js_analysis$src$Evaluator_ts$default(this, filename);
      this.status = ___$$priv$romejs$js_analysis$src$Hub_ts$statuses.OPEN;
    }

    close() {
      this.status = ___$$priv$romejs$js_analysis$src$Hub_ts$statuses.CLOSING;

      for (const [node] of this.graph.nodesByValue) {
        this.utils.reduce(node);
      }

      this.status = ___$$priv$romejs$js_analysis$src$Hub_ts$statuses.CLOSED;
    }

    isClosing() {
      return this.status === ___$$priv$romejs$js_analysis$src$Hub_ts$statuses.CLOSING;
    }

    isOpen() {
      return this.isClosing() || this.status === ___$$priv$romejs$js_analysis$src$Hub_ts$statuses.OPEN;
    }

    isClosed() {
      return this.isClosing() || this.status === ___$$priv$romejs$js_analysis$src$Hub_ts$statuses.CLOSED;
    }

    assertOpen() {
      if (this.isClosed() && this.isClosing() === false) {
        throw new Error('This method can only be called when the graph has been open');
      }
    }

    assertClosed() {
      if (this.isOpen() && this.isClosing() === false) {
        throw new Error('This method can only be called when the graph has been closed');
      }
    }
  }

  // romejs/js-analysis/src/api/buildGraph.ts

  async function ___$romejs$js_analysis$src$api$buildGraph_ts$default(opts) {
    const {ast: ast, filename: filename, connected: connected, projectConfig: projectConfig, provider: provider} = opts;

    const hub = new ___$romejs$js_analysis$src$Hub_ts$default(filename, projectConfig, ast);
    const {evaluator: evaluator} = hub;
    if (provider.libs !== undefined) {
      let body = [];
      for (const ast of provider.libs) {
        body = [...body, ...ast.body];
      }
      evaluator.seed({
        type: 'Program',
        body: body});
    }
    evaluator.seed(ast);

    if (connected) {
      const graphs = new Map();
      async function getModuleSignature(source, relative) {
        const graphKey = `${relative}:${source}`;
        if (graphs.has(graphKey)) {
          return graphs.get(graphKey);
        }

        const graph = await provider.getExportTypes(relative, source);

        if (graph === undefined) {
          graphs.set(graphKey, undefined);
          return undefined;
        }

        if (graphs.has(graph.filename)) {
          const manager = graphs.get(graph.filename);
          graphs.set(graphKey, manager);
          return manager;
        }

        const manager = evaluator.initModuleSignature(graph, getModuleSignature);
        graphs.set(graphKey, manager);
        graphs.set(graph.filename, manager);
        await manager.init();
        return manager;
      }

      const seedCache = new Set();
      await Promise.all(
      evaluator.imports.map(({source: source, relative: relative}) => {
        const cacheKey = `${source}:${relative}`;
        if (seedCache.has(cacheKey)) {
          return undefined;
        }

        seedCache.add(cacheKey);
        return getModuleSignature(source, relative);
      }));

      for (const {source: source, importedName: importedName, relative: relative, type: type} of evaluator.imports) {
        const graphKey = `${relative}:${source}`;
        const graph = graphs.get(graphKey);
        if (graph === undefined) {
          continue;
        }

        if (importedName === undefined) {
          continue;
        }

        type.setAbsolute(graph.filename);
        graph.link(importedName, type);
      }
    }

    evaluator.intrinsics.link();
    hub.close();
    return hub;
  }

  // romejs/js-analysis/src/api/getModuleSignature.ts

  const ___$$priv$romejs$js_analysis$src$api$getModuleSignature_ts$exportsCache = new WeakMap();

  async function ___$romejs$js_analysis$src$api$getModuleSignature_ts$default(opts) {
    const {ast: ast, provider: provider} = opts;
    const {filename: filename} = ast;

    if (filename.includes('node_modules')) {
      return {
        filename: filename,
        exports: [],
        types: {}};
    }

    const cached = ___$$priv$romejs$js_analysis$src$api$getModuleSignature_ts$exportsCache.get(ast);
    if (cached !== undefined) {
      return cached;
    }

    const {
      evaluator: {exports: exports},
      utils: utils} = await ___$romejs$js_analysis$src$api$buildGraph_ts$default({
      ast: ast,
      filename: filename,
      projectConfig: opts.projectConfig,
      connected: false,
      provider: provider});
    const types = {};
    const exportMap = [];

    const added = new Set();

    function addType(type) {
      const reducedType = utils.reduce(type);
      if (added.has(reducedType)) {
        return reducedType.id;
      } else {
        added.add(reducedType);
      }

      if (reducedType instanceof ___$romejs$js_analysis$src$types$errors$E_ts$default) {
        types[reducedType.id] = {
          human: undefined,
          origin: reducedType.originLoc,
          type: 'AnyT',
          data: {}};
        return reducedType.id;
      }

      const data = reducedType.serialize(addType);

      types[reducedType.id] = {
        human: reducedType.human,
        origin: reducedType.originLoc,
        type: reducedType.getConstructor().type,
        data: data};
      return reducedType.id;
    }

    for (const def of exports) {
      if (def.type === 'all') {
        exportMap.push({
          type: 'all',
          source: def.source});
      } else if (def.type === 'local') {
        exportMap.push({
          type: 'local',
          name: def.name,
          value: addType(def.value)});
      } else {
        throw new Error('unknown export def type');
      }
    }

    const result = {
      filename: filename,
      exports: exportMap,
      types: types};
    ___$$priv$romejs$js_analysis$src$api$getModuleSignature_ts$exportsCache.set(ast, result);
    return result;
  }

  // romejs/js-analysis/src/api/check.ts

  async function ___$romejs$js_analysis$src$api$check_ts$default(opts) {
    const hub = await ___$romejs$js_analysis$src$api$buildGraph_ts$default({
      ast: opts.ast,
      filename: opts.filename,
      connected: true,
      provider: opts.provider,
      projectConfig: opts.projectConfig});
    ___$$priv$romejs$js_analysis$src$api$check_ts$resolveGraph(hub);
    return hub.context.diagnostics;
  }

  function ___$$priv$romejs$js_analysis$src$api$check_ts$isError(t) {
    return t !== undefined && t instanceof ___$romejs$js_analysis$src$types$errors$E_ts$default;
  }

  function ___$$priv$romejs$js_analysis$src$api$check_ts$resolveGraph(hub) {
    const {graph: graph, utils: utils, context: context} = hub;

    const caughtErrors = new Set();

    for (const node of graph.nodes) {
      const lower = node.value;

      if (lower instanceof ___$romejs$js_analysis$src$types$OpenT_ts$default) {
        continue;
      }

      const reduced = utils.reduce(lower);
      if (reduced instanceof ___$romejs$js_analysis$src$types$errors$E_ts$default) {
        if (caughtErrors.has(reduced)) {
          continue;
        } else {
          caughtErrors.add(reduced);
        }

        const {
          lowerTarget: lowerTarget,
          upperTarget: upperTarget,
          advice: rawAdvice,
          message: message} = reduced.getError();

        if (___$$priv$romejs$js_analysis$src$api$check_ts$isError(lowerTarget) || ___$$priv$romejs$js_analysis$src$api$check_ts$isError(upperTarget)) {
          continue;
        }

        let advice = [];

        if (upperTarget !== undefined) {
          const marker = upperTarget && !(upperTarget instanceof reduced.constructor) ? utils.humanize(upperTarget) : undefined;
          const {originLoc: originLoc} = upperTarget;

          if (originLoc !== undefined && marker !== undefined) {
            advice.push({
              type: 'log',
              category: 'info',
              message: marker});
          } else if (originLoc !== undefined) {
            advice.push({
              type: 'frame',
              filename: originLoc.filename,
              start: originLoc.start,
              end: originLoc.end,
              marker: marker});
          }
        }

        if (rawAdvice !== undefined) {
          advice = advice.concat(rawAdvice);
        }

        context.addNodeDiagnostic(lowerTarget.originNode, {
          category: 'typeError',
          message: message,
          advice: advice,
          marker: lowerTarget && !(lowerTarget instanceof reduced.constructor) ? utils.humanize(lowerTarget) : undefined});
        continue;
      }

      if (node.lines.length === 0) {
        continue;
      }

      for (const line of node.lines) {
        const upper = line.value;
        const compatibility = utils.checkCompability(upper, lower);

        if (compatibility.type === 'incompatible') {
          if (___$$priv$romejs$js_analysis$src$api$check_ts$isError(compatibility.lower) || ___$$priv$romejs$js_analysis$src$api$check_ts$isError(compatibility.upper)) {
            continue;
          }

          const advice = [{
            type: 'log',
            category: 'error',
            message: `This type is incompatible with expected type of`}];

          const {originLoc: originLoc} = upper;
          if (originLoc === undefined) {
            advice.push({
              type: 'log',
              category: 'info',
              message: utils.humanize(upper)});
          } else {
            advice.push({
              type: 'frame',
              filename: originLoc.filename,
              start: originLoc.start,
              end: originLoc.end,
              marker: utils.humanize(upper)});
          }

          context.addNodeDiagnostic(compatibility.lower.originNode, {
            category: 'typeError',
            message: 'Type incompatibility found',
            marker: utils.humanize(compatibility.lower),
            advice: advice});
        }
      }
    }

    return context.diagnostics;
  }

  // romejs/js-analysis/src/types.ts

  const ___$romejs$js_analysis$src$types_ts = {};

  // romejs/js-analysis/src/index.ts


  // romejs/core/src/worker/extensions.ts

  function ___$romejs$core$src$worker$extensions_ts$getExtensionName(filename) {
    const [, ...parts] = filename.split('.');

    for (let i = 0; i < parts.length; i++) {
      const ext = parts.slice(i).join('.');
      const extInfo = ___$$priv$romejs$core$src$worker$extensions_ts$extensions.get(ext);
      if (extInfo !== undefined) {
        return ext;
      }
    }

    return undefined;
  }

  function ___$romejs$core$src$worker$extensions_ts$getExtensionHandler(filename) {
    const ext = ___$romejs$core$src$worker$extensions_ts$getExtensionName(filename);

    if (ext !== undefined) {
      const extInfo = ___$$priv$romejs$core$src$worker$extensions_ts$extensions.get(ext);
      ___$romejs$invariant$src$index_ts$default(extInfo !== undefined, 'expected extension info');
      return extInfo;
    }

    return undefined;
  }

  const ___$$priv$romejs$core$src$worker$extensions_ts$textExt = {
    toJs({src: src}) {
      const serial = JSON.stringify(src);
      return `export default ${serial};`;
    }};

  const ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt = {
    hasScale: true,
    isBinary: true,

    async toJs() {
      return `export default '';`;
    }};

  function ___$$priv$romejs$core$src$worker$extensions_ts$getRJSONMode(filename) {
    return filename.endsWith('.rjson') ? 'son' : 'json';
  }

  function ___$$priv$romejs$core$src$worker$extensions_ts$shouldDeoptJSON(mode, src) {
    return mode === 'json' && src.length > 50000;
  }

  const ___$$priv$romejs$core$src$worker$extensions_ts$jsonExt = {
    hasteMode: 'noext',

    async lint(info) {
      const {file: ref, projectConfig: projectConfig, worker: worker} = info;
      const {uid: uid, real: real} = ref;
      const src = await worker.readFile(real);

      const mode = ___$$priv$romejs$core$src$worker$extensions_ts$getRJSONMode(real);
      let formatted = src;

      if (projectConfig.format.enabled) {
        if (___$$priv$romejs$core$src$worker$extensions_ts$shouldDeoptJSON(mode, src)) {
          ___$romejs$codec_json$src$index_ts$parseJSON({
            mode: mode,
            filename: ref.uid,
            input: src,
            locations: false});
        } else {
          const consumer = ___$romejs$codec_json$src$index_ts$consumeJSON({input: src, filename: uid, mode: mode});

          if (mode === 'json') {
            formatted = String(
            JSON.stringify(consumer.asMixed(), undefined, '  '));
          } else {
            formatted = consumer.stringify() + '\n';
          }
        }
      }

      return {
        diagnostics: [],
        raw: src,
        formatted: formatted};
    },

    toJs({file: file, src: src}) {
      const mode = ___$$priv$romejs$core$src$worker$extensions_ts$getRJSONMode(file.real);
      const obj = ___$romejs$codec_json$src$index_ts$parseJSON({
        mode: mode,
        filename: file.uid,
        input: src,
        locations: false});

      const rawJson = JSON.stringify(obj);
      const json = rawJson === undefined ? 'undefined' : rawJson;

      return `export default ${json};`;
    }};

  const ___$$priv$romejs$core$src$worker$extensions_ts$jsExt = {
    canAnalyze: true,
    hasteMode: 'ext',

    toJs({src: src}) {
      return src;
    },

    async lint(info) {
      const {file: ref, projectConfig: projectConfig, prefetchedModuleSignatures: prefetchedModuleSignatures, worker: worker} = info;
      const {ast: ast, src: src} = await worker.parse(ref);

      worker.logger.info(`Linting: `, ref.real);

      const res = await ___$romejs$js_compiler$src$api$lint_ts$default({
        options: {},
        ast: ast,
        projectConfig: projectConfig,
        src: src});

      let {diagnostics: diagnostics} = res;

      let typeCheckingEnabled = projectConfig.typeChecking.enabled === true;
      if (projectConfig.typeChecking.libs.includes(ref.real) === true) {
        typeCheckingEnabled = false;
      }

      if (typeCheckingEnabled) {
        const typeCheckProvider = await worker.getTypeCheckProvider(
        ref.project,
        prefetchedModuleSignatures);
        const typeDiagnostics = await ___$romejs$js_analysis$src$api$check_ts$default({
          ast: ast,
          filename: ref.uid,
          provider: typeCheckProvider,
          projectConfig: projectConfig});
        diagnostics = [...diagnostics, ...typeDiagnostics];
      }

      return {
        diagnostics: diagnostics,
        raw: src,
        formatted: res.src};
    }};

  const ___$$priv$romejs$core$src$worker$extensions_ts$extensions = new Map();

  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('html', ___$$priv$romejs$core$src$worker$extensions_ts$textExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('htm', ___$$priv$romejs$core$src$worker$extensions_ts$textExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('css', ___$$priv$romejs$core$src$worker$extensions_ts$textExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('txt', ___$$priv$romejs$core$src$worker$extensions_ts$textExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('md', ___$$priv$romejs$core$src$worker$extensions_ts$textExt);

  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('png', ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('jpg', ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('jpeg', ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('gif', ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('webm', ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('mp4', ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('m4v', ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('avi', ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('mkv', ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('mp3', ___$$priv$romejs$core$src$worker$extensions_ts$binaryExt);

  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('js', ___$$priv$romejs$core$src$worker$extensions_ts$jsExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('jsx', ___$$priv$romejs$core$src$worker$extensions_ts$jsExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('mjs', ___$$priv$romejs$core$src$worker$extensions_ts$jsExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('rjs', ___$$priv$romejs$core$src$worker$extensions_ts$jsExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('ts', ___$$priv$romejs$core$src$worker$extensions_ts$jsExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('tsx', ___$$priv$romejs$core$src$worker$extensions_ts$jsExt);

  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('json', ___$$priv$romejs$core$src$worker$extensions_ts$jsonExt);
  ___$$priv$romejs$core$src$worker$extensions_ts$extensions.set('son', ___$$priv$romejs$core$src$worker$extensions_ts$jsonExt);

  const ___$romejs$core$src$worker$extensions_ts$JS_EXTENSIONS = ['js', 'mjs', 'rjs', 'ts', 'tsx', 'jsx'];

  const ___$romejs$core$src$worker$extensions_ts$IMPLICIT_JS_EXTENSIONS = ['js', 'js', 'json', 'ts', 'tsx'];

  // romejs/core/src/master/MemoryFileSystem.ts

  const ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path = require('path');
  const ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$fs = require('fs');
  const ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$DEFAULT_DENYLIST = ['.hg', '.git'];

  const ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$PACKAGE_JSON = 'package.json';

  const ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$PRIORITY_FILES = new Set([___$$priv$romejs$core$src$master$MemoryFileSystem_ts$PACKAGE_JSON, ___$romejs$core$src$common$constants_ts$ROME_CONFIG_FILENAME]);

  async function ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$createRegularWatcher(memoryFs, diagnostics, projectFolder) {
    const {logger: logger} = memoryFs.master;

    const activityPrefix = `Adding project ${projectFolder}`;
    const activity = memoryFs.master.connectedReporters.spinner();
    activity.setText(activityPrefix);

    const watcher = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$fs.watch(
    projectFolder,
    {recursive: true, persistent: false},
    (eventType, filename) => {
      const loc = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.resolve(projectFolder, filename);

      memoryFs.stat(loc).then(stats => {
        const diagnostics = memoryFs.master.createDisconnectedDiagnosticsProcessor(
        ['memory-fs: Processing fs.watch changes']);
        if (stats.type === 'file') {
          memoryFs.handleFileChange(loc, stats, {diagnostics: diagnostics});
        } else if (stats.type === 'directory') {
          memoryFs.addDirectory(loc, stats, {diagnostics: diagnostics});
        }
      }).catch(err => {
        if (err.code === 'ENOENT') {
          memoryFs.handleDeletion(loc);
        } else {
          throw err;
        }
      });
    });

    const stats = await memoryFs.stat(projectFolder);
    let totalFiles = 0;
    await memoryFs.addDirectory(projectFolder, stats, {
      diagnostics: diagnostics,
      tick(filename) {
        totalFiles++;

        activity.setText(
        `${activityPrefix}: #${___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(totalFiles)}: ${filename}`);
        activity.render();
      }});
    logger.info(
    `[MemoryFileSystem] Finished initial crawl for ${projectFolder} - added ${___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(
    memoryFs.countFiles(projectFolder))} files`);
    activity.end();

    return () => {
      watcher.close();
    };
  }

  async function ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$createWatchmanWatcher(memoryFs, diagnostics, projectFolder) {
    try {
      const client = await ___$romejs$codec_watchman$src$index_ts$createWatchmanClient(___$romejs$cli_reporter$src$Reporter_ts$default.fromProcess());

      const {event: event, root: root} = await client.createSubscription(projectFolder, {
        fields: ['mtime', 'name', 'size', 'type', 'exists']});

      const initial = await event.wait();
      ___$romejs$invariant$src$index_ts$default(
      initial.is_fresh_instance === true,
      'expected this to be a fresh instance');

      const processChanges = async (data, diagnostics) => {
        const dirs = [];
        const files = [];

        for (const file of data.files) {
          if (file.exists === false) {
            memoryFs.handleDeletion(___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.join(root, file.name));
            continue;
          }

          if (file.type === 'f') {
            const basename = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.basename(file.name);

            if (___$$priv$romejs$core$src$master$MemoryFileSystem_ts$PRIORITY_FILES.has(basename)) {
              files.unshift(file);
            } else {
              files.push(file);
            }
          } else if (file.type === 'd') {
            dirs.push(file);
          } else if (file.type === 'l') {} else {}
        }

        await Promise.all(
        dirs.map(async dir => {
          await memoryFs.addDirectory(
          ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.join(root, dir.name),
          {
            size: dir.size,
            mtime: dir.mtime,
            type: 'directory'},
          {diagnostics: diagnostics, watchman: true});
        }));

        await Promise.all(
        files.map(async file => {
          const stats = {
            size: file.size,
            mtime: file.mtime,
            type: 'file'};

          const loc = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.join(root, file.name);
          if (memoryFs.files.has(loc)) {
            await memoryFs.handleFileChange(loc, stats, {
              diagnostics: diagnostics,
              watchman: true});
          } else {
            await memoryFs.addFile(loc, stats, {diagnostics: diagnostics, watchman: true});
          }
        }));
      };

      await processChanges(initial, diagnostics);

      event.subscribe(data => {
        processChanges(
        data,
        memoryFs.master.createDisconnectedDiagnosticsProcessor(['memory-fs: Processing watchman changes']));
      });

      return () => {};
    } catch (err) {
      if (err.message.includes('RootResolveError')) {
        memoryFs.master.connectedReporters.error(
        `Failed to use watchman: ${err.message}`);
        return ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$createRegularWatcher(memoryFs, diagnostics, projectFolder);
      } else {
        throw err;
      }
    }
  }

  class ___$romejs$core$src$master$MemoryFileSystem_ts$default {
    constructor(master) {
      this.master = master;

      this.watchPromises = new Map();
      this.directoryListings = new Map();
      this.directories = new Map();
      this.files = new Map();
      this.manifests = new Map();
      this.watchers = new Map();

      this.changedFileEvent = new ___$romejs$events$src$Event_ts$default({name: 'MemoryFileSystem.changedFile'});
      this.deletedFileEvent = new ___$romejs$events$src$Event_ts$default({name: 'MemoryFileSystem.deletedFile'});
    }

    unwatchAll() {
      for (const close of this.watchers.values()) {
        close();
      }
    }

    readdir(loc) {
      const listing = this.directoryListings.get(loc);
      if (listing === undefined) {
        return [];
      } else {
        return listing;
      }
    }

    isDirectory(filename) {
      return this.directories.has(filename);
    }

    isFile(filename) {
      return this.files.has(filename);
    }

    getFiles() {
      return Array.from(this.files.values());
    }

    getManifestDefinition(dirname) {
      return this.manifests.get(dirname);
    }

    getManifest(dirname) {
      const def = this.getManifestDefinition(dirname);
      if (def === undefined) {
        return undefined;
      } else {
        return def.manifest;
      }
    }

    addFileToDirectoryListing(filename) {
      const dirname = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.dirname(filename);
      let listing = this.directoryListings.get(dirname);
      if (listing === undefined) {
        listing = new Set();
        this.directoryListings.set(dirname, listing);
      }
      listing.add(filename);
    }

    handleDeletion(loc) {
      const folderInfo = this.directories.get(loc);
      if (folderInfo !== undefined) {
        this.directories.delete(loc);

        const listing = this.directoryListings.get(loc);
        if (listing !== undefined) {
          this.directoryListings.delete(loc);
          for (const file of listing) {
            this.handleDeletion(file);
          }
        }
      }

      this.files.delete(loc);

      this.handleDeletedHaste(loc);

      const basename = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.basename(loc);
      if (___$romejs$codec_js_manifest$src$index_ts$getManifestKindFromBasename(basename) !== undefined) {
        this.handleDeletedManifest(loc);
      }

      const dirname = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.dirname(loc);
      const parentListing = this.directoryListings.get(dirname);
      if (parentListing !== undefined) {
        parentListing.delete(loc);
      }

      this.deletedFileEvent.send({filename: loc});
    }

    handleDeletedHaste(loc) {
      const hasteName = this.getHasteName(loc);
      if (hasteName === undefined) {
        return undefined;
      }

      const projects = this.master.projectManager.getHierarchyFromFilename(loc);
      for (const {hasteMap: hasteMap} of projects) {
        const existing = hasteMap.get(hasteName);
        if (existing === loc) {
          hasteMap.delete(hasteName);
        }
      }
    }

    handleDeletedManifest(loc) {
      const folder = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.dirname(loc);
      const manifestDef = this.manifests.get(folder);
      if (manifestDef === undefined) {
        return undefined;
      }

      const {manifest: manifest} = manifestDef;

      this.manifests.delete(folder);

      const namedManifest = ___$romejs$codec_js_manifest$src$index_ts$ifNamedManifest(manifest);
      if (namedManifest === undefined || !this.isInsideProject(loc)) {
        return undefined;
      }

      for (const project of this.master.projectManager.getHierarchyFromFilename(
      loc)) {
        const pkg = project.packages.get(namedManifest.name);
        if (pkg === undefined) {
          continue;
        }

        if (pkg.folder === folder) {
          project.packages.delete(namedManifest.name);
        }
      }
    }

    async handleFileChange(loc, stats, opts) {
      const oldStats = this.getFileStats(loc);
      const changed = await this.addFile(loc, stats, opts);
      if (changed) {
        const newStats = this.getFileStatsAssert(loc);
        this.changedFileEvent.send({filename: loc, oldStats: oldStats, newStats: newStats});
      }
    }

    async watch(projectFolder, config) {
      const {logger: logger} = this.master;

      const cached = this.watchPromises.get(projectFolder);
      if (cached !== undefined) {
        await cached;
        return undefined;
      }

      if (this.watchers.has(projectFolder)) {
        return undefined;
      }

      for (const loc of this.watchers.keys()) {
        if ((projectFolder + ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.sep).startsWith(loc)) {
          logger.info(
          `[MemoryFileSystem] Skipped crawl for ${projectFolder} because we're already watching a parent directory`);
          return undefined;
        }
      }

      for (const [loc, promise] of this.watchPromises) {
        if ((projectFolder + ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.sep).startsWith(loc)) {
          await promise;
          return undefined;
        }
      }

      for (const [loc, promise] of this.watchPromises) {
        if (loc.startsWith(projectFolder + ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.sep)) {
          await promise;
        }
      }

      logger.info(
      `[MemoryFileSystem] Adding new project folder ${projectFolder}`);

      for (const [loc, closeWatcher] of this.watchers) {
        if (loc.startsWith(projectFolder + ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.sep)) {
          this.watchers.delete(loc);
          closeWatcher();
        }
      }

      const diagnostics = new ___$romejs$diagnostics$src$DiagnosticsProcessor_ts$default({
        origins: ['memory-fs: Crawl project folder']});

      let promise;
      if (config.files.watchman) {
        logger.info(`[MemoryFileSystem] Watching ${projectFolder} with watchman`);
        promise = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$createWatchmanWatcher(this, diagnostics, projectFolder);
      } else {
        logger.info(`[MemoryFileSystem] Watching ${projectFolder} with fs.watch`);
        promise = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$createRegularWatcher(this, diagnostics, projectFolder);
      }
      this.watchPromises.set(projectFolder, promise);

      const watcherClose = await promise;
      this.watchers.set(projectFolder, watcherClose);
      this.watchPromises.delete(projectFolder);

      diagnostics.maybeThrowDiagnosticsError();
    }

    async stat(loc) {
      const stats = await ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$fs.promises.stat(loc);

      let type = 'unknown';
      if (stats.isDirectory()) {
        type = 'directory';
      } else if (stats.isFile()) {
        type = 'file';
      }

      return {
        type: type,
        size: stats.size,
        mtime: stats.mtimeMs};
    }

    getMtime(filename) {
      const stats = this.getFileStats(filename);
      if (stats === undefined) {
        throw new Error(`File ${filename} not in database, cannot get mtime`);
      } else {
        return stats.mtime;
      }
    }

    getFileStats(filename) {
      return this.files.get(filename);
    }

    getFileStatsAssert(filename) {
      const stats = this.getFileStats(filename);
      if (stats === undefined) {
        throw new Error(`Expected file stats for ${filename}`);
      }
      return stats;
    }

    isIgnored(filename, type) {
      const project = this.master.projectManager.findProjectExisting(filename);
      if (project === undefined) {
        return false;
      }

      if (type === 'file' && ___$romejs$core$src$worker$extensions_ts$getExtensionHandler(filename) === undefined) {
        return true;
      }

      const basename = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.basename(filename);
      if (___$$priv$romejs$core$src$master$MemoryFileSystem_ts$DEFAULT_DENYLIST.includes(basename)) {
        return true;
      }

      return false;
    }

    isInsideProject(filename) {
      return filename.includes('node_modules') === false;
    }

    isInsideHaste(filename) {
      if (!this.isInsideProject(filename) ||
      filename.includes('__mocks__') ||
      filename.includes('__tests__') === true) {
        return false;
      }

      for (const dir of ___$romejs$core$src$common$utils$walkDirectoryPath_ts$default(___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.dirname(filename))) {
        const packageLoc = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.join(dir, ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$PACKAGE_JSON);
        if (filename === packageLoc) {
          continue;
        }

        const module = this.getManifest(packageLoc);
        if (module !== undefined && module.haste_commonjs === true) {
          return false;
        }
      }

      return true;
    }

    getHasteName(loc) {
      const extension = ___$romejs$core$src$worker$extensions_ts$getExtensionHandler(loc);
      if (extension === undefined || extension.hasteMode === undefined) {
        return undefined;
      }

      const {hasteMode: hasteMode} = extension;

      let ext = ___$romejs$core$src$worker$extensions_ts$getExtensionName(loc);
      ___$romejs$invariant$src$index_ts$default(
      ext !== undefined,
      'expected extension name for %s as we already validated that it has one',
      loc);

      const basename = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.basename(loc);

      if (hasteMode === 'ext') {
        ext = '.' + ext;

        ___$romejs$invariant$src$index_ts$default(
        loc.endsWith(ext),
        'expected %s to end with %s as it was returned as the extension name',
        loc,
        ext);

        return basename.slice(0, -ext.length);
      } else if (hasteMode === 'noext') {
        return basename;
      }

      return undefined;
    }

    async declareManifest(opts) {
      try {
        return await this._declareManifest(opts);
      } catch (err) {
        const diagnostics = ___$romejs$diagnostics$src$errors_ts$getDiagnosticsFromError(err);

        if (diagnostics === undefined) {
          throw err;
        } else {
          opts.diagnostics.addDiagnostics(diagnostics);
        }
        return undefined;
      }
    }

    async _declareManifest({
      loc: loc,
      kind: kind,
      hasteName: hasteName,
      diagnostics: diagnostics}) {
      const manifestRaw = await ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$fs.promises.readFile(loc, 'utf8');

      let consumer;
      if (kind === 'json') {
        consumer = ___$romejs$codec_json$src$index_ts$consumeJSON({
          filename: loc,
          input: manifestRaw});
      } else {
        throw new Error(`Unknown manifest kind`);
      }

      const manifest = ___$romejs$codec_js_manifest$src$index_ts$normalizeManifest(loc, consumer);

      const folder = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.dirname(loc);
      this.manifests.set(folder, {
        raw: consumer.asUnknownObject(),
        manifest: manifest,
        kind: kind});

      const namedManifest = ___$romejs$codec_js_manifest$src$index_ts$ifNamedManifest(manifest);

      if (namedManifest !== undefined) {
        hasteName = namedManifest.name;
      }

      if (namedManifest !== undefined && this.isInsideProject(loc)) {
        const {projectManager: projectManager} = this.master;

        const project = projectManager.findProjectExisting(loc);
        if (project !== undefined) {
          projectManager.declarePackage(
          project,
          {
            manifestFilename: loc,
            folder: folder,
            manifest: namedManifest},
          diagnostics);
        }
      }

      return hasteName;
    }

    glob(cwd, opts = {}) {
      const {extensions: extensions, ignore: ignore} = opts;

      const files = [];
      const ignoreParsed = ignore === undefined ? [] : ignore;

      const cwdSegs = ___$romejs$match_path$src$parse_ts$parsePath({input: cwd});
      let crawl = [cwd];

      while (crawl.length > 0) {
        const loc = crawl.pop();
        if (loc === undefined) {
          throw new Error('crawl.length already validated');
        }

        if (___$romejs$match_path$src$index_ts$matchPathPatterns(___$romejs$match_path$src$parse_ts$parsePath({input: loc}), ignoreParsed, cwdSegs)) {
          continue;
        }

        if (this.files.has(loc)) {
          const ext = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.extname(loc).slice(1);
          if (extensions === undefined || extensions.includes(ext)) {
            files.push(loc);
          }
          continue;
        }

        const listing = this.directoryListings.get(loc);
        if (listing !== undefined) {
          crawl = crawl.concat(Array.from(listing));
          continue;
        }
      }

      return files;
    }

    getAllFilesInFolder(folder) {
      let files = [];

      const listing = this.directoryListings.get(folder);
      if (listing !== undefined) {
        for (const file of listing) {
          if (this.files.has(file)) {
            files.push(file);
          } else {
            files = files.concat(this.getAllFilesInFolder(file));
          }
        }
      }

      return files;
    }

    countFiles(folder) {
      let count = 0;

      const listing = this.directoryListings.get(folder);
      if (listing !== undefined) {
        for (const file of listing) {
          count++;
          count += this.countFiles(file);
        }
      }

      return count;
    }

    async addDirectory(folder, stats, opts) {
      const oldFolderStats = this.directories.get(folder);
      if (oldFolderStats !== undefined && oldFolderStats.mtime === stats.mtime) {
        return false;
      }

      if (this.isIgnored(folder, 'directory')) {
        return false;
      }

      if (opts.tick !== undefined) {
        opts.tick(folder);
      }

      this.addFileToDirectoryListing(folder);
      this.directories.set(folder, stats);

      if (opts.watchman === true) {} else {
        const files = new Set((await ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$fs.promises.readdir(folder)));

        const declareItem = async file => {
          const loc = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.join(folder, file);
          const stats = await this.stat(loc);
          if (stats.type === 'file') {
            await this.addFile(loc, stats, opts);
          } else if (stats.type === 'directory') {
            await this.addDirectory(loc, stats, opts);
          }
        };

        for (const file of files) {
          if (___$$priv$romejs$core$src$master$MemoryFileSystem_ts$PRIORITY_FILES.has(file)) {
            files.delete(file);
            await declareItem(file);
          }
        }

        await Promise.all(Array.from(files, declareItem));
      }

      return true;
    }

    exists(loc) {
      if (this.files.has(loc) || this.directories.has(loc)) {
        return true;
      }

      for (const [projectFolder] of this.watchPromises) {
        if (loc.startsWith(projectFolder + ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.sep)) {
          return undefined;
        }
      }

      const parent = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.dirname(loc);
      if (this.directories.has(parent)) {
        return false;
      }

      return undefined;
    }

    async addFile(loc, stats, opts) {
      const {projectManager: projectManager} = this.master;

      const oldFileInfo = this.files.get(loc);
      if (oldFileInfo !== undefined && oldFileInfo.mtime === stats.mtime) {
        return false;
      }

      if (this.isIgnored(loc, 'file')) {
        return false;
      }

      if (opts.tick !== undefined) {
        opts.tick(loc);
      }

      this.files.set(loc, stats);
      this.addFileToDirectoryListing(loc);

      let hasteLoc = loc;
      let hasteName = this.getHasteName(loc);

      const basename = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.basename(loc);
      const dirname = ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$path.dirname(loc);

      projectManager.checkConfigFile(basename, loc, opts.diagnostics);

      if (basename === ___$romejs$core$src$common$constants_ts$ROME_CONFIG_FILENAME) {
        await projectManager.queueAddProject({dir: dirname, isPackage: false});
      }

      if (basename === ___$$priv$romejs$core$src$master$MemoryFileSystem_ts$PACKAGE_JSON &&
      (await projectManager.hasPackageJsonConfig(dirname))) {
        await projectManager.queueAddProject({dir: dirname, isPackage: true});
      }

      const manifestKind = ___$romejs$codec_js_manifest$src$index_ts$getManifestKindFromBasename(basename);
      if (manifestKind !== undefined) {
        hasteName = await this.declareManifest({
          diagnostics: opts.diagnostics,
          kind: manifestKind,
          dirname: dirname,
          loc: loc,
          hasteName: hasteName,
          hasteLoc: hasteLoc});
        hasteLoc = dirname;
      }

      if (hasteName !== undefined && this.isInsideHaste(loc)) {
        projectManager.declareHaste(loc, hasteName, hasteLoc, opts.diagnostics);
      }

      return true;
    }
  }

  // romejs/core/src/master/commands/logs.ts

  const ___$$priv$romejs$core$src$master$commands$logs_ts$path = require('path');
  const ___$$priv$romejs$core$src$master$commands$logs_ts$fs = require('fs');
  const ___$romejs$core$src$master$commands$logs_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'listen and stream daemon logs',

    async default(req) {
      const {master: master, reporter: reporter, flags: flags} = req;
      const {stdout: stdout} = reporter;
      return new Promise(() => {
        let fileout;
        if (flags.logPath !== '') {
          fileout = ___$$priv$romejs$core$src$master$commands$logs_ts$fs.createWriteStream(___$$priv$romejs$core$src$master$commands$logs_ts$path.resolve(flags.cwd, flags.logPath));

          req.teardownEvent.subscribe(() => {
            if (fileout !== undefined) {
              fileout.end();
            }
          });
        }

        function onLog(chunk) {
          if (fileout === undefined) {
            stdout.write(chunk);
          } else {
            fileout.write(___$romejs$string_ansi$src$format_ts$stripAnsi(chunk));
          }
        }

        const subscriptions = [];
        subscriptions.push(master.logEvent.subscribe(onLog));

        if (flags.logWorkers) {
          for (const {bridge: bridge} of master.workerManager.getWorkers()) {
            subscriptions.push(bridge.log.subscribe(onLog));
          }

          subscriptions.push(
          master.workerManager.workerStartEvent.subscribe(worker => {
            subscriptions.push(worker.log.subscribe(onLog));
          }));
        }

        req.teardownEvent.subscribe(() => {
          for (const listener of subscriptions) {
            listener.unsubscribe();
          }
        });
      });
    }});

  // romejs/core/src/master/MasterRequest.ts

  const ___$$priv$romejs$core$src$master$MasterRequest_ts$path = require('path');
  class ___$romejs$core$src$master$MasterRequest_ts$default {
    constructor(opts) {
      this.args = opts.args;
      this.flags = opts.flags;
      this.master = opts.master;
      this.client = opts.client;
      this.reporter = opts.reporter;
      this.command = opts.command;
      this.teardownEvent = new ___$romejs$events$src$Event_ts$default({name: 'MasterRequest.teardown'});
    }

    teardown() {
      this.reporter.teardown();
      this.teardownEvent.send(undefined);
    }

    createDiagnosticsPrinter(origin) {
      return new ___$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$default({
        origins: [`master: ${this.command} command was dispatched`, origin],
        reporter: this.reporter,
        cwd: this.flags.cwd,
        flags: this.getDiagnosticsPrinterFlags()});
    }

    getDiagnosticsPrinterFlags() {
      return {
        grep: this.flags.grep,
        inverseGrep: this.flags.inverseGrep,
        focus: this.flags.focus,
        showAllDiagnostics: this.flags.showAllDiagnostics,
        verboseDiagnostics: this.flags.verboseDiagnostics,
        maxDiagnostics: this.flags.maxDiagnostics,
        fieri: this.flags.fieri};
    }

    getResolverOptionsFromFlags() {
      return {
        platform: this.flags.resolverPlatform,
        scale: this.flags.resolverScale,
        mocks: this.flags.resolverMocks};
    }

    getBundlerConfigFromFlags() {
      return {
        inlineSourceMap: false,
        mode: this.flags.bundlerMode,
        cwd: this.flags.cwd};
    }

    async getFilesFromArgs(getIgnoreForProject) {
      const {master: master} = this;

      const args = [...this.args];
      if (args.length === 0) {
        const project = await master.projectManager.assertProject(this.flags.cwd);
        args.push(project.dir);
      }

      let files = [];
      for (let arg of args) {
        if (!___$$priv$romejs$core$src$master$MasterRequest_ts$path.isAbsolute(arg)) {
          arg = ___$$priv$romejs$core$src$master$MasterRequest_ts$path.resolve(this.flags.cwd, arg);
        }

        const project = await master.projectManager.assertProject(arg);
        const projectIgnore = getIgnoreForProject(project);

        const matches = master.memoryFs.glob(arg, {ignore: projectIgnore});
        files = files.concat(matches);
      }
      return files;
    }
  }

  // romejs/core/src/common/types/project.ts

  const ___$romejs$core$src$common$types$project_ts = {
    get DEFAULT_PROJECT_CONFIG() {
      return ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG;
    }};
  const ___$$priv$romejs$core$src$common$types$project_ts$path = require('path');
  const ___$$priv$romejs$core$src$common$types$project_ts$os = require('os');
  const ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG = {
    name: 'unknown',
    isolated: false,
    memoryCacheCounter: 0,
    configHashes: [],
    configDependencies: [],

    cache: {
      endpoint: undefined,
      folder: ___$$priv$romejs$core$src$common$types$project_ts$path.join(___$$priv$romejs$core$src$common$types$project_ts$os.tmpdir(), `rome-${___$romejs$core$src$common$constants_ts$VERSION}`)},

    bundler: {
      mode: 'flat'},
    resolver: {},

    typeChecking: {
      enabled: false,
      libs: []},

    dependencies: {
      enabled: false,
      folder: ___$$priv$romejs$core$src$common$types$project_ts$path.join(___$$priv$romejs$core$src$common$types$project_ts$os.userInfo().homedir, '.rome-dependencies')},

    format: {
      enabled: false},

    haste: {
      enabled: false,
      ignore: []},

    lint: {
      enabled: false,
      ignore: [],
      globals: []},

    testing: {
      enabled: false,
      folderName: '__tests__',
      ignore: []},

    files: {
      watchman: false,

      maxSize: 40000000}};

  // romejs/core/src/master/project/utils.ts

  function ___$romejs$core$src$master$project$utils_ts$arrayOfStrings(consumer) {
    if (consumer.exists()) {
      return consumer.asArray().map(item => item.asString());
    } else {
      return [];
    }
  }

  function ___$romejs$core$src$master$project$utils_ts$arrayOfPatterns(consumer) {
    return consumer.asArray().map(item => {
      return ___$romejs$match_path$src$parse_ts$parsePattern({
        input: item.asString(),
        offsetPosition: item.getInnerLocation().start});
    });
  }

  function ___$romejs$core$src$master$project$utils_ts$mergeArrays(a, b) {
    if (a === undefined) {
      return a;
    }

    if (b === undefined) {
      return a;
    }

    return [...a, ...b];
  }

  // romejs/core/src/master/project/load.ts

  const ___$$priv$romejs$core$src$master$project$load_ts$crypto = require('crypto');
  const ___$$priv$romejs$core$src$master$project$load_ts$path = require('path');
  const ___$$priv$romejs$core$src$master$project$load_ts$fs = require('fs');
  const ___$$priv$romejs$core$src$master$project$load_ts$WATCHMAN_CONFIG_FILENAME = '.watchmanconfig';

  const ___$$priv$romejs$core$src$master$project$load_ts$IGNORE_FILENAMES = ['.gitignore', '.hgignore'];

  let ___$$priv$romejs$core$src$master$project$load_ts$memoryCacheCounter = 1;

  function ___$romejs$core$src$master$project$load_ts$loadCompleteProjectConfig(projectFolder, configLoc, subKey) {
    const {partial: partial, consumer: consumer} = ___$$priv$romejs$core$src$master$project$load_ts$loadPartialProjectConfig(
    projectFolder,
    configLoc,
    subKey);

    const config = Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG, {
      memoryCacheCounter: ___$$priv$romejs$core$src$master$project$load_ts$memoryCacheCounter++,
      name: consumer.getProperty('name').asString(___$$priv$romejs$core$src$master$project$load_ts$path.basename(projectFolder)),
      isolated: partial.isolated === undefined ? ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.isolated : partial.isolated,
      configDependencies: partial.configDependencies,
      configHashes: partial.configHashes,
      cache: Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.cache, partial.cache),
      bundler: Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.bundler, partial.bundler),
      lint: Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.lint, partial.lint),
      resolver: Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.resolver, partial.resolver),
      haste: Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.haste, partial.haste),
      typeChecking: Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.typeChecking, partial.typeChecking),
      format: Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.format, partial.format),
      dependencies: Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.dependencies, partial.dependencies),
      testing: Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.testing, partial.testing),
      files: Object.assign({}, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG.files, partial.files)});

    for (const filename of ___$$priv$romejs$core$src$master$project$load_ts$IGNORE_FILENAMES) {
      const possibleLoc = ___$$priv$romejs$core$src$master$project$load_ts$path.join(projectFolder, filename);
      config.configDependencies.push(possibleLoc);

      if (___$$priv$romejs$core$src$master$project$load_ts$fs.existsSync(possibleLoc)) {
        const file = ___$$priv$romejs$core$src$master$project$load_ts$fs.readFileSync(possibleLoc, 'utf8');
        const lines = file.split('\n');

        let index = 0;

        const patterns = lines.map((line, i) => {
          const pattern = ___$romejs$match_path$src$parse_ts$parsePattern({
            input: line,
            filename: possibleLoc,
            offsetPosition: {
              index: index,
              line: i,
              column: 0}});

          index += line.length;
          index++;

          return pattern;
        });

        config.lint.ignore = [...config.lint.ignore, ...patterns];
      }
    }

    if (partial.files.watchman === undefined) {
      const watchmanConfigLoc = ___$$priv$romejs$core$src$master$project$load_ts$path.join(
      projectFolder,
      ___$$priv$romejs$core$src$master$project$load_ts$WATCHMAN_CONFIG_FILENAME);
      config.configDependencies.push(watchmanConfigLoc);
      if (___$$priv$romejs$core$src$master$project$load_ts$fs.existsSync(watchmanConfigLoc)) {
        config.files.watchman = true;
      }
    }

    return config;
  }

  function ___$$priv$romejs$core$src$master$project$load_ts$loadPartialProjectConfig(projectFolder, configLoc, subKey) {
    const configFile = ___$$priv$romejs$core$src$master$project$load_ts$fs.readFileSync(configLoc, 'utf8');

    let consumer = ___$romejs$codec_json$src$index_ts$consumeJSON({
      filename: configLoc,
      input: configFile});

    if (subKey !== undefined) {
      consumer = consumer.getProperty(subKey);
    }

    return {
      partial: ___$$priv$romejs$core$src$master$project$load_ts$normalizeProjectConfig(consumer, configFile, projectFolder),
      consumer: consumer};
  }

  function ___$$priv$romejs$core$src$master$project$load_ts$normalizeProjectConfig(consumer, input, projectFolder) {
    const hash = ___$$priv$romejs$core$src$master$project$load_ts$crypto.createHash('sha256').update(input).digest('hex');

    const config = {
      configHashes: [hash],
      configDependencies: [],
      bundler: {},
      cache: {},
      lint: {},
      haste: {},
      resolver: {},
      typeChecking: {},
      format: {},
      dependencies: {},
      testing: {},
      files: {}};

    if (consumer.hasProperty('isolated')) {
      config.isolated = consumer.getProperty('isolated').asBoolean();
    }

    const cache = consumer.getProperty('cache');
    if (cache.exists()) {
      if (cache.hasProperty('folder')) {
        config.cache.folder = cache.getProperty('folder').asString();
      }

      if (cache.hasProperty('endpoint')) {
        config.cache.endpoint = cache.getProperty('endpoint').asString();
      }
    }

    const resolver = consumer.getProperty('resolver');
    if (resolver.exists()) {}

    const bundler = consumer.getProperty('bundler');
    if (bundler.exists()) {}

    const haste = consumer.getProperty('haste');
    if (haste.exists()) {
      if (haste.hasProperty('enabled')) {
        config.haste.enabled = haste.getProperty('enabled').asBoolean();
      }

      if (haste.hasProperty('ignore')) {
        config.haste.ignore = ___$romejs$core$src$master$project$utils_ts$arrayOfPatterns(haste.getProperty('ignore'));
      }
    }

    const typeChecking = consumer.getProperty('typeChecking');
    if (typeChecking.exists()) {
      if (typeChecking.hasProperty('enabled')) {
        config.typeChecking.enabled = typeChecking.getProperty('enabled').asBoolean();
      }

      if (typeChecking.hasProperty('libs')) {
        config.typeChecking.libs = ___$$priv$romejs$core$src$master$project$load_ts$normalizeTypeCheckingLibs(
        projectFolder,
        typeChecking.getProperty('libs'));
      }
    }

    const lint = consumer.getProperty('lint');
    if (lint.exists()) {
      if (lint.hasProperty('enabled')) {
        config.lint.enabled = lint.getProperty('enabled').asBoolean();
      }

      if (lint.hasProperty('ignore')) {
        config.lint.ignore = ___$romejs$core$src$master$project$utils_ts$arrayOfPatterns(lint.getProperty('ignore'));
      }

      if (lint.hasProperty('globals')) {
        config.lint.globals = ___$romejs$core$src$master$project$utils_ts$arrayOfStrings(lint.getProperty('globals'));
      }
    }

    const format = consumer.getProperty('format');
    if (format.exists()) {
      if (format.hasProperty('enabled')) {
        config.format.enabled = format.getProperty('enabled').asBoolean();
      }
    }

    const dependencies = consumer.getProperty('dependencies');
    if (dependencies.exists()) {
      if (dependencies.hasProperty('enabled')) {
        config.dependencies.enabled = dependencies.getProperty('enabled').asBoolean();
      }

      if (dependencies.hasProperty('folder')) {
        config.dependencies.folder = ___$$priv$romejs$core$src$master$project$load_ts$path.resolve(
        projectFolder,
        dependencies.getProperty('folder').asString());
      }
    }

    const testing = consumer.getProperty('testing');
    if (testing.exists()) {
      if (testing.hasProperty('enabled')) {
        config.testing.enabled = testing.getProperty('enabled').asBoolean();
      }

      if (testing.hasProperty('folderName')) {
        config.testing.folderName = testing.getProperty('folderName').asString();
      }

      if (testing.hasProperty('ignore')) {
        config.testing.ignore = ___$romejs$core$src$master$project$utils_ts$arrayOfPatterns(testing.getProperty('ignore'));
      }
    }

    const files = consumer.getProperty('files');
    if (files.exists()) {
      if (files.hasProperty('watchman')) {
        config.files.watchman = files.getProperty('watchman').asBoolean();
      }

      if (files.hasProperty('maxSize')) {
        config.files.maxSize = files.getProperty('maxSize').asNumber();
      }
    }

    const _extends = consumer.getProperty('extends');
    if (_extends.exists()) {
      return ___$$priv$romejs$core$src$master$project$load_ts$extendProjectConfig(projectFolder, _extends, config);
    }

    return config;
  }

  function ___$$priv$romejs$core$src$master$project$load_ts$normalizeTypeCheckingLibs(projectFolder, consumer) {
    const libFiles = [];

    const libFolders = ___$romejs$core$src$master$project$utils_ts$arrayOfStrings(consumer).map(libFolder => ___$$priv$romejs$core$src$master$project$load_ts$path.resolve(projectFolder, libFolder));

    for (const folder of libFolders) {
      const files = ___$$priv$romejs$core$src$master$project$load_ts$fs.readdirSync(folder);
      for (const file of files) {
        const loc = ___$$priv$romejs$core$src$master$project$load_ts$path.join(folder, file);
        const stats = ___$$priv$romejs$core$src$master$project$load_ts$fs.statSync(loc);
        if (stats.isFile()) {
          libFiles.push(loc);
        } else if (stats.isDirectory()) {
          libFolders.push(loc);
        }
      }
    }

    return libFiles;
  }

  function ___$$priv$romejs$core$src$master$project$load_ts$extendProjectConfig(projectFolder, extendsConsumer, config) {
    const extendsRelative = extendsConsumer.asString();

    if (extendsRelative === 'parent') {}

    const extendsLoc = ___$$priv$romejs$core$src$master$project$load_ts$path.resolve(projectFolder, extendsRelative);
    const {partial: extendsObj} = ___$$priv$romejs$core$src$master$project$load_ts$loadPartialProjectConfig(
    ___$$priv$romejs$core$src$master$project$load_ts$path.dirname(extendsLoc),
    extendsLoc);

    if (config.configDependencies.includes(extendsLoc)) {
      throw extendsConsumer.unexpected('Recursive config value');
    }

    const merged = {
      configDependencies: [extendsLoc, ...extendsObj.configDependencies, ...config.configDependencies],
      configHashes: [...extendsObj.configHashes, ...config.configHashes],
      cache: Object.assign({}, extendsObj.cache, config.cache),
      lint: Object.assign({}, extendsObj.lint, config.lint),
      bundler: Object.assign({}, extendsObj.bundler, config.bundler),
      resolver: Object.assign({}, extendsObj.resolver, config.resolver),
      haste: Object.assign({}, extendsObj.haste, config.haste),
      typeChecking: Object.assign({}, extendsObj.typeChecking, config.typeChecking),
      testing: Object.assign({}, extendsObj.testing, config.testing),
      format: Object.assign({}, extendsObj.format, config.format),
      dependencies: Object.assign({}, extendsObj.dependencies, config.dependencies),
      files: Object.assign({}, extendsObj.files, config.files)};

    const lintIgnore = ___$romejs$core$src$master$project$utils_ts$mergeArrays(extendsObj.lint.ignore, config.lint.ignore);
    if (lintIgnore !== undefined) {
      merged.lint.ignore = lintIgnore;
    }

    const lintGlobals = ___$romejs$core$src$master$project$utils_ts$mergeArrays(extendsObj.lint.globals, config.lint.globals);
    if (lintGlobals !== undefined) {
      merged.lint.globals = lintGlobals;
    }

    const hasteIgnore = ___$romejs$core$src$master$project$utils_ts$mergeArrays(extendsObj.haste.ignore, config.haste.ignore);
    if (hasteIgnore !== undefined) {
      merged.haste.ignore = hasteIgnore;
    }

    const testingIgnore = ___$romejs$core$src$master$project$utils_ts$mergeArrays(
    extendsObj.testing.ignore,
    config.testing.ignore);
    if (testingIgnore !== undefined) {
      merged.testing.ignore = testingIgnore;
    }

    const typeCheckingLibs = ___$romejs$core$src$master$project$utils_ts$mergeArrays(
    extendsObj.typeChecking.libs,
    config.typeChecking.libs);
    if (typeCheckingLibs !== undefined) {
      merged.typeChecking.libs = typeCheckingLibs;
    }

    return merged;
  }

  // romejs/core/src/master/ProjectManager.ts

  const ___$$priv$romejs$core$src$master$ProjectManager_ts$path = require('path');
  const ___$$priv$romejs$core$src$master$ProjectManager_ts$fs = require('fs');
  function ___$$priv$romejs$core$src$master$ProjectManager_ts$cleanName(name) {
    if (name[0] === '@') {
      return name.slice(1);
    } else {
      return name;
    }
  }

  class ___$romejs$core$src$master$ProjectManager_ts$default {
    constructor(master) {
      this.master = master;

      this.isAddingProject = false;
      this.pendingAddProjects = [];

      this.projectIdCounter = 0;

      this.projectFolderToId = new Map();
      this.projectConfigDependenciesToIds = new Map();
      this.fileToProject = new Map();
      this.projects = new Map();

      this.uidToFilename = new Map();
      this.filenameToUid = new Map();
    }

    getFilenameFromUid(filename) {
      return this.uidToFilename.get(filename);
    }

    getUid(filename) {
      const existing = this.filenameToUid.get(filename);
      if (existing !== undefined) {
        return existing;
      }

      const project = this.assertProjectExisting(filename);
      const parts = [];
      parts.push(project.config.name);

      if (this.isHasteDeclared(filename, project)) {
        const hasteName = this.master.memoryFs.getHasteName(filename);
        if (hasteName === undefined) {
          throw new Error('isHasteDeclared returned true so this should always return a valid name');
        }
        parts.push(hasteName);
      } else {
        let root = project.dir;
        const pkg = this.getOwnedPackage(filename);
        if (pkg !== undefined) {
          parts.push(pkg.manifest.name);
          root = pkg.folder;

          if (___$$priv$romejs$core$src$master$ProjectManager_ts$cleanName(parts[1]).startsWith(___$$priv$romejs$core$src$master$ProjectManager_ts$cleanName(parts[0]))) {
            parts.shift();
          }
        }

        const relative = ___$$priv$romejs$core$src$master$ProjectManager_ts$path.relative(root, filename);
        parts.push(relative);
      }

      const uid = ___$$priv$romejs$core$src$master$ProjectManager_ts$cleanName(parts.join('/'));

      const collided = this.uidToFilename.get(uid);
      if (collided !== undefined && collided !== filename) {
        throw new Error(`UID collision between ${filename} and ${collided}: ${uid}`);
      }

      this.uidToFilename.set(uid, filename);
      this.filenameToUid.set(filename, uid);

      return uid;
    }

    getFileReference(filename) {
      const project = this.assertProjectExisting(filename);
      const uid = this.getUid(filename);
      return {
        uid: uid,
        project: project.id,
        real: filename};
    }

    getOwnedPackage(filename) {
      let expectedFolder;
      for (const dir of ___$romejs$core$src$common$utils$walkDirectoryPath_ts$default(___$$priv$romejs$core$src$master$ProjectManager_ts$path.dirname(filename))) {
        if (this.master.memoryFs.getManifest(dir) !== undefined) {
          expectedFolder = dir;
          break;
        }
      }

      for (const project of this.getHierarchyFromFilename(filename)) {
        for (const pkg of project.packages.values()) {
          if (pkg.folder === expectedFolder) {
            return pkg;
          }
        }
      }

      return undefined;
    }

    async maybeEvictPossibleConfig(filename) {
      const projectIds = this.projectConfigDependenciesToIds.get(filename);
      if (projectIds === undefined) {
        return false;
      }

      for (const evictProjectId of projectIds) {
        const project = this.projects.get(evictProjectId);
        if (project === undefined) {
          throw new Error(`Expected project of id ${evictProjectId} since it was declared in projectConfigLocsToId`);
        }

        for (const [configLoc, projectIds] of this.projectConfigDependenciesToIds) {
          if (projectIds.has(evictProjectId)) {
            projectIds.delete(evictProjectId);
          }

          if (projectIds.size === 0) {
            this.projectConfigDependenciesToIds.delete(configLoc);
          }
        }

        for (const {bridge: bridge} of this.master.workerManager.getWorkers()) {
          bridge.evictProject.send({id: evictProjectId});
        }

        this.projects.delete(evictProjectId);
        this.projectFolderToId.delete(project.dir);

        const ownedFiles = [];
        for (const [filename, projectId] of this.fileToProject) {
          if (evictProjectId === projectId) {
            this.fileToProject.delete(filename);
            ownedFiles.push(filename);
          }
        }
        await Promise.all(
        ownedFiles.map(filename => this.master.fileManager.evict(filename)));
      }

      return true;
    }

    getProjects() {
      return Array.from(this.projects.values());
    }

    async queueAddProject(request) {
      const projectFolder = request.dir;

      const maybeProject = this.findProjectExisting(projectFolder);
      if (maybeProject !== undefined) {
        return maybeProject;
      }

      if (this.isAddingProject) {
        return new Promise(resolve => {
          this.pendingAddProjects.push({request: request, resolve: resolve});
        });
      }

      this.isAddingProject = true;

      const mainProject = await this.addProject(request);
      const resolvedProjectsByDir = new Map();
      resolvedProjectsByDir.set(projectFolder, mainProject);

      const resolvedProjects = [];
      for (const {request: request, resolve: resolve} of this.pendingAddProjects) {
        const existing = resolvedProjectsByDir.get(request.dir);
        if (existing !== undefined) {
          resolvedProjects.push({project: existing, resolve: resolve});
        } else {
          const project = await this.addProject(request);
          resolvedProjects.push({project: project, resolve: resolve});
        }
      }

      for (const {project: project, resolve: resolve} of resolvedProjects) {
        resolve(project);
      }

      this.pendingAddProjects = [];
      this.isAddingProject = false;

      return mainProject;
    }

    addDependencyToProjectId(filename, projectId) {
      const ids = this.projectConfigDependenciesToIds.get(filename);

      if (ids === undefined) {
        this.projectConfigDependenciesToIds.set(filename, new Set());
        return this.addDependencyToProjectId(filename, projectId);
      }

      ids.add(projectId);
    }

    async addProject(request) {
      const projectFolder = request.dir;

      let configLoc = ___$$priv$romejs$core$src$master$ProjectManager_ts$path.join(projectFolder, ___$romejs$core$src$common$constants_ts$ROME_CONFIG_FILENAME);
      let subKey = undefined;
      if (request.isPackage) {
        configLoc = ___$$priv$romejs$core$src$master$ProjectManager_ts$path.join(projectFolder, 'package.json');
        subKey = ___$romejs$core$src$common$constants_ts$ROME_CONFIG_PACKAGE_JSON_KEY;
      }
      const config = ___$romejs$core$src$master$project$load_ts$loadCompleteProjectConfig(projectFolder, configLoc, subKey);

      for (const project of this.projects.values()) {
        if (project.config.name === config.name) {
          throw new Error(`Conflicting project names. ${projectFolder} and ${project.dir}`);
        }
      }

      const parentProject = this.findProjectExisting(___$$priv$romejs$core$src$master$ProjectManager_ts$path.dirname(projectFolder));
      const project = {
        config: config,
        configLoc: configLoc,
        dir: projectFolder,
        id: this.projectIdCounter++,
        packages: new Map(),
        hasteMap: new Map(),
        parent: parentProject};
      this.projects.set(project.id, project);
      this.fileToProject.set(projectFolder, project.id);
      this.projectFolderToId.set(projectFolder, project.id);

      this.addDependencyToProjectId(configLoc, project.id);
      for (const loc of config.configDependencies) {
        this.addDependencyToProjectId(loc, project.id);
      }

      this.master.cache.onNewProject(project);
      this.master.workerManager.onNewProject(project);

      await this.master.memoryFs.watch(projectFolder, config);

      return project;
    }

    declarePackage(project, opts, diagnostics) {
      const {manifestFilename: manifestFilename, manifest: manifest} = opts;

      const {name: name} = manifest;
      if (name === undefined) {
        return undefined;
      }

      const projects = this.getHierarchyFromProject(project);

      for (const project of projects) {
        const existingPackage = project.packages.get(name);
        if (existingPackage === undefined) {
          continue;
        }

        diagnostics.addDiagnostic({
          category: 'projectManager',
          filename: manifestFilename,
          message: `Duplicate package name <emphasis>${name}</emphasis>`,
          advice: [{
            type: 'log',
            category: 'info',
            message: `Defined already by <filelink filename="${existingPackage.manifestFilename}" />`}]});
        return undefined;
      }

      for (const project of projects) {
        project.packages.set(name, opts);
      }
    }

    isHasteIgnored(loc, config) {
      return ___$romejs$match_path$src$index_ts$matchPathPatterns(___$romejs$match_path$src$parse_ts$parsePath({input: loc}), config.haste.ignore);
    }

    isHasteDeclared(loc, project) {
      if (project.config.haste.enabled === false) {
        return false;
      }

      const hasteName = this.master.memoryFs.getHasteName(loc);
      if (hasteName === undefined) {
        return false;
      }

      return project.hasteMap.get(hasteName) === loc;
    }

    declareHaste(loc, hasteName, hasteLoc, diagnostics) {
      for (const project of this.getHierarchyFromFilename(loc)) {
        const {hasteMap: hasteMap, config: config} = project;

        if (config.haste.enabled === false) {
          break;
        }

        if (this.isHasteIgnored(loc, config)) {
          continue;
        }

        let existing = hasteMap.get(hasteName);
        if (existing !== undefined && existing !== hasteLoc) {
          if (hasteLoc ===
          this.master.resolver.resolvePath({
            origin: existing,
            source: existing})) {
            continue;
          }

          diagnostics.addDiagnostic({
            category: 'projectManager',
            filename: hasteLoc,
            message: `Found a haste collision for <emphasis>${hasteName}</emphasis>`,
            advice: [{
              type: 'log',
              category: 'info',
              message: `Defined already by <filelink filename="${existing}" />`}]});
          continue;
        }

        hasteMap.set(hasteName, hasteLoc);
      }
    }

    async notifyWorkersOfProjects(workers, projects) {
      if (projects === undefined) {
        projects = Array.from(this.projects.values());
      }

      const projectsSerial = [];
      for (const project of projects) {
        projectsSerial.push({
          config: project.config,
          id: project.id});
      }

      await Promise.all(
      workers.map(async worker => {
        return worker.bridge.updateProjects.call({projects: projectsSerial});
      }));
    }

    async assertProject(loc) {
      const project = await this.findProject(loc);
      if (project) {
        if (project.config.isolated === false) {
          await this.findProject(___$$priv$romejs$core$src$master$ProjectManager_ts$path.dirname(project.dir));
        }

        return project;
      } else {
        throw new Error(`Couldn't find a ${___$romejs$core$src$common$constants_ts$ROME_CONFIG_FILENAME} for ${loc}`);
      }
    }

    getHierarchyFromFilename(filename) {
      const project = this.findProjectExisting(filename);
      if (project === undefined) {
        return [];
      } else {
        return this.getHierarchyFromProject(project);
      }
    }

    getHierarchyFromProject(project) {
      const projects = [];

      let currProject = project;
      while (currProject !== undefined) {
        projects.push(currProject);

        if (currProject.config.isolated) {
          break;
        }

        currProject = project.parent;
      }

      return projects;
    }

    assertProjectExisting(loc) {
      const project = this.findProjectExisting(loc);
      if (project === undefined) {
        throw new Error(`Expected existing project for ${loc}`);
      }
      return project;
    }

    findProjectExisting(cwd) {
      const tried = [];

      for (const dir of ___$romejs$core$src$common$utils$walkDirectoryPath_ts$default(cwd)) {
        const cachedProjectId = this.fileToProject.get(dir);
        if (cachedProjectId === undefined) {
          tried.push(dir);
        } else {
          for (const dir of tried) {
            this.fileToProject.set(dir, cachedProjectId);
          }

          const project = this.projects.get(cachedProjectId);
          if (project === undefined) {
            throw new Error('Expected project from project id found in fileToProject');
          }
          return project;
        }
      }

      return undefined;
    }

    checkConfigFile(basename, loc, diagnostics) {
      if (___$romejs$core$src$common$constants_ts$ROME_CONFIG_WARN_FILENAMES.includes(basename)) {
        this.warnIncorrectConfigFile(loc, diagnostics);
      }
    }

    warnIncorrectConfigFile(loc, diagnostics) {
      diagnostics.addDiagnostic({
        category: 'projectManager',
        filename: loc,
        message: `Invalid rome config filename, <emphasis>${___$romejs$core$src$common$constants_ts$ROME_CONFIG_FILENAME}</emphasis> is the only valid filename`});
    }

    async hasPackageJsonConfig(dir) {
      const packageLoc = ___$$priv$romejs$core$src$master$ProjectManager_ts$path.join(dir, 'package.json');
      if (!(await this.master.exists(packageLoc))) {
        return false;
      }

      const json = await ___$$priv$romejs$core$src$master$ProjectManager_ts$fs.promises.readFile(packageLoc, 'utf8');
      const obj = ___$romejs$codec_json$src$index_ts$consumeJSON({
        input: json,
        filename: packageLoc}).asUnknownObject();
      return typeof obj === 'object' &&
      obj != null &&
      obj[___$romejs$core$src$common$constants_ts$ROME_CONFIG_PACKAGE_JSON_KEY] !== undefined;
    }

    async findProject(cwd) {
      const syncProject = this.findProjectExisting(cwd);
      if (syncProject !== undefined) {
        return syncProject;
      }

      for (const dir of ___$romejs$core$src$common$utils$walkDirectoryPath_ts$default(cwd)) {
        const loc = ___$$priv$romejs$core$src$master$ProjectManager_ts$path.join(dir, ___$romejs$core$src$common$constants_ts$ROME_CONFIG_FILENAME);

        let hasProject = await this.master.exists(loc);
        let isPackage = false;

        if (hasProject === false && (await this.hasPackageJsonConfig(dir))) {
          hasProject = true;
          isPackage = true;
        }

        if (hasProject) {
          return this.queueAddProject({dir: dir, isPackage: isPackage});
        }
      }

      for (const dir of ___$romejs$core$src$common$utils$walkDirectoryPath_ts$default(cwd)) {
        for (const basename of ___$romejs$core$src$common$constants_ts$ROME_CONFIG_WARN_FILENAMES) {
          const loc = ___$$priv$romejs$core$src$master$ProjectManager_ts$path.join(dir, basename);

          if (await this.master.exists(loc)) {
            this.warnIncorrectConfigFile(
            loc,
            ___$romejs$diagnostics$src$DiagnosticsProcessor_ts$default.createImmediateThrower(['project-manager: Find project']));
          }
        }
      }

      return undefined;
    }
  }

  // romejs/core/src/common/utils/fork.ts

  const ___$$priv$romejs$core$src$common$utils$fork_ts$child = require('child_process');
  function ___$romejs$core$src$common$utils$fork_ts$default(processType, opts) {
    return ___$$priv$romejs$core$src$common$utils$fork_ts$child.fork(___$romejs$core$src$common$constants_ts$BIN, ___$romejs$core$src$common$constants_ts$CHILD_ARGS, Object.assign({
      stdio: 'inherit'}, opts, {
      env: Object.assign({}, process.env, {
        ROME_PROCESS_VERSION: ___$romejs$core$src$common$constants_ts$VERSION,
        ROME_PROCESS_TYPE: processType})}));
  }

  // romejs/core/src/common/utils/Locker.ts

  class ___$$priv$romejs$core$src$common$utils$Locker_ts$Lock {
    constructor(locker, key) {
      this.locker = locker;
      this.resolves = [];
      this.key = key;
    }

    addResolve(resolve) {
      this.resolves.push(resolve);
    }

    release() {
      const {resolves: resolves} = this;

      if (resolves.length === 0) {
        this.locker.locks.delete(this.key);
      } else {
        const resolve = resolves.shift();
        if (resolve === undefined) {
          throw new Error('Already validated resolved.length aboved');
        }
        resolve(this);
      }
    }
  }

  class ___$romejs$core$src$common$utils$Locker_ts$default {
    constructor() {
      this.locks = new Map();
    }

    hasLock(id) {
      return this.locks.has(id);
    }

    getNewLock(key) {
      ___$romejs$invariant$src$index_ts$default(this.locks.has(key) === false, 'Expected no lock to exist');

      const lock = new ___$$priv$romejs$core$src$common$utils$Locker_ts$Lock(this, key);
      this.locks.set(key, lock);
      return lock;
    }

    async getLock(key) {
      const existingLock = this.locks.get(key);

      if (existingLock === undefined) {
        return this.getNewLock(key);
      } else {
        return new Promise(resolve => {
          existingLock.addResolve(resolve);
        });
      }
    }

    async waitLock(key) {
      if (this.hasLock(key)) {
        const lock = await this.getLock(key);
        lock.release();
      }
    }
  }

  // romejs/core/src/master/WorkerManager.ts

  const ___$$priv$romejs$core$src$master$WorkerManager_ts$child = require('child_process');
  class ___$romejs$core$src$master$WorkerManager_ts$default {
    constructor(master) {
      this.master = master;

      this.workerStartEvent = new ___$romejs$events$src$Event_ts$default({name: 'WorkerManager.workerStart'});
      this.selfWorker = true;
      this.locker = new ___$romejs$core$src$common$utils$Locker_ts$default();
      this.workers = new Map();
      this.idCounter = 0;
    }

    getNextWorkerId() {
      return this.idCounter++;
    }

    getWorkerAssert(id) {
      const worker = this.workers.get(id);
      if (worker === undefined) {
        throw new Error('Expected worker');
      }
      return worker;
    }

    getWorkers() {
      return Array.from(this.workers.values());
    }

    getWorkerCount() {
      let count = 0;
      for (const worker of this.workers.values()) {
        if (worker.ghost === false) {
          count++;
        }
      }
      return count;
    }

    getExternalWorkers() {
      return this.getWorkers().filter(worker => worker.process !== undefined);
    }

    end() {
      for (const {bridge: bridge} of this.workers.values()) {
        bridge.end();
      }
    }

    getLowestByteCountWorker() {
      let smallestWorker;
      let byteCount;
      for (const worker of this.workers.values()) {
        if (!worker.ghost &&
        (byteCount === undefined || byteCount > worker.byteCount)) {
          smallestWorker = worker;
          byteCount = worker.byteCount;
        }
      }

      if (smallestWorker === undefined) {
        throw new Error('No worker found');
      } else {
        return smallestWorker;
      }
    }

    async init() {
      const bridge = ___$romejs$events$src$bridgeCreators_ts$createBridgeFromLocal(___$romejs$core$src$common$bridges$WorkerBridge_ts$default);
      const worker = new ___$romejs$core$src$worker$Worker_ts$default(bridge);

      const id = this.getNextWorkerId();
      ___$romejs$invariant$src$index_ts$default(id === 0, 'Expected master worker id to be 0');

      const container = {
        id: 0,
        fileCount: 0,
        byteCount: 0,
        process: undefined,
        bridge: bridge,
        ghost: false,
        ready: false};
      this.workers.set(0, container);
      worker.init();

      await Promise.all([this.workerHandshake(container), bridge.handshake()]);

      this.workerStartEvent.send(bridge);
    }

    async replaceOwnWorker() {
      const lock = this.locker.getNewLock(0);

      try {
        const masterWorker = this.getWorkerAssert(0);
        this.master.logger.info(
        `[WorkerManager] Spawning first worker outside of master after exceeding ${___$romejs$core$src$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS} bytes`);
        this.selfWorker = false;

        const newWorker = await this.spawnWorker(this.getNextWorkerId(), true);

        masterWorker.bridge.end();

        this.workers.set(0, {
          id: 0,
          fileCount: masterWorker.fileCount,
          byteCount: masterWorker.byteCount,
          bridge: newWorker.bridge,
          process: newWorker.process,
          ghost: false,
          ready: true});
        this.workers.delete(newWorker.id);
      } finally {
        lock.release();
      }
    }

    onNewProject(newProject) {
      this.master.projectManager.notifyWorkersOfProjects(this.getWorkers(), [newProject]);
    }

    async workerHandshake(worker) {
      const {bridge: bridge} = worker;
      await bridge.handshake(3000);
      await this.master.projectManager.notifyWorkersOfProjects([worker]);
      worker.ready = true;
    }

    async spawnWorker(workerId, isGhost = false) {
      const lock = this.locker.getNewLock(workerId);
      try {
        return await this._spawnWorker(workerId, isGhost);
      } finally {
        lock.release();
      }
    }

    async _spawnWorker(workerId, isGhost) {
      const start = Date.now();

      const process = ___$romejs$core$src$common$utils$fork_ts$default('worker');

      const bridge = ___$romejs$events$src$bridgeCreators_ts$createBridgeFromChildProcess(___$romejs$core$src$common$bridges$WorkerBridge_ts$default, process, {
        onSendMessage: data => {
          this.master.logger.info(
          `[WorkerManager] Sending worker request to %s:`,
          workerId,
          data);
        }});

      const worker = {
        id: workerId,
        fileCount: 0,
        byteCount: 0,
        process: process,
        bridge: bridge,
        ghost: isGhost,
        ready: false};
      this.workers.set(workerId, worker);

      process.once('error', err => {
        this.master.onFatalError(err);
        process.kill();
      });

      process.once('exit', () => {
        this.master.onFatalError(new Error(`Worker ${String(workerId)} died`));
      });

      await this.workerHandshake(worker);

      if (this.master.profiling) {
        await bridge.profilingStart.call();
      }

      this.workerStartEvent.send(bridge);

      this.master.logger.info(
      `[WorkerManager] Worker %s started after %sms`,
      workerId,
      Date.now() - start);

      return worker;
    }

    own(workerId, stats) {
      const worker = this.getWorkerAssert(workerId);
      worker.byteCount += stats.size;
      worker.fileCount++;
    }

    disown(workerId, stats) {
      const worker = this.getWorkerAssert(workerId);
      worker.byteCount -= stats.size;
      worker.fileCount--;
    }

    async getNextWorker(filename) {
      const {logger: logger, memoryFs: memoryFs, fileManager: fileManager} = this.master;

      const stats = memoryFs.getFileStats(filename);
      if (stats === undefined) {
        throw new Error(`The file ${filename} doesn't exist`);
      }

      fileManager.verifySize(filename, stats);

      await this.locker.waitLock(0);

      if (this.selfWorker) {
        const worker = this.getWorkerAssert(0);
        if (worker.byteCount > ___$romejs$core$src$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS) {
          await this.replaceOwnWorker();
        }
      }

      const smallestWorker = this.getLowestByteCountWorker();
      let workerId = smallestWorker.id;

      if (smallestWorker.byteCount > ___$romejs$core$src$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD &&
      this.getWorkerCount() < ___$romejs$core$src$common$constants_ts$MAX_WORKER_COUNT) {
        logger.info(
        `[WorkerManager] Spawning a new worker as we've exceeded ${___$romejs$core$src$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD} bytes across each worker`);
        workerId = this.getNextWorkerId();
        await this.spawnWorker(workerId);
      }

      this.own(workerId, stats);

      await this.locker.waitLock(workerId);

      return this.getWorkerAssert(workerId);
    }
  }

  // romejs/core/src/common/types/platform.ts

  const ___$romejs$core$src$common$types$platform_ts = {
    get PLATFORMS() {
      return ___$romejs$core$src$common$types$platform_ts$PLATFORMS;
    },
    get PLATFORM_ALIASES() {
      return ___$romejs$core$src$common$types$platform_ts$PLATFORM_ALIASES;
    }};
  const ___$romejs$core$src$common$types$platform_ts$PLATFORMS = ['ios', 'android', 'mobile', 'electron', 'web', 'node'];

  const ___$romejs$core$src$common$types$platform_ts$PLATFORM_ALIASES = {
    ios: ['mobile'],
    android: ['mobile'],
    electron: ['web'],
    mobile: [],
    node: [],
    web: []};

  // romejs/core/src/master/Resolver.ts

  const ___$$priv$romejs$core$src$master$Resolver_ts$path = require('path');
  const ___$$priv$romejs$core$src$master$Resolver_ts$NODE_MODULES = 'node_modules';
  const ___$$priv$romejs$core$src$master$Resolver_ts$MOCKS_DIR = '__mocks__';

  function ___$$priv$romejs$core$src$master$Resolver_ts$getPrefferedMain(manifest) {
    const {main: main, 'rome:main': romeMain, 'jsnext:main': jsnextMain} = manifest;

    if (romeMain !== undefined) {
      return romeMain;
    }

    if (jsnextMain !== undefined) {
      return jsnextMain;
    }

    return main;
  }

  class ___$romejs$core$src$master$Resolver_ts$default {
    constructor(master) {
      this.master = master;
    }

    async findProjectFromQuery(query) {
      if (___$$priv$romejs$core$src$master$Resolver_ts$path.isAbsolute(query.source)) {
        await this.master.projectManager.findProject(___$$priv$romejs$core$src$master$Resolver_ts$path.resolve(query.source));
      } else {
        await this.master.projectManager.findProject(query.origin);
        await this.master.projectManager.findProject(
        ___$$priv$romejs$core$src$master$Resolver_ts$path.join(query.origin, query.source));
      }
    }

    async resolveEntryAssert(query, loc) {
      await this.findProjectFromQuery(query);
      return this.resolveAssert(Object.assign({}, query, {
        entry: true}), loc);
    }

    async resolveEntry(query) {
      await this.findProjectFromQuery(query);
      return this.resolve(Object.assign({}, query, {
        entry: true}));
    }

    resolveAssert(query, loc) {
      const resolved = this.resolve(query);
      if (resolved !== undefined) {
        return resolved;
      }

      const errMsg = `Failed to resolve ${query.source} from '${query.origin}`;

      if (loc === undefined) {
        throw new Error(errMsg);
      }

      throw new ___$romejs$diagnostics$src$errors_ts$DiagnosticError(errMsg, {
        category: 'resolver/resolve',
        filename: loc.filename,
        start: loc.start,
        end: loc.end,
        message: `Failed to resolve <emphasis>${query.source}</emphasis>`});
    }

    resolve(query) {
      const {source: source} = query;
      if (source === '' || source[0] === '.' || ___$$priv$romejs$core$src$master$Resolver_ts$path.isAbsolute(source)) {
        return this.resolvePath(query);
      }

      const resolved = this.resolveModule(query);

      if (resolved === undefined && query.entry === true) {
        return this.resolvePath(query);
      }

      return resolved;
    }

    *getFilenameVariants(query) {
      const seen = new Set();
      for (const variant of this._getFilenameVariants(query, ['root'])) {
        if (seen.has(variant)) {
          continue;
        }

        seen.add(variant);
        yield variant;
      }
    }

    *_getFilenameVariants(query, callees) {
      const {platform: platform, source: source} = query;
      const extname = ___$$priv$romejs$core$src$master$Resolver_ts$path.extname(source);
      const noextname = ___$$priv$romejs$core$src$master$Resolver_ts$path.join(
      ___$$priv$romejs$core$src$master$Resolver_ts$path.dirname(source),
      ___$$priv$romejs$core$src$master$Resolver_ts$path.basename(source, extname));

      yield source;

      const extension = ___$romejs$core$src$worker$extensions_ts$getExtensionHandler(source);
      let usesUnknownExtension = extension === undefined;

      if (usesUnknownExtension) {
        for (const ext of ___$romejs$core$src$worker$extensions_ts$IMPLICIT_JS_EXTENSIONS) {
          yield* this._getFilenameVariants(Object.assign({}, query, {
            source: source + '.' + ext}), [...callees, 'unknownext']);
        }
        return undefined;
      }

      if (platform !== undefined && !callees.includes('platform')) {
        yield* this._getFilenameVariants(Object.assign({}, query, {
          source: `${noextname}.${platform}`}), [...callees, 'platform']);

        const platformAliases = ___$romejs$core$src$common$types$platform_ts$PLATFORM_ALIASES[platform];
        if (platformAliases !== undefined) {
          for (const platform of platformAliases) {
            yield* this._getFilenameVariants(Object.assign({}, query, {
              source: `${noextname}.${platform}`}), [...callees, 'platform']);
          }
        }
      }

      if (extension !== undefined &&
      extension.hasScale === true &&
      !callees.includes('scale')) {
        const scale = query.scale === undefined ? 3 : query.scale;
        for (let i = scale; i >= 1; i--) {
          yield* this._getFilenameVariants(Object.assign({}, query, {
            source: `${noextname}@${String(i)}x${extname}`}), [...callees, 'scale']);
        }
      }
    }

    resolvePath(query, checkVariants = true) {
      const {memoryFs: memoryFs} = this.master;
      const {origin: origin, source: source} = query;

      const originFolder = memoryFs.isFile(origin) ? ___$$priv$romejs$core$src$master$Resolver_ts$path.dirname(origin) : origin;
      const loc = ___$$priv$romejs$core$src$master$Resolver_ts$path.resolve(originFolder, source);

      if (memoryFs.isFile(loc)) {
        if (query.type === 'package') {
          return undefined;
        }

        return loc;
      }

      if (checkVariants) {
        for (const variant of this.getFilenameVariants(query)) {
          if (variant === source) {
            continue;
          }

          const resolved = this.resolvePath(Object.assign({}, query, {
            source: variant}), false);
          if (resolved !== undefined) {
            return resolved;
          }
        }
      }

      if (memoryFs.isDirectory(loc)) {
        if (query.type === 'folder') {
          return loc;
        }

        const manifest = memoryFs.getManifest(loc);
        if (manifest !== undefined) {
          if (query.type === 'package') {
            return loc;
          }

          if (manifest !== undefined) {
            const main = ___$$priv$romejs$core$src$master$Resolver_ts$getPrefferedMain(manifest);
            if (main !== undefined) {
              return this.resolvePath(Object.assign({}, query, {
                origin: loc, source: main}));
            }
          }
        }

        for (const ext of ___$romejs$core$src$worker$extensions_ts$IMPLICIT_JS_EXTENSIONS) {
          const indexResolved = this.resolvePath(Object.assign({}, query, {
            source: ___$$priv$romejs$core$src$master$Resolver_ts$path.join(loc, 'index.' + ext)}));
          if (indexResolved !== undefined) {
            return indexResolved;
          }
        }
      }

      return undefined;
    }

    resolvePackageFolder(query, moduleName) {
      const project = this.master.projectManager.findProjectExisting(
      query.origin);
      if (project === undefined) {
        return undefined;
      }

      const projects = this.master.projectManager.getHierarchyFromProject(
      project);
      for (const project of projects) {
        const pkg = project.packages.get(moduleName);
        if (pkg !== undefined) {
          return pkg.folder;
        }
      }

      return undefined;
    }

    resolvePackage(query, moduleName, moduleNameParts) {
      const packageDir = this.resolvePackageFolder(query, moduleName);

      if (packageDir === undefined) {
        return undefined;
      } else {
        return this.resolvePath(Object.assign({}, query, {
          source: ___$$priv$romejs$core$src$master$Resolver_ts$path.join(packageDir, ...moduleNameParts)}));
      }
    }

    resolveMock(query, parentDirectories) {
      const moduleName = query.source;
      for (const dir of parentDirectories) {
        const mocksDir = ___$$priv$romejs$core$src$master$Resolver_ts$path.join(dir, ___$$priv$romejs$core$src$master$Resolver_ts$MOCKS_DIR);

        if (!this.master.memoryFs.exists(mocksDir)) {
          continue;
        }

        const resolved = this.resolve(Object.assign({}, query, {
          source: ___$$priv$romejs$core$src$master$Resolver_ts$path.join(mocksDir, moduleName)}));
        if (resolved !== undefined) {
          return resolved;
        }
      }
      return undefined;
    }

    resolveHaste(query, project, moduleName, moduleNameParts) {
      const resolved = project.hasteMap.get(moduleName);
      if (resolved !== undefined) {
        return this.resolvePath(Object.assign({}, query, {
          source: ___$$priv$romejs$core$src$master$Resolver_ts$path.join(resolved, ...moduleNameParts)}));
      }

      for (const filename of this.getFilenameVariants(query)) {
        const hasteName = this.master.memoryFs.getHasteName(filename);

        if (hasteName !== undefined) {
          const resolved = project.hasteMap.get(hasteName);
          if (resolved !== undefined) {
            return this.resolvePath(Object.assign({}, query, {
              source: resolved}));
          }
        }
      }

      return undefined;
    }

    splitModuleName(moduleNameFull) {
      const [moduleName, ...moduleNameParts] = moduleNameFull.split('/');

      if (moduleName[0] === '@' && moduleNameParts.length > 0) {
        return [moduleName + '/' + moduleNameParts.shift(), moduleNameParts];
      }

      return [moduleName, moduleNameParts];
    }

    resolveModule(query) {
      const {origin: origin, source: source} = query;

      const project = this.master.projectManager.findProjectExisting(origin);

      const parentDirectories = Array.from(
      ___$romejs$core$src$common$utils$walkDirectoryPath_ts$default(___$$priv$romejs$core$src$master$Resolver_ts$path.dirname(origin)));

      if (query.mocks === true) {
        const mockResolved = this.resolveMock(query, parentDirectories);
        if (mockResolved !== undefined) {
          return mockResolved;
        }
      }

      const [moduleName, moduleNameParts] = this.splitModuleName(source);

      if (project !== undefined && project.hasteMap.size > 0) {
        const hasteResolved = this.resolveHaste(
        query,
        project,
        moduleName,
        moduleNameParts);
        if (hasteResolved !== undefined) {
          return hasteResolved;
        }
      }

      const packageResolved = this.resolvePackage(
      query,
      moduleName,
      moduleNameParts);
      if (packageResolved !== undefined) {
        return packageResolved;
      }

      for (const dir of parentDirectories) {
        const nodeModulesLoc = ___$$priv$romejs$core$src$master$Resolver_ts$path.join(dir, ___$$priv$romejs$core$src$master$Resolver_ts$NODE_MODULES, source);
        const nodeModulesResolved = this.resolvePath(Object.assign({}, query, {
          source: nodeModulesLoc}));
        if (nodeModulesResolved !== undefined) {
          return nodeModulesResolved;
        }
      }

      return undefined;
    }
  }

  // romejs/core/src/master/FileManager.ts

  class ___$romejs$core$src$master$FileManager_ts$default {
    constructor(master) {
      this.master = master;
      this.fileToWorker = new Map();
      this.locker = new ___$romejs$core$src$common$utils$Locker_ts$default();
    }

    getAllOwnedFilenames() {
      return Array.from(this.fileToWorker.keys());
    }

    hasOwner(filename) {
      return this.getOwnerId(filename) !== undefined;
    }

    getOwnerId(filename) {
      return this.fileToWorker.get(filename);
    }

    verifySize(filename, stats) {
      const project = this.master.projectManager.assertProjectExisting(filename);
      const maxSize = project.config.files.maxSize;

      if (stats.size > maxSize) {
        throw new Error(`The file ${filename} exceeds the project config max size of ${maxSize} bytes`);
      }
    }

    getOwnerAssert(filename) {
      const {workerManager: workerManager} = this.master;
      const workerId = this.getOwnerId(filename);
      if (workerId === undefined) {
        throw new Error(`No worker found for ${filename}`);
      }

      const worker = workerManager.getWorkerAssert(workerId);
      ___$romejs$invariant$src$index_ts$default(worker.ready, 'Worker %s isn\'t ready', workerId);
      return worker;
    }

    async getOrAssignOwner(filename) {
      const {workerManager: workerManager} = this.master;

      const workerId = this.getOwnerId(filename);
      if (workerId === undefined) {
        return this.assignOwner(filename);
      } else {
        await workerManager.locker.waitLock(workerId);
        return workerManager.getWorkerAssert(workerId);
      }
    }

    async groupFilesByWorker(files) {
      const filesByWorker = new Map();

      await Promise.all(
      files.map(async file => {
        const worker = await this.getOrAssignOwner(file);

        let queue = filesByWorker.get(worker.id);
        if (queue === undefined) {
          queue = [];
          filesByWorker.set(worker.id, queue);
        }
        queue.push(file);
      }));

      return Array.from(filesByWorker.values());
    }

    async evict(filename) {
      const workerId = this.getOwnerId(filename);
      if (workerId === undefined) {
        return undefined;
      }

      const worker = this.master.workerManager.getWorkerAssert(workerId);
      await worker.bridge.evict.call({
        filename: filename});
    }

    async disown(filename) {
      const workerId = this.getOwnerId(filename);
      if (workerId === undefined) {
        return undefined;
      }

      await this.evict(filename);

      await this.master.cache.evict(filename);

      this.fileToWorker.delete(filename);

      const stats = this.master.memoryFs.getFileStatsAssert(filename);
      this.master.workerManager.disown(workerId, stats);
    }

    async onFileChange(filename, oldStats, newStats) {
      const {logger: logger, workerManager: workerManager} = this.master;

      if (this.hasOwner(filename)) {
        const workerId = this.getOwnerId(filename);
        if (workerId === undefined) {
          throw new Error(`Expected worker id for ${filename}`);
        }

        await this.evict(filename);

        this.verifySize(filename, newStats);

        if (oldStats === undefined) {
          throw new Error('File already has an owner so expected to have old stats but had none');
        }
        workerManager.disown(workerId, oldStats);
        workerManager.own(workerId, newStats);
      } else if (await this.master.projectManager.maybeEvictPossibleConfig(filename)) {
        logger.info(
        `[FileManager] Evicted the project belonging to config %s`,
        filename);
      } else {
        logger.info(`[FileManager] No owner for eviction %s`, filename);
      }
    }

    async assignOwner(filename) {
      const {workerManager: workerManager, logger: logger} = this.master;

      const lock = await this.locker.getLock(filename);

      if (this.hasOwner(filename)) {
        lock.release();
        return this.getOwnerAssert(filename);
      }

      const worker = await workerManager.getNextWorker(filename);

      logger.info(
      `[FileManager] File %s assigned to worker %s`,
      filename,
      worker.id);
      this.fileToWorker.set(filename, worker.id);

      lock.release();
      return worker;
    }
  }

  // romejs/core/src/common/utils/Logger.ts

  class ___$romejs$core$src$common$utils$Logger_ts$default extends ___$romejs$cli_reporter$src$Reporter_ts$default {
    constructor(name, event, opts) {
      super(Object.assign({
        verbose: true}, opts));
      this._loggerName = name;
      this.event = event;
    }

    isEnabled() {
      return this.event.hasSubscribers();
    }

    log(msg) {
      if (this.isEnabled()) {
        const prefix = ___$romejs$string_ansi$src$format_ts$formatAnsi.dim(`[${this._loggerName} ${process.pid}]`);
        super.log(`${prefix} ${msg}`);
      }
    }
  }

  // romejs/core/src/master/Cache.ts

  const ___$$priv$romejs$core$src$master$Cache_ts$path = require('path');
  const ___$$priv$romejs$core$src$master$Cache_ts$fs = require('fs');
  class ___$romejs$core$src$master$Cache_ts$default {
    constructor(master) {
      this.master = master;
      this.loadedEntries = new Map();
      this.disabled = process.env.ROME_CACHE === '0';
    }

    async onNewProject(project) {
      if (this.disabled) {
        return undefined;
      }

      const {memoryFs: memoryFs} = this.master;
      const folder = project.config.cache.folder;

      await ___$$priv$romejs$core$src$master$Cache_ts$fs.promises.mkdir(folder, {recursive: true});
      await memoryFs.watch(folder, ___$romejs$core$src$common$types$project_ts$DEFAULT_PROJECT_CONFIG);
    }

    async createEntry(filename) {
      const {projectManager: projectManager, memoryFs: memoryFs} = this.master;

      const project = await projectManager.assertProject(filename);

      const entry = {
        filename: filename,
        version: ___$romejs$core$src$common$constants_ts$VERSION,
        projectDir: project.dir,
        configHash: project.config.configHashes.join(';'),
        mtime: memoryFs.getMtime(filename),
        compile: {},
        analyzeDependencies: undefined,
        moduleSignature: undefined};

      return entry;
    }

    getCacheFilename(filename) {
      const project = this.master.projectManager.assertProjectExisting(filename);
      const uid = this.master.projectManager.getUid(filename);
      return ___$$priv$romejs$core$src$master$Cache_ts$path.join(project.config.cache.folder, uid);
    }

    async evict(filename) {
      const cacheFilename = this.getCacheFilename(filename);
      await ___$$priv$romejs$core$src$master$Cache_ts$fs.promises.unlink(cacheFilename);
      this.loadedEntries.delete(filename);
    }

    async get(filename) {
      const loaded = this.loadedEntries.get(filename);
      if (loaded !== undefined) {
        return loaded;
      }

      const defaultEntry = await this.createEntry(filename);
      if (this.disabled) {
        return defaultEntry;
      }

      const {memoryFs: memoryFs} = this.master;
      const cacheFilename = this.getCacheFilename(filename);
      const entry = await this._get(cacheFilename, defaultEntry);

      if (entry === defaultEntry && memoryFs.exists(cacheFilename)) {
        await this.evict(filename);
      }

      this.loadedEntries.set(filename, entry);

      return entry;
    }

    async _get(cacheFilename, defaultEntry) {
      const {memoryFs: memoryFs} = this.master;

      if (!memoryFs.exists(cacheFilename)) {
        return defaultEntry;
      }

      try {
        const json = await ___$$priv$romejs$core$src$master$Cache_ts$fs.promises.readFile(cacheFilename, 'utf8');
        const obj = JSON.parse(json);

        if (obj.version !== defaultEntry.version) {
          return defaultEntry;
        }

        if (obj.configHash !== defaultEntry.configHash) {
          return defaultEntry;
        }

        if (obj.mtime !== defaultEntry.mtime) {
          return defaultEntry;
        }

        if (obj.filename !== defaultEntry.filename) {
          return defaultEntry;
        }

        return Object.assign({}, defaultEntry, obj);
      } catch (err) {
        return defaultEntry;
      }
    }

    async write(filename, entry) {
      const cacheFilename = this.getCacheFilename(filename);
      this.loadedEntries.set(filename, entry);

      if (this.disabled) {
        return undefined;
      }

      await ___$$priv$romejs$core$src$master$Cache_ts$fs.promises.mkdir(___$$priv$romejs$core$src$master$Cache_ts$path.dirname(cacheFilename), {recursive: true});
      await ___$$priv$romejs$core$src$master$Cache_ts$fs.promises.writeFile(
      cacheFilename,
      JSON.stringify(entry, null, '  '));
    }
  }

  // romejs/core/src/master/MasterAPI.ts

  const ___$$priv$romejs$core$src$master$MasterAPI_ts$crypto = require('crypto');
  class ___$romejs$core$src$master$MasterAPI_ts$default {
    constructor(master) {
      this.master = master;
    }

    normalizeCompileResult(res) {
      const {projectManager: projectManager} = this.master;

      return Object.assign({}, res, {
        cacheDependencies: res.cacheDependencies.map(filename => {
          return projectManager.getFileReference(filename).uid;
        })});
    }

    async wrapDiagnostic(ref, action, promise) {
      try {
        return await promise;
      } catch (err) {
        if (err instanceof ___$romejs$diagnostics$src$errors_ts$DiagnosticError || err instanceof ___$romejs$diagnostics$src$errors_ts$DiagnosticsError) {
          throw err;
        } else {
          err.__ROME_ERROR_ADVICE__ = [...(err.__ROME_ERROR_ADVICE__ || []), {
            type: 'log',
            category: 'info',
            message: `Error occured while ${action} <emphasis><filelink filename="${ref.uid}" /></emphasis>`}];
          throw err;
        }
      }
    }

    async getFileInfo(filename) {
      const {master: master} = this;
      const owner = await master.fileManager.getOrAssignOwner(filename);
      const ref = master.projectManager.getFileReference(filename);
      return [owner.bridge, ref];
    }

    async parse(filename, opts) {
      const [bridge, file] = await this.getFileInfo(filename);
      return bridge.parse.call({file: file, opts: opts});
    }

    async compile(filename, stage, options) {
      const {cache: cache} = this.master;

      const optionsHash = options === undefined ? 'none' : ___$$priv$romejs$core$src$master$MasterAPI_ts$crypto.createHash('sha256').update(JSON.stringify(options)).digest('hex');
      const cacheKey = `${stage}:${optionsHash}`;

      const cacheEntry = await cache.get(filename);
      const cached = cacheEntry.compile[cacheKey];
      if (cached !== undefined) {
        return cached;
      }

      if (options === undefined) {
        options = {};
      }

      const [bridge, file] = await this.getFileInfo(filename);
      const compileRes = await this.wrapDiagnostic(
      file,
      'compiling',
      bridge.compile.call({file: file, stage: stage, options: options}));
      const res = this.normalizeCompileResult(compileRes);

      await cache.write(filename, Object.assign({}, cacheEntry, {
        compile: Object.assign({}, cacheEntry.compile, {
          [cacheKey]: res})}));

      return res;
    }

    async analyzeDependencies(filename) {
      const {cache: cache} = this.master;

      const cacheEntry = await cache.get(filename);
      if (cacheEntry.analyzeDependencies !== undefined) {
        return cacheEntry.analyzeDependencies;
      }

      const [bridge, file] = await this.getFileInfo(filename);
      const res = await this.wrapDiagnostic(
      file,
      'analyzing dependencies',
      bridge.analyzeDependencies.call({file: file}));
      await cache.write(filename, Object.assign({}, cacheEntry, {
        analyzeDependencies: res}));
      return res;
    }

    async moduleSignature(filename) {
      const {cache: cache} = this.master;

      const cacheEntry = await cache.get(filename);
      if (cacheEntry.moduleSignature !== undefined) {
        return cacheEntry.moduleSignature;
      }

      const [bridge, file] = await this.getFileInfo(filename);
      const res = await this.wrapDiagnostic(
      file,
      'calculating module signature',
      bridge.moduleSignature.call({file: file}));
      await cache.write(filename, Object.assign({}, cacheEntry, {
        moduleSignature: res}));
      return res;
    }

    async maybePrefetchModuleSignatures(filename) {
      const {projectManager: projectManager} = this.master;

      const prefetchedModuleSignatures = {};
      const project = await projectManager.assertProject(filename);
      if (project.config.typeChecking.enabled === false) {
        return prefetchedModuleSignatures;
      }

      return prefetchedModuleSignatures;
    }

    async lint(filename, fix) {
      const prefetchedModuleSignatures = await this.maybePrefetchModuleSignatures(
      filename);
      const [bridge, file] = await this.getFileInfo(filename);
      return await this.wrapDiagnostic(
      file,
      'linting',
      bridge.lint.call({file: file, fix: fix, prefetchedModuleSignatures: prefetchedModuleSignatures}));
    }
  }

  // romejs/core/src/master/WorkerQueue.ts

  class ___$romejs$core$src$master$WorkerQueue_ts$default {
    constructor(master) {
      this.master = master;
      this.queue = [];
      this.callbacks = [];
      this.promises = [];
      this.workers = new Map();
      this.open = true;
    }

    pushQueue(filename, metadata) {
      ___$romejs$invariant$src$index_ts$default(this.open, 'WorkerQueue has already closed');
      this.queue.push([filename, metadata]);
    }

    addCallback(callback) {
      this.callbacks.push(callback);
    }

    async updateWorkerQueues() {
      const {queue: queue} = this;

      while (queue.length > 0) {
        const item = queue.shift();
        if (item === undefined) {
          throw new Error('Already validated queue.length above');
        }

        const filename = item[0];
        const workerContainer = await this.master.fileManager.getOrAssignOwner(
        filename);

        let worker = this.workers.get(workerContainer);
        if (worker === undefined) {
          worker = {
            running: false,
            queue: []};
        }
        worker.queue.push(item);

        if (worker.running === false) {
          this.promises.push(this.processWorker(worker));
        }
      }
    }

    async processWorker(item) {
      item.running = true;

      const {queue: queue} = item;

      while (queue.length > 0) {
        const item = queue.shift();
        if (item === undefined) {
          throw new Error('Already validated queue.length above');
        }

        const [filename, metadata] = item;
        for (const callback of this.callbacks) {
          await callback(filename, metadata);
        }
        await this.updateWorkerQueues();
      }

      item.running = false;
    }

    async spin() {
      const {queue: queue} = this;

      await this.updateWorkerQueues();

      while (this.promises.length > 0) {
        const {promises: promises} = this;
        this.promises = [];
        await Promise.all(promises);
      }

      this.open = false;

      ___$romejs$invariant$src$index_ts$default(queue.length === 0, 'Expected no queue items to remain');

      for (const [worker, {queue: queue}] of this.workers) {
        ___$romejs$invariant$src$index_ts$default(
        queue.length === 0,
        'Expected no queue items to remain for worker %s',
        worker.id);
      }
    }
  }

  // romejs/core/src/master/dependencies/DependencyOrderer.ts

  class ___$romejs$core$src$master$dependencies$DependencyOrderer_ts$default {
    constructor(graph) {
      this.graph = graph;
      this.orderedNodes = new Set();
      this.visitedNodes = new Set();
      this.possibleCyclePaths = new Map();
      this.diagnostics = [];
      this.firstTopAwaitLocations = [];
    }

    handleAlreadyVisitedFile(node, filename, ancestry) {
      const isPossibleCycle = this.orderedNodes.has(node) === false && ancestry.includes(filename);
      if (isPossibleCycle) {
        const ourCyclePath = ancestry.concat([filename]);
        const existingCycle = this.possibleCyclePaths.get(node);

        const isShortestCycle = existingCycle === undefined ||
        existingCycle.length > ourCyclePath.length;
        if (isShortestCycle) {
          this.possibleCyclePaths.set(node, ourCyclePath);
        }
      }
    }

    addFile(filename, ancestry) {
      const node = this.graph.getNode(filename);

      if (this.visitedNodes.has(node)) {
        this.handleAlreadyVisitedFile(node, filename, ancestry);
        return undefined;
      }

      this.visitedNodes.add(node);

      const {firstTopAwaitLocation: firstTopAwaitLocation} = node.analyze;
      if (firstTopAwaitLocation !== undefined) {
        this.firstTopAwaitLocations.push(firstTopAwaitLocation);
      }

      for (const depFilename of node.getAbsoluteDependencies()) {
        const dep = node.getDependencyInfoFromAbsolute(depFilename);
        if (dep.kind === 'value') {
          this.addFile(depFilename, ancestry.concat([filename]));
        }
      }

      this.orderedNodes.add(node);
    }

    detectCycles() {
      const flatOrder = Array.from(this.orderedNodes);

      for (let i = 0; i < flatOrder.length; i++) {
        const node = flatOrder[i];

        for (const imp of node.analyze.importFirstUsage) {
          const filename = node.getAbsoluteFromRelativeDependency(imp.source);
          const resolved = this.graph.resolveImport(imp.imported, filename);
          if (resolved === undefined) {
            continue;
          }

          if (resolved.hoisted) {
            continue;
          }

          const dep = resolved.node;

          const isBefore = flatOrder.indexOf(dep) > i;
          if (isBefore) {
            this.flagCycle(node, dep, imp);
          }
        }
      }
    }

    flagCycle(node, dep, imp) {
      const path = this.possibleCyclePaths.get(dep);
      if (!path) {
        return undefined;
      }

      const target = path[path.length - 1];
      const culprit = String(
      path.find((value, index) => path[index - 1] === target));

      function formatPart(part, index) {
        const tagged = `<filelink filename="${part}" />`;
        if (part === culprit) {
          return `${___$romejs$string_ansi$src$format_ts$formatAnsi.magenta(tagged)}${___$romejs$string_ansi$src$format_ts$formatAnsi.dim('[1]')}`;
        } else if (part === target) {
          return `${___$romejs$string_ansi$src$format_ts$formatAnsi.cyan(tagged)}${___$romejs$string_ansi$src$format_ts$formatAnsi.dim('[2]')}`;
        } else if (index === 0) {
          return `${tagged} <inverse>ENTRY</inverse>`;
        } else {
          return tagged;
        }
      }

      this.diagnostics.push({
        category: 'bundler/moduleCycle',
        filename: node.filename,
        start: imp.loc === undefined ? undefined : imp.loc.start,
        end: imp.loc === undefined ? undefined : imp.loc.end,
        message: `The variable <emphasis>${imp.local}</emphasis> won't be initialized yet`,
        advice: [{
          type: 'log',
          category: 'info',
          message: `The likely cause is the file ${formatPart(
          culprit)} that was required by ${formatPart(
          target)} which created a circular dependency:`}, {
          type: 'ordered-list',
          reverse: true,
          list: path.map(formatPart)}]});
    }

    order(filename) {
      this.addFile(filename, []);
      this.detectCycles();

      return {
        firstTopAwaitLocations: this.firstTopAwaitLocations,
        diagnostics: this.diagnostics,
        files: Array.from(this.orderedNodes, node => node.filename)};
    }
  }

  // romejs/core/src/master/dependencies/DependencyNode.ts

  class ___$romejs$core$src$master$dependencies$DependencyNode_ts$default {
    constructor(graph, id, filename, res) {
      this.graph = graph;

      this.project = graph.master.projectManager.assertProjectExisting(filename);
      this.filename = filename;
      this.id = id;
      this.type = res.type;

      this.usedAsync = false;
      this.all = false;
      this.resolvedDependencies = new Map();
      this.dependencies = new Map();

      this.analyze = res;
    }

    setUsedAsync(usedAsync) {
      this.usedAsync = usedAsync;
    }

    setAll(all) {
      this.all = all;
    }

    addDependency(relative, absolute, dep) {
      this.resolvedDependencies.set(relative, absolute);
      this.dependencies.set(absolute, dep);
    }

    getDependencyInfoFromAbsolute(filename) {
      const dep = this.dependencies.get(filename);
      if (dep === undefined) {
        throw new Error('Expected dependency');
      }
      return dep;
    }

    getAbsoluteFromRelativeDependency(relative) {
      const absolute = this.resolvedDependencies.get(relative);
      if (absolute === undefined) {
        throw new Error(`Expected dependency ${relative} in ${this.filename}`);
      }
      return absolute;
    }

    getAbsoluteDependencies() {
      return Array.from(this.resolvedDependencies.values());
    }

    getTransitiveDependencies() {
      let queue = [this];

      const nodes = new Set();

      while (queue.length > 0) {
        const node = queue.shift();
        if (node === undefined) {
          throw new Error('Already validated queue.length');
        }

        nodes.add(node);

        for (const absolute of node.getAbsoluteDependencies()) {
          const node = this.graph.getNode(absolute);

          if (!nodes.has(node)) {
            queue.push(node);
          }
        }
      }

      return Array.from(nodes);
    }

    getDependencyOrder() {
      const orderer = new ___$romejs$core$src$master$dependencies$DependencyOrderer_ts$default(this.graph);
      return orderer.order(this.filename);
    }
  }

  // romejs/core/src/master/dependencies/DependencyGraph.ts

  const ___$$priv$romejs$core$src$master$dependencies$DependencyGraph_ts$BUILTINS = ['electron', 'buffer', 'child_process', 'crypto', 'dgram', 'dns', 'fs', 'http', 'https', 'net', 'os', 'readline', 'stream', 'string_decoder', 'tls', 'tty', 'zlib', 'constants', 'events', 'url', 'assert', 'util', 'path', 'punycode', 'querystring', 'cluster', 'console', 'module', 'process', 'vm', 'domain', 'v8', 'repl', 'timers', 'inspector'];

  class ___$romejs$core$src$master$dependencies$DependencyGraph_ts$default {
    constructor(master, resolverOpts) {
      this.master = master;
      this.nodes = new Map();
      this.resolverOpts = resolverOpts;

      this.seedQueue = new ___$romejs$core$src$master$WorkerQueue_ts$default(master);

      this.locker = new ___$romejs$core$src$common$utils$Locker_ts$default();
    }

    isExternal(source) {
      return ___$$priv$romejs$core$src$master$dependencies$DependencyGraph_ts$BUILTINS.includes(source);
    }

    getBundleBuddyStats(entries) {
      const stats = [];

      for (const node of this.nodes.values()) {
        const source = node.id;

        for (const absoluteTarget of node.resolvedDependencies.values()) {
          const target = this.getNode(absoluteTarget).id;
          stats.push({
            target: target,
            source: source});
        }
      }

      for (const absoluteEntry of entries) {
        const source = this.getNode(absoluteEntry).id;
        stats.push({
          source: source,
          target: undefined});
      }

      return stats;
    }

    addNode(filename, res) {
      const module = new ___$romejs$core$src$master$dependencies$DependencyNode_ts$default(this, this.master.projectManager.getUid(filename), filename, res);
      this.nodes.set(filename, module);
      return module;
    }

    getNode(filename) {
      const mod = this.nodes.get(filename);
      if (mod === undefined) {
        throw new Error(`No module found for ${filename}`);
      }
      return mod;
    }

    async seed(filename, diagnosticsProcessor, analyzeProgress) {
      const root = await this.resolve(
      filename,
      {
        all: true,
        async: false,
        ancestry: []},
      diagnosticsProcessor,
      analyzeProgress);

      this.seedQueue.addCallback(async (filename, item) => {
        const mod = await this.resolve(
        filename,
        {
          all: item.all,
          async: item.async,
          ancestry: item.ancestry},
        diagnosticsProcessor,
        analyzeProgress);
        mod;
      });

      await this.seedQueue.spin();

      return root;
    }

    async resolve(filename, opts, diagnosticsProcessor, analyzeProgress) {
      const {async: async, all: all, ancestry: ancestry} = opts;
      const {master: master} = this;

      if (async === true) {
        ___$romejs$invariant$src$index_ts$default(
        all === true,
        'When async is set on a module then all should be too but it wasn\'t...');
      }

      const lock = await this.locker.getLock(filename);

      if (this.nodes.has(filename)) {
        const node = this.getNode(filename);

        if (all) {
          node.setAll(true);
        }

        if (async) {
          node.setUsedAsync(true);
        }

        lock.release();

        return node;
      }

      if (analyzeProgress !== undefined) {
        analyzeProgress.pushText(filename);
      }

      const res = await master.api.analyzeDependencies(
      filename);

      const node = this.addNode(filename, res);
      node.setAll(all);
      node.setUsedAsync(async);
      lock.release();

      const {dependencies: dependencies, diagnostics: diagnostics} = res;

      if (diagnostics.length > 0) {
        diagnosticsProcessor.addDiagnostics(diagnostics);
      }

      await Promise.all(
      dependencies.map(async dep => {
        const {source: source, optional: optional} = dep;
        if (this.isExternal(source)) {
          return undefined;
        }

        const {foundDiagnostics: foundDiagnostics, diagnostics: diagnostics} = await ___$romejs$diagnostics$src$wrap_ts$catchDiagnosticsAsync(
        'Caught by DependencyGraph.resolve',
        async () => {
          const absolute = await master.resolver.resolveAssert(Object.assign({
            origin: filename}, this.resolverOpts, {
            source: source}), dep.loc);

          node.addDependency(source, absolute, dep);
        });

        if (foundDiagnostics && !optional) {
          diagnosticsProcessor.addDiagnostics(diagnostics);
        }
      }));

      const subAncestry = [...ancestry, filename];
      for (const filename of node.getAbsoluteDependencies()) {
        const dep = node.getDependencyInfoFromAbsolute(filename);
        this.seedQueue.pushQueue(filename, {
          all: dep.all,
          async: dep.async,
          type: dep.type,
          loc: dep.loc,
          ancestry: subAncestry});
      }

      if (analyzeProgress !== undefined) {
        analyzeProgress.popText(filename);
        analyzeProgress.tick();
      }

      return node;
    }

    resolveImport(name, filename, ignoreDefault = false, ancestry = []) {
      if (ancestry.includes(filename)) {
        return undefined;
      }

      const node = this.getNode(filename);
      const deps = node.resolvedDependencies;
      const subAncestry = [...ancestry, filename];

      for (const record of node.analyze.exports.reverse()) {
        if (record.type === 'local' &&
        record.name === 'default' &&
        ignoreDefault) {
          continue;
        }

        if (record.type === 'local' && record.name === name) {
          return {
            node: node,
            kind: record.kind,
            hoisted: record.hoisted,
            name: record.name};
        }

        if (record.type === 'external' && record.exported === name) {
          const absolute = deps.get(record.source);
          if (absolute === undefined) {
            throw new Error(`Expected source ${record.source} for file ${filename}, have ${deps}`);
          }

          return this.resolveImport(
          record.imported,
          absolute,
          false,
          subAncestry);
        }

        if (record.type === 'externalAll') {
          const absolute = deps.get(record.source);
          if (absolute === undefined) {
            throw new Error(`Expected source ${record.source} for file ${filename}, have ${deps}`);
          }

          const maybeResolved = this.resolveImport(
          name,
          absolute,
          true,
          subAncestry);
          if (maybeResolved !== undefined) {
            return maybeResolved;
          }
        }
      }

      return undefined;
    }
  }

  // romejs/core/src/master/bundler/prelude.ts

  const ___$romejs$core$src$master$bundler$prelude_ts$default = `
  var Rome = (function() {
    var hasOwn = Object.prototype.hasOwnProperty;

    var factories = {};
    var modules = {};

    var Rome = {
      declare: function(id, callback) {
        factories[id] = callback;
      },

      declareModule: function(id, module) {
        return modules[id] = {exports: module};
      },

      import: function(id) {
        return Promise.resolve(Rome.require(id));
      },

      requireDefault: function(moduleId) {
        var mod = Rome.require(moduleId);
        return mod.__esModule ? mod.default : mod;
      },

      require: function(moduleId) {
        if (hasOwn.call(modules, moduleId)) {
          return modules[moduleId].exports;
        }

        if (hasOwn.call(factories, moduleId)) {
          const factory = factories[moduleId];
          const module = Rome.declareModule(moduleId, {});
          factory(module, module.exports);
          return module.exports;
        }

        throw new Error('No module ' + moduleId);
      },
    };
    return Rome;
  })();
`;

  // romejs/core/src/master/bundler/BundleRequest.ts

  class ___$romejs$core$src$master$bundler$BundleRequest_ts$default {
    constructor(bundler, mode, resolvedEntry) {
      this.bundler = bundler;

      this.mode = mode;

      this.resolvedEntry = resolvedEntry;
      this.resolvedEntryUid = bundler.master.projectManager.getUid(resolvedEntry);

      this.diagnosticsProcessor = new ___$romejs$diagnostics$src$DiagnosticsProcessor_ts$default({
        origins: [`bundler: Requested bundle for <filelink filename="${this.resolvedEntryUid}" />`]});
      this.compiles = new Map();

      this.sourceMap = new ___$romejs$codec_source_map$src$SourceMapGenerator_ts$default({
        file: 'TODO-something'});
    }

    async stepAnalyze() {
      const {reporter: reporter, graph: graph} = this.bundler;

      const analyzeProgress = reporter.progress();
      analyzeProgress.setTitle('Analysing');
      const node = await graph.seed(
      this.resolvedEntry,
      this.diagnosticsProcessor,
      analyzeProgress);
      analyzeProgress.end();
      return node;
    }

    async stepCompile(files) {
      const {reporter: reporter, master: master} = this.bundler;

      const compilingSpinner = reporter.progress();
      compilingSpinner.setTotal(files.length);
      compilingSpinner.setText('Compiling');

      const groupedFiles = await master.fileManager.groupFilesByWorker(files);
      await Promise.all(
      groupedFiles.map(async files => {
        for (const filename of files) {
          await this.compile(filename);
          compilingSpinner.tick();
        }
      }));
      compilingSpinner.end();
    }

    async compile(source) {
      const {graph: graph, master: master} = this.bundler;

      const mod = graph.getNode(source);
      const deps = mod.resolvedDependencies;

      const relativeSourcesToModuleId = {};
      for (const [relative, absolute] of mod.resolvedDependencies) {
        const moduleId = graph.getNode(absolute).id;
        relativeSourcesToModuleId[relative] = moduleId;
      }

      const resolvedImports = {};

      const parentModule = mod;
      const allowTypeImportsAsValue = mod.analyze.syntax.includes('ts');
      for (const absolute of deps.values()) {
        const mod = graph.getNode(absolute);

        if (mod.type === 'cjs') {
          continue;
        }

        const usedNames = parentModule.getDependencyInfoFromAbsolute(absolute).names;

        for (const {name: name, kind: kind, loc: loc} of usedNames) {
          if (kind === 'type') {
            continue;
          }

          const resolved = graph.resolveImport(name, absolute);

          if (resolved === undefined) {
            this.diagnosticsProcessor.addDiagnostic(Object.assign({
              category: 'bundler'}, loc, {
              message: `Couldn't find export <emphasis>${name}</emphasis> in <emphasis><filelink filename="${mod.id}" /></emphasis>`}));
            continue;
          }

          if (!allowTypeImportsAsValue &&
          kind === 'value' &&
          (resolved.kind === 'type' || resolved.kind === 'typeof')) {
            this.diagnosticsProcessor.addDiagnostic(Object.assign({
              category: 'bundler'}, loc, {
              message: `The export <emphasis>${name}</emphasis> in <emphasis><filelink filename="${mod.id}" /></emphasis> was incorrectly imported as a <emphasis>${kind}</emphasis> when it's actually a <emphasis>${resolved.kind}</emphasis>`}));
          }

          if (resolved.node.id !== mod.id) {
            resolvedImports[`${mod.id}:${name}`] = {
              id: resolved.node.id,
              name: resolved.name};
          }
        }
      }

      const opts = {
        mode: this.mode,
        moduleAll: mod.all,
        moduleType: mod.type,
        moduleId: mod.id,
        relativeSourcesToModuleId: relativeSourcesToModuleId,
        resolvedImports: resolvedImports};

      const res = await master.api.compile(
      source,
      'compileForBundle',
      {bundle: opts});

      if (res.diagnostics.length > 0) {
        this.diagnosticsProcessor.addDiagnostics(res.diagnostics);
      }

      this.compiles.set(source, res);
    }

    async stepCombine(order) {
      const {files: files} = order;
      const {inlineSourceMap: inlineSourceMap} = this.bundler.config;
      const {graph: graph} = this.bundler;
      const {resolvedEntry: resolvedEntry, mode: mode, sourceMap: sourceMap} = this;

      let content = '';
      let lineOffset = 0;

      function push(str) {
        str += '\n';
        content += str;
        for (let cha of str) {
          if (cha === '\n') {
            lineOffset++;
          }
        }
      }

      function addMappings(filename, sourceContent, mappings) {
        sourceMap.setSourceContent(filename, sourceContent);
        for (const mapping of mappings) {
          sourceMap.addMapping(Object.assign({}, mapping, {
            generatedLine: lineOffset + mapping.generatedLine}));
        }
      }

      if (order.firstTopAwaitLocations.length > 0) {
        if (mode === 'wrapper') {
          for (const loc of order.firstTopAwaitLocations) {
            this.diagnosticsProcessor.addDiagnostic({
              category: 'bundler/topLevelAwait',
              filename: loc.filename,
              start: loc.start,
              end: loc.end,
              message: 'This module contains a top level await which isn\'t supported in wrapper mode'});
          }
        }

        push(`(async function() {`);
      } else {
        push(`(function() {`);
      }

      if (mode === 'flat') {
        push(`  'use strict';`);
      }

      push(___$romejs$core$src$master$bundler$prelude_ts$default);

      const declaredCJS = new Set();
      const declareCJS = module => {
        if (mode !== 'flat' ||
        module.type !== 'cjs' ||
        module.all === false ||
        declaredCJS.has(module)) {
          return undefined;
        }

        declaredCJS.add(module);

        push(`  var ${___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(module.id)} = {};`);
      };

      for (const source of files) {
        const module = graph.getNode(source);

        for (const filename of module.getAbsoluteDependencies()) {
          declareCJS(graph.getNode(filename));
        }

        const compileResult = this.compiles.get(source);
        if (compileResult === undefined) {
          throw new Error('Expected compile result');
        }

        if (mode === 'flat') {
          push(`  // ${module.id}`);
        }

        declareCJS(module);

        addMappings(module.id, compileResult.src, compileResult.mappings);
        push(compileResult.code);

        if (module.usedAsync) {
          push(
          `  Rome.declareModule(${String(
          module.id)}, ${___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(module.id)});`);
        }

        push('');
      }

      const entryModule = graph.getNode(resolvedEntry);
      if (mode === 'flat') {
        push(`  return ${___$romejs$js_compiler$src$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(entryModule.id)};`);
      } else {
        push(`  return Rome.require("${entryModule.id}");`);
      }

      push('})();');

      if (inlineSourceMap === true) {
        const sourceMapComment = sourceMap.toComment();
        content += sourceMapComment;
      }

      return {
        diagnostics: this.diagnosticsProcessor.getPartialDiagnostics(),
        content: content,
        map: sourceMap.toJSON()};
    }

    shouldAbort() {
      return this.diagnosticsProcessor.hasDiagnostics();
    }

    abort() {
      return {
        map: this.sourceMap.toJSON(),
        content: '',
        diagnostics: this.diagnosticsProcessor.getPartialDiagnostics()};
    }

    async bundle() {
      const node = await this.stepAnalyze();

      const order = node.getDependencyOrder();
      this.diagnosticsProcessor.addDiagnostics(
      order.diagnostics,
      'bundler: Dependency order from entry file requested');
      if (this.shouldAbort()) {
        return this.abort();
      }

      await this.stepCompile(order.files);
      if (this.shouldAbort()) {
        return this.abort();
      }

      return await this.stepCombine(order);
    }
  }

  // romejs/core/src/master/bundler/Bundler.ts

  class ___$romejs$core$src$master$bundler$Bundler_ts$default {
    constructor(req, reporter, config, resolverOpts) {
      this.config = config;
      this.master = req.master;
      this.reporter = reporter;
      this.request = req;

      this.entries = [];

      this.graph = new ___$romejs$core$src$master$dependencies$DependencyGraph_ts$default(req.master, resolverOpts);

      this.diagnosticsProcessor = new ___$romejs$diagnostics$src$DiagnosticsProcessor_ts$default({
        origins: []});

      this.resolverOpts = resolverOpts;
    }

    static createFromMasterRequest(req) {
      return new ___$romejs$core$src$master$bundler$Bundler_ts$default(req, req.reporter, req.getBundlerConfigFromFlags(), req.getResolverOptionsFromFlags());
    }

    async getResolvedEntry(unresolvedEntry) {
      const {cwd: cwd} = this.config;

      const resolvedEntry = await this.master.resolver.resolveEntryAssert(Object.assign({}, this.resolverOpts, {
        origin: cwd,
        source: unresolvedEntry}));

      if (resolvedEntry === undefined) {
        ___$romejs$invariant$src$index_ts$default(
        false,
        'Could not find entry file %s relative to %s',
        unresolvedEntry,
        cwd);
      }

      return resolvedEntry;
    }

    createBundleRequest(resolvedEntry, mode) {
      this.entries.push(resolvedEntry);
      return new ___$romejs$core$src$master$bundler$BundleRequest_ts$default(this, mode, resolvedEntry);
    }

    async bundle(unresolvedEntry) {
      const {reporter: reporter, master: master} = this;
      const {cwd: cwd} = this.config;
      const resolvedEntry = await this.getResolvedEntry(unresolvedEntry);

      let mode = this.config.mode;
      if (mode === undefined) {
        const project = master.projectManager.assertProjectExisting(
        resolvedEntry);
        mode = project.config.bundler.mode;
      }

      const manifestRoot = master.resolver.resolve(Object.assign({}, this.resolverOpts, {
        origin: cwd,
        type: 'package',
        source: unresolvedEntry}));
      let manifestRaw;
      let manifest;
      if (manifestRoot !== undefined) {
        const def = master.memoryFs.getManifestDefinition(manifestRoot);
        if (def !== undefined) {
          manifest = def.manifest;
          manifestRaw = def.raw;
        }
      }

      const createBundle = async resolvedSegment => {
        reporter.info(
        `Bundling <emphasis><filelink filename="${resolvedSegment}" /></emphasis>`);

        if (mode === undefined) {
          throw new Error('This shouldnt be undefined after our refinement above...');
        }

        const req = this.createBundleRequest(resolvedSegment, mode);
        const res = await req.bundle();
        this.diagnosticsProcessor.addDiagnostics(res.diagnostics);
        return res;
      };

      const res = await createBundle(resolvedEntry);
      this.diagnosticsProcessor.maybeThrowDiagnosticsError();

      const files = new Map();
      files.set('index.js', res.content);
      files.set('index.js.map', JSON.stringify(res.map));

      const bundleBuddyStats = this.graph.getBundleBuddyStats(this.entries);
      files.set('bundlebuddy.json', JSON.stringify(bundleBuddyStats, null, '  '));

      if (manifestRaw !== undefined &&
      manifest !== undefined &&
      manifestRoot !== undefined) {
        const newManifest = Object.assign({}, manifestRaw, {
          main: 'index.js',
          browser: 'index.min.js'});

        if (Array.isArray(manifest.files)) {
          for (const pattern of manifest.files) {
            if (typeof pattern !== 'string') {
              continue;
            }
          }
        }

        const bin = manifest.bin;
        if (bin !== undefined) {
          const newBin = {};
          newManifest.bin = newBin;

          for (const [binName, relative] of manifest.bin) {
            const absolute = await master.resolver.resolvePath(Object.assign({
              origin: manifestRoot,
              source: relative}, this.resolverOpts));

            if (absolute === undefined) {
              continue;
            }

            const binOut = `bin/${binName}`;
            const binIndex = `${binOut}/index.js`;
            newBin[binName] = binIndex;

            const res = await createBundle(absolute);

            files.set(binIndex, res.content);
            files.set(`${binOut}/index.map`, JSON.stringify(res.map));
          }
        }

        files.set('package.json', JSON.stringify(newManifest, undefined, '  '));
      }

      this.diagnosticsProcessor.maybeThrowDiagnosticsError();

      return {
        manifest: manifest,
        files: files,
        map: res.map,
        content: res.content};
    }
  }

  // romejs/core/src/master/commands/run.ts

  const ___$romejs$core$src$master$commands$run_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.PROJECT_MANAGEMENT,
    description: 'TODO',

    parseCLIFlags(p) {
      p.allowUnknownArguments();
      return undefined;
    },

    async default(req) {
      const {master: master, args: args, flags: flags} = req;

      if (args.length !== 1) {
        throw new Error('Expected one argument');
      }

      async function executeCode(loc) {
        const bundler = ___$romejs$core$src$master$bundler$Bundler_ts$default.createFromMasterRequest(req);
        const {content: content, map: map} = await bundler.bundle(loc);
        return {
          type: 'executeCode',
          filename: loc,
          code: content,
          map: map};
      }

      const project = await master.projectManager.findProject(flags.cwd);

      const target = args[0];
      const resolved = await master.resolver.resolveEntry(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: flags.cwd,
        source: target}));
      if (resolved !== undefined) {
        return executeCode(resolved);
      }

      if (project !== undefined) {
        for (const {manifest: manifest, folder: folder} of project.packages.values()) {
          const relative = manifest.bin.get(target);
          if (relative === undefined) {
            continue;
          }

          const resolved = await master.resolver.resolveEntry(Object.assign({}, req.getResolverOptionsFromFlags(), {
            origin: folder,
            platform: 'node',
            source: relative}));
          if (resolved === undefined) {
            throw new Error(`Failed to resolve relative path in found bin from '${folder} to ${relative}`);
          }

          return executeCode(resolved);
        }
      }

      throw new Error(`Failed to find "${target}"`);
    }});

  // romejs/core/src/master/commands/publish.ts

  const ___$romejs$core$src$master$commands$publish_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.PROJECT_MANAGEMENT,
    description: 'TODO',

    async default(req) {
      const {args: args} = req;
      if (args.length !== 1) {
        throw new Error('Expected exactly one argument');
      }
    }});

  // romejs/core/src/master/commands/status.ts

  const ___$romejs$core$src$master$commands$status_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'dump memory and process info of master and workers',

    async default({master: master}) {
      const workers = await Promise.all(
      master.workerManager.getWorkers().map(
      async worker => {
        const workerStatus = await worker.bridge.status.call();

        return {
          astCacheSize: workerStatus.astCacheSize,
          heapTotal: workerStatus.memoryUsage.heapTotal,
          pid: workerStatus.pid,
          uptime: workerStatus.uptime,
          ownedBytes: worker.byteCount,
          ownedFileCount: worker.fileCount};
      }));

      const {heapTotal: heapTotal} = process.memoryUsage();
      return {
        master: {
          heapTotal: heapTotal,
          pid: process.pid,
          uptime: process.uptime()},
        workers: workers,
        projects: master.projectManager.getProjects()};
    }});

  // romejs/core/src/master/commands/stop.ts

  const ___$romejs$core$src$master$commands$stop_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'stop daemon',

    async default({master: master}) {
      master.end();
    }});

  // romejs/codec-websocket/src/types.ts

  const ___$romejs$codec_websocket$src$types_ts$OPCODES = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    TERMINATE: 8,
    PING: 9,
    PONG: 10};

  const ___$romejs$codec_websocket$src$types_ts$GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';

  // romejs/codec-websocket/src/frame.ts

  const ___$$priv$romejs$codec_websocket$src$frame_ts$crypto = require('crypto');
  function ___$romejs$codec_websocket$src$frame_ts$isCompleteFrame(frame) {
    return Buffer.byteLength(frame.payload) >= frame.payloadLength;
  }

  function ___$romejs$codec_websocket$src$frame_ts$unmaskPayload(payload, mask, offset) {
    if (mask === undefined) {
      return payload;
    }

    for (let i = 0; i < payload.length; i++) {
      payload[i] ^= mask[offset + i & 3];
    }

    return payload;
  }

  function ___$romejs$codec_websocket$src$frame_ts$buildFrame(opts, shouldMask) {
    const {opcode: opcode, fin: fin, data: data} = opts;

    let offset = shouldMask ? 6 : 2;
    let dataLength = data.length;

    if (dataLength >= 65536) {
      offset += 8;
      dataLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      dataLength = 126;
    }

    const head = Buffer.allocUnsafe(offset);

    head[0] = fin ? opcode | 128 : opcode;
    head[1] = dataLength;

    if (dataLength === 126) {
      head.writeUInt16BE(data.length, 2);
    } else if (dataLength === 127) {
      head.writeUInt32BE(0, 2);
      head.writeUInt32BE(data.length, 6);
    }

    if (shouldMask) {
      const mask = ___$$priv$romejs$codec_websocket$src$frame_ts$crypto.randomBytes(4);
      head[1] |= 128;
      head[offset - 4] = mask[0];
      head[offset - 3] = mask[1];
      head[offset - 2] = mask[2];
      head[offset - 1] = mask[3];

      const masked = Buffer.alloc(dataLength);
      for (let i = 0; i < dataLength; ++i) {
        masked[i] = data[i] ^ mask[i & 3];
      }

      return Buffer.concat([head, masked]);
    } else {
      return Buffer.concat([head, data]);
    }
  }

  function ___$romejs$codec_websocket$src$frame_ts$parseFrame(buffer) {
    const firstByte = buffer.readUInt8(0);
    const isFinalFrame = Boolean(firstByte >>> 7 & 1);
    const opcode = firstByte & 15;

    const [reserved1, reserved2, reserved3] = [(firstByte >>> 6 & 1) === 1, (firstByte >>> 5 & 1) === 1, (firstByte >>> 4 & 1) === 1];
    reserved1;
    reserved2;
    reserved3;

    const secondByte = buffer.readUInt8(1);
    const isMasked = Boolean(secondByte >>> 7 & 1);

    let currentOffset = 2;
    let payloadLength = secondByte & 127;
    if (payloadLength > 125) {
      if (payloadLength === 126) {
        payloadLength = buffer.readUInt16BE(currentOffset);
        currentOffset += 2;
      } else if (payloadLength === 127) {
        const leftPart = buffer.readUInt32BE(currentOffset);
        currentOffset += 4;

        if (leftPart > Math.pow(2, 53 - 32) - 1) {
          throw new Error('Unsupported WebSocket frame: payload length > 2^53 - 1');
        }

        const rightPart = buffer.readUInt32BE(currentOffset);
        currentOffset += 4;

        payloadLength = leftPart * Math.pow(2, 32) + rightPart;
      } else {
        throw new Error('Unknown payload length');
      }
    }

    let mask;
    if (isMasked) {
      mask = buffer.slice(currentOffset, currentOffset + 4);
      currentOffset += 4;
    }

    let payload = ___$romejs$codec_websocket$src$frame_ts$unmaskPayload(buffer.slice(currentOffset), mask, 0);

    return {
      fin: isFinalFrame,
      opcode: opcode,
      mask: mask,
      payload: payload,
      payloadLength: payloadLength};
  }

  // romejs/codec-websocket/src/index.ts

  const ___$$priv$romejs$codec_websocket$src$index_ts$crypto = require('crypto');
  const ___$$priv$romejs$codec_websocket$src$index_ts$url = require('url');
  const ___$$priv$romejs$codec_websocket$src$index_ts$http = require('http');
  const ___$$priv$romejs$codec_websocket$src$index_ts$net = require('net');
  function ___$romejs$codec_websocket$src$index_ts$createKey(key) {
    return ___$$priv$romejs$codec_websocket$src$index_ts$crypto.createHash('sha1').update(`${key}${___$romejs$codec_websocket$src$types_ts$GUID}`).digest('base64');
  }

  class ___$romejs$codec_websocket$src$index_ts$WebSocketInterface {
    constructor(type, socket) {
      this.unfinishedFrame = undefined;

      this.incompleteFrame = undefined;

      this.socket = socket;
      this.type = type;

      this.messageEvent = new ___$romejs$events$src$Event_ts$default({name: 'WebSocketInterface.message'});
      this.errorEvent = new ___$romejs$events$src$Event_ts$default({name: 'WebSocketInterface.error'});
      this.endEvent = new ___$romejs$events$src$Event_ts$default({name: 'WebSocketInterface.end'});

      socket.on('data', buff => {
        this.addBuffer(buff);
      });

      socket.on('error', err => {
        if (err.code === 'ECONNRESET') {
          this.endEvent.send();
        } else {
          this.errorEvent.send(err);
        }
      });

      socket.on('close', () => {
        this.endEvent.send();
      });
    }

    end() {
      this.socket.end();
    }

    send(buff) {
      if (typeof buff === 'string') {
        this.sendFrame({
          opcode: ___$romejs$codec_websocket$src$types_ts$OPCODES.TEXT,
          fin: true,
          data: new Buffer(buff)});
      } else if (buff instanceof Buffer) {
        this.sendFrame({
          opcode: ___$romejs$codec_websocket$src$types_ts$OPCODES.BINARY,
          fin: true,
          data: buff});
      } else {
        throw new Error('Don\'t know how to send this');
      }
    }

    sendJSON(val) {
      this.send(String(JSON.stringify(val)));
    }

    sendFrame(frameOpts) {
      this.socket.write(___$romejs$codec_websocket$src$frame_ts$buildFrame(frameOpts, this.type === 'client'));
    }

    completeFrame(frame) {
      const {unfinishedFrame: unfinishedFrame} = this;
      if (unfinishedFrame !== undefined) {
        if (frame.opcode === ___$romejs$codec_websocket$src$types_ts$OPCODES.CONTINUATION) {
          unfinishedFrame.payload = Buffer.concat([unfinishedFrame.payload, ___$romejs$codec_websocket$src$frame_ts$unmaskPayload(
          frame.payload,
          unfinishedFrame.mask,
          unfinishedFrame.payload.length)]);

          if (frame.fin) {
            this.unfinishedFrame = undefined;
            this.completeFrame(unfinishedFrame);
          }
        } else {
          throw new Error('We\'re waiting for a frame to finish so only allow continuation frames');
        }
        return undefined;
      }

      if (frame.fin) {
        if (frame.opcode === ___$romejs$codec_websocket$src$types_ts$OPCODES.PING) {
          this.sendFrame({
            opcode: ___$romejs$codec_websocket$src$types_ts$OPCODES.PONG,
            fin: true,
            data: frame.payload});
        } else {
          let excess;
          if (frame.payload.length > frame.payloadLength) {
            excess = frame.payload.slice(frame.payloadLength);
            frame.payload = frame.payload.slice(0, frame.payloadLength);
          }

          this.messageEvent.send(frame);

          if (excess !== undefined) {
            this.addBuffer(excess);
          }
        }
      } else {
        this.unfinishedFrame = frame;
      }
    }

    addBufferToIncompleteFrame(incompleteFrame, buff) {
      incompleteFrame.payload = Buffer.concat([incompleteFrame.payload, ___$romejs$codec_websocket$src$frame_ts$unmaskPayload(buff, incompleteFrame.mask, incompleteFrame.payload.length)]);

      if (___$romejs$codec_websocket$src$frame_ts$isCompleteFrame(incompleteFrame)) {
        this.incompleteFrame = undefined;
        this.completeFrame(incompleteFrame);
      }
    }

    addBuffer(buff) {
      const {incompleteFrame: incompleteFrame} = this;
      if (incompleteFrame !== undefined) {
        this.addBufferToIncompleteFrame(incompleteFrame, buff);
        return undefined;
      }

      const frame = ___$romejs$codec_websocket$src$frame_ts$parseFrame(buff);

      if (___$romejs$codec_websocket$src$frame_ts$isCompleteFrame(frame)) {
        this.completeFrame(frame);
      } else {
        this.incompleteFrame = frame;
      }
    }
  }

  async function ___$romejs$codec_websocket$src$index_ts$createClient(rawUrl) {
    const parts = ___$$priv$romejs$codec_websocket$src$index_ts$url.parse(rawUrl);

    return new Promise((resolve, reject) => {
      const key = ___$$priv$romejs$codec_websocket$src$index_ts$crypto.randomBytes(16).toString('base64');
      const digest = ___$romejs$codec_websocket$src$index_ts$createKey(key);

      const req = ___$$priv$romejs$codec_websocket$src$index_ts$http.request({
        hostname: parts.hostname,
        port: parts.port,
        path: parts.path,
        method: 'GET',
        headers: {
          Connection: 'Upgrade',
          Upgrade: 'websocket',
          'Sec-WebSocket-Key': key,
          'Sec-WebSocket-Version': '13'}});

      req.on('response', res => {
        if (res.statusCode >= 400) {
          process.stderr.write(`Unexpected HTTP code: ${res.statusCode}\n`);
          res.pipe(process.stderr);
        } else {
          res.pipe(process.stderr);
        }
      });

      req.on('upgrade', (res, socket, head) => {
        if (res.headers['sec-websocket-accept'] !== digest) {
          res.end();
          socket.end();
          reject(
          new Error(`Digest mismatch ${digest} !== ${res.headers['sec-websocket-accept']}`));
          return undefined;
        }

        const client = new ___$romejs$codec_websocket$src$index_ts$WebSocketInterface('client', socket);

        head;
        resolve(client);
      });

      req.on('error', err => {
        reject(err);
      });

      req.end();
    });
  }

  // romejs/core/src/master/web/index.ts

  const ___$$priv$romejs$core$src$master$web$index_ts$http = require('http');
  const ___$$priv$romejs$core$src$master$web$index_ts$url = require('url');
  class ___$romejs$core$src$master$web$index_ts$WebServer {
    constructor(req) {
      this.req = req;
      this.master = req.master;

      this.consoleLogBuffer = new Set();
      this.lastPrintedLogId = undefined;

      this.server = ___$$priv$romejs$core$src$master$web$index_ts$http.createServer((req, res) => {
        this.handleRequest(req, res);
      });
    }

    close() {
      this.server.close();
    }

    listen(port) {
      this.server.listen(port);
    }

    loadRawBody(req) {
      req.setEncoding('utf8');
      let rawBody = '';

      return new Promise(resolve => {
        req.on('data', chunk => {
          rawBody += chunk;
        });

        req.on('end', () => {
          resolve(rawBody);
        });
      });
    }

    async handleRequest(req, res) {
      try {
        const rawBody = await this.loadRawBody(req);
        await this.handleRequestWithBody(req, rawBody, res);
        res.end();
      } catch (err) {
        res.writeHead(500, {'Content-Type': 'text/plain'});
        console.error(err.stack);

        let diagnostics = ___$romejs$diagnostics$src$errors_ts$getDiagnosticsFromError(err);
        if (diagnostics === undefined) {
          diagnostics = [___$romejs$diagnostics$src$derive_ts$deriveDiagnosticFromError({error: err})];
        }

        res.end('Diagnostics available, see console');
      }
    }

    async handleRequestWithBody(req, body, res) {
      const reqUrl = req.url;
      if (reqUrl === undefined) {
        throw new Error('req.url should not be undefined');
      }
      const parts = ___$$priv$romejs$core$src$master$web$index_ts$url.parse(reqUrl, true);
      console.log('Request for', req.url);

      switch (parts.pathname) {
        case '/log-to-console':
          return this.handleConsoleLog(req, body, res);

        case '/websocket':
          return this.handleWebsocket(req, res);

        case '/script.js':
          return this.handleFrontendScript(req, res);

        case '/':
          res.writeHead(200, {'Content-Type': 'text/html'});
          res.end(`
          <!doctype html>
          <html>
            <head>
              <meta charset="utf-8"/>
              <title>Rome</title>
            </head>
            <body>
              <div id="app"></div>
              <script src="/script.js"></script>
            </body>
          </html>
        `);
          break;

        default:
          if (parts.pathname !== undefined &&
          parts.pathname.endsWith('.bundle')) {
            return this.handleBundleRequest(req, parts, res);
          }

          res.writeHead(404);
          res.end('Not found');}
    }

    printConsoleLog(msg) {
      this.lastPrintedLogId = msg.id;

      const {reporter: reporter} = this.req;
      switch (msg.level) {
        case 'info':
          reporter.info('');
          break;

        case 'warn':
          reporter.warn('');
          break;

        case 'error':
          reporter.error('');
          break;

        default:
          reporter.log('');
          break;}

      for (let bufMsg of this.consoleLogBuffer) {
        if (bufMsg.id === msg.id + 1) {
          this.consoleLogBuffer.delete(bufMsg);
          this.printConsoleLog(bufMsg);
          break;
        }
      }
    }

    async handleBundleRequest(req, parts, res) {
      const pathname = ___$romejs$string_utils$src$removePrefix_ts$removePrefix(
      ___$romejs$string_utils$src$removeSuffix_ts$removeSuffix(String(parts.pathname), '.bundle'),
      '/');

      const bundler = ___$romejs$core$src$master$bundler$Bundler_ts$default.createFromMasterRequest(this.req);
      const bundle = await bundler.bundle(pathname);

      res.writeHead(200, {'Content-Type': 'application/javascript'});
      res.end(bundle.content);
    }

    async handleFrontendScript(req, res) {
      res.writeHead(200, {'Content-Type': 'application/javascript'});
      res.end('');
    }

    handleConsoleLog(req, body, res) {
      const msg = JSON.parse(body);

      if (this.lastPrintedLogId === undefined ||
      this.lastPrintedLogId >= msg.id ||
      this.lastPrintedLogId === msg.id - 1) {
        this.printConsoleLog(msg);
      } else {
        this.consoleLogBuffer.add(msg);
      }
    }

    handleWebsocket(req, res) {
      const digest = ___$romejs$codec_websocket$src$index_ts$createKey(String(req.headers['sec-websocket-key']));

      const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', 'Sec-WebSocket-Protocol: rome', `Sec-WebSocket-Accept: ${digest}`, ''];

      req.socket.write(headers.join('\r\n'));

      const socket = new ___$romejs$codec_websocket$src$index_ts$WebSocketInterface('server', req.socket);
      socket;
      res;
    }
  }

  // romejs/core/src/master/commands/web.ts

  const ___$$priv$romejs$core$src$master$commands$web_ts$DEFAULT_PORT = 8081;
  const ___$romejs$core$src$master$commands$web_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.SOURCE_CODE,
    description: 'start a web server',

    parseCLIFlags(p) {
      return {
        port: p.number('port', {
          description: '',
          default: ___$$priv$romejs$core$src$master$commands$web_ts$DEFAULT_PORT})};
    },

    async default(req, flags) {
      const {reporter: reporter} = req;
      const port = flags.getProperty('port').asNumber(___$$priv$romejs$core$src$master$commands$web_ts$DEFAULT_PORT);

      const web = new ___$romejs$core$src$master$web$index_ts$WebServer(req);
      web.listen(port);
      reporter.success(`Listening on http://localhost:${String(port)}`);

      req.teardownEvent.subscribe(() => {
        web.close();
      });

      await new Promise(() => {});
    }});

  // romejs/core/src/master/commands/compile.ts

  const ___$romejs$core$src$master$commands$compile_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.SOURCE_CODE,
    description: 'compile a single file',

    async default(req) {
      const {master: master, args: args, flags: flags, reporter: reporter} = req;
      const {stdout: stdout} = reporter;
      if (args.length !== 1) {
        throw new Error('Expected exactly one rgument.');
      }

      const filename = await master.resolver.resolveEntryAssert(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: flags.cwd,
        source: args[0]}));
      const {code: code, diagnostics: diagnostics} = await master.api.compile(
      filename,
      'compile');

      if (diagnostics.length > 0) {
        throw new ___$romejs$diagnostics$src$errors_ts$DiagnosticsError('Compile diagnostics', diagnostics);
      }

      stdout.write(code);
    }});

  // romejs/core/src/master/commands/resolve.ts

  const ___$$priv$romejs$core$src$master$commands$resolve_ts$path = require('path');
  const ___$romejs$core$src$master$commands$resolve_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.SOURCE_CODE,
    description: 'resolve a file',

    async default(req) {
      const {master: master, args: args, reporter: reporter, flags: flags} = req;
      if (args.length !== 2 && args.length !== 1) {
        throw new Error('Expected one or two file arguments');
      }

      let origin = '';
      let relative = '';

      if (args.length === 2) {
        origin = ___$$priv$romejs$core$src$master$commands$resolve_ts$path.resolve(flags.cwd, args[0]);
        relative = args[1];
      } else {
        origin = flags.cwd;
        relative = args[0];
      }

      const loc = await master.resolver.resolveEntryAssert(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: origin,
        source: relative}));
      if (loc === undefined) {
        throw new Error(`Could not resolve ${relative} from '${origin}`);
      } else {
        reporter.log(loc);
      }
    }});

  // romejs/core/src/master/commands/analyzeDependencies.ts

  const ___$romejs$core$src$master$commands$analyzeDependencies_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.SOURCE_CODE,
    description: 'analyze and dump the dependencies of a file',

    async default(req) {
      const {master: master, args: args, reporter: reporter, flags: flags} = req;
      if (args.length !== 1) {
        throw new Error('Expected one argument');
      }

      const filename = await master.resolver.resolveEntryAssert(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: flags.cwd,
        source: args[0]}));
      reporter.inspect((await master.api.analyzeDependencies(filename)));
    }});

  // romejs/core/src/master/commands/parse.ts

  const ___$romejs$core$src$master$commands$parse_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.SOURCE_CODE,
    description: 'parse a single file and dump its ast',

    parseCLIFlags(p) {
      return {
        compact: p.boolean('compact', {
          description: 'remove locations and other noise from the output',
          default: true}),
        sourceType: p.string('source-type', {
          description: '',
          default: 'module'}),
        showDespiteDiagnostics: p.boolean('show-despite-diagnostics', {
          description: '',
          default: false})};
    },

    async default(req, commandFlags) {
      const {args: args, master: master, reporter: reporter, flags: flags} = req;
      if (args.length !== 1) {
        throw new Error('Expected exactly 1 argument.');
      }

      const filename = await master.resolver.resolveEntryAssert(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: flags.cwd,
        source: args[0]}));

      const ast = await master.api.parse(filename, {
        compact: commandFlags.getProperty('compact').asBoolean(false),

        sourceType: commandFlags.getProperty('sourceType').asString('module')});

      const showDespiteDiagnostics = commandFlags.getProperty('showDespiteDiagnostics').asBoolean(false);
      const hasErrors = ast.diagnostics.length > 0;

      if (!hasErrors || showDespiteDiagnostics) {
        reporter.inspect(ast);
      }

      if (hasErrors) {
        throw new ___$romejs$diagnostics$src$errors_ts$DiagnosticsError('Parsing failed', ast.diagnostics);
      }
    }});

  // romejs/core/src/master/commands/bundle.ts

  const ___$$priv$romejs$core$src$master$commands$bundle_ts$path = require('path');
  const ___$$priv$romejs$core$src$master$commands$bundle_ts$fs = require('fs');
  const ___$romejs$core$src$master$commands$bundle_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.SOURCE_CODE,
    description: 'build a standalone js bundle for a package',

    parseCLIFlags(p) {
      return {
        dumpModuleOrder: p.boolean('dump-module-order', {
          description: '',
          default: false})};
    },

    async default(req, flagConsumer) {
      const {args: args, flags: flags, reporter: reporter} = req;

      if (args.length !== 2) {
        throw new Error('Expected two arguments');
      }

      const [entryFilename, outputFolder] = args;
      const bundler = ___$romejs$core$src$master$bundler$Bundler_ts$default.createFromMasterRequest(req);

      const {files: outFiles, content: content, map: map} = await bundler.bundle(entryFilename);

      const savedList = [];
      const dir = ___$$priv$romejs$core$src$master$commands$bundle_ts$path.resolve(flags.cwd, outputFolder);
      for (const [filename, content] of outFiles) {
        const loc = ___$$priv$romejs$core$src$master$commands$bundle_ts$path.join(dir, filename);
        savedList.push(`<filelink filename="${loc}">${filename}</filelink>`);
        await ___$$priv$romejs$core$src$master$commands$bundle_ts$fs.promises.mkdir(___$$priv$romejs$core$src$master$commands$bundle_ts$path.dirname(loc), {recursive: true});
        await ___$$priv$romejs$core$src$master$commands$bundle_ts$fs.promises.writeFile(loc, content);
      }

      reporter.success(`Saved bundle to folder <filelink filename="${dir}" />`);
      reporter.list(savedList);

      if (flagConsumer.getProperty('dumpModuleOrder').asBoolean(false)) {
        reporter.info(`Module order from root entry`);

        reporter.list(
        bundler.graph.getNode(bundler.entries[0]).getDependencyOrder().files);
      }

      return {
        content: content,
        map: JSON.stringify(map)};
    }});

  // romejs/core/src/master/linter/CompilerLinter.ts

  class ___$romejs$core$src$master$linter$CompilerLinter_ts$default {
    constructor(req, printer) {
      this.request = req;
      this.printer = printer;
    }

    async lint() {
      const {request: request, printer: printer} = this;
      const {master: master, reporter: reporter} = request;
      const globalIgnore = [___$romejs$match_path$src$parse_ts$parsePattern({input: 'node_modules'}), ___$romejs$match_path$src$parse_ts$parsePattern({input: '__generated__'})];

      const files = await request.getFilesFromArgs(project => project.config.lint.ignore.concat(globalIgnore));

      const filesByWorker = await master.fileManager.groupFilesByWorker(files);
      const activity = reporter.spinnerGroup(files.length, filesByWorker.length);
      const startTime = Date.now();
      let totalProcessedBytes = 0;

      for (let i = 0; i < activity.spinners.length; i++) {
        const files = filesByWorker[i];
        const spinner = activity.spinners[i];
        spinner.setTotal(files.length);
      }

      await Promise.all(
      filesByWorker.map(async (files, workerNum) => {
        const spinner = activity.spinners[workerNum];

        let i = 0;
        for (const filename of files) {
          i++;
          spinner.setCurrent(i);
          spinner.setText(filename);
          totalProcessedBytes += master.memoryFs.getFileStatsAssert(filename).size;

          const fileDiagnostics = await master.api.lint(
          filename,
          false);
          printer.addDiagnostics(fileDiagnostics);

          activity.tick();
        }

        spinner.setText('Done');
        spinner.pause();
      }));

      activity.end();

      const elapsed = Date.now() - startTime;

      printer.onBeforeFooterPrint(reporter => {
        const kbps = Math.round(totalProcessedBytes / elapsed);
        reporter.verbose(`Processing speed ${___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(kbps)}kbps`);

        const fileCount = files.length;
        if (fileCount === 0) {
          reporter.warn('No files linted');
        } else if (fileCount === 1) {
          reporter.info(`<emphasis>1</emphasis> file linted`);
        } else {
          reporter.info(
          `<emphasis>${___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(fileCount)}</emphasis> files linted`);
        }
      });
    }
  }

  // romejs/core/src/master/linter/Linter.ts

  class ___$romejs$core$src$master$linter$Linter_ts$default {
    constructor(req) {
      this.request = req;
    }

    async lint() {
      const {request: request} = this;
      const printer = request.createDiagnosticsPrinter('Linting');

      const compilerLinter = new ___$romejs$core$src$master$linter$CompilerLinter_ts$default(request, printer);

      await compilerLinter.lint();

      throw printer;
    }
  }

  // romejs/core/src/master/commands/lint.ts

  const ___$romejs$core$src$master$commands$lint_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.CODE_QUALITY,
    description: 'run lint against a set of files',

    async default(req) {
      return new Promise((resolve, reject) => {
        if (req.flags.watch) {
          ___$$priv$romejs$core$src$master$commands$lint_ts$initWatchLint(req, reject);
        } else {
          resolve(___$$priv$romejs$core$src$master$commands$lint_ts$runLint(req));
        }
      });
    }});
  function ___$$priv$romejs$core$src$master$commands$lint_ts$initWatchLint(req, reject) {
    const {master: master, reporter: reporter} = req;

    let queued = false;

    let running = false;

    let runAgainAfterComplete = false;

    function runWatchLint() {
      if (running) {
        runAgainAfterComplete = true;
        return undefined;
      }

      queued = false;
      running = true;
      reporter.clear();

      ___$$priv$romejs$core$src$master$commands$lint_ts$runLint(req).then(() => {
        running = false;

        if (runAgainAfterComplete) {
          runAgainAfterComplete = false;
          runWatchLint();
        }
      }, reject);
    }

    const listener = master.fileChangeEvent.subscribe(() => {
      if (running) {
        runWatchLint();
        return undefined;
      }

      if (queued) {
        return undefined;
      }

      queued = true;
      setTimeout(runWatchLint, 250);
    });

    req.teardownEvent.subscribe(() => {
      listener.unsubscribe();
    });

    runWatchLint();
  }

  async function ___$$priv$romejs$core$src$master$commands$lint_ts$runLint(req) {
    const linter = new ___$romejs$core$src$master$linter$Linter_ts$default(req);
    await linter.lint();
  }

  // romejs/core/src/master/testing/TestRunner.ts

  const ___$$priv$romejs$core$src$master$testing$TestRunner_ts$child = require('child_process');
  function ___$$priv$romejs$core$src$master$testing$TestRunner_ts$sortMapKeys(map) {
    const sortedKeys = Array.from(map.keys()).sort(___$romejs$string_utils$src$naturalCompare_ts$naturalCompare);
    const newMap = new Map();
    for (const key of sortedKeys) {
      const val = map.get(key);
      if (val === undefined) {
        throw new Error('Expected value');
      }
      newMap.set(key, val);
    }
    return newMap;
  }

  function ___$$priv$romejs$core$src$master$testing$TestRunner_ts$formatPercent(num) {
    const str = String(Math.floor(num));
    if (num > 80) {
      return ___$romejs$string_ansi$src$format_ts$formatAnsi.green(str);
    } else if (num > 40) {
      return ___$romejs$string_ansi$src$format_ts$formatAnsi.yellow(str);
    } else {
      return ___$romejs$string_ansi$src$format_ts$formatAnsi.red(str);
    }
  }

  function ___$$priv$romejs$core$src$master$testing$TestRunner_ts$percentInsideCoverageFolder(folder) {
    let totalFiles = 0;
    let functions = 0;
    let branches = 0;
    let lines = 0;

    const folders = [folder];
    while (folders.length > 0) {
      const folder = folders.shift();
      if (folder === undefined) {
        throw new Error('folders.length has already been validated');
      }

      for (const file of folder.files.values()) {
        totalFiles++;
        functions += file.functions.percent;
        branches += file.branches.percent;
        lines += file.lines.percent;
      }

      for (const subFolder of folder.folders.values()) {
        folders.push(subFolder);
      }
    }

    return {
      functions: totalFiles === 0 ? 100 : functions / totalFiles,
      branches: totalFiles === 0 ? 100 : branches / totalFiles,
      lines: totalFiles === 0 ? 100 : lines / totalFiles};
  }

  class ___$romejs$core$src$master$testing$TestRunner_ts$default {
    constructor(opts) {
      this.sources = opts.sources;
      this.reporter = opts.request.reporter;
      this.master = opts.request.master;
      this.cwd = opts.request.flags.cwd;
      this.request = opts.request;
      this.coverageCollector = opts.coverageCollector;
      this.showAllCoverage = opts.showAllCoverage;

      this.progress = {
        total: 0,
        started: 0,
        finished: 0};

      this.runningTests = new Map();

      this.printer = opts.request.createDiagnosticsPrinter('test: Run initiated');
      this.printer.addDiagnostics(opts.addDiagnostics);
    }

    async spawnWorker() {
      const proc = ___$romejs$core$src$common$utils$fork_ts$default('test-worker', {
        stdio: 'pipe'});

      const {stdout: stdout, stderr: stderr} = proc;
      if (stdout == null || stderr == null) {
        throw new Error('stdout or stderr was undefined for a spawned Worker');
      }

      stdout.on('data', chunk => {
        process.stdout.write(chunk);
      });

      stderr.on('data', chunk => {
        const str = chunk.toString();

        if (str.startsWith('Debugger listening on ws://')) {
          return undefined;
        }

        if (str.startsWith('Debugger attached')) {
          return undefined;
        }

        process.stderr.write(chunk);
      });

      const bridge = ___$romejs$events$src$bridgeCreators_ts$createBridgeFromChildProcess(___$romejs$core$src$common$bridges$TestWorkerBridge_ts$default, proc);
      await bridge.handshake();

      const {inspectorUrl: inspectorUrl} = await bridge.inspectorDetails.call();

      let inspector;
      if (inspectorUrl !== undefined) {
        inspector = new ___$romejs$v8$src$InspectorClient_ts$default((await ___$romejs$codec_websocket$src$index_ts$createClient(inspectorUrl)));
        await inspector.call('Debugger.enable');
      }

      return {
        bridge: bridge,
        process: proc,
        inspector: inspector};
    }

    async setupWorkers() {
      const containers = [await this.spawnWorker()];

      for (const container of containers) {
        container.bridge.monitorHeartbeat(5000, async () => {
          this.handleWorkerTimeout('10 seconds', container);
        });
      }

      return containers;
    }

    async init() {
      this.workers = await this.setupWorkers();
      this.setupProgress();
    }

    async handleWorkerTimeout(duration, container) {
      console.log('killing after', duration);
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          container.bridge.end(
          `Test worker was unresponsive for ${duration}. We tried to collect some additional metadata but we timed out again trying to fetch it...`);
          resolve();
        }, 3000);

        this._handleWorkerTimeout(duration, container).then(() => {
          clearTimeout(timeout);
          resolve();
        }).catch(err => {
          clearTimeout(timeout);
          if (err instanceof ___$romejs$v8$src$InspectorClient_ts$InspectorClientCloseError) {
            container.bridge.end(
            `Test worker was unresponsive for ${duration}. We tried to collect some additional metadata but the inspector connection closed abruptly`);
            resolve();
          } else {
            reject(err);
          }
        });
      });
    }

    async _handleWorkerTimeout(duration, {bridge: bridge, inspector: inspector}) {
      if (inspector === undefined) {
        bridge.end(
        `Test worker was unresponsive for ${duration}. There was no inspector connected so we were unable to capture stack frames before it was killed.`);
        return undefined;
      }

      inspector.call('Debugger.pause');

      const params = await inspector.wait('Debugger.paused');

      const frames = [];

      for (const callFrame of params.callFrames.slice(0, 10)) {
        const resolved = ___$romejs$v8$src$index_ts$sourceMapManager.resolveLocation(
        callFrame.url.slice('file://'.length),
        callFrame.location.lineNumber + 1,
        callFrame.location.columnNumber);

        const name = callFrame.scopeChain[0].name.split('$').pop();

        frames.push({
          resolvedLocation: resolved.found,
          typeName: undefined,
          functionName: name,
          methodName: undefined,
          filename: resolved.filename,
          lineNumber: resolved.line,
          columnNumber: resolved.column,
          isToplevel: false,
          isEval: false,
          isNative: false,
          isConstructor: false});
      }

      bridge.endWithError(
      new ___$romejs$core$src$master$testing$index_ts$TestWorkerUnresponsiveError(`Test worker was unresponsive for ${duration}. Likely an infinite loop. Below is a stack trace before the test was killed.`, frames));
    }

    getWorkers() {
      if (this.workers === undefined) {
        throw new Error('TestRunner.init has not been called yet');
      } else {
        return this.workers;
      }
    }

    refToKey(ref) {
      return `${ref.filename}: ${ref.testName}`;
    }

    onTestStart(container, ref, timeoutMs) {
      this.progress.started++;

      let timeout = undefined;
      if (timeoutMs !== undefined) {
        timeout = setTimeout(() => {
          this.handleWorkerTimeout(`${String(timeoutMs)}ms`, container);
        }, timeoutMs);
      }

      this.runningTests.set(this.refToKey(ref), {
        ref: ref,
        timeout: timeout});
    }

    onTestFound(data, isSkipped) {
      if (isSkipped) {
        return undefined;
      }

      data;
      this.progress.total++;
    }

    onTestFinished(ref) {
      const key = this.refToKey(ref);
      const running = this.runningTests.get(key);
      if (running === undefined) {
        throw new Error('Expected there to be a running test');
      }

      if (running.timeout !== undefined) {
        clearTimeout(running.timeout);
      }
      this.runningTests.delete(key);

      this.progress.finished++;
    }

    setupProgress() {
      const workers = this.getWorkers();

      for (let i = 0; i < workers.length; i++) {
        const container = workers[i];
        const {bridge: bridge} = container;

        const ourRunningTests = new Set();

        bridge.endEvent.subscribe(error => {
          for (const key of ourRunningTests) {
            const test = this.runningTests.get(key);
            if (test === undefined) {
              continue;
            }

            const {ref: ref} = test;
            this.onTestFinished(ref);
            this.printer.addDiagnostic(
            ___$romejs$diagnostics$src$derive_ts$deriveDiagnosticFromError({
              error: error,
              name: ref.testName,
              filename: ref.filename}),
            'test: Worker died and this diagnostic was automatically generated to fail a test');
          }
        });

        bridge.testFound.subscribe(data => {
          this.onTestFound(data.ref, data.isSkipped);
        });

        bridge.testStart.subscribe(data => {
          ourRunningTests.add(this.refToKey(data.ref));
          this.onTestStart(container, data.ref, data.timeout);
        });

        bridge.testError.subscribe(data => {
          let origin = 'test: Generated from a test worker without being attached to a test';

          const {ref: ref} = data;
          if (ref !== undefined) {
            const uid = this.master.projectManager.getUid(ref.filename);
            origin = `test: Generated from the file <filelink filename="${uid}" /> and test name "${ref.testName}"`;
            this.onTestFinished(ref);
          }

          this.printer.addDiagnostic(data.diagnostic, origin);
        });

        bridge.testSuccess.subscribe(data => {
          this.onTestFinished(data.ref);
        });
      }
    }

    printCoverageReport() {
      const {reporter: reporter, master: master} = this;

      const files = this.coverageCollector.generate();
      if (files.length === 0) {
        return undefined;
      }

      reporter.heading('Code coverage');

      const testedPackages = new Set();
      for (const [testFile] of this.sources) {
        testedPackages.add(master.projectManager.getOwnedPackage(testFile));
      }

      let root = {
        name: undefined,
        folders: new Map(),
        files: new Map()};

      let totalFiles = 0;

      for (const file of files) {
        const {filename: filename} = file;

        const absolute = master.projectManager.getFilenameFromUid(filename);
        if (absolute === undefined) {
          continue;
        }

        const pkg = master.projectManager.getOwnedPackage(absolute);
        if (testedPackages.has(pkg) === false) {
          continue;
        }

        totalFiles++;

        const filenameParts = filename.split('/');
        const basename = filenameParts.pop();
        if (basename === undefined) {
          throw new Error('Should always be at least one element from a split()');
        }

        let target = root;

        for (const part of filenameParts) {
          const existingFolder = target.folders.get(part);
          if (existingFolder === undefined) {
            const newFolder = {
              name: part,
              folders: new Map(),
              files: new Map()};
            target.folders.set(part, newFolder);
            target = newFolder;
          } else {
            target = existingFolder;
          }
        }

        target.files.set(basename, file);
      }

      while (root.folders.size === 1 && root.files.size === 0) {
        const newRoot = root.folders.values().next().value;
        ___$romejs$invariant$src$index_ts$default(
        newRoot !== undefined,
        'Already checked for the existence of newRoot above');
        root = Object.assign({}, newRoot, {
          name: root.name !== undefined && newRoot.name !== undefined ? `${root.name}/${newRoot.name}` : newRoot.name});
      }

      const rows = [];

      const showAllCoverage = this.showAllCoverage || totalFiles < 15;

      function buildRows(folder, depth) {
        const name = folder.name === undefined ? 'All files' : `${folder.name}/`;
        const folderPercent = ___$$priv$romejs$core$src$master$testing$TestRunner_ts$percentInsideCoverageFolder(folder);

        rows.push([' '.repeat(depth) + ___$romejs$string_ansi$src$format_ts$formatAnsi.bold(name), ___$$priv$romejs$core$src$master$testing$TestRunner_ts$formatPercent(folderPercent.functions), ___$$priv$romejs$core$src$master$testing$TestRunner_ts$formatPercent(folderPercent.branches), ___$$priv$romejs$core$src$master$testing$TestRunner_ts$formatPercent(folderPercent.lines)]);

        if (!showAllCoverage && depth > 0) {
          return undefined;
        }

        const fileIndent = ' '.repeat(depth + 1);
        for (const [name, file] of ___$$priv$romejs$core$src$master$testing$TestRunner_ts$sortMapKeys(folder.files)) {
          let absolute = master.projectManager.getFilenameFromUid(file.filename);
          if (absolute === undefined) {
            absolute = file.filename;
          }

          rows.push([fileIndent + ___$romejs$string_ansi$src$format_ts$formatAnsi.fileHyperlink(name, absolute), ___$$priv$romejs$core$src$master$testing$TestRunner_ts$formatPercent(file.functions.percent), ___$$priv$romejs$core$src$master$testing$TestRunner_ts$formatPercent(file.branches.percent), ___$$priv$romejs$core$src$master$testing$TestRunner_ts$formatPercent(file.lines.percent)]);
        }

        for (const subFolder of ___$$priv$romejs$core$src$master$testing$TestRunner_ts$sortMapKeys(folder.folders).values()) {
          buildRows(subFolder, depth + 1);
        }
      }

      buildRows(root, 0);

      reporter.table(['File', '% Functions', '% Branches', '% Lines'], rows);

      if (!showAllCoverage) {
        reporter.spacer();
        reporter.info(
        'Additional coverage information available. Refine the executed tests or add the <emphasis>--show-all-coverage</emphasis> flag');
      }

      reporter.hr();
    }

    printTestResults() {
      if (this.printer.hasDiagnostics()) {
        this.throwErrorDiagnosticsPrinter();
      } else {
        this.printTestSuccess();
      }
    }

    printTestSuccess() {
      this.printCoverageReport();
      this.reporter.success(
      `All <emphasis>${___$romejs$string_utils$src$humanizeNumber_ts$humanizeNumber(
      this.progress.total)}</emphasis> tests passed!`);
    }

    getSourceCode(filename) {
      const testSource = this.sources.get(filename);
      if (testSource === undefined) {
        return undefined;
      } else {
        return testSource.code;
      }
    }

    throwErrorDiagnosticsPrinter() {
      const {printer: printer} = this;

      if (this.showAllCoverage) {
        printer.onBeforeFooterPrint(() => {
          this.printCoverageReport();
        });
      }

      throw printer;
    }
  }

  // romejs/core/src/master/testing/index.ts

  class ___$romejs$core$src$master$testing$index_ts$TestWorkerUnresponsiveError extends ___$romejs$events$src$BridgeError_ts$default {
    constructor(message, frames) {
      super(message);
      this.__ROME_ERROR_FRAMES__ = frames;
    }
  }

  async function ___$romejs$core$src$master$testing$index_ts$runTests(req, opts, testFiles, addDiagnostics) {
    const {flags: flags} = req;

    const coverageCollector = new ___$romejs$v8$src$CoverageCollector_ts$default();

    const runner = new ___$romejs$core$src$master$testing$TestRunner_ts$default({
      addDiagnostics: addDiagnostics,
      showAllCoverage: opts.showAllCoverage,
      coverageCollector: coverageCollector,
      sources: testFiles,
      request: req});

    await runner.init();

    const workerContainers = runner.getWorkers();

    const testQueue = Array.from(
    testFiles.entries());

    async function runWorker({bridge: bridge, process: process, inspector: inspector}) {
      if (inspector !== undefined && opts.coverage === true) {
        await inspector.call('Profiler.enable');
        await inspector.call('Profiler.startPreciseCoverage', {
          callCount: false,

          detailed: true});
      }

      async function nextTest() {
        if (testQueue.length === 0) {
          return undefined;
        }

        const item = testQueue.pop();
        if (item === undefined) {
          throw new Error('testQueue.length was validated above');
        }
        const [filename, {code: code, sourceMap: sourceMap}] = item;
        coverageCollector.addSourceMap(filename, code, sourceMap);

        ___$romejs$v8$src$index_ts$sourceMapManager.addSourceMap(filename, sourceMap);

        await bridge.run.call({
          options: opts,
          filename: filename,
          cwd: flags.cwd,
          code: code,
          sourceMap: sourceMap});
        await nextTest();
      }

      try {
        await nextTest();
      } catch (err) {
        if (err instanceof ___$romejs$events$src$BridgeError_ts$default) {} else {
          throw err;
        }
      } finally {
        if (inspector !== undefined && opts.coverage) {
          if (inspector !== undefined && inspector.alive) {
            const profile = await inspector.call(
            'Profiler.takePreciseCoverage');
            coverageCollector.addCoverage(profile.result);

            await inspector.call('Profiler.stopPreciseCoverage');
            await inspector.call('Profiler.disable');
          } else {}
        }

        if (inspector !== undefined) {
          inspector.end();
        }

        process.kill();
      }
    }

    await Promise.all(workerContainers.map(container => runWorker(container)));

    runner.printTestResults();
  }

  // romejs/core/src/master/commands/test.ts

  const ___$$priv$romejs$core$src$master$commands$test_ts$path = require('path');
  function ___$$priv$romejs$core$src$master$commands$test_ts$isTestFile(filename, testFolder) {
    const parts = filename.split(___$$priv$romejs$core$src$master$commands$test_ts$path.sep);

    for (const part of parts) {
      if (part[0] === '_' && part !== testFolder) {
        return false;
      }

      if (part === 'node_modules') {
        return false;
      }
    }

    for (const part of parts) {
      if (part === testFolder) {
        return true;
      }
    }

    return false;
  }
  const ___$romejs$core$src$master$commands$test_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.CODE_QUALITY,
    description: 'run tests',
    hasHeader: true,

    parseCLIFlags(p) {
      return {
        coverage: p.boolean('coverage', {
          description: '',
          default: true}),
        showAllCoverage: p.boolean('show-all-coverage', {
          description: '',
          default: false}),
        updateSnapshots: p.boolean('update-snapshots', {
          description: '',
          default: false})};
    },

    async default(req, flagConsumer) {
      const {master: master, args: args, flags: flags, reporter: reporter} = req;

      if (args.length === 0) {
        const project = await master.projectManager.assertProject(flags.cwd);
        args.push(project.dir);
      }

      const files = [];

      for (const arg of args) {
        const loc = ___$$priv$romejs$core$src$master$commands$test_ts$path.resolve(flags.cwd, arg);
        await master.projectManager.assertProject(loc);
        const matches = master.memoryFs.glob(loc, {extensions: ___$romejs$core$src$worker$extensions_ts$JS_EXTENSIONS});

        for (const filename of matches) {
          const project = master.projectManager.assertProjectExisting(filename);

          if (___$$priv$romejs$core$src$master$commands$test_ts$isTestFile(filename, project.config.testing.folderName)) {
            files.push(filename);
          }
        }
      }

      if (files.length === 0) {
        reporter.warn('No tests ran');
        return undefined;
      }

      let addDiagnostics = [];

      const tests = new Map();

      for (const resolvedTestFile of files) {
        const {diagnostics: diagnostics} = await ___$romejs$diagnostics$src$wrap_ts$catchDiagnosticsAsync(
        'test: Bundling test file',
        async () => {
          const bundler = new ___$romejs$core$src$master$bundler$Bundler_ts$default(req, req.reporter.fork({
            stderr: undefined,
            stdout: undefined}), req.getBundlerConfigFromFlags(), Object.assign({}, req.getResolverOptionsFromFlags(), {
            mocks: true}));

          const {content: content, map: map} = await bundler.bundle(resolvedTestFile);
          tests.set(resolvedTestFile, {
            code: content,
            sourceMap: map});
        });

        addDiagnostics = [...addDiagnostics, ...diagnostics];
      }

      await ___$romejs$core$src$master$testing$index_ts$runTests(
      req,
      {
        coverage: flagConsumer.getProperty('coverage').asBoolean(true),
        showAllCoverage: flagConsumer.getProperty('showAllCoverage').asBoolean(false),
        updateSnapshots: flagConsumer.getProperty('updateSnapshots').asBoolean(false),
        verboseDiagnostics: req.flags.verboseDiagnostics},
      tests,
      addDiagnostics);
    }});

  // romejs/core/src/master/commands/ci.ts

  const ___$romejs$core$src$master$commands$ci_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.CODE_QUALITY,
    description: 'install dependencies, run lint and tests',

    async default(req, flags) {
      const {reporter: reporter} = req;

      reporter.heading('Installing dependencies');

      reporter.heading('Linting');
      await ___$romejs$core$src$master$commands$lint_ts$default.default(req, flags);

      reporter.heading('Running tests');
      await ___$romejs$core$src$master$commands$test_ts$default.default(req, flags);
    }});

  // romejs/core/src/master/commands/_evict.ts

  const ___$romejs$core$src$master$commands$_evict_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    description: 'evict a file from the memory cache',
    category: ___$romejs$core$src$commands_ts$commandCategories.INTERNAL,

    async default({master: master, args: args, reporter: reporter}) {
      const files = args.length === 0 ? master.fileManager.getAllOwnedFilenames() : args;

      for (const file of files) {
        await master.fileManager.evict(file);
        reporter.success(`Evicted ${file}`);
      }

      reporter.info(`Evicted ${String(files.length)} files`);
    }});

  // romejs/core/src/master/commands/_moduleSignature.ts

  const ___$romejs$core$src$master$commands$_moduleSignature_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.INTERNAL,
    description: 'get the module type signature of a file',

    async default(req) {
      const {master: master, args: args, flags: flags, reporter: reporter} = req;
      if (args.length !== 1) {
        throw new Error('Expected exactly one argument');
      }

      const filename = await master.resolver.resolveEntryAssert(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: flags.cwd,
        source: args[0]}));
      reporter.inspect((await master.api.moduleSignature(filename)));
    }});

  // romejs/core/src/master/commands/rage.ts

  const ___$romejs$core$src$master$commands$rage_ts$default = ___$romejs$core$src$commands_ts$createMasterCommand({
    category: ___$romejs$core$src$commands_ts$commandCategories.INTERNAL,
    description: '',

    getRequestFlags() {
      return {
        rage: true};
    },

    async default(req) {
      req;
    }});

  // romejs/core/src/master/commands/index.ts

  const ___$romejs$core$src$master$commands$index_ts$masterCommands = new Map();
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('_moduleSignature', ___$romejs$core$src$master$commands$_moduleSignature_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('evict', ___$romejs$core$src$master$commands$_evict_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('test', ___$romejs$core$src$master$commands$test_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('lint', ___$romejs$core$src$master$commands$lint_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('bundle', ___$romejs$core$src$master$commands$bundle_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('parse', ___$romejs$core$src$master$commands$parse_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('analyzeDependencies', ___$romejs$core$src$master$commands$analyzeDependencies_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('resolve', ___$romejs$core$src$master$commands$resolve_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('compile', ___$romejs$core$src$master$commands$compile_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('stop', ___$romejs$core$src$master$commands$stop_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('status', ___$romejs$core$src$master$commands$status_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('logs', ___$romejs$core$src$master$commands$logs_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('run', ___$romejs$core$src$master$commands$run_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('publish', ___$romejs$core$src$master$commands$publish_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('ci', ___$romejs$core$src$master$commands$ci_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('web', ___$romejs$core$src$master$commands$web_ts$default);
  ___$romejs$core$src$master$commands$index_ts$masterCommands.set('rage', ___$romejs$core$src$master$commands$rage_ts$default);

  // romejs/core/src/master/Master.ts

  const ___$$priv$romejs$core$src$master$Master_ts$stream = require('stream');
  const ___$$priv$romejs$core$src$master$Master_ts$fs = require('fs');
  const ___$$priv$romejs$core$src$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH = 100000;

  class ___$romejs$core$src$master$Master_ts$default {
    constructor(dedicated) {
      this.profiling = false;
      this.fileChangeEvent = new ___$romejs$events$src$Event_ts$default({name: 'Master.fileChange'});
      this.dedicated = dedicated;

      this.logEvent = new ___$romejs$events$src$Event_ts$default({name: 'Master.log'});
      this.stdout = new ___$$priv$romejs$core$src$master$Master_ts$stream.Writable({
        write: (chunk, encoding, callback) => {
          this.logEvent.send(chunk.toString());
          callback();
        }});
      this.logger = new ___$romejs$core$src$common$utils$Logger_ts$default('master', this.logEvent, {
        stderr: this.stdout,
        stdout: this.stdout});
      this.connectedReporters = new ___$romejs$cli_reporter$src$ReporterCollection_ts$default({});

      this.memoryFs = new ___$romejs$core$src$master$MemoryFileSystem_ts$default(this);
      this.projectManager = new ___$romejs$core$src$master$ProjectManager_ts$default(this);
      this.workerManager = new ___$romejs$core$src$master$WorkerManager_ts$default(this);
      this.fileManager = new ___$romejs$core$src$master$FileManager_ts$default(this);
      this.resolver = new ___$romejs$core$src$master$Resolver_ts$default(this);
      this.cache = new ___$romejs$core$src$master$Cache_ts$default(this);
      this.api = new ___$romejs$core$src$master$MasterAPI_ts$default(this);

      this.memoryFs.deletedFileEvent.subscribe(({filename: filename}) => {
        this.handleFileDelete(filename).catch(this.onFatalError);
      });

      this.memoryFs.changedFileEvent.subscribe(
      ({filename: filename, oldStats: oldStats, newStats: newStats}) => {
        this.handleFileChange(filename, oldStats, newStats).catch(
        this.onFatalError);
      });

      this.warnedCacheClients = new WeakSet();
      this.onFatalError = err => {
        const message = `Fatal error occured: ${err.stack}`;
        this.logger.info(message);
        this.connectedReporters.info(message);
        process.exit();
      };
    }

    handleDisconnectedDiagnostics(diagnostics) {
      diagnostics;
    }

    createDisconnectedDiagnosticsProcessor(origins) {
      return new ___$romejs$diagnostics$src$DiagnosticsProcessor_ts$default({
        onDiagnostics: diags => {
          this.handleDisconnectedDiagnostics(diags);
        },
        origins: [...origins, 'master: Created disconnected diagnostics collector']});
    }

    async init() {
      await this.workerManager.init();
    }

    end() {
      if (this.dedicated) {
        process.exit();
        return undefined;
      }

      this.workerManager.end();
      this.memoryFs.unwatchAll();
    }

    async attachToBridge(client) {
      let profiler;

      if (this.dedicated === false) {
        client.endEvent.subscribe(() => {
          this.end();
        });
      }

      client.profilingStart.subscribe(async () => {
        if (profiler !== undefined) {
          throw new Error('Expected no profiler to be running');
        }
        profiler = new ___$romejs$v8$src$Profiler_ts$default();
        await profiler.startProfiling();
        this.profiling = true;
        for (const {bridge: bridge} of this.workerManager.getExternalWorkers()) {
          await bridge.profilingStart.call();
        }
      });

      client.profilingStop.subscribe(async () => {
        if (profiler === undefined) {
          throw new Error('Expected profiler to be running');
        }
        const masterProfile = await profiler.stopProfiling();
        profiler = undefined;
        this.profiling = false;

        const workerProfiles = [];
        for (const {bridge: bridge} of this.workerManager.getExternalWorkers()) {
          workerProfiles.push((await bridge.profilingStop.call()));
        }

        return {
          master: masterProfile,
          workers: workerProfiles};
      });

      client.query.subscribe(async request => {
        return await this.handleRequest(client, request);
      });

      client.endEvent.subscribe(() => {});

      await client.handshake();
    }

    async shouldIgnoreChange(loc) {
      if (loc.includes('node_modules/.cache')) {
        return true;
      }

      return false;
    }

    async handleFileDelete(loc) {
      if (await this.shouldIgnoreChange(loc)) {
        return undefined;
      }

      this.logger.info(`[Master] File delete:`, loc);

      await this.fileManager.disown(loc);

      this.fileChangeEvent.send(loc);
    }

    async handleFileChange(loc, oldStats, newStats) {
      if (await this.shouldIgnoreChange(loc)) {
        return undefined;
      }

      this.logger.info(`[Master] File change:`, loc);

      await this.fileManager.onFileChange(loc, oldStats, newStats);

      this.fileChangeEvent.send(loc);
    }

    async exists(loc) {
      const resolvedExistence = this.memoryFs.exists(loc);
      if (resolvedExistence === undefined) {
        try {
          await ___$$priv$romejs$core$src$master$Master_ts$fs.promises.access(loc);
          return true;
        } catch (err) {
          return false;
        }
      } else {
        return resolvedExistence;
      }
    }

    async handleRequest(client, query) {
      const {flags: flags} = query;
      this.logger.info(`[Master] Handling CLI request:`, query);

      let req;

      let clientEndEvent;
      const clientEndReject = new Promise((resolve, reject) => {
        clientEndEvent = client.endEvent.subscribe(err => {
          reject(err);
        });
      });
      if (clientEndEvent === undefined) {
        throw new Error('Expected clientEndEvent to have been initialized');
      }

      try {
        const stderr = new ___$$priv$romejs$core$src$master$Master_ts$stream.Writable({
          write: (chunk, encoding, callback) => {
            client.stderr.send(chunk.toString());
            callback();
          }});

        const stdout = new ___$$priv$romejs$core$src$master$Master_ts$stream.Writable({
          write: (chunk, encoding, callback) => {
            if (flags.silent === true) {
              callback();
              return undefined;
            }

            let str = chunk.toString();

            if (flags.color === false) {
              str = ___$romejs$string_ansi$src$format_ts$stripAnsi(str);
            }

            if (str.length < ___$$priv$romejs$core$src$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH) {
              client.stdout.send(str);
            } else {
              while (str.length > 0) {
                const chunk = str.slice(0, ___$$priv$romejs$core$src$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH);
                str = str.slice(___$$priv$romejs$core$src$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH);
                client.stdout.send(chunk);
              }
            }

            callback();
          }});

        function setColumns(columns) {
          stderr.columns = columns;

          stdout.columns = columns;
        }

        setColumns(query.columns);

        client.setColumns.subscribe(columns => {
          setColumns(columns);
        });

        const reporter = new ___$romejs$cli_reporter$src$Reporter_ts$default({
          isTTY: true,
          stderr: stderr,
          stdout: stdout,
          verbose: query.flags.verbose,
          silent: query.flags.silent,
          json: query.flags.json,
          markupOptions: {
            cwd: flags.cwd,
            normalizeFilename: filename => {
              const uid = this.projectManager.getFilenameFromUid(filename);
              if (uid === undefined) {
                return filename;
              } else {
                return uid;
              }
            }}});

        reporter.json(___$romejs$cli_reporter$src$constants_ts$JSON_START);

        reporter.hasClearScreen = query.hasClearScreen;

        this.connectedReporters.addReporter(reporter);

        req = new ___$romejs$core$src$master$MasterRequest_ts$default({
          command: query.command,
          master: this,
          reporter: reporter,
          args: query.args,
          client: client,
          flags: flags});

        const commandFlagsConsumer = ___$romejs$codec_json$src$index_ts$consumeMixed(query.commandFlags);

        let promises = [clientEndReject];

        if (flags.logs || flags.logPath !== '' || flags.logWorkers) {
          promises.push(___$romejs$core$src$master$commands$logs_ts$default.default(req, commandFlagsConsumer));
        }

        const commandOpts = ___$romejs$core$src$master$commands$index_ts$masterCommands.get(
        query.command);
        if (commandOpts) {
          if (commandOpts.hasHeader === true) {
            reporter.header(query.command);
          }

          if (process.env.ROME_CACHE === '0' &&
          !this.warnedCacheClients.has(client)) {
            reporter.warn(
            'Disk caching has been disabled by the <emphasis>ROME_CACHE</emphasis> environment variable');
            this.warnedCacheClients.add(client);
          }

          const commandPromise = commandOpts.default(req, commandFlagsConsumer);
          promises.push(commandPromise);

          await Promise.race(promises);

          const data = await commandPromise;
          if (query.noData) {
            return {};
          } else {
            return {data: data};
          }
        } else {
          throw new Error(`Unknown command ${String(query.command)}`);
        }
      } catch (err) {
        let diagnostics;
        if (req !== undefined) {
          diagnostics = await this.handleRequestError(req, err);
        }

        if (diagnostics === undefined) {
          return {
            error: {
              handled: true,
              name: err.name,
              message: err.message,
              stack: err.stack}};
        } else {
          return {diagnostics: diagnostics};
        }
      } finally {
        this.logger.info(`[Master] Replying to CLI request:`, query);

        clientEndEvent.unsubscribe();

        if (req !== undefined) {
          req.reporter.json(___$romejs$cli_reporter$src$constants_ts$JSON_END);

          this.connectedReporters.deleteReporter(req.reporter);
          req.teardown();
        }
      }
    }

    async handleRequestError(req, err) {
      const diagnostics = ___$romejs$diagnostics$src$errors_ts$getDiagnosticsFromError(err);
      if (diagnostics !== undefined) {
        const printer = req.createDiagnosticsPrinter(
        'Derived diagnostics from thrown error');
        printer.addDiagnostics(diagnostics);
        err = printer;
      }

      if (err instanceof ___$romejs$cli_diagnostics$src$DiagnosticsPrinter_ts$default) {
        const printer = err;
        await printer.print();
        printer.footer();
        return printer.getDiagnostics();
      }

      const printer = req.createDiagnosticsPrinter(
      'Error captured and converted into a diagnostic');
      printer.addDiagnostic(
      ___$romejs$diagnostics$src$derive_ts$deriveDiagnosticFromError({
        error: err,
        lastAdvice: [{
          type: 'log',
          category: 'info',
          message: 'This diagnostic was derived from an internal error'}]}));
      await printer.print();

      return undefined;
    }
  }

  // romejs/core/src/api/API.ts

  const ___$$priv$romejs$core$src$api$API_ts$stream = require('stream');
  const ___$$priv$romejs$core$src$api$API_ts$tty = require('tty');
  const ___$$priv$romejs$core$src$api$API_ts$net = require('net');
  const ___$$priv$romejs$core$src$api$API_ts$fs = require('fs');
  const ___$$priv$romejs$core$src$api$API_ts$NEW_SERVER_INIT_TIMEOUT = 600000;

  class ___$romejs$core$src$api$API_ts$default {
    constructor(opts) {
      this.flags = Object.assign({}, ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS, opts.flags);

      this.bridgeStatus = undefined;

      const reporter = new ___$romejs$cli_reporter$src$Reporter_ts$default({
        silent: this.flags.silent ||
        opts.stdout === undefined ||
        opts.stderr === undefined,
        verbose: this.flags.verbose,
        stderr: opts.stderr,
        stdout: opts.stdout,
        markupOptions: {
          cwd: this.flags.cwd}});
      this.reporter = reporter;
      this.stdout = reporter.stdout;
      this.stderr = reporter.stderr;
    }

    end() {
      const status = this.bridgeStatus;
      if (status !== undefined) {
        status.bridge.end();
        this.bridgeStatus = undefined;
      }
    }

    query(opts) {
      const request = new ___$romejs$core$src$api$APIRequest_ts$default(this, opts);
      return request.init();
    }

    getBridge() {
      return this.bridgeStatus;
    }

    async attachBridge(bridge, dedicated) {
      const {stderr: stderr, stdout: stdout, reporter: reporter} = this;

      this.bridgeStatus = {bridge: bridge, dedicated: dedicated};

      bridge.stderr.subscribe(chunk => {
        stderr.write(chunk);
      });

      bridge.stdout.subscribe(chunk => {
        stdout.write(chunk);
      });

      if (stdout instanceof ___$$priv$romejs$core$src$api$API_ts$tty.WriteStream && stdout.isTTY) {
        function onStdoutResize() {
          bridge.setColumns.call(reporter.getColumns());
        }

        stdout.on('resize', onStdoutResize);

        bridge.endEvent.subscribe(() => {
          stdout.off('resize', onStdoutResize);
        });
      }

      await bridge.handshake();
    }

    async findOrStartMaster() {
      const connected = this.getBridge();
      if (connected !== undefined) {
        return connected.bridge;
      }

      const runningDaemon = await this.tryConnectToExistingDaemon();
      if (runningDaemon) {
        await this.attachBridge(runningDaemon, true);
        return runningDaemon;
      }

      const master = new ___$romejs$core$src$master$Master_ts$default(false);
      const bridge = ___$romejs$events$src$bridgeCreators_ts$createBridgeFromLocal(___$romejs$core$src$common$bridges$MasterBridge_ts$default);
      await master.init();
      await Promise.all([master.attachToBridge(bridge), this.attachBridge(bridge, false)]);
      return bridge;
    }

    async startDaemon() {
      const {reporter: reporter} = this;

      reporter.info('No running daemon found. Starting one...');
      const proc = ___$romejs$core$src$common$utils$fork_ts$default('master', {
        detached: true});
      proc.unref();

      let exited = false;

      const newDaemon = await new Promise(resolve => {
        const timeout = setTimeout(() => {
          reporter.error('Daemon connection timed out');
          cleanup();
          resolve();
        }, ___$$priv$romejs$core$src$api$API_ts$NEW_SERVER_INIT_TIMEOUT);

        const socketServer = ___$$priv$romejs$core$src$api$API_ts$net.createServer(() => {
          cleanup();
          resolve(this.tryConnectToNewDaemon());
        });

        ___$$priv$romejs$core$src$api$API_ts$fs.unlink(___$romejs$core$src$common$constants_ts$CLI_SOCKET_PATH, () => {
          socketServer.listen(___$romejs$core$src$common$constants_ts$CLI_SOCKET_PATH);
        });

        proc.on('close', () => {
          exited = true;
          cleanup();
          resolve();
        });

        function cleanup() {
          clearTimeout(timeout);
          socketServer.close();
        }
      });
      if (newDaemon) {
        await this.attachBridge(newDaemon, true);
        return newDaemon;
      }

      if (exited) {
        reporter.error('Daemon died while initialising.');
      } else {
        reporter.error('Failed to connect. Killing daemon.');
      }
      proc.kill();

      return undefined;
    }

    async tryConnectToNewDaemon() {
      const bridge = await this.tryConnectToExistingDaemon();
      if (bridge) {
        this.reporter.success(`Started daemon!`);
        return bridge;
      } else {
        return undefined;
      }
    }

    async tryConnectToExistingDaemon() {
      const promise = new Promise((resolve, reject) => {
        const socket = ___$$priv$romejs$core$src$api$API_ts$net.createConnection(
        {
          path: ___$romejs$core$src$common$constants_ts$SOCKET_PATH},
        () => {
          resolve(socket);
        });

        socket.on('error', err => {
          if (err.code === 'ENOENT') {
            resolve();
          } else {
            reject(err);
          }
        });
      });

      const socket = await promise;
      if (socket === undefined) {
        return undefined;
      }

      const client = ___$romejs$events$src$bridgeCreators_ts$createBridgeFromSocket(___$romejs$core$src$common$bridges$MasterBridge_ts$default, socket);
      await this.attachBridge(client, true);
      this.reporter.success('Connected to daemon');
      return client;
    }
  }

  // romejs/core/src/common/types/bundler.ts

  const ___$romejs$core$src$common$types$bundler_ts = {
    get BUNDLER_MODES() {
      return ___$romejs$core$src$common$types$bundler_ts$BUNDLER_MODES;
    }};
  const ___$romejs$core$src$common$types$bundler_ts$BUNDLER_MODES = ['flat', 'wrapper'];

  // romejs/core/src/worker/WorkerAPI.ts

  class ___$romejs$core$src$worker$WorkerAPI_ts$default {
    constructor(worker) {
      this.worker = worker;
      this.logger = worker.logger;
    }

    async moduleSignature(ref) {
      const {ast: ast, projectConfig: projectConfig} = await this.worker.parse(ref);

      this.logger.info(`Generating export types:`, ref.real);

      return await ___$romejs$js_analysis$src$api$getModuleSignature_ts$default({
        ast: ast,
        projectConfig: projectConfig,
        provider: await this.worker.getTypeCheckProvider(ref.project)});
    }

    async analyzeDependencies(ref) {
      const {ast: ast, src: src, projectConfig: projectConfig} = await this.worker.parse(ref);
      this.logger.info(`Analysing:`, ref.real);
      return ___$romejs$js_compiler$src$api$analyzeDependencies_ts$default({ast: ast, src: src, projectConfig: projectConfig, options: {}});
    }

    async compile(ref, stage, options) {
      const {ast: ast, projectConfig: projectConfig, src: src} = await this.worker.parse(ref);
      this.logger.info(`Compiling:`, ref.real);
      return ___$romejs$js_compiler$src$api$compile_ts$default({
        ast: ast,
        src: src,
        options: options,
        projectConfig: projectConfig,
        stage: stage});
    }

    async parse(ref, opts) {
      const {ast: ast} = await this.worker.parse(ref, {
        sourceType: opts.sourceType,
        cache: false});

      if (opts.compact) {
        return ___$romejs$js_ast$src$core$Program_ts$program.assert(___$romejs$js_ast_utils$src$removeLoc_ts$default(ast));
      } else {
        return ast;
      }
    }

    async lint(ref, prefetchedModuleSignatures, fix) {
      const projectConfig = this.worker.getProjectConfig(ref.project);
      this.logger.info(`Linting:`, ref.real);

      const extension = ___$romejs$core$src$worker$extensions_ts$getExtensionHandler(ref.real);
      if (extension === undefined) {
        throw new Error('Expected extension to be valid');
      }

      const {lint: lint} = extension;
      if (lint === undefined) {
        return [];
      }

      const res = await ___$romejs$diagnostics$src$wrap_ts$catchDiagnosticsAsync('Caught by WorkerAPI.lint', () => lint({
        file: ref,
        projectConfig: projectConfig,
        prefetchedModuleSignatures: prefetchedModuleSignatures,
        worker: this.worker}));

      if (res.foundDiagnostics) {
        return res.diagnostics;
      }

      const {formatted: formatted, raw: raw, diagnostics: diagnostics} = res.value;

      const needsFix = formatted !== raw;

      if (fix && needsFix) {
        await this.worker.writeFile(ref.real, formatted);

        return this.lint(ref, prefetchedModuleSignatures, false);
      }

      if (!needsFix) {
        return diagnostics;
      }

      return [...diagnostics, {
        category: 'lint/pendingFixes',
        filename: ref.uid,
        message: 'Pending lint fixes',
        advice: [{
          type: 'diff',
          diff: ___$romejs$string_diff$src$index_ts$default(raw, formatted)}]}];
    }
  }

  // romejs/core/src/worker/Worker.ts

  const ___$$priv$romejs$core$src$worker$Worker_ts$stream = require('stream');
  const ___$$priv$romejs$core$src$worker$Worker_ts$fs = require('fs');
  class ___$romejs$core$src$worker$Worker_ts$default {
    constructor(bridge) {
      this.bridge = bridge;

      this.projects = new Map();
      this.fileCache = new Map();
      this.astCache = new Map();
      this.moduleSignatureCache = new Map();

      this.stdout = new ___$$priv$romejs$core$src$worker$Worker_ts$stream.Writable({
        write: (chunk, encoding, callback) => {
          bridge.log.send(chunk.toString());
          callback();
        }});

      this.logger = new ___$romejs$core$src$common$utils$Logger_ts$default('worker', bridge.log, {
        stderr: this.stdout,
        stdout: this.stdout});

      this.api = new ___$romejs$core$src$worker$WorkerAPI_ts$default(this);
    }

    end() {
      this.astCache.clear();
      this.fileCache.clear();
      this.projects.clear();
      this.moduleSignatureCache.clear();
    }

    init() {
      const bridge = this.bridge;

      bridge.endEvent.subscribe(() => {
        this.end();
      });

      let profiler;
      bridge.profilingStart.subscribe(async () => {
        if (profiler !== undefined) {
          throw new Error('Expected no profiler to be running');
        }
        profiler = new ___$romejs$v8$src$Profiler_ts$default();
        await profiler.startProfiling();
      });

      bridge.profilingStop.subscribe(async () => {
        if (profiler === undefined) {
          throw new Error('Expected a profiler to be running');
        }
        const workerProfile = await profiler.stopProfiling();
        profiler = undefined;
        return workerProfile;
      });

      bridge.compile.subscribe(payload => {
        return this.api.compile(payload.file, payload.stage, payload.options);
      });

      bridge.parse.subscribe(payload => {
        return this.api.parse(payload.file, payload.opts);
      });

      bridge.lint.subscribe(payload => {
        return this.api.lint(
        payload.file,
        payload.prefetchedModuleSignatures,
        payload.fix);
      });

      bridge.analyzeDependencies.subscribe(payload => {
        return this.api.analyzeDependencies(payload.file);
      });

      bridge.evict.subscribe(payload => {
        this.evict(payload.filename);
        return undefined;
      });

      bridge.moduleSignature.subscribe(payload => {
        return this.api.moduleSignature(payload.file);
      });

      bridge.evictProject.subscribe(data => {
        return this.evictProject(data.id);
      });

      bridge.updateProjects.subscribe(payload => {
        return this.updateProjects(payload.projects);
      });

      bridge.status.subscribe(() => {
        return {
          astCacheSize: this.astCache.size,
          pid: process.pid,
          memoryUsage: process.memoryUsage(),
          uptime: process.uptime()};
      });
    }

    async getTypeCheckProvider(projectId, prefetchedModuleSignatures = {}) {
      const libs = [];

      const resolveGraph = async key => {
        const value = prefetchedModuleSignatures[key];
        if (value === undefined) {
          return undefined;
        }

        switch (value.type) {
          case 'RESOLVED':
            this.moduleSignatureCache.set(value.graph.filename, value.graph);
            return value.graph;

          case 'OWNED':
            return this.api.moduleSignature(value.file);

          case 'POINTER':
            return resolveGraph(value.key);

          case 'USE_CACHED':
            const cached = this.moduleSignatureCache.get(value.filename);
            ___$romejs$invariant$src$index_ts$default(
            cached !== undefined,
            'Master told us we have the export types for %s cached but we dont!',
            value.filename);
            return cached;}
      };

      return {
        getExportTypes: async (origin, relative) => {
          return resolveGraph(`${origin}:${relative}`);
        },
        libs: libs};
    }

    async readFile(filename) {
      const cached = this.fileCache.get(filename);
      if (cached !== undefined) {
        this.fileCache.set(filename, Object.assign({}, cached, {
          lastAccessed: Date.now()}));
        return cached.src;
      }

      const src = await ___$$priv$romejs$core$src$worker$Worker_ts$fs.promises.readFile(filename, 'utf8');
      this.fileCache.set(filename, {
        lastAccessed: Date.now(),
        src: src});
      return src;
    }

    async parse(ref, opts = {}) {
      const {project: project, real: real, uid: uid} = ref;
      const projectConfig = this.getProjectConfig(project);

      const sourceType = opts.sourceType === undefined ? 'module' : opts.sourceType;
      const cacheEnabled = opts.cache !== false;

      if (cacheEnabled) {
        const cachedFile = this.fileCache.get(real);
        if (cachedFile) {
          this.fileCache.set(real, Object.assign({}, cachedFile, {
            lastAccessed: Date.now()}));
        }

        const cachedResult = this.astCache.get(real);
        if (cachedResult && cachedResult.sourceType === sourceType) {
          this.astCache.set(real, Object.assign({}, cachedResult, {
            lastAccessed: Date.now()}));
          return cachedResult;
        }
      }

      this.logger.info(`Parsing:`, real);

      const extension = ___$romejs$core$src$worker$extensions_ts$getExtensionHandler(real);
      if (extension === undefined) {
        throw new Error(`We don't have an extension handler for ${real}`);
      }
      if (extension.toJs === undefined) {
        throw new Error(`We don't know how to convert the file ${real} to js`);
      }

      const src = extension.isBinary === true ? '' : await ___$$priv$romejs$core$src$worker$Worker_ts$fs.promises.readFile(real, 'utf8');

      const jsSrc = await extension.toJs(
      {
        file: ref,
        src: src},
      this);

      const ast = ___$romejs$js_parser$src$index_ts$parse(jsSrc, {
        filename: uid,
        sourceType: sourceType});

      const lastAccessed = Date.now();
      const res = {
        ast: ast,
        lastAccessed: lastAccessed,
        src: jsSrc,
        projectConfig: projectConfig,
        sourceType: sourceType};

      if (cacheEnabled) {
        this.astCache.set(real, res);
        this.fileCache.set(real, {
          lastAccessed: lastAccessed,
          src: src});
      }

      return res;
    }

    getProjectConfig(id) {
      const config = this.projects.get(id);
      if (config === undefined) {
        throw new Error(`Unknown project ${id}, known projects are ${this.projects.keys()}`);
      }
      return config;
    }

    async writeFile(filename, content) {
      await ___$$priv$romejs$core$src$worker$Worker_ts$fs.promises.writeFile(filename, content);

      this.evict(filename);
    }

    evict(filename) {
      this.astCache.delete(filename);
      this.fileCache.delete(filename);
      this.moduleSignatureCache.delete(filename);
    }

    evictProject(id) {
      this.projects.delete(id);
    }

    async updateProjects(projects) {
      this.projects.clear();
      for (const {config: config, id: id} of projects) {
        this.projects.set(id, config);
      }
    }
  }

  // romejs/core/src/test-worker/TestAPI.ts

  const ___$$priv$romejs$core$src$test_worker$TestAPI_ts$assert = require('assert');
  function ___$$priv$romejs$core$src$test_worker$TestAPI_ts$formatExpectedError(expected) {
    if (typeof expected === 'string') {
      return JSON.stringify(expected);
    }

    if (expected instanceof RegExp) {
      return String(expected);
    }

    if (typeof expected === 'function') {
      return expected.name;
    }

    return 'unknown';
  }

  function ___$$priv$romejs$core$src$test_worker$TestAPI_ts$matchExpectedError(error, expected) {
    if (expected === undefined) {
      return true;
    }

    if (typeof expected === 'string') {
      return error.message.includes(expected);
    }

    if (expected instanceof RegExp) {
      return expected.test(error.message);
    }

    if (typeof expected === 'function') {
      return error instanceof expected;
    }

    return false;
  }

  const ___$$priv$romejs$core$src$test_worker$TestAPI_ts$TRUNCATION_MATCH_LIMIT = 500;

  function ___$$priv$romejs$core$src$test_worker$TestAPI_ts$maybeTruncate(str, noTruncate) {
    if (noTruncate || str.length < ___$$priv$romejs$core$src$test_worker$TestAPI_ts$TRUNCATION_MATCH_LIMIT) {
      return str;
    } else {
      return `${str.slice(0, ___$$priv$romejs$core$src$test_worker$TestAPI_ts$TRUNCATION_MATCH_LIMIT)}...`;
    }
  }

  class ___$romejs$core$src$test_worker$TestAPI_ts$default {
    constructor(testName, onTimeout, snapshotManager, options) {
      this.testName = testName;
      this.options = options;
      this.snapshotManager = snapshotManager;
      this.snapshotCounter = 0;

      this.teardownEvent = new ___$romejs$events$src$Event_ts$default({name: 'TestAPI.teardown'});

      this.startTime = Date.now();
      this.onTimeout = onTimeout;
      this.timeoutMax = 0;
      this.timeoutId = undefined;
      this.setTimeout(5000);

      this.advice = [];
    }

    buildMatchParts(received, expected) {
      let expectedFormat;
      let receivedFormat;
      if (typeof received === 'string' && typeof expected === 'string') {
        expectedFormat = expected;
        receivedFormat = received;
      } else {
        expectedFormat = ___$romejs$pretty_format$src$index_ts$default(expected);
        receivedFormat = ___$romejs$pretty_format$src$index_ts$default(received);
      }

      const expectedFormatCode = ___$$priv$romejs$core$src$test_worker$TestAPI_ts$maybeTruncate(
      expectedFormat,
      this.options.verboseDiagnostics);
      const receivedFormatCode = ___$$priv$romejs$core$src$test_worker$TestAPI_ts$maybeTruncate(
      receivedFormat,
      this.options.verboseDiagnostics);
      const hasTruncated = expectedFormatCode !== expectedFormat ||
      receivedFormatCode !== receivedFormat;

      const advice = [{
        type: 'log',
        category: 'info',
        message: `Expected to receive`}, {
        type: 'code',
        code: expectedFormatCode}, {
        type: 'log',
        category: 'info',
        message: `But got`}, {
        type: 'code',
        code: receivedFormatCode}, {
        type: 'log',
        category: 'info',
        message: `Diff`}, {
        type: 'diff',
        diff: ___$romejs$string_diff$src$index_ts$default(receivedFormat, expectedFormat)}];

      if (hasTruncated) {
        advice.push({
          type: 'log',
          category: 'info',
          message: 'Some values have been truncated for being too long, add the --verbose-diagnostics flag to disable truncation'});
      }

      return advice;
    }

    addAdvice(item) {
      this.advice.push(item);
    }

    onTeardown(callback) {
      this.teardownEvent.subscribe(callback);
    }

    clearTimeout() {
      if (this.timeoutId !== undefined) {
        clearTimeout(this.timeoutId);
      }

      this.timeoutMax = undefined;
      this.timeoutStart = undefined;
    }

    extendTimeout(time) {
      const {timeoutMax: timeoutMax, timeoutStart: timeoutStart} = this;
      if (timeoutMax === undefined || timeoutStart === undefined) {
        throw new Error('No timeout set');
      }

      const elapsed = Date.now() - timeoutStart;
      const newTime = timeoutMax - elapsed + time;
      this.setTimeout(newTime);
    }

    setTimeout(time) {
      this.clearTimeout();

      this.timeoutStart = Date.now();
      this.timeoutMax = time;

      this.timeoutId = setTimeout(() => {
        this.onTimeout(time);
      }, time);
    }

    checkTimeout() {
      const {startTime: startTime, timeoutMax: timeoutMax} = this;
      if (timeoutMax === undefined) {
        return undefined;
      }

      const delta = Date.now() - startTime;
      if (delta > timeoutMax) {
        throw new Error(`Test timeout - exceeded ${String(timeoutMax)}ms`);
      }
    }

    fail(message, advice, framesToPop = 0) {
      const actualMessage = message === undefined ? 'Test failure triggered by t.fail()' : message;
      const error = new ___$romejs$v8$src$errors_ts$V8Error(actualMessage, advice, framesToPop + 1);
      throw error;
    }

    truthy(value, message = 'Expected value to be truthy') {
      if (Boolean(value) === false) {
        this.fail(
        message,
        [{
          type: 'log',
          category: 'info',
          message: `Received`}, {
          type: 'code',
          code: ___$romejs$pretty_format$src$index_ts$default(value)}],
        1);
      }
    }

    falsy(value, message = 'Expected value to be falsy') {
      if (Boolean(value) === true) {
        this.fail(
        message,
        [{
          type: 'log',
          category: 'info',
          message: `Received`}, {
          type: 'code',
          code: ___$romejs$pretty_format$src$index_ts$default(value)}],
        1);
      }
    }

    true(value, message = 'Expected value to be true') {
      if (value !== true) {
        this.fail(
        message,
        [{
          type: 'log',
          category: 'info',
          message: `Received`}, {
          type: 'code',
          code: ___$romejs$pretty_format$src$index_ts$default(value)}],
        1);
      }
    }

    false(value, message = 'Expected value to be false') {
      if (value !== false) {
        this.fail(
        message,
        [{
          type: 'log',
          category: 'info',
          message: `Received`}, {
          type: 'code',
          code: ___$romejs$pretty_format$src$index_ts$default(value)}],
        1);
      }
    }

    is(received, expected, message = 't.is() failed, using Object.is semantics') {
      if (Object.is(received, expected) !== true) {
        this.fail(message, this.buildMatchParts(received, expected), 2);
      }
    }

    not(received, expected, message = 't.not() failed, using !Object.is() semantics') {
      if (Object.is(received, expected) === true) {
        this.fail(message, this.buildMatchParts(received, expected), 2);
      }
    }

    deepEqual(value, expected, message) {
      ___$$priv$romejs$core$src$test_worker$TestAPI_ts$assert.deepStrictEqual(value, expected);
      message;
    }

    notDeepEqual(value, expected, message) {
      throw new Error('unimplemented');
    }

    throws(thrower, expected, message = 't.throws() failed, callback did not throw an error') {
      try {
        thrower();
      } catch (err) {
        if (___$$priv$romejs$core$src$test_worker$TestAPI_ts$matchExpectedError(err, expected)) {
          return undefined;
        } else {
          this.fail(
          `t.throws() expected an error to be thrown that matches ${___$$priv$romejs$core$src$test_worker$TestAPI_ts$formatExpectedError(
          expected)} but got ${err.name}: ${JSON.stringify(err.message)}`,
          ___$romejs$diagnostics$src$derive_ts$getErrorStackAdvice(err, 'Incorrect error stack trace'),
          1);
        }
      }

      this.fail(message, undefined, 1);
    }

    async throwsAsync(thrower, expected, message) {
      throw new Error('unimplemented');
    }

    notThrows(nonThrower, message) {
      try {
        nonThrower();
      } catch (err) {
        message;
        throw err;
      }
    }

    async notThrowsAsync(nonThrower, message) {
      throw new Error('unimplemented');
    }

    regex(contents, regex, message) {
      throw new Error('unimplemented');
    }

    notRegex(contents, regex, message) {
      throw new Error('unimplemented');
    }

    snapshot(expected, message) {
      const id = this.snapshotCounter++;
      return this._snapshotNamed(id, expected, message, 2);
    }

    snapshotNamed(name, expected, message) {
      return this._snapshotNamed(name, expected, message, 1);
    }

    getSnapshot(name) {
      const key = this.snapshotManager.toSnapshotKey(this.testName, name);
      return this.snapshotManager.get(key);
    }

    _snapshotNamed(name, expected, message = 'Snapshots don\'t match', framesToPop) {
      const key = this.snapshotManager.toSnapshotKey(this.testName, name);

      const formatted = ___$romejs$pretty_format$src$index_ts$default(expected);

      const existingSnapshot = this.snapshotManager.get(key);
      if (existingSnapshot === undefined) {
        this.snapshotManager.set(key, formatted);
        return undefined;
      }

      if (formatted !== existingSnapshot) {
        this.fail(
        message,
        [{
          type: 'log',
          category: 'info',
          message: 'Snapshot diff'}, {
          type: 'diff',
          diff: ___$romejs$string_diff$src$index_ts$default(existingSnapshot, formatted)}],
        framesToPop);
      }
    }
  }

  // romejs/core/src/test-worker/SnapshotManager.ts

  const ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$util = require('util');
  const ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$path = require('path');
  const ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$fs = require('fs');
  const ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$writeFile = ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$util.promisify(___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$fs.writeFile);
  const ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$mkdir = ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$util.promisify(___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$fs.mkdir);
  const ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$readFile = ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$util.promisify(___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$fs.readFile);
  const ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$exists = ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$util.promisify(___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$fs.exists);

  const ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$SNAPSHOTS_DIR = '__snapshots__';

  class ___$romejs$core$src$test_worker$SnapshotManager_ts$default {
    constructor(testFilename, forceUpdate) {
      this.testFilename = testFilename;
      this.snapshotFolder = ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$path.join(___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$path.dirname(testFilename), ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$SNAPSHOTS_DIR);
      this.snapshotFilename = ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$path.join(
      this.snapshotFolder,
      ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$path.basename(testFilename) + '.snap');
      this.forceUpdate = forceUpdate;

      this.snapshots = new Map();
    }

    async load() {
      const {snapshotFilename: snapshotFilename} = this;
      if (!(await ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$exists(snapshotFilename))) {
        return undefined;
      }

      if (this.forceUpdate) {
        return undefined;
      }

      const file = await ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$readFile(snapshotFilename, 'utf8');
      const json = JSON.parse(file);

      for (const key in json) {
        this.snapshots.set(key, String(json[key]));
      }
    }

    async save() {
      if (this.snapshots.size === 0) {
        return undefined;
      }

      const {snapshotFolder: snapshotFolder, snapshotFilename: snapshotFilename} = this;

      if (!(await ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$exists(snapshotFolder))) {
        await ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$mkdir(snapshotFolder);
      }

      const json = {};
      for (const [key, value] of this.snapshots) {
        json[key] = value;
      }
      const formatted = JSON.stringify(json, undefined, '  ');

      await ___$$priv$romejs$core$src$test_worker$SnapshotManager_ts$writeFile(snapshotFilename, formatted);
    }

    toSnapshotKey(testName, id) {
      if (id === 0) {
        return testName;
      } else {
        return `${testName}: ${id}`;
      }
    }

    get(key) {
      return this.snapshots.get(key);
    }

    set(key, value) {
      this.snapshots.set(key, value);
    }
  }

  // romejs/core/src/test-worker/TestWorkerRunner.ts

  const ___$$priv$romejs$core$src$test_worker$TestWorkerRunner_ts$MAX_RUNNING_TESTS = 20;

  class ___$romejs$core$src$test_worker$TestWorkerRunner_ts$default {
    constructor(opts, bridge) {
      this.opts = opts;
      this.locked = false;
      this.filename = opts.filename;
      this.options = opts.options;
      this.bridge = bridge;
      this.snapshotManager = new ___$romejs$core$src$test_worker$SnapshotManager_ts$default(opts.filename, opts.options.updateSnapshots);

      this.hasFocusedTest = false;
      this.foundTests = new Map();
    }

    getEnvironment() {
      return {
        __REGISTER_TEST__: (err, opts, callback) => {
          this.registerTest(err, opts, callback);
        }};
    }

    async discoverTests() {
      const {filename: filename, code: code, sourceMap: sourceMap} = this.opts;

      const res = await ___$romejs$core$src$common$utils$executeMain_ts$default({
        filename: filename,
        code: code,
        sourceMap: sourceMap,
        globals: this.getEnvironment()});

      if (res.syntaxError !== undefined) {
        throw new Error('A syntax error occured in the final bundle. This is the result of Rome messing up.');
      }
    }

    lockTests() {
      this.locked = true;
    }

    registerTest(callsiteError, options, callback) {
      if (this.locked) {
        throw new Error('Test can\'t be added outside of init');
      }

      let testName = options.name;
      if (Array.isArray(testName)) {
        testName = testName.join(' > ');
      }

      ___$romejs$invariant$src$index_ts$default(
      this.foundTests.has(testName) === false,
      'Test %s has already been defined');

      this.foundTests.set(testName, {
        callback: callback,
        options: options,
        callsiteError: callsiteError});

      if (options.only === true) {
        this.hasFocusedTest = true;
      }
    }

    onError(testName, error, firstAdvice) {
      const {filename: filename} = this;

      let ref = undefined;
      if (testName !== undefined) {
        ref = {
          filename: filename,
          testName: testName};
      }

      this.bridge.testError.send({
        ref: ref,
        diagnostic: ___$romejs$diagnostics$src$derive_ts$deriveDiagnosticFromError({
          firstAdvice: firstAdvice,
          error: error,
          name: testName,
          filename: filename})});
    }

    async teardownTest(testName, api) {
      api.clearTimeout();

      try {
        await api.teardownEvent.callOptional();
      } catch (err) {
        this.onError(testName + ' teardown', err, []);
      }
    }

    async runTest(testName, callback) {
      let onTimeout = () => {
        throw new Error('Promise wasn\'t created. Should be impossible.');
      };

      const timeoutPromise = new Promise((resolve, reject) => {
        onTimeout = time => {
          reject(new Error(`Test timeout - exceeded ${String(time)}ms`));
        };
      });

      const api = new ___$romejs$core$src$test_worker$TestAPI_ts$default(testName, onTimeout, this.snapshotManager, this.options);

      try {
        const res = callback(api);

        if (res !== undefined && typeof res.then === 'function') {
          await Promise.race([timeoutPromise, res]);
        }

        this.bridge.testSuccess.send({
          ref: {
            filename: this.filename,
            testName: testName}});
      } catch (err) {
        this.onError(testName, err, api.advice);
      } finally {
        await this.teardownTest(testName, api);
      }
    }

    async runTests() {
      const promises = new Set();

      for (const [testName, {options: options, callback: callback}] of this.foundTests) {
        if (callback === undefined) {
          continue;
        }

        this.bridge.testStart.send({
          ref: {
            filename: this.filename,
            testName: testName},
          timeout: options.timeout});

        const promise = this.runTest(testName, callback);
        promise.then(() => {
          promises.delete(promise);
        });
        promises.add(promise);

        if (promises.size > ___$$priv$romejs$core$src$test_worker$TestWorkerRunner_ts$MAX_RUNNING_TESTS) {
          await Promise.race(Array.from(promises));
        }
      }

      await Promise.all(Array.from(promises));

      await this.snapshotManager.save();
    }

    async emitFoundTests() {
      const promises = [];

      for (const [testName, {callback: callback, options: options}] of this.foundTests) {
        let isSkipped = callback === undefined;
        if (this.hasFocusedTest && options.only !== true) {
          isSkipped = true;
        }

        promises.push(
        this.bridge.testFound.call({
          ref: {
            filename: this.filename,
            testName: testName},
          isSkipped: isSkipped}));
      }

      await Promise.all(promises);
    }

    async run() {
      try {
        await this.snapshotManager.load();
        await this.discoverTests();
        await this.emitFoundTests();

        this.lockTests();
        await this.runTests();
      } catch (err) {
        this.onError(undefined, err, []);
      }
    }
  }

  // romejs/core/src/test-worker/TestWorker.ts

  const ___$$priv$romejs$core$src$test_worker$TestWorker_ts$inspector = require('inspector');
  class ___$romejs$core$src$test_worker$TestWorker_ts$default {
    constructor() {
      this.bridge = this.buildBridge();
    }

    async init() {
      ___$$priv$romejs$core$src$test_worker$TestWorker_ts$inspector.open();

      await this.bridge.handshake();
    }

    buildBridge() {
      const bridge = ___$romejs$events$src$bridgeCreators_ts$createBridgeFromParentProcess(___$romejs$core$src$common$bridges$TestWorkerBridge_ts$default);

      process.on('unhandledRejection', err => {
        bridge.testError.send({
          ref: undefined,
          diagnostic: ___$romejs$diagnostics$src$derive_ts$deriveDiagnosticFromError({
            error: err,
            name: 'unhandledRejection'})});
      });

      bridge.inspectorDetails.subscribe(() => {
        return {
          inspectorUrl: ___$$priv$romejs$core$src$test_worker$TestWorker_ts$inspector.url()};
      });

      bridge.run.subscribe(data => {
        return this.runTest(data);
      });

      return bridge;
    }

    async runTest(opts) {
      const testRun = new ___$romejs$core$src$test_worker$TestWorkerRunner_ts$default(opts, this.bridge);
      await testRun.run();
    }
  }

  // romejs/core/src/common/bridges/WorkerBridge.ts

  class ___$romejs$core$src$common$bridges$WorkerBridge_ts$default extends ___$romejs$events$src$Bridge_ts$default {
    constructor(...args) {
      super(...args);
      this.log = this.createEvent({name: 'log'});
      this.evictProject = this.createEvent({name: 'evictProject'});
      this.updateProjects = this.createEvent({
        name: 'updateProjects'});
      this.profilingStart = this.createEvent({name: 'profiling.start'});
      this.profilingStop = this.createEvent({name: 'profiling.stop'});
      this.status = this.createEvent({name: 'status'});
      this.evict = this.createEvent({name: 'evict'});
      this.moduleSignature = this.createEvent({
        name: 'moduleSignature'});
      this.analyzeDependencies = this.createEvent(
      {
        name: 'analyzeDependencies'});
      this.lint = this.createEvent(
      {name: 'lint'});
      this.compile = this.createEvent(
      {name: 'compile'});
      this.parse = this.createEvent(
      {name: 'parse'});
    }
    init() {
      this.addErrorTransport('DiagnosticError', {
        serialize(err) {
          if (!(err instanceof ___$romejs$diagnostics$src$errors_ts$DiagnosticError)) {
            throw new Error('Expected DiagnosticError');
          }

          return {
            message: err.message,
            diagnostic: err.diagnostic};
        },
        hydrate(err, data) {
          return new ___$romejs$diagnostics$src$errors_ts$DiagnosticError(String(err.message), data.diagnostic);
        }});

      this.addErrorTransport('DiagnosticsError', {
        serialize(err) {
          if (!(err instanceof ___$romejs$diagnostics$src$errors_ts$DiagnosticsError)) {
            throw new Error('Expected DiagnosticsError');
          }

          return {
            diagnostic: err.diagnostics};
        },
        hydrate(err, data) {
          return new ___$romejs$diagnostics$src$errors_ts$DiagnosticsError(String(err.message), data.diagnostics);
        }});
    }
  }

  // romejs/core/src/common/bridges/MasterBridge.ts

  class ___$romejs$core$src$common$bridges$MasterBridge_ts$default extends ___$romejs$events$src$Bridge_ts$default {
    constructor(...args) {
      super(...args);
      this.stdout = this.createEvent({name: 'stdout'});
      this.stderr = this.createEvent({name: 'stderr'});
      this.setColumns = this.createEvent({name: 'columns.set'});
      this.query = this.createEvent({
        name: 'query'});
      this.profilingStart = this.createEvent({name: 'profiling.start'});
      this.profilingStop = this.createEvent(
      {name: 'profiling.stop'});
    }
  }

  // romejs/core/src/common/bridges/WebBridge.ts

  class ___$romejs$core$src$common$bridges$WebBridge_ts$default extends ___$romejs$events$src$Bridge_ts$default {
    constructor(...args) {
      super(...args);
      this.ping = this.createEvent({name: 'ping'});
    }
  }

  // romejs/core/src/common/bridges/TestWorkerBridge.ts

  class ___$romejs$core$src$common$bridges$TestWorkerBridge_ts$default extends ___$romejs$events$src$Bridge_ts$default {
    constructor(...args) {
      super(...args);
      this.inspectorDetails = this.createEvent(
      {
        name: 'inspectorDetails'});
      this.run = this.createEvent({name: 'run'});
      this.testFound = this.createEvent({
        name: 'onTestFound'});
      this.testStart = this.createEvent(
      {
        name: 'onTestStart'});
      this.testError = this.createEvent(
      {name: 'onTestError'});
      this.testSuccess = this.createEvent({
        name: 'onTestSuccess'});
    }
  }

  // romejs/core/src/index.ts


  // romejs/cli/src/utils/setProcessTitle.ts

  function ___$romejs$cli$src$utils$setProcessTitle_ts$default(title) {
    process.title = `rome-${title}`;
  }

  // romejs/cli-flags/src/Parser.ts

  class ___$romejs$cli_flags$src$Parser_ts$BreakCommand {}

  class ___$romejs$cli_flags$src$Parser_ts$default {
    constructor(reporter, opts, rawArgs) {
      this.reporter = reporter;
      this.opts = opts;

      this.declaredArguments = new Map();
      this.args = new Map();
      this._ = [];

      this.commands = new Map();
      this.ranCommands = [];
      this.currentCommand = undefined;
      this.ranAssert = false;
      this.errors = [];
      this._allowUnknownArguments = false;

      this.consumeRawArgs(rawArgs);

      if (opts.version !== undefined) {
        this.declareArgument('version', {
          type: 'boolean',
          description: 'show the version'});
      }

      this.declareArgument('help', {
        type: 'boolean',
        description: 'show this help screen',
        shorthand: 'h'});

      this.helpMode = this.getBooleanArg('help', false);
    }

    looksLikeFlag(flag) {
      return flag !== undefined && flag[0] === '-';
    }

    consumeRawArgs(rawArgs) {
      while (rawArgs.length > 0) {
        const arg = String(rawArgs.shift());

        if (arg === '--') {
          this._ = this._.concat(rawArgs);
          break;
        } else if (arg[0] === '-' && arg[1] === '-') {
          const name = arg.slice(2);

          if (rawArgs.length === 0 || this.looksLikeFlag(rawArgs[0])) {
            this.args.set(name, 'true');
          } else {
            this.args.set(name, String(rawArgs.shift()));
          }
        } else if (arg[0] === '-') {
          const names = arg.slice(1).split('');

          for (const name of names) {
            this.args.set(name, 'true');
          }

          if (rawArgs.length > 0 && this.looksLikeFlag(rawArgs[0]) === false) {
            this.args.set(String(names.pop()), String(rawArgs.shift()));
          }
        } else {
          this._.push(arg);
        }
      }
    }

    addShorthand(frm, to) {
      const arg = this.args.get(frm);
      if (arg !== undefined) {
        this.args.set(to, arg);
      }
    }

    hasArg(name) {
      return this.args.has(name) && this.args.get(name) !== undefined;
    }

    getArg(name, def) {
      const arg = this.args.get(name);

      if (arg !== undefined) {
        return arg;
      }

      if (def !== undefined) {
        return def;
      }

      if (this.helpMode) {
        return '';
      }

      this.error(`Argument ${name} is required`);
      return '';
    }

    declareArgument(name, decl) {
      ___$romejs$invariant$src$index_ts$default(
      this.ranAssert === false,
      'Cannot declare an argument after calling assert()');

      ___$romejs$invariant$src$index_ts$default(
      this.declaredArguments.has(name) === false,
      `Already declared argument ${name}`);

      if (decl.shorthand !== undefined) {
        ___$romejs$invariant$src$index_ts$default(
        decl.shorthand.length === 1,
        'Flag shorthand expected to be 1 character');
        this.addShorthand(decl.shorthand, name);
      }

      let argKey = name;

      if (this.currentCommand !== undefined && this.helpMode === true) {
        argKey += ` [${this.currentCommand}]`;
      }

      this.declaredArguments.set(argKey, Object.assign({
        key: name,
        command: this.currentCommand}, decl));
    }

    getStringArg(name, def) {
      const arg = this.getArg(name, def);
      return String(arg);
    }

    getBooleanArg(name, def) {
      if (this.args.get(`no-${name}`) === 'true') {
        return false;
      }

      const arg = this.getArg(name, def);
      return arg === true || arg === 'true';
    }

    getNumberArg(name, def) {
      const arg = this.getArg(name, def);
      return Number(arg);
    }

    getInterface() {
      return new ___$romejs$cli_flags$src$Parser_ts$ParserInterface(this);
    }

    assert() {
      this.ranAssert = true;

      if (this.errors.length > 0) {
        for (const msg of this.errors) {
          this.reporter.error(msg);
        }
        process.exit(1);
      }

      if (this.helpMode) {
        if (this.currentCommand !== undefined) {
          throw new ___$romejs$cli_flags$src$Parser_ts$BreakCommand();
        }

        this.showHelp();
        process.exit(1);
      }

      if (this.getBooleanArg('version', false)) {
        this.reporter.log(String(this.opts.version));
        process.exit(0);
      }

      for (const [key, value] of this.args) {
        const declared = this.declaredArguments.get(key);

        if (declared !== undefined &&
        declared.type === 'boolean' &&
        value !== 'true') {
          this._.push(value);

          this.args.set(key, 'true');
        }
      }

      if (this._allowUnknownArguments) {
        return undefined;
      }

      let hasUnknownArguments = false;
      for (const [rawKey] of this.args) {
        let key = rawKey;

        if (key.startsWith('no-')) {
          key = key.slice(3);
        }

        if (this.declaredArguments.has(key) === false) {
          hasUnknownArguments = true;
          this.reporter.error(`Unknown argument ${key} specified`);
        }
      }
      if (hasUnknownArguments) {
        process.exit(1);
      }
    }

    error(msg) {
      if (this.ranAssert) {
        throw new Error('error() can only be called before assert()');
      }
      this.errors.push(msg);
    }

    logHelp(str) {
      this.reporter.log(`  ${str}`);
    }

    buildOptionsHelp(keys) {
      const lines = [];

      const optionOutput = [];
      let argColumnLength = 0;

      for (const key of keys) {
        const decl = this.declaredArguments.get(key);
        if (decl === undefined) {
          throw new Error('Expected argument declaration');
        }
        if (decl.hidden === true) {
          continue;
        }

        let argName = decl.key;
        let argCol = decl.key;

        if (decl.type === 'boolean' && decl.default === true) {
          argCol = `--no-${argCol}`;
          argName = `no-${argName}`;
        } else {
          argCol = `--${argCol}`;
        }

        if (decl.shorthand !== undefined) {
          argCol = `${argCol}, -${decl.shorthand}`;
        }

        if (decl.type !== 'boolean') {
          const inputName = decl.inputName === undefined ? 'input' : decl.inputName;
          argCol += ` <${inputName}>`;
        }

        if (argColumnLength < argCol.length) {
          argColumnLength = argCol.length;
        }

        const descCol = decl.description === undefined ? 'no description found' : decl.description;

        optionOutput.push({
          argName: argName,
          arg: argCol,
          description: descCol});
      }

      optionOutput.sort((a, b) => ___$romejs$string_utils$src$naturalCompare_ts$naturalCompare(a.argName, b.argName));

      for (const {arg: arg, description: description} of optionOutput) {
        lines.push(
        `  ${___$romejs$string_ansi$src$format_ts$formatAnsi.brightBlack(
        ___$romejs$string_ansi$src$pad_ts$rightPad(arg, argColumnLength, ' '))}  ${description}`);
      }

      return lines;
    }

    showCommandsHelp(heading, rawCommandNames) {
      if (rawCommandNames.length === 0) {
        return undefined;
      }

      this.logHelp('');
      this.logHelp(___$romejs$string_ansi$src$format_ts$formatAnsi.bold(heading));
      this.logHelp('');

      const commandNames = rawCommandNames.sort();
      const cmdOutput = [];
      let nameColumnLength = 0;
      for (const cmd of commandNames) {
        const opts = this.commands.get(cmd);
        if (opts === undefined) {
          throw new Error('Expected command options');
        }

        if (cmd[0] === '_') {
          continue;
        }

        if (nameColumnLength < cmd.length) {
          nameColumnLength = cmd.length;
        }

        const argKeys = [];
        for (const [key, decl] of this.declaredArguments) {
          if (decl.command === cmd) {
            argKeys.push(key);
          }
        }

        const desc = opts.description === undefined ? 'no description available' : opts.description;
        const optLines = this.buildOptionsHelp(argKeys);
        cmdOutput.push([cmd, desc, optLines]);
      }

      for (const [nameCol, descCol, optLines] of cmdOutput) {
        this.logHelp(
        `  ${___$romejs$string_ansi$src$format_ts$formatAnsi.brightBlack(
        ___$romejs$string_ansi$src$pad_ts$rightPad(nameCol, nameColumnLength, ' '))}  ${descCol}`);

        for (const line of optLines) {
          this.logHelp(`  ${line}`);
        }
      }
    }

    showHelp() {
      const {description: description, usage: usage, examples: examples} = this.opts;

      this.logHelp('');
      this.logHelp(
      `${___$romejs$string_ansi$src$format_ts$formatAnsi.bold('Usage:')} ${usage === undefined ? '[flags]' : usage}`);
      this.logHelp('');

      if (description !== undefined) {
        this.logHelp(description);
        this.logHelp('');
      }

      this.logHelp(___$romejs$string_ansi$src$format_ts$formatAnsi.bold('Options'));
      this.logHelp('');

      const lonerArgKeys = [];
      for (const [key, decl] of this.declaredArguments) {
        if (decl.command === undefined) {
          lonerArgKeys.push(key);
        }
      }
      for (const line of this.buildOptionsHelp(lonerArgKeys)) {
        this.logHelp(line);
      }

      const commandNames = new Set(this.commands.keys());
      const commandsByCategory = new Map();
      for (const name of commandNames) {
        const command = this.commands.get(name);
        if (command === undefined) {
          throw new Error('Expected command');
        }

        const {category: category} = command;
        if (category === undefined) {
          continue;
        }

        let categoryNames = commandsByCategory.get(category);
        if (categoryNames === undefined) {
          categoryNames = [];
          commandsByCategory.set(category, categoryNames);
        }
        categoryNames.push(name);

        commandNames.delete(name);
      }

      const categoryNames = Array.from(commandsByCategory.keys()).sort();
      for (const category of categoryNames) {
        const commandNames = commandsByCategory.get(category);
        if (commandNames === undefined) {
          throw new Error('Expected command names');
        }
        this.showCommandsHelp(`${category} Commands`, commandNames);
      }

      this.showCommandsHelp(
      commandsByCategory.size > 0 ? 'Other Commands' : 'Commands',
      Array.from(commandNames));

      if (examples !== undefined) {
        this.logHelp('');
        this.logHelp(___$romejs$string_ansi$src$format_ts$formatAnsi.bold('Examples:'));
        this.logHelp('');

        for (const cmd of examples) {
          this.logHelp(`  $ ${cmd}`);
        }
      }

      this.logHelp('');
    }

    allowUnknownArguments() {
      if (this.helpMode) {
        return undefined;
      }

      this._allowUnknownArguments = true;
    }

    commandRequired() {
      if (this.ranCommands.length === 0) {
        this.reporter.error(
        'No command specified. Run --help to see available commands.');
        process.exit(1);
      }
    }

    addCommand(cmd, opts, callback) {
      ___$romejs$invariant$src$index_ts$default(
      this.currentCommand === undefined,
      'Nested commands aren\'t allowed');

      this.commands.set(cmd, Object.assign({}, opts, {
        callback: callback}));

      const cmdParts = this.splitCommand(cmd);
      let shouldRun = true;
      let matched = true;
      for (let i = 0; i < cmdParts.length; i++) {
        const part = cmdParts[i];
        if (part !== this._[i]) {
          matched = false;
          shouldRun = false;
          break;
        }
      }

      this.processCommand(cmd, shouldRun, matched);
    }

    splitCommand(cmd) {
      return cmd.split(' ');
    }

    processCommand(cmd, shouldRun, matched) {
      const opts = this.commands.get(cmd);
      if (opts === undefined) {
        throw new Error('Expected options');
      }

      const cmdParts = this.splitCommand(cmd);

      const old_ = this._;
      if (matched) {
        this._ = this._.slice(cmdParts.length);
      }

      if (this.helpMode) {
        shouldRun = true;
      }

      const {callback: callback} = opts;
      if (shouldRun && callback !== undefined) {
        this.ranAssert = false;
        this.currentCommand = cmd;
        this.ranCommands.push(cmd);

        try {
          callback();
        } catch (err) {
          if (err instanceof ___$romejs$cli_flags$src$Parser_ts$BreakCommand) {} else {
            throw err;
          }
        }

        ___$romejs$invariant$src$index_ts$default(
        this.ranAssert === true,
        'assert() was not called in command callback');

        this.ranAssert = false;
        this.currentCommand = undefined;
      }

      if (matched) {
        this._ = old_;
      }
    }
  }

  class ___$romejs$cli_flags$src$Parser_ts$ParserInterface {
    constructor(parser) {
      this.parser = parser;
    }

    assert() {
      this.parser.assert();
    }

    showHelp() {
      this.parser.showHelp();
    }

    getArgs() {
      return this.parser._;
    }

    allowUnknownArguments() {
      this.parser.allowUnknownArguments();
    }

    defaultCommand(callback) {
      if (this.parser.ranCommands.length === 0) {
        callback();
      }
    }

    error(msg) {
      this.parser.error(msg);
    }

    commandRequired() {
      this.parser.commandRequired();
    }

    command(cmd, callbackOrOpts, maybeCallback) {
      const opts = typeof callbackOrOpts === 'function' ? {} : callbackOrOpts;
      const callback = typeof callbackOrOpts === 'function' ? callbackOrOpts : maybeCallback;

      this.parser.addCommand(cmd, opts, callback);
    }

    optionalStringSet(name, validValues, decl = {}) {
      if (this.parser.hasArg(name)) {
        return this.stringSet(name, validValues, decl);
      } else {
        this.parser.declareArgument(name, Object.assign({
          type: 'string'}, decl));
        return undefined;
      }
    }

    stringSet(name, validValues, decl = {}) {
      this.parser.declareArgument(name, Object.assign({
        type: 'string'}, decl));

      if (this.parser.hasArg(name)) {
        const val = this.parser.getStringArg(name);
        if (validValues.includes(val)) {
          return val;
        } else {
          this.error(
          `Argument ${name} was given an invalid value of "${val}" - possible values are ${JSON.stringify(
          validValues)}`);
          return validValues[0];
        }
      } else if (decl.default !== undefined) {
        return decl.default;
      } else {
        this.error(`Argument ${name} is required`);
        return validValues[0];
      }
    }

    optionalString(name, decl = {}) {
      this.parser.declareArgument(name, Object.assign({
        type: 'string'}, decl));
      if (this.parser.hasArg(name)) {
        return this.parser.getStringArg(name);
      } else {
        return undefined;
      }
    }

    string(name, decl = {}) {
      this.parser.declareArgument(name, Object.assign({
        type: 'string'}, decl));
      return this.parser.getStringArg(name, decl.default);
    }

    optionalNumber(name, decl = {}) {
      this.parser.declareArgument(name, Object.assign({
        type: 'number'}, decl));
      if (this.parser.hasArg(name)) {
        return this.parser.getNumberArg(name);
      } else {
        return undefined;
      }
    }

    number(name, decl = {}) {
      this.parser.declareArgument(name, Object.assign({
        type: 'number'}, decl));
      return this.parser.getNumberArg(name, decl.default);
    }

    boolean(name, decl = {}) {
      this.parser.declareArgument(name, Object.assign({
        type: 'boolean'}, decl));
      return this.parser.getBooleanArg(name, decl.default);
    }
  }

  // romejs/cli-flags/src/index.ts

  function ___$romejs$cli_flags$src$index_ts$parse(reporter, args, opts) {
    const parser = new ___$romejs$cli_flags$src$Parser_ts$default(reporter, opts === undefined ? {} : opts, args);
    return parser.getInterface();
  }

  function ___$romejs$cli_flags$src$index_ts$parseArgv(opts = {}) {
    return ___$romejs$cli_flags$src$index_ts$parse(___$romejs$cli_reporter$src$Reporter_ts$default.fromProcess(), process.argv.slice(2), opts);
  }

  // romejs/cli/src/cli.ts

  async function ___$romejs$cli$src$cli_ts$default() {
    ___$romejs$cli$src$utils$setProcessTitle_ts$default('cli');

    const p = ___$romejs$cli_flags$src$index_ts$parseArgv({
      usage: 'rome [command] [flags]'});

    let command = '';
    let flags = {
      cwd: p.string('cwd', {
        description: 'Change the current working directory',
        default: process.cwd(),
        inputName: 'path'}),
      logs: p.boolean('logs', {
        description: 'Output master logs while your request is being processed',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.logs}),
      logWorkers: p.boolean('log-workers', {
        description: 'Output worker logs while your request is being processed',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.logWorkers}),
      logPath: p.string('log-path', {
        description: 'Write logs to file',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.logPath,
        inputName: 'path'}),
      verbose: p.boolean('verbose', {
        description: 'Whether to enable verbose logs',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.verbose}),
      silent: p.boolean('silent', {
        description: 'Don\'t output anything to stdout',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.silent}),
      color: p.boolean('color', {
        description: 'Whether we should strip special ANSI control codes like color (disabled when under a non-TTY)',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.color}),
      json: p.boolean('json', {
        description: 'Output JSON instead of CLI output',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.json}),
      profile: p.boolean('profile', {
        description: 'Collect a CPU profile of all processes involved while performing a request',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.profile}),
      profilePath: p.string('profile-path', {
        description: 'Path to write a profile to',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.profilePath,
        inputName: 'path'}),
      profileTimeout: p.number('profile-timeout', {
        description: 'Specify a timeout in milliseconds for stopping a CPU profile',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.profileTimeout,
        inputName: 'ms'}),
      rage: p.boolean('rage', {
        description: 'Produce logs and a profile',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.rage}),
      ragePath: p.string('rage-path', {
        description: 'Path to write the rage archive to',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.ragePath,
        inputName: 'path'}),
      watch: p.boolean('watch', {
        description: 'whether to stay alive and watch for file changes',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.watch}),
      fieri: p.boolean('fieri', {
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.fieri,
        hidden: true}),
      focus: p.string('focus', {
        description: 'if a filename, line number, column tuple is passed here then only diagnostics related to it wil be shown',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.focus}),
      grep: p.string('grep', {
        description: 'only show diagnostics that contain this string',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.grep}),
      maxDiagnostics: p.number('max-diagnostics', {
        description: '',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.maxDiagnostics}),
      verboseDiagnostics: p.boolean('verbose-diagnostics', {
        description: '',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.verboseDiagnostics}),
      showAllDiagnostics: p.boolean('show-all-diagnostics', {
        description: `show all diagnostics, default is to truncate`,
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.showAllDiagnostics}),
      inverseGrep: p.boolean('inverse-grep', {
        description: 'flip grep matches',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.inverseGrep}),

      bundlerMode: p.optionalStringSet('bundler-mode', ___$romejs$core$src$common$types$bundler_ts$BUNDLER_MODES, {
        description: '',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.bundlerMode}),
      resolverPlatform: p.optionalStringSet('resolver-platform', ___$romejs$core$src$common$types$platform_ts$PLATFORMS, {
        description: ''}),
      resolverScale: p.optionalNumber('resolver-scale', {
        description: ''}),
      resolverMocks: p.boolean('resolver-mocks', {
        description: '',
        default: ___$romejs$core$src$common$types$api_ts$DEFAULT_API_REQUEST_FLAGS.resolverMocks})};
    let commandFlags;
    let args = [];

    const commandNames = new Set([...___$romejs$core$src$api$commands_ts$localCommands.keys(), ...___$romejs$core$src$master$commands$index_ts$masterCommands.keys()]);

    for (const cmd of commandNames) {
      const local = ___$romejs$core$src$api$commands_ts$localCommands.get(cmd);
      const master = ___$romejs$core$src$master$commands$index_ts$masterCommands.get(cmd);
      const opts = local || master;
      if (opts === undefined) {
        throw new Error('Impossible');
      }

      p.command(
      cmd,
      {
        category: opts.category,
        description: opts.description},
      () => {
        if (master !== undefined && master.getRequestFlags !== undefined) {
          flags = Object.assign({}, flags, master.getRequestFlags());
        }

        if (opts.parseCLIFlags !== undefined) {
          commandFlags = opts.parseCLIFlags(p);
        }

        args = p.getArgs();
        command = cmd;
        p.assert();
      });
    }

    p.assert();
    p.commandRequired();

    const api = new ___$romejs$core$src$api$API_ts$default({
      flags: flags,
      stdout: process.stdout,
      stderr: process.stderr});

    const res = await api.query({
      command: command,
      commandFlags: commandFlags,
      args: args});

    const {error: error} = res;
    if (error === undefined && (res.diagnostics === undefined || res.diagnostics.length === 0)) {
      process.exit(0);
    } else {
      console.error('Unhandled CLI query error');
      if (error !== undefined && !error.handled) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  }

  // romejs/cli/src/master.ts

  const ___$$priv$romejs$cli$src$master_ts$net = require('net');
  const ___$$priv$romejs$cli$src$master_ts$fs = require('fs');
  function ___$romejs$cli$src$master_ts$default() {
    ___$romejs$cli$src$utils$setProcessTitle_ts$default('master');

    ___$$priv$romejs$cli$src$master_ts$fs.watch(___$romejs$core$src$common$constants_ts$BIN, {recursive: true, persistent: false}, () => {
      process.exit();
    });

    const master = new ___$romejs$core$src$master$Master_ts$default(true);

    return master.init().then(() => {
      const socketServer = ___$$priv$romejs$cli$src$master_ts$net.createServer(function(socket) {
        const client = ___$romejs$events$src$bridgeCreators_ts$createBridgeFromSocket(___$romejs$core$src$common$bridges$MasterBridge_ts$default, socket);
        master.attachToBridge(client);
      });

      ___$$priv$romejs$cli$src$master_ts$fs.unlink(___$romejs$core$src$common$constants_ts$SOCKET_PATH, () => {
        socketServer.listen(___$romejs$core$src$common$constants_ts$SOCKET_PATH, () => {
          const socket = ___$$priv$romejs$cli$src$master_ts$net.createConnection(___$romejs$core$src$common$constants_ts$CLI_SOCKET_PATH, () => {
            socket.end();
          });

          socket.on('error', err => {
            err;
            process.exit();
          });
        });
      });
    });
  }

  // romejs/cli/src/testWorker.ts

  function ___$romejs$cli$src$testWorker_ts$default() {
    ___$romejs$cli$src$utils$setProcessTitle_ts$default('test-worker');
    const worker = new ___$romejs$core$src$test_worker$TestWorker_ts$default();
    worker.init();
  }

  // romejs/cli/src/worker.ts

  function ___$romejs$cli$src$worker_ts$default() {
    ___$romejs$cli$src$utils$setProcessTitle_ts$default('worker');
    const bridge = ___$romejs$events$src$bridgeCreators_ts$createBridgeFromParentProcess(___$romejs$core$src$common$bridges$WorkerBridge_ts$default);
    const worker = new ___$romejs$core$src$worker$Worker_ts$default(bridge);
    worker.init();
    bridge.handshake();
  }

  // romejs/cli/bin/rome.ts

  const ___$romejs$cli$bin$rome_ts = {};
  const ___$$priv$romejs$cli$bin$rome_ts$fs = require('fs');
  async function ___$$priv$romejs$cli$bin$rome_ts$main() {
    switch (process.env.ROME_PROCESS_VERSION === ___$romejs$core$src$common$constants_ts$VERSION &&
    process.env.ROME_PROCESS_TYPE) {
      case 'master':
        return ___$romejs$cli$src$master_ts$default();

      case 'worker':
        return ___$romejs$cli$src$worker_ts$default();

      case 'test-worker':
        return ___$romejs$cli$src$testWorker_ts$default();

      default:
        return ___$romejs$cli$src$cli_ts$default();}
  }

  ___$romejs$v8$src$index_ts$sourceMapManager.init();
  ___$romejs$v8$src$index_ts$sourceMapManager.addSourceMap(___$romejs$core$src$common$constants_ts$BIN, JSON.parse(___$$priv$romejs$cli$bin$rome_ts$fs.readFileSync(___$romejs$core$src$common$constants_ts$MAP, 'utf8')));

  ___$$priv$romejs$cli$bin$rome_ts$main().catch(err => {
    console.error('Error thrown inside the CLI handler');
    console.error(err.stack);
    process.exit(1);
  });

  return ___$romejs$cli$bin$rome_ts;
})();
