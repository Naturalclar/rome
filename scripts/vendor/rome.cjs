(function(global) {
  'use strict';
  // romejs/ob1/index.ts


  function ___R$romejs$ob1$index_ts$add(a, b) {
    return a + b;
  }

  function ___R$romejs$ob1$index_ts$sub(a, b) {
    return a - b;
  }

  function ___R$romejs$ob1$index_ts$get0(x) {
    return x;
  }

  function ___R$romejs$ob1$index_ts$get1(x) {
    return x;
  }

  function ___R$romejs$ob1$index_ts$coerce0(x) {
    return x;
  }
  const ___R$romejs$ob1$index_ts$number0 = ___R$romejs$ob1$index_ts$coerce0(0);
  const ___R$romejs$ob1$index_ts$number0Neg1 = ___R$romejs$ob1$index_ts$coerce0(-1);

  function ___R$romejs$ob1$index_ts$coerce1(x) {
    return x;
  }
  const ___R$romejs$ob1$index_ts$number1 = ___R$romejs$ob1$index_ts$coerce1(1);
  const ___R$romejs$ob1$index_ts$number1Neg1 = ___R$romejs$ob1$index_ts$coerce1(-1);

  function ___R$romejs$ob1$index_ts$coerce0to1(x) {
    return x + 1;
  }

  function ___R$romejs$ob1$index_ts$coerce1to0(x) {
    return x - 1;
  }

  function ___R$romejs$ob1$index_ts$inc(x) {
    return x + 1;
  }

  function ___R$romejs$ob1$index_ts$dec(x) {
    return x - 1;
  }

  // romejs/diagnostics/normalize.ts

  const ___R$romejs$diagnostics$normalize_ts = {
    normalizePosition: ___R$romejs$diagnostics$normalize_ts$normalizePosition,
    normalizeDiagnostics: ___R$romejs$diagnostics$normalize_ts$normalizeDiagnostics,
    normalizeDiagnostic: ___R$romejs$diagnostics$normalize_ts$normalizeDiagnostic,
    normalizeDiagnosticAdviceItem: ___R$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdviceItem};
  const ___R$$priv$romejs$diagnostics$normalize_ts$DEFAULT_LIST_TRUNCATE = 100;
  const ___R$$priv$romejs$diagnostics$normalize_ts$DEFAULT_STACKTRACE_TRUNCATE = 10;

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeLanguage(language) {
    if (language === 'js' ||
    language === 'json' ||
    language === 'shell' ||
    language === 'url') {
      return language;
    }

    return 'unknown';
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizePositionAssert(position) {
    const normalized = ___R$romejs$diagnostics$normalize_ts$normalizePosition(position);
    if (normalized === undefined) {
      return {
        index: ___R$romejs$ob1$index_ts$number0Neg1,
        line: ___R$romejs$ob1$index_ts$number1,
        column: ___R$romejs$ob1$index_ts$number0};
    } else {
      return normalized;
    }
  }

  function ___R$romejs$diagnostics$normalize_ts$normalizePosition(position) {
    const {line: line, column: column, index: index} = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeDiagnosticsObject(position);

    if (typeof line !== 'number' ||
    typeof column !== 'number' ||
    typeof index !== 'number') {
      return undefined;
    }

    return {
      index: ___R$romejs$ob1$index_ts$coerce0(Math.max(index, -1)),
      line: ___R$romejs$ob1$index_ts$coerce1(Math.max(line, 1)),
      column: ___R$romejs$ob1$index_ts$coerce0(Math.max(column, 0))};
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeLogCategory(value) {
    if (value === 'none' ||
    value === 'question' ||
    value === 'info' ||
    value === 'warn' ||
    value === 'error') {
      return value;
    }

    return 'error';
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeStringArray(value) {
    if (Array.isArray(value)) {
      return value.map(item => ___R$$priv$romejs$diagnostics$normalize_ts$normalizeString(item, 'Nothing provided'));
    } else {
      return [];
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalNumber(value) {
    if (typeof value === 'number') {
      return value;
    } else {
      return undefined;
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeNumber(value, def) {
    if (typeof value === 'number') {
      return value;
    } else {
      return def;
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(value) {
    if (typeof value === 'string') {
      return value;
    } else {
      return undefined;
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeString(value, def) {
    if (typeof value === 'string') {
      return value;
    } else {
      return def;
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeBoolean(value, def) {
    if (typeof value === 'boolean') {
      return value;
    } else {
      return def;
    }
  }

  function ___R$romejs$diagnostics$normalize_ts$normalizeDiagnostics(diagnostics, opts) {
    if (Array.isArray(diagnostics)) {
      return diagnostics.map(diag => ___R$romejs$diagnostics$normalize_ts$normalizeDiagnostic(diag, opts));
    } else {
      return [];
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeFilename(filename, opts) {
    if (filename === undefined) {
      return 'unknown';
    } else if (opts.normalizeFilename === undefined) {
      return filename;
    } else {
      return opts.normalizeFilename(filename);
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeDiagnosticsObject(obj) {
    if (typeof obj !== 'object' || obj == null || Array.isArray(obj)) {
      return {};
    } else {
      return obj;
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeSourceType(val) {
    if (val === 'module' || val === 'script' || val === 'template') {
      return val;
    } else {
      return 'unknown';
    }
  }

  function ___R$romejs$diagnostics$normalize_ts$normalizeDiagnostic(rawDiagnostic, opts) {
    const diagnostic = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeDiagnosticsObject(rawDiagnostic);

    const filename = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeFilename(
    ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(diagnostic.filename),
    opts);
    const mtime = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalNumber(diagnostic.mtime);
    const origins = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOrigins(diagnostic.origins);

    const start = ___R$romejs$diagnostics$normalize_ts$normalizePosition(diagnostic.start);
    const end = ___R$romejs$diagnostics$normalize_ts$normalizePosition(diagnostic.end);

    const fixable = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeBoolean(diagnostic.fixable, false);
    const sourceText = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(diagnostic.sourceText);
    const language = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeLanguage(diagnostic.language);
    const sourceType = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeSourceType(diagnostic.sourceType);
    const category = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeString(diagnostic.category, 'unknown');
    const message = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeString(diagnostic.message, 'No message provided');
    const marker = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(diagnostic.marker);
    const dependencies = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeDependencies(diagnostic.dependencies, opts);

    const diag = {
      category: category,
      message: message,
      origins: origins,
      marker: marker,
      language: language,
      sourceType: sourceType,
      sourceText: sourceText,
      fixable: fixable,
      dependencies: dependencies,
      advice: [],
      filename: filename,
      mtime: mtime,
      start: start,
      end: end};

    const advice = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdvice(diag, diagnostic.advice, opts);

    return Object.assign({}, diag, {
      advice: advice});
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeDependencies(value, opts) {
    if (Array.isArray(value)) {
      const deps = [];

      for (const elem of value) {
        if (typeof elem === 'object' &&
        elem != null &&
        typeof elem.filename === 'string' &&
        typeof elem.mtime === 'number') {
          deps.push({
            filename: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeFilename(elem.filename, opts),
            mtime: elem.mtime});
        }
      }

      return deps;
    } else {
      return [];
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOrigins(value) {
    if (Array.isArray(value)) {
      return value.map(elem => {
        if (typeof elem === 'object' && elem != null) {
          return {
            category: typeof elem.category === 'string' ? elem.category : 'unknown',
            message: typeof elem.message === 'string' ? elem.message : undefined};
        } else {
          return {category: 'unknown'};
        }
      });
    } else {
      return [];
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceStackFrame(value, opts) {
    return {
      prefix: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(value.prefix),
      suffix: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(value.suffix),
      object: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(value.object),
      property: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(value.property),
      filename: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeFilename(___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(value.filename), opts),
      line: ___R$romejs$ob1$index_ts$coerce1(___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalNumber(value.line)),
      column: ___R$romejs$ob1$index_ts$coerce0(___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalNumber(value.column)),
      sourceText: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(value.sourceText),
      language: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeLanguage(value.language)};
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceStackFrames(value, opts) {
    if (Array.isArray(value)) {
      return value.map(item => ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceStackFrame(item, opts));
    } else {
      return [];
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdvice(diag, value, opts) {
    if (Array.isArray(value)) {
      return value.map(item => ___R$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdviceItem(diag, item, opts));
    } else {
      return [];
    }
  }

  function ___R$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdviceItem(diag, rawPart, opts) {
    const part = ___R$$priv$romejs$diagnostics$normalize_ts$normalizeDiagnosticsObject(rawPart);

    if (typeof part.type !== 'string') {
      return {
        type: 'log',
        category: 'error',
        message: 'Unsupported diagnostics part with no type',
        compact: false};
    }

    switch (part.type) {
      case 'log':
        return {
          type: 'log',
          category: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeLogCategory(part.category),
          message: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeString(part.message, 'No message provided'),
          compact: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeBoolean(part.compact, false)};

      case 'list':
        return {
          type: 'list',
          list: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeStringArray(part.list),
          truncate: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeNumber(part.truncate, ___R$$priv$romejs$diagnostics$normalize_ts$DEFAULT_LIST_TRUNCATE),
          reverse: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeBoolean(part.reverse, false),
          ordered: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeBoolean(part.ordered, false)};

      case 'code':
        return {
          type: 'code',
          code: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeString(part.code, ''),
          language: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeLanguage(part.language || diag.language),
          sourceType: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeSourceType(part.sourceType || diag.sourceType)};

      case 'frame':
        return {
          type: 'frame',
          sourceType: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeSourceType(part.sourceType || diag.sourceType),
          language: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeLanguage(part.language || diag.language),
          sourceText: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(part.sourceText),
          marker: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(part.marker),
          filename: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeFilename(
          ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(part.filename),
          opts),
          mtime: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalNumber(part.mtime),
          start: ___R$$priv$romejs$diagnostics$normalize_ts$normalizePositionAssert(part.start),
          end: ___R$$priv$romejs$diagnostics$normalize_ts$normalizePositionAssert(part.end)};

      case 'diff':
        return {
          type: 'diff',
          diff: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceDiff(part.diff)};

      case 'action':
        return {
          type: 'action',
          message: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeString(part.message, 'No message provided'),
          cancelable: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeBoolean(part.cancelable, false),
          buttons: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceActionButtons(part.buttons)};

      case 'stacktrace':
        return {
          type: 'stacktrace',
          title: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeOptionalString(part.title),
          frames: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceStackFrames(part.frames, opts),
          truncate: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeNumber(part.truncate, ___R$$priv$romejs$diagnostics$normalize_ts$DEFAULT_STACKTRACE_TRUNCATE)};

      case 'inspect':
        return {
          type: 'inspect',

          data: part.data};

      default:
        return {
          type: 'log',
          category: 'error',
          message: 'Unsupported diagnostics part ' + part.type,
          compact: false};}
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceDiffEntry([op, text]) {
    if (typeof text === 'string' && (op === -1 || op === 0 || op === 1)) {
      return [op, text];
    } else {
      return [0, ''];
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceDiff(value) {
    if (Array.isArray(value)) {
      return value.map(item => {
        if (Array.isArray(item)) {
          return ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceDiffEntry(item);
        } else {
          return ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceDiffEntry([]);
        }
      });
    } else {
      return [];
    }
  }

  function ___R$$priv$romejs$diagnostics$normalize_ts$normalizeAdviceActionButtons(value) {
    if (Array.isArray(value)) {
      return value.map(item => {
        if (typeof item !== 'object' || item == null) {
          item = {};
        }

        return {
          text: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeString(item.text, 'No text provided'),
          command: ___R$$priv$romejs$diagnostics$normalize_ts$normalizeString(item.command, '')};
      });
    } else {
      return [];
    }
  }

  // romejs/string-escape/messages.ts

  const ___R$romejs$string$escape$messages_ts = {
    get NOT_ENOUGH_CODE_POINTS() {
      return ___R$romejs$string$escape$messages_ts$NOT_ENOUGH_CODE_POINTS;
    },
    get INVALID_STRING_CHARACTER() {
      return ___R$romejs$string$escape$messages_ts$INVALID_STRING_CHARACTER;
    },
    get INVALID_HEX_DIGIT_FOR_ESCAPE() {
      return ___R$romejs$string$escape$messages_ts$INVALID_HEX_DIGIT_FOR_ESCAPE;
    }};
  const ___R$romejs$string$escape$messages_ts$NOT_ENOUGH_CODE_POINTS = 'Not enough code point digits';
  const ___R$romejs$string$escape$messages_ts$INVALID_STRING_CHARACTER = 'Invalid string character (U+0000 to U+001F)';
  const ___R$romejs$string$escape$messages_ts$INVALID_HEX_DIGIT_FOR_ESCAPE = 'Invalid hex digit for unicode escape';

  // romejs/string-escape/constants.ts

  const ___R$romejs$string$escape$constants_ts = {
    get DOUBLE_QUOTE() {
      return ___R$romejs$string$escape$constants_ts$DOUBLE_QUOTE;
    },
    get SINGLE_QUOTE() {
      return ___R$romejs$string$escape$constants_ts$SINGLE_QUOTE;
    },
    get TICK_QUOTE() {
      return ___R$romejs$string$escape$constants_ts$TICK_QUOTE;
    }};
  const ___R$romejs$string$escape$constants_ts$DOUBLE_QUOTE = '"';
  const ___R$romejs$string$escape$constants_ts$SINGLE_QUOTE = '\'';
  const ___R$romejs$string$escape$constants_ts$TICK_QUOTE = '`';

  // romejs/parser-core/types.ts

  const ___R$romejs$parser$core$types_ts = {
    get UNKNOWN_POSITION() {
      return ___R$romejs$parser$core$types_ts$UNKNOWN_POSITION;
    }};

  const ___R$romejs$parser$core$types_ts$UNKNOWN_POSITION = {
    index: ___R$romejs$ob1$index_ts$number0Neg1,
    line: ___R$romejs$ob1$index_ts$coerce1(-1),
    column: ___R$romejs$ob1$index_ts$number0Neg1};

  // romejs/path/collections.ts

  const ___R$romejs$path$collections_ts = {
    get AbsoluteFilePathMap() {
      return ___R$romejs$path$collections_ts$AbsoluteFilePathMap;
    },
    get RelativeFilePathMap() {
      return ___R$romejs$path$collections_ts$RelativeFilePathMap;
    },
    get UnknownFilePathMap() {
      return ___R$romejs$path$collections_ts$UnknownFilePathMap;
    },
    get AbsoluteFilePathSet() {
      return ___R$romejs$path$collections_ts$AbsoluteFilePathSet;
    },
    get RelativeFilePathSet() {
      return ___R$romejs$path$collections_ts$RelativeFilePathSet;
    },
    get UnknownFilePathSet() {
      return ___R$romejs$path$collections_ts$UnknownFilePathSet;
    }};
  class ___R$$priv$romejs$path$collections_ts$FilePathMap {
    constructor(entries) {
      this.joinedToValue = new Map();
      this.joinedToPath = new Map();

      if (entries !== undefined) {
        for (const [key, value] of entries) {
          this.set(key, value);
        }
      }
    }

    get size() {
      return this.joinedToValue.size;
    }

    *[Symbol.iterator]() {
      for (const [joined, value] of this.joinedToValue) {
        const path = this.joinedToPath.get(joined);
        if (path === undefined) {
          throw new Error('Impossible');
        }

        yield [path, value];
      }
    }

    clear() {
      this.joinedToValue.clear();
      this.joinedToPath.clear();
    }

    keys() {
      return this.joinedToPath.values();
    }

    values() {
      return this.joinedToValue.values();
    }

    delete(path) {
      const joined = path.join();
      this.joinedToValue.delete(joined);
      this.joinedToPath.delete(joined);
    }

    has(path) {
      return this.joinedToValue.has(path.join());
    }

    get(path) {
      return this.joinedToValue.get(path.join());
    }

    set(path, value) {
      const joined = path.join();
      this.joinedToValue.set(joined, value);
      this.joinedToPath.set(joined, path);
    }
  }

  class ___R$$priv$romejs$path$collections_ts$FilePathSet {
    constructor(entries) {
      this.map = new ___R$$priv$romejs$path$collections_ts$FilePathMap();

      if (entries !== undefined) {
        for (const path of entries) {
          this.add(path);
        }
      }
    }

    [Symbol.iterator]() {
      return this.map.keys()[Symbol.iterator]();
    }

    has(path) {
      return this.map.has(path);
    }

    add(path) {
      this.map.set(path);
    }

    delete(path) {
      this.map.delete(path);
    }

    clear() {
      this.map.clear();
    }
  }

  class ___R$romejs$path$collections_ts$AbsoluteFilePathMap extends ___R$$priv$romejs$path$collections_ts$FilePathMap {}

  class ___R$romejs$path$collections_ts$RelativeFilePathMap extends ___R$$priv$romejs$path$collections_ts$FilePathMap {}

  class ___R$romejs$path$collections_ts$UnknownFilePathMap extends ___R$$priv$romejs$path$collections_ts$FilePathMap {}

  class ___R$romejs$path$collections_ts$AbsoluteFilePathSet extends ___R$$priv$romejs$path$collections_ts$FilePathSet {}

  class ___R$romejs$path$collections_ts$RelativeFilePathSet extends ___R$$priv$romejs$path$collections_ts$FilePathSet {}

  class ___R$romejs$path$collections_ts$UnknownFilePathSet extends ___R$$priv$romejs$path$collections_ts$FilePathSet {}

  // romejs/path/index.ts

  const ___R$$priv$romejs$path$index_ts$os = require('os');

  function ___R$$priv$romejs$path$index_ts$toFilePath(pathOrString) {
    if (typeof pathOrString === 'string') {
      return ___R$romejs$path$index_ts$createUnknownFilePath(pathOrString);
    } else {
      return pathOrString;
    }
  }

  class ___R$$priv$romejs$path$index_ts$BaseFilePath {
    constructor(parsed, opts) {
      this.segments = parsed.segments;
      this.absoluteTarget = parsed.absoluteTarget;
      this.absoluteType = parsed.absoluteType;

      this.memoizedParent = opts.parent;
      this.memoizedFilename = opts.filename;
      this.memoizedExtension = opts.ext;
      this.memoizedChildren = new Map();
    }

    getParsed() {
      return {
        segments: this.segments,
        absoluteTarget: this.absoluteTarget,
        absoluteType: this.absoluteType};
    }

    _assert() {
      throw new Error('Unimplemented');
    }
    _fork(parsed, opts) {
      throw new Error('Unimplemented');
    }

    addExtension(ext, clearExt = false) {
      const newBasename = clearExt ? this.getExtensionlessBasename() : this.getBasename();
      const newExt = clearExt ? ext : this.memoizedExtension + ext;
      const segments = this.getParentSegments().concat(newBasename + ext);

      return this._fork(Object.assign({}, this.getParsed(), {
        segments: segments}), {
        ext: newExt,
        parent: this.memoizedParent});
    }

    changeBasename(newBasename) {
      const segments = this.getParentSegments().concat(newBasename);
      return this._fork(Object.assign({}, this.getParsed(), {
        segments: segments}), {
        parent: this.memoizedParent});
    }

    getBasename() {
      const {segments: segments} = this;
      return segments[segments.length - 1];
    }

    getExtensionlessBasename() {
      const basename = this.getBasename();
      const ext = this.getExtensions();

      if (ext === '') {
        return basename;
      } else {
        return basename.slice(0, -ext.length);
      }
    }

    getParent() {
      if (this.memoizedParent !== undefined) {
        return this.memoizedParent;
      }

      const parent = this._fork(Object.assign({}, this.getParsed(), {
        segments: this.getParentSegments()}), {});
      this.memoizedParent = parent;
      return parent;
    }

    getParentSegments() {
      return this.segments.slice(0, -1);
    }

    toExplicitRelative() {
      const relative = this.assertRelative();
      if (relative.isExplicitRelative()) {
        return relative;
      } else {
        return ___R$romejs$path$index_ts$createRelativeFilePath('.').append(relative);
      }
    }

    assertRelative() {
      if (this.isAbsolute()) {
        throw new Error('Expected relative file path but got: ' + this.join());
      } else {
        return new ___R$romejs$path$index_ts$RelativeFilePath(this.getParsed(), {
          ext: this.memoizedExtension,
          filename: this.memoizedFilename});
      }
    }

    assertAbsolute() {
      if (this.isAbsolute()) {
        return new ___R$romejs$path$index_ts$AbsoluteFilePath(this.getParsed(), {
          ext: this.memoizedExtension,
          filename: this.memoizedFilename});
      } else {
        throw new Error('Expected absolute file path but got: ' + this.join());
      }
    }

    assertURL() {
      if (this.isURL()) {
        return new ___R$romejs$path$index_ts$URLFilePath(this.getParsed(), {
          ext: this.memoizedExtension,
          filename: this.memoizedFilename});
      } else {
        throw new Error('Expected URL file path but got: ' + this.join());
      }
    }

    isRoot() {
      if (this.segments.length === 1) {
        return true;
      }

      if (this.segments.length === 3) {
        return this.absoluteType === 'windows-unc';
      }

      return false;
    }

    isWindows() {
      return this.absoluteType === 'windows-drive' ||
      this.absoluteType === 'windows-unc';
    }

    isPosix() {
      return !this.isWindows();
    }

    isURL() {
      return this.absoluteType === 'url';
    }

    isAbsolute() {
      return this.absoluteTarget !== undefined && this.absoluteType !== 'url';
    }

    isRelative() {
      return !this.isAbsolute();
    }

    isRelativeTo(otherRaw) {
      const other = ___R$$priv$romejs$path$index_ts$toFilePath(otherRaw);
      const otherSegments = other.getSegments();
      const ourSegments = this.getSegments();

      if (otherSegments.length > ourSegments.length) {
        return false;
      }

      for (let i = 0; i < otherSegments.length; i++) {
        if (otherSegments[i] !== ourSegments[i]) {
          return false;
        }
      }

      return true;
    }

    isImplicitRelative() {
      return !this.isExplicitRelative() && !this.isAbsolute() && !this.isURL();
    }

    isExplicitRelative() {
      const [firstSeg] = this.segments;
      return !this.isURL() && (firstSeg === '.' || firstSeg === '..');
    }

    getExtensions() {
      if (this.memoizedExtension === undefined) {
        const ext = ___R$$priv$romejs$path$index_ts$getExtension(this.getBasename());
        this.memoizedExtension = ext;
        return ext;
      } else {
        return this.memoizedExtension;
      }
    }

    hasExtensions() {
      return this.getExtensions() !== '';
    }

    getSegments() {
      return this.segments;
    }

    toString() {
      return this.join();
    }

    join() {
      if (this.memoizedFilename !== undefined) {
        return this.memoizedFilename;
      }

      const {segments: segments} = this;

      let filename;
      if (this.isWindows()) {
        filename = segments.join('\\');
      } else {
        filename = segments.join('/');
      }
      this.memoizedFilename = filename;
      return filename;
    }

    equal(other) {
      if (this.memoizedFilename !== undefined &&
      other.memoizedFilename !== undefined) {
        return this.memoizedFilename === other.memoizedFilename;
      }

      const a = this.getSegments();
      const b = other.getSegments();

      if (a.length !== b.length) {
        return false;
      }

      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }

      return true;
    }

    format(cwd) {
      const filename = this.join();
      const names = [];
      names.push(filename);

      if (this.isRelativeTo(___R$romejs$path$index_ts$HOME_PATH)) {
        const relativeToHome = ___R$romejs$path$index_ts$HOME_PATH.relative(this._assert());

        names.push(
        new ___R$romejs$path$index_ts$RelativeFilePath({
          segments: ['~', ...relativeToHome.getSegments()],
          absoluteType: 'posix',
          absoluteTarget: undefined}, {}).join());
      }

      if (cwd !== undefined) {
        names.push(cwd.relative(filename).join());
      }

      const human = names.sort((a, b) => a.length - b.length)[0];
      if (human === '') {
        return './';
      } else {
        return human;
      }
    }

    append(raw) {
      if (typeof raw === 'string') {
        const cached = this.memoizedChildren.get(raw);
        if (cached !== undefined) {
          return cached;
        }
      }

      const items = Array.isArray(raw) ? raw : [raw];

      let segments = this.getSegments();

      for (const item of items) {
        segments = segments.concat(___R$$priv$romejs$path$index_ts$toFilePath(item).getSegments());
      }

      const parsed = ___R$$priv$romejs$path$index_ts$parsePathSegments(segments);
      const child = this._fork(parsed, {});

      if (typeof raw === 'string') {
        this.memoizedChildren.set(raw, child);
      }

      return child;
    }
  }

  class ___R$romejs$path$index_ts$RelativeFilePath extends ___R$$priv$romejs$path$index_ts$BaseFilePath {
    constructor(...args) {
      super(...args);
      this.type = 'relative';
    }
    _assert() {
      return this;
    }

    _fork(parsed, opts) {
      return new ___R$romejs$path$index_ts$RelativeFilePath(parsed, opts);
    }

    assertRelative() {
      return this;
    }
  }

  class ___R$romejs$path$index_ts$AbsoluteFilePath extends ___R$$priv$romejs$path$index_ts$BaseFilePath {
    constructor(...args) {
      super(...args);
      this.type = 'absolute';
    }
    _assert() {
      return this;
    }

    _fork(parsed, opts) {
      return new ___R$romejs$path$index_ts$AbsoluteFilePath(parsed, opts);
    }

    assertAbsolute() {
      return this;
    }

    getChain() {
      if (this.chain !== undefined) {
        return this.chain;
      }

      const paths = [];
      this.chain = paths;

      let target = this;
      while (true) {
        paths.push(target);
        if (target.isRoot()) {
          break;
        } else {
          target = target.getParent();
        }
      }

      return paths;
    }

    resolveMaybeUrl(otherRaw) {
      const other = ___R$$priv$romejs$path$index_ts$toFilePath(otherRaw);
      if (other.isURL()) {
        return other.assertURL();
      } else {
        return this.resolve(other);
      }
    }

    resolve(otherRaw) {
      const other = ___R$$priv$romejs$path$index_ts$toFilePath(otherRaw);
      if (other.isAbsolute()) {
        return other.assertAbsolute();
      }

      return new ___R$romejs$path$index_ts$AbsoluteFilePath(___R$$priv$romejs$path$index_ts$parsePathSegments([...this.getSegments(), ...other.getSegments()]), {});
    }

    relative(otherRaw) {
      const other = this.resolve(___R$$priv$romejs$path$index_ts$toFilePath(otherRaw));

      if (other.equal(this)) {
        return ___R$romejs$path$index_ts$createRelativeFilePath('.');
      }

      const absolute = this.getSegments().slice();
      const relative = other.getSegments().slice();

      if (absolute[0] !== relative[0]) {
        return other;
      }

      while (absolute[0] === relative[0]) {
        absolute.shift();
        relative.shift();
      }

      let finalSegments = [];
      for (let i = 0; i < absolute.length; i++) {
        finalSegments.push('..');
      }
      finalSegments = finalSegments.concat(relative);

      return ___R$$priv$romejs$path$index_ts$createUnknownFilePathFromSegments(___R$$priv$romejs$path$index_ts$parsePathSegments(finalSegments));
    }
  }

  class ___R$romejs$path$index_ts$URLFilePath extends ___R$$priv$romejs$path$index_ts$BaseFilePath {
    constructor(...args) {
      super(...args);
      this.type = 'url';
    }
    _assert() {
      return this;
    }

    _fork(parsed, opts) {
      return new ___R$romejs$path$index_ts$URLFilePath(parsed, opts);
    }

    assertURL() {
      return this;
    }

    isURL() {
      return true;
    }

    getDomain() {
      return this.segments[2];
    }

    getProtocol() {
      const {absoluteTarget: absoluteTarget} = this;
      if (absoluteTarget === undefined) {
        throw new Error('Expected a URLFilePath to always have an absoluteTarget');
      }
      return absoluteTarget;
    }

    resolve(path) {
      if (path.isURL()) {
        return path.assertURL();
      } else if (path.isAbsolute()) {
        const domainSegments = this.getSegments().slice(0, 3);
        const finalSegments = [...domainSegments, ...path.getSegments()];
        return new ___R$romejs$path$index_ts$URLFilePath(___R$$priv$romejs$path$index_ts$parsePathSegments(finalSegments), {});
      } else {
        return this.append(path);
      }
    }
  }

  const ___R$romejs$path$index_ts$HOME_PATH = ___R$romejs$path$index_ts$createAbsoluteFilePath(___R$$priv$romejs$path$index_ts$os.userInfo().homedir);
  const ___R$romejs$path$index_ts$TEMP_PATH = ___R$romejs$path$index_ts$createAbsoluteFilePath(___R$$priv$romejs$path$index_ts$os.tmpdir());
  const ___R$romejs$path$index_ts$CWD_PATH = ___R$romejs$path$index_ts$createAbsoluteFilePath(process.cwd());

  function ___R$$priv$romejs$path$index_ts$getExtension(basename) {
    const match = basename.match(/\.(.*?)$/);
    if (match == null) {
      return '';
    } else {
      return match[0];
    }
  }

  function ___R$$priv$romejs$path$index_ts$isWindowsDrive(first) {
    return first.length === 2 && first[1] === ':' && /[A-Z]/i.test(first[0]);
  }

  function ___R$$priv$romejs$path$index_ts$parsePathSegments(segments) {
    if (segments.length === 0) {
      throw new Error('Cannot construct a FilePath with zero segments');
    }

    let absoluteType = 'posix';
    let absoluteTarget;
    let firstSeg = segments[0];

    if (firstSeg[firstSeg.length - 1] === ':' && segments[1] === '') {
      absoluteTarget = firstSeg.slice(0, -1);

      switch (absoluteTarget) {
        case 'file':
          return ___R$$priv$romejs$path$index_ts$parsePathSegments(segments.slice(2));

        default:
          const absoluteSegments = segments.slice(0, 3);
          return {
            segments: ___R$$priv$romejs$path$index_ts$normalizeSegments(
            segments,
            absoluteSegments.length,
            absoluteSegments),
            absoluteType: 'url',
            absoluteTarget: absoluteTarget};}
    }

    if (firstSeg === '~') {
      segments = [...___R$romejs$path$index_ts$HOME_PATH.getSegments()];
      firstSeg = segments[0];
    }

    let segmentOffset = 0;

    const absoluteSegments = [];
    if (firstSeg === '') {
      absoluteSegments.push('');
      absoluteTarget = 'posix';
      segmentOffset++;

      if (segments[1] === '' && segments.length >= 3 && segments[2] !== '') {
        const name = segments[2];
        segmentOffset += 2;
        absoluteSegments.push('');
        absoluteSegments.push(name);
        absoluteType = 'windows-unc';
        absoluteTarget = 'unc:' + name;
      }
    } else if (___R$$priv$romejs$path$index_ts$isWindowsDrive(firstSeg)) {
      const drive = firstSeg.toUpperCase();
      absoluteSegments.push(drive);
      absoluteType = 'windows-drive';
      absoluteTarget = 'drive:' + drive;
      segmentOffset++;
    }

    const pathSegments = ___R$$priv$romejs$path$index_ts$normalizeSegments(
    segments,
    segmentOffset,
    absoluteSegments);
    return {
      segments: pathSegments,
      absoluteType: absoluteType,
      absoluteTarget: absoluteTarget};
  }

  function ___R$$priv$romejs$path$index_ts$normalizeSegments(segments, offset, absoluteSegments) {
    const pathSegments = [];
    for (let i = offset; i < segments.length; i++) {
      let seg = segments[i];

      if (seg === '.' &&
      (segments[1] === '..' || i > 0 || absoluteSegments.length > 0)) {
        continue;
      }

      if (seg === '') {
        continue;
      }

      if (seg === '..' &&
      pathSegments.length > 0 &&
      pathSegments[pathSegments.length - 1] !== '..') {
        pathSegments.pop();
        continue;
      }

      pathSegments.push(seg);
    }

    return [...absoluteSegments, ...pathSegments];
  }

  function ___R$$priv$romejs$path$index_ts$createUnknownFilePathFromSegments(parsed) {
    const path = new ___R$$priv$romejs$path$index_ts$BaseFilePath(parsed, {});

    if (path.isAbsolute()) {
      return path.assertAbsolute();
    } else {
      return path.assertRelative();
    }
  }

  function ___R$romejs$path$index_ts$createFilePathFromSegments(segments) {
    const parsed = ___R$$priv$romejs$path$index_ts$parsePathSegments(segments);
    return ___R$$priv$romejs$path$index_ts$createUnknownFilePathFromSegments(parsed);
  }

  function ___R$romejs$path$index_ts$toJoinedFilePath(filename) {
    if (typeof filename === 'string') {
      return filename;
    } else {
      return ___R$romejs$path$index_ts$createUnknownFilePath(filename).join();
    }
  }

  function ___R$romejs$path$index_ts$createRelativeFilePath(filename) {
    return ___R$romejs$path$index_ts$createUnknownFilePath(filename).assertRelative();
  }

  function ___R$romejs$path$index_ts$createURLFilePath(filename) {
    return ___R$romejs$path$index_ts$createUnknownFilePath(filename).assertURL();
  }

  function ___R$romejs$path$index_ts$createAbsoluteFilePath(filename) {
    return ___R$romejs$path$index_ts$createUnknownFilePath(filename).assertAbsolute();
  }

  function ___R$romejs$path$index_ts$createUnknownFilePath(filename) {
    if (filename instanceof ___R$$priv$romejs$path$index_ts$BaseFilePath) {
      return filename;
    }

    const segments = filename.split(/[\\\/]/g);
    const parsed = ___R$$priv$romejs$path$index_ts$parsePathSegments(segments);
    return ___R$$priv$romejs$path$index_ts$createUnknownFilePathFromSegments(parsed);
  }

  function ___R$romejs$path$index_ts$maybeCreateURLFilePath(filename) {
    if (filename !== undefined) {
      return ___R$romejs$path$index_ts$createURLFilePath(filename);
    }
  }

  function ___R$romejs$path$index_ts$maybeCreateRelativeFilePath(filename) {
    if (filename !== undefined) {
      return ___R$romejs$path$index_ts$createRelativeFilePath(filename);
    }
  }

  function ___R$romejs$path$index_ts$maybeCreateAbsoluteFilePath(filename) {
    if (filename !== undefined) {
      return ___R$romejs$path$index_ts$createAbsoluteFilePath(filename);
    }
  }

  function ___R$romejs$path$index_ts$maybeCreateUnknownFilePath(filename) {
    if (filename !== undefined) {
      return ___R$romejs$path$index_ts$createUnknownFilePath(filename);
    }
  }

  // romejs/parser-core/index.ts


  function ___R$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(parserOpts, opts) {
    try {
      return opts.parse(parserOpts);
    } catch (err) {
      const diagnostics = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
      if (diagnostics === undefined) {
        throw err;
      } else {
        opts.parse(Object.assign({}, parserOpts, {
          offsetPosition: opts.getOffsetPosition()}));
        throw new Error('Expected error');
      }
    }
  }

  const ___R$$priv$romejs$parser$core$index_ts$SOF_TOKEN = {
    type: 'SOF',
    start: ___R$romejs$ob1$index_ts$number0Neg1,
    end: ___R$romejs$ob1$index_ts$number0Neg1};

  class ___R$romejs$parser$core$index_ts$ParserCore {
    constructor(opts, parserName, initialState) {
      const {path: path, mtime: mtime, input: input, offsetPosition: offsetPosition} = opts;

      this.path = path === undefined ? undefined : ___R$romejs$path$index_ts$createUnknownFilePath(path);
      this.filename = this.path === undefined ? undefined : this.path.join();
      this.mtime = mtime;
      this.input = input === undefined ? '' : input;
      this.length = ___R$romejs$ob1$index_ts$coerce0(this.input.length);

      this.eofToken = {
        type: 'EOF',
        start: ___R$romejs$ob1$index_ts$coerce0(this.input.length),
        end: ___R$romejs$ob1$index_ts$coerce0(this.input.length)};

      this.offsetPosition = offsetPosition;
      this.parserName = parserName;
      this.tokenizing = false;
      this.currLine =
      offsetPosition === undefined ? ___R$romejs$ob1$index_ts$number1 : offsetPosition.line;
      this.currColumn =
      offsetPosition === undefined ? ___R$romejs$ob1$index_ts$number0 : offsetPosition.column;
      this.startLine = this.currLine;
      this.startColumn = this.currColumn;
      this.nextTokenIndex = ___R$romejs$ob1$index_ts$number0;
      this.currentToken = ___R$$priv$romejs$parser$core$index_ts$SOF_TOKEN;
      this.prevToken = ___R$$priv$romejs$parser$core$index_ts$SOF_TOKEN;
      this.state = initialState;
    }

    getPathAssert() {
      const {path: path} = this;
      if (path === undefined) {
        throw new Error('Path expected but none was passed to this Parser');
      } else {
        return path;
      }
    }

    getFilenameAssert() {
      const {filename: filename} = this;
      if (filename === undefined) {
        throw new Error('Filename expected but none was passed to this Parser');
      } else {
        return filename;
      }
    }

    tokenizeAll() {
      const tokens = [];
      try {
        while (!this.matchToken('EOF')) {
          tokens.push(this.getToken());
          this.nextToken();
        }
      } catch (err) {
        const diagnostics = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
        if (diagnostics === undefined) {
          throw err;
        } else {
          tokens.push({
            type: 'Invalid',
            start: this.nextTokenIndex,
            end: this.length});
        }
      }
      return tokens;
    }

    tokenize(index, input) {
      throw new Error('Unimplemented');
    }

    tokenizeWithState(index, input, state) {
      const token = this.tokenize(index, input);
      if (token !== undefined) {
        return {token: token, state: state};
      }
    }

    getToken() {
      const {currentToken: currentToken} = this;
      if (currentToken === ___R$$priv$romejs$parser$core$index_ts$SOF_TOKEN) {
        return this.nextToken();
      } else {
        return currentToken;
      }
    }

    getPrevToken() {
      return this.prevToken;
    }

    nextToken() {
      if (this.isEOF()) {
        this.currentToken = this.eofToken;
        return this.eofToken;
      }

      if (this.tokenizing) {
        throw new Error('Can\'t call nextToken while tokenizing');
      }

      const prevToken = this.currentToken;
      const {token: nextToken, state: state} = this.lookahead();

      if (nextToken.end === prevToken.end) {
        throw new Error('tokenize() returned a token with the same position as the last - Previous token: ' + JSON.stringify(
        prevToken) + '; Next token: ' + JSON.stringify(nextToken) + '; Input: ' + this.input.slice(
        0,
        100));
      }

      for (let i = ___R$romejs$ob1$index_ts$get0(prevToken.start); i < ___R$romejs$ob1$index_ts$get0(nextToken.start); i++) {
        const char = this.input[i];
        if (char === '\n') {
          this.currLine = ___R$romejs$ob1$index_ts$inc(this.currLine);
          this.currColumn = ___R$romejs$ob1$index_ts$number0;
        } else {
          this.currColumn = ___R$romejs$ob1$index_ts$inc(this.currColumn);
        }
      }

      this.nextTokenIndex = nextToken.end;
      this.prevToken = prevToken;
      this.currentToken = nextToken;
      this.state = state;
      return nextToken;
    }

    getPosition() {
      const {currentToken: currentToken} = this;
      return {
        index: currentToken === undefined ? ___R$romejs$ob1$index_ts$number0 : currentToken.start,
        line: this.currLine,
        column: this.currColumn};
    }

    getEndPosition() {
      const token = this.getToken();
      return this.getPositionFromIndex(token.end);
    }

    getPrevEndPosition() {
      return this.getPositionFromIndex(this.prevToken.end);
    }

    lookaheadToken(index) {
      return this.lookahead(index).token;
    }

    lookahead(index = this.nextTokenIndex) {
      if (this.isEOF(index)) {
        return {token: this.eofToken, state: this.state};
      }

      const prevNextTokenIndex = this.nextTokenIndex;
      this.nextTokenIndex = index;

      const wasTokenizing = this.tokenizing;
      this.tokenizing = true;

      const nextToken = this.tokenizeWithState(index, this.input, this.state);
      if (nextToken === undefined) {
        throw this.unexpected({
          start: this.getPositionFromIndex(index)});
      }

      this.tokenizing = wasTokenizing;
      this.nextTokenIndex = prevNextTokenIndex;

      return nextToken;
    }

    getPositionFromIndex(index) {
      const targetIndex = index;

      let line = this.startLine;
      let column = this.startColumn;

      const currPosition = this.getPosition();
      if (currPosition.index < index) {
        line = currPosition.line;
        column = currPosition.column;
        index = ___R$romejs$ob1$index_ts$sub(index, currPosition.index);
      }

      for (let i = 0; i < ___R$romejs$ob1$index_ts$get0(index); i++) {
        const char = this.input[i];

        if (char === '\n') {
          line = ___R$romejs$ob1$index_ts$inc(line);
          column = ___R$romejs$ob1$index_ts$number0;
        } else {
          column = ___R$romejs$ob1$index_ts$inc(column);
        }
      }

      return {
        index: targetIndex,
        line: line,
        column: column};
    }

    unexpected(opts = {}) {
      const {currentToken: currentToken} = this;
      let {message: message, start: start, end: end, loc: loc} = opts;

      if (loc !== undefined) {
        start = loc.start;
        end = loc.end;
      }

      if (start === undefined && end === undefined) {
        end = this.getEndPosition();
      }

      if (start === undefined) {
        start = this.getPosition();
      }

      if (end === undefined) {
        end = start;
      }

      if (end.index === ___R$romejs$ob1$index_ts$number0) {
        end = start;
      }

      if (message === undefined) {
        if (currentToken !== undefined &&
        start !== undefined &&
        start.index === currentToken.start) {
          message = 'Unexpected ' + currentToken.type;
        } else {
          const char = this.input[___R$romejs$ob1$index_ts$get0(start.index)];
          message = 'Unexpected character <emphasis>' + ___R$romejs$string$markup$escape_ts$escapeMarkup(
          char) + '</emphasis>';
        }
      }

      let errMessage = message + ' (' + start.line + ':' + start.column + ')';
      if (this.path !== undefined) {
        errMessage = this.path + ': ' + errMessage + ' Input: ' + this.input;
      }

      throw new ___R$romejs$diagnostics$errors_ts$DiagnosticsError(errMessage, [{
        message: message,
        advice: opts.advice,
        category: this.parserName,
        sourceText: this.path === undefined ? this.input : undefined,
        mtime: this.mtime,
        start: start,
        end: end,
        filename: this.filename}]);
    }

    assertNoSpace() {
      if (this.currentToken.start !== this.prevToken.end) {
        throw this.unexpected({
          message: 'Expected no space between'});
      }
    }

    eatToken(type) {
      if (this.matchToken(type)) {
        return this.nextToken();
      }
    }

    isEOF(index = this.nextTokenIndex) {
      return ___R$romejs$ob1$index_ts$get0(index) >= this.input.length;
    }

    matchToken(type) {
      return this.getToken().type === type;
    }

    expectToken(type, message) {
      const token = this.getToken();
      if (token.type === type) {
        this.nextToken();

        return token;
      } else {
        throw this.unexpected({
          message: message === undefined ? 'Expected token ' + type + ' but got ' + token.type : message});
      }
    }

    readInputFrom(index, callback) {
      const {input: input} = this;
      let value = '';

      while (___R$romejs$ob1$index_ts$get0(index) < input.length &&
      callback(input[___R$romejs$ob1$index_ts$get0(index)], index, input)) {
        value += input[___R$romejs$ob1$index_ts$get0(index)];
        index = ___R$romejs$ob1$index_ts$inc(index);
      }

      return value;
    }

    getRawInput(start, end) {
      return this.input.slice(___R$romejs$ob1$index_ts$get0(start), ___R$romejs$ob1$index_ts$get0(end));
    }

    getLoc(node) {
      if (node === undefined || node.loc === undefined) {
        throw new Error('Tried to fetch node loc start but none found');
      } else {
        return node.loc;
      }
    }

    finishToken(type, end = ___R$romejs$ob1$index_ts$inc(this.nextTokenIndex)) {
      return {
        type: type,
        start: this.nextTokenIndex,
        end: end};
    }

    finishValueToken(type, value, end = ___R$romejs$ob1$index_ts$inc(this.nextTokenIndex)) {
      return {
        type: type,
        value: value,
        start: this.nextTokenIndex,
        end: end};
    }

    finishLoc(start) {
      return this.finishLocAt(start, this.getEndPosition());
    }

    finishLocAt(start, end) {
      return {
        filename: this.filename,
        start: start,
        end: end};
    }

    finalize() {
      if (!this.eatToken('EOF')) {
        throw this.unexpected({
          message: 'Expected end of file'});
      }
    }
  }

  class ___R$romejs$parser$core$index_ts$ParserWithRequiredPath extends ___R$romejs$parser$core$index_ts$ParserCore {
    constructor(opts, parserName, initialState) {
      super(opts, parserName, initialState);
      this.filename = this.getFilenameAssert();
      this.path = this.getPathAssert();
    }
  }

  function ___R$romejs$parser$core$index_ts$isDigit(char) {
    return char !== undefined && /[0-9]/.test(char);
  }

  function ___R$romejs$parser$core$index_ts$isAlpha(char) {
    return char !== undefined && /[A-Za-z]/.test(char);
  }

  function ___R$romejs$parser$core$index_ts$isHexDigit(char) {
    return char !== undefined && /[0-9A-Fa-f]/.test(char);
  }

  function ___R$romejs$parser$core$index_ts$isESIdentifier(char) {
    return char !== undefined && /[A-F0-9a-z_$]/.test(char);
  }

  function ___R$romejs$parser$core$index_ts$isESIdentifierStart(char) {
    return char !== undefined && /[A-Fa-z_$]/.test(char);
  }

  function ___R$romejs$parser$core$index_ts$isEscaped(index, input) {
    const prevChar = input[___R$romejs$ob1$index_ts$get0(index) - 1];
    const prevPrevChar = input[___R$romejs$ob1$index_ts$get0(index) - 2];
    const isEscaped = prevChar === '\\' && prevPrevChar !== '\\';
    return isEscaped;
  }

  function ___R$romejs$parser$core$index_ts$readUntilLineBreak(char) {
    return char !== '\n';
  }

  function ___R$romejs$parser$core$index_ts$createParser(callback) {
    let klass;

    return (...args) => {
      if (klass === undefined) {
        klass = callback(___R$romejs$parser$core$index_ts$ParserCore, ___R$romejs$parser$core$index_ts$ParserWithRequiredPath);
      }

      return new klass(...args);
    };
  }

  // romejs/string-escape/escapeString.ts

  const ___R$$priv$romejs$string$escape$escapeString_ts$PRINTABLE_ASCII = /[ !#-&\(-\[\]-_a-~]/;

  function ___R$$priv$romejs$string$escape$escapeString_ts$escapeChar(char, ignoreWhitespaceEscapes) {
    switch (char) {
      case '"':
        return '\\"';

      case '\'':
        return '\\\'';

      case '\b':
        return '\\b';

      case '\f':
        return '\\f';

      case '\\':
        return '\\\\';}

    if (ignoreWhitespaceEscapes) {
      return undefined;
    }

    switch (char) {
      case '\n':
        return '\\n';

      case '\r':
        return '\\r';

      case '\t':
        return '\\t';}

    return undefined;
  }

  function ___R$romejs$string$escape$escapeString_ts$default(str, opts = {}) {
    let index = -1;
    let result = '';

    const quote = opts.quote === undefined ? ___R$romejs$string$escape$constants_ts$DOUBLE_QUOTE : opts.quote;
    const isJSON = opts.json === undefined ? false : opts.json;
    const ignoreEscapes = opts.ignoreWhitespaceEscapes === undefined ? false : true;

    while (++index < str.length) {
      const char = str[index];

      if (isJSON === false) {
        const charCode = str.charCodeAt(index);
        const isHighSurrogate = charCode >= 55296 && charCode <= 56319;
        const hasNextCodePoint = str.length > index + 1;
        const isSurrogatePairStart = isHighSurrogate && hasNextCodePoint;

        if (isSurrogatePairStart) {
          const nextCharCode = str.charCodeAt(index + 1);
          const isLowSurrogate = nextCharCode >= 56320 && nextCharCode <= 57343;
          if (isLowSurrogate) {
            const codePoint = (charCode - 55296) * 1024 + nextCharCode - 56320 + 65536;
            const hex = codePoint.toString(16);
            result += '\\u{' + hex + '}';
            index++;
            continue;
          }
        }
      }

      if (___R$$priv$romejs$string$escape$escapeString_ts$PRINTABLE_ASCII.test(char)) {
        result += char;
        continue;
      }

      if (char == ___R$romejs$string$escape$constants_ts$DOUBLE_QUOTE) {
        result += quote == char ? '\\"' : char;
        continue;
      }

      if (char == ___R$romejs$string$escape$constants_ts$SINGLE_QUOTE) {
        result += quote == char ? '\\\'' : char;
        continue;
      }

      if (char == ___R$romejs$string$escape$constants_ts$TICK_QUOTE) {
        result += quote == char ? '\\`' : char;
        continue;
      }

      if (char == '\0' && !isJSON && !___R$romejs$parser$core$index_ts$isDigit(str[index + 1])) {
        result += '\\0';
        continue;
      }

      const replacement = ___R$$priv$romejs$string$escape$escapeString_ts$escapeChar(char, ignoreEscapes);
      if (replacement !== undefined) {
        result += replacement;
        continue;
      }

      const hex = char.charCodeAt(0).toString(16);
      const isLonghand = isJSON || hex.length > 2;
      const modifier = isLonghand ? 'u' : 'x';
      const code = ('0000' + hex).slice(isLonghand ? -4 : -2);
      const escaped = '\\' + modifier + code;
      result += escaped;
      continue;
    }

    return quote + result + quote;
  }

  // romejs/string-escape/unescapeString.ts

  function ___R$$priv$romejs$string$escape$unescapeString_ts$unescapeChar(modifier) {
    switch (modifier) {
      case 'b':
        return '\b';

      case 'f':
        return '\f';

      case 'n':
        return '\n';

      case 'r':
        return '\r';

      case 't':
        return '\t';

      case 'v':
        return '\x0b';

      default:
        return modifier;}
  }

  const ___R$$priv$romejs$string$escape$unescapeString_ts$UNEXPECTED_DEFAULT_THROWER = (message, index) => {
    throw new TypeError(message + ' (' + String(index) + ')');
  };

  function ___R$romejs$string$escape$unescapeString_ts$default(input, unexpected = ___R$$priv$romejs$string$escape$unescapeString_ts$UNEXPECTED_DEFAULT_THROWER) {
    let buffer = '';

    let index = 0;

    while (index < input.length) {
      const char = input[index];
      const prevChar = input[index - 1];
      const prevPrevChar = input[index - 2];
      const isEscaped = prevChar === '\\' && prevPrevChar !== '\\';

      if (isEscaped && char === '\\' || char !== '\\') {
        const codePoint = char.codePointAt(0);
        if (codePoint === undefined) {
          throw new Error('Already validated that this index exists');
        }
        if (codePoint >= 0 && codePoint <= 31) {
          throw unexpected(___R$romejs$string$escape$messages_ts$INVALID_STRING_CHARACTER, index);
        }

        buffer += char;
        index++;
        continue;
      }

      const modifierIndex = index + 1;
      const modifier = input[modifierIndex];

      if (modifier === 'u') {
        const codeStartIndex = modifierIndex + 1;
        const rawCode = input.slice(codeStartIndex, codeStartIndex + 4);

        if (rawCode.length < 4) {
          const lastDigitIndex = codeStartIndex + rawCode.length - 1;
          throw unexpected(___R$romejs$string$escape$messages_ts$NOT_ENOUGH_CODE_POINTS, lastDigitIndex);
        }

        for (let i = 0; i < rawCode.length; i++) {
          const char = rawCode[i];
          if (!___R$romejs$parser$core$index_ts$isHexDigit(char)) {
            const pos = codeStartIndex + i;
            throw unexpected(___R$romejs$string$escape$messages_ts$INVALID_HEX_DIGIT_FOR_ESCAPE, pos);
          }
        }

        const code = parseInt(rawCode, 16);

        buffer += String.fromCodePoint(code);

        index += 6;
      } else {
        buffer += ___R$$priv$romejs$string$escape$unescapeString_ts$unescapeChar(modifier);

        index += 2;
      }
    }

    return buffer;
  }

  // romejs/string-escape/index.ts

  const ___R$romejs$string$escape$index_ts$messages = ___R$romejs$string$escape$messages_ts

  // romejs/string-markup/parse.ts

  const ___R$romejs$string$markup$parse_ts = {
    isTagChar: ___R$romejs$string$markup$parse_ts$isTagChar,
    parseMarkup: ___R$romejs$string$markup$parse_ts$parseMarkup};
  const ___R$$priv$romejs$string$markup$parse_ts$globalAttributes = ['emphasis', 'dim'];

  const ___R$$priv$romejs$string$markup$parse_ts$tags = new Map();
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('emphasis', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('number', ['approx']);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('hyperlink', ['target']);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('filelink', ['target', 'column', 'line']);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('inverse', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('dim', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('filesize', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('duration', ['approx']);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('italic', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('underline', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('strike', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('black', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('brightBlack', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('red', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('brightRed', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('green', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('brightGreen', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('yellow', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('brightYellow', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('blue', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('brightBlue', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('magenta', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('brightMagenta', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('cyan', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('brightCyan', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('white', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('brightWhite', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgBlack', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgBrightBlack', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgRed', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgBrightRed', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgGreen', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgBrightGreen', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgYellow', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgBrightYellow', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgBlue', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgBrightBlue', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgMagenta', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgBrightMagenta', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgCyan', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgBrightCyan', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgWhite', []);
  ___R$$priv$romejs$string$markup$parse_ts$tags.set('bgBrightWhite', []);

  function ___R$$priv$romejs$string$markup$parse_ts$isStringValueChar(char, index, input) {
    if (char === '"' && !___R$romejs$parser$core$index_ts$isEscaped(index, input)) {
      return false;
    }

    return true;
  }

  function ___R$$priv$romejs$string$markup$parse_ts$isTextChar(char, index, input) {
    return !___R$romejs$string$markup$parse_ts$isTagChar(index, input);
  }

  function ___R$romejs$string$markup$parse_ts$isTagChar(index, input) {
    const i = ___R$romejs$ob1$index_ts$get0(index);
    return input[i] === '<' &&
    !___R$romejs$parser$core$index_ts$isEscaped(index, input) &&
    (___R$romejs$parser$core$index_ts$isAlpha(input[i + 1]) || input[i + 1] === '/');
  }

  const ___R$$priv$romejs$string$markup$parse_ts$createStringMarkupParser = ___R$romejs$parser$core$index_ts$createParser(
  ParserCore => class StringMarkupParser extends ParserCore {
    constructor(opts) {
      super(opts, '@romejs/string-markup', {inTagHead: false});
    }

    tokenizeWithState(index, input, state) {
      const escaped = ___R$romejs$parser$core$index_ts$isEscaped(index, input);
      const char = input[___R$romejs$ob1$index_ts$get0(index)];

      if (!escaped && state.inTagHead) {
        if (char === ' ') {
          return this.lookahead(___R$romejs$ob1$index_ts$inc(index));
        }

        if (char === '=') {
          return {
            state: state,
            token: this.finishToken('Equals')};
        }

        if (char === '/') {
          return {
            state: state,
            token: this.finishToken('Slash')};
        }

        if (___R$romejs$parser$core$index_ts$isAlpha(char)) {
          const value = this.readInputFrom(index, ___R$romejs$parser$core$index_ts$isAlpha);
          return {
            state: state,
            token: this.finishValueToken(
            'Word',
            value,
            ___R$romejs$ob1$index_ts$add(index, value.length))};
        }

        if (char === '"') {
          const value = this.readInputFrom(___R$romejs$ob1$index_ts$inc(index), ___R$$priv$romejs$string$markup$parse_ts$isStringValueChar);
          const end = ___R$romejs$ob1$index_ts$add(___R$romejs$ob1$index_ts$add(index, value.length), 2);

          if (input[___R$romejs$ob1$index_ts$get0(end) - 1] !== '"') {
            throw this.unexpected({
              message: 'Unclosed string',
              start: this.getPositionFromIndex(end)});
          }

          const unescaped = ___R$romejs$string$escape$unescapeString_ts$default(value);
          return {
            state: state,
            token: this.finishValueToken('String', unescaped, end)};
        }

        if (char === '>') {
          return {
            state: {
              inTagHead: false},
            token: this.finishToken('Greater')};
        }
      }

      if (___R$romejs$string$markup$parse_ts$isTagChar(index, input)) {
        return {
          state: {
            inTagHead: true},
          token: this.finishToken('Less')};
      }

      const value = this.readInputFrom(index, ___R$$priv$romejs$string$markup$parse_ts$isTextChar);
      return {
        state: state,
        token: {
          type: 'Text',
          value: ___R$$priv$romejs$string$markup$parse_ts$normalizeTextValue(value),
          start: index,
          end: ___R$romejs$ob1$index_ts$add(index, value.length)}};
    }

    atTagEnd() {
      return this.matchToken('Less') && this.lookahead().token.type === 'Slash';
    }

    parseTag() {
      const nameToken = this.expectToken('Word');
      const rawName = nameToken.value;

      const allowedAttributes = ___R$$priv$romejs$string$markup$parse_ts$tags.get(rawName);
      if (allowedAttributes === undefined) {
        throw this.unexpected({
          message: 'Unknown tag name <emphasis>' + rawName + '</emphasis>',
          start: this.getPositionFromIndex(nameToken.start)});
      }

      const tagName = rawName;
      const attributes = new Map();
      const children = [];
      let selfClosing = false;

      while (!this.matchToken('EOF') && !this.matchToken('Greater')) {
        const keyToken = this.getToken();

        let key;
        if (keyToken.type === 'Word') {
          key = keyToken.value;

          if (!allowedAttributes.includes(key) &&
          !___R$$priv$romejs$string$markup$parse_ts$globalAttributes.includes(key)) {
            throw this.unexpected({
              message: key + ' is not a valid attribute name for <' + tagName + '>'});
          }

          this.nextToken();

          if (this.matchToken('Word') ||
          this.matchToken('Slash') ||
          this.matchToken('Greater')) {
            attributes.set(key, 'true');
            continue;
          }

          this.expectToken('Equals');

          const valueToken = this.expectToken('String');
          if (valueToken.type !== 'String') {
            throw new Error('Expected String');
          }
          const value = valueToken.value;

          attributes.set(key, value);
        } else if (keyToken.type === 'Slash') {
          this.nextToken();
          selfClosing = true;
        } else {
          throw this.unexpected({
            message: 'Expected attribute name'});
        }
      }

      this.expectToken('Greater');

      if (!selfClosing) {
        while (!this.matchToken('EOF') && !this.atTagEnd()) {
          children.push(this.parseChild());
        }

        if (this.matchToken('EOF')) {
          throw this.unexpected({
            message: 'Unclosed ' + tagName + ' tag'});
        } else {
          this.expectToken('Less');
          this.expectToken('Slash');

          const name = this.getToken();
          if (name.type === 'Word') {
            if (name.value !== tagName) {
              throw this.unexpected({
                message: 'Expected to close ' + tagName + ' but found ' + name.value});
            }

            this.nextToken();
          } else {
            throw this.unexpected({
              message: 'Expected closing tag name'});
          }

          this.expectToken('Greater');
        }
      }

      return {
        type: 'Tag',
        attributes: attributes,
        name: tagName,
        children: children};
    }

    parseChild() {
      const token = this.getToken();
      this.nextToken();

      if (token.type === 'Text') {
        return {
          type: 'Text',
          value: token.value};
      } else if (token.type === 'Less') {
        return this.parseTag();
      } else {
        throw this.unexpected({
          message: 'Unknown child start'});
      }
    }

    parse() {
      const children = [];
      while (!this.matchToken('EOF')) {
        children.push(this.parseChild());
      }
      return children;
    }
  });

  function ___R$romejs$string$markup$parse_ts$parseMarkup(input) {
    try {
      return ___R$$priv$romejs$string$markup$parse_ts$createStringMarkupParser({input: input}).parse();
    } catch (err) {
      throw err;
    }
  }

  function ___R$$priv$romejs$string$markup$parse_ts$normalizeTextValue(str) {
    return str.replace(/\\<([a-zA-Z\/])/g, '<$1');
  }

  // romejs/string-utils/orderBySimilarity.ts

  const ___R$romejs$string$utils$orderBySimilarity_ts = {
    orderBySimilarity: ___R$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity};
  function ___R$$priv$romejs$string$utils$orderBySimilarity_ts$getMap(map, key, defaultValue) {
    const existing = map.get(key);

    if (existing === undefined) {
      if (defaultValue === undefined) {
        throw new Error('Key didn\'t exist and no defaultValue passed');
      }

      map.set(key, defaultValue);
      return defaultValue;
    } else {
      return existing;
    }
  }

  function ___R$$priv$romejs$string$utils$orderBySimilarity_ts$compareTwoStrings(aStr, bStr) {
    const a = aStr.replace(/\s+/g, '');
    const b = bStr.replace(/\s+/g, '');

    if (!a.length && !b.length) {
      return 1;
    }

    if (!a.length || !b.length) {
      return 0;
    }

    if (a === b) {
      return 1;
    }

    if (a.length === 1 && b.length === 1) {
      return 0;
    }

    if (a.length < 2 || b.length < 2) {
      return 0;
    }

    let firstBigrams = new Map();
    for (let i = 0; i < a.length - 1; i++) {
      const bigram = a.substring(i, i + 2);

      const count = firstBigrams.has(bigram) ? ___R$$priv$romejs$string$utils$orderBySimilarity_ts$getMap(firstBigrams, bigram) + 1 : 1;
      if (count === undefined) {
        throw new Error('Already used has() above');
      }

      firstBigrams.set(bigram, count);
    }

    let intersectionSize = 0;
    for (let i = 0; i < b.length - 1; i++) {
      const bigram = b.substring(i, i + 2);

      const count = ___R$$priv$romejs$string$utils$orderBySimilarity_ts$getMap(firstBigrams, bigram, 0);
      if (count === undefined) {
        throw new Error('Already used has() above');
      }

      if (count > 0) {
        firstBigrams.set(bigram, count - 1);
        intersectionSize++;
      }
    }

    return 2 * intersectionSize / (a.length + b.length - 2);
  }

  function ___R$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(compareStr, targets, minRating, strMap) {
    if (targets.length === 0) {
      return [];
    }

    const ratings = Array.from(
    targets,
    target => {
      let compareTarget = target;
      if (strMap !== undefined) {
        compareTarget = strMap(target);
      }

      return {
        target: target,
        rating: ___R$$priv$romejs$string$utils$orderBySimilarity_ts$compareTwoStrings(compareStr, compareTarget)};
    });

    const sortedRatings = ratings.sort((a, b) => {
      return b.rating - a.rating;
    }).filter(item => minRating === undefined || item.rating >= minRating);

    return sortedRatings;
  }

  // romejs/string-charcodes/index.ts

  const ___R$romejs$string$charcodes$index_ts = {
    get backSpace() {
      return ___R$romejs$string$charcodes$index_ts$backSpace;
    },
    get tab() {
      return ___R$romejs$string$charcodes$index_ts$tab;
    },
    get lineFeed() {
      return ___R$romejs$string$charcodes$index_ts$lineFeed;
    },
    get carriageReturn() {
      return ___R$romejs$string$charcodes$index_ts$carriageReturn;
    },
    get shiftOut() {
      return ___R$romejs$string$charcodes$index_ts$shiftOut;
    },
    get space() {
      return ___R$romejs$string$charcodes$index_ts$space;
    },
    get exclamationMark() {
      return ___R$romejs$string$charcodes$index_ts$exclamationMark;
    },
    get quotationMark() {
      return ___R$romejs$string$charcodes$index_ts$quotationMark;
    },
    get numberSign() {
      return ___R$romejs$string$charcodes$index_ts$numberSign;
    },
    get dollarSign() {
      return ___R$romejs$string$charcodes$index_ts$dollarSign;
    },
    get percentSign() {
      return ___R$romejs$string$charcodes$index_ts$percentSign;
    },
    get ampersand() {
      return ___R$romejs$string$charcodes$index_ts$ampersand;
    },
    get apostrophe() {
      return ___R$romejs$string$charcodes$index_ts$apostrophe;
    },
    get leftParenthesis() {
      return ___R$romejs$string$charcodes$index_ts$leftParenthesis;
    },
    get rightParenthesis() {
      return ___R$romejs$string$charcodes$index_ts$rightParenthesis;
    },
    get asterisk() {
      return ___R$romejs$string$charcodes$index_ts$asterisk;
    },
    get plusSign() {
      return ___R$romejs$string$charcodes$index_ts$plusSign;
    },
    get comma() {
      return ___R$romejs$string$charcodes$index_ts$comma;
    },
    get dash() {
      return ___R$romejs$string$charcodes$index_ts$dash;
    },
    get dot() {
      return ___R$romejs$string$charcodes$index_ts$dot;
    },
    get slash() {
      return ___R$romejs$string$charcodes$index_ts$slash;
    },
    get digit0() {
      return ___R$romejs$string$charcodes$index_ts$digit0;
    },
    get digit1() {
      return ___R$romejs$string$charcodes$index_ts$digit1;
    },
    get digit2() {
      return ___R$romejs$string$charcodes$index_ts$digit2;
    },
    get digit3() {
      return ___R$romejs$string$charcodes$index_ts$digit3;
    },
    get digit4() {
      return ___R$romejs$string$charcodes$index_ts$digit4;
    },
    get digit5() {
      return ___R$romejs$string$charcodes$index_ts$digit5;
    },
    get digit6() {
      return ___R$romejs$string$charcodes$index_ts$digit6;
    },
    get digit7() {
      return ___R$romejs$string$charcodes$index_ts$digit7;
    },
    get digit8() {
      return ___R$romejs$string$charcodes$index_ts$digit8;
    },
    get digit9() {
      return ___R$romejs$string$charcodes$index_ts$digit9;
    },
    get colon() {
      return ___R$romejs$string$charcodes$index_ts$colon;
    },
    get semicolon() {
      return ___R$romejs$string$charcodes$index_ts$semicolon;
    },
    get lessThan() {
      return ___R$romejs$string$charcodes$index_ts$lessThan;
    },
    get equalsTo() {
      return ___R$romejs$string$charcodes$index_ts$equalsTo;
    },
    get greaterThan() {
      return ___R$romejs$string$charcodes$index_ts$greaterThan;
    },
    get questionMark() {
      return ___R$romejs$string$charcodes$index_ts$questionMark;
    },
    get atSign() {
      return ___R$romejs$string$charcodes$index_ts$atSign;
    },
    get uppercaseA() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseA;
    },
    get uppercaseB() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseB;
    },
    get uppercaseC() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseC;
    },
    get uppercaseD() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseD;
    },
    get uppercaseE() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseE;
    },
    get uppercaseF() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseF;
    },
    get uppercaseG() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseG;
    },
    get uppercaseH() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseH;
    },
    get uppercaseI() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseI;
    },
    get uppercaseJ() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseJ;
    },
    get uppercaseK() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseK;
    },
    get uppercaseL() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseL;
    },
    get uppercaseM() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseM;
    },
    get uppercaseN() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseN;
    },
    get uppercaseO() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseO;
    },
    get uppercaseP() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseP;
    },
    get uppercaseQ() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseQ;
    },
    get uppercaseR() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseR;
    },
    get uppercaseS() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseS;
    },
    get uppercaseT() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseT;
    },
    get uppercaseU() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseU;
    },
    get uppercaseV() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseV;
    },
    get uppercaseW() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseW;
    },
    get uppercaseX() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseX;
    },
    get uppercaseY() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseY;
    },
    get uppercaseZ() {
      return ___R$romejs$string$charcodes$index_ts$uppercaseZ;
    },
    get leftSquareBracket() {
      return ___R$romejs$string$charcodes$index_ts$leftSquareBracket;
    },
    get backslash() {
      return ___R$romejs$string$charcodes$index_ts$backslash;
    },
    get rightSquareBracket() {
      return ___R$romejs$string$charcodes$index_ts$rightSquareBracket;
    },
    get caret() {
      return ___R$romejs$string$charcodes$index_ts$caret;
    },
    get underscore() {
      return ___R$romejs$string$charcodes$index_ts$underscore;
    },
    get graveAccent() {
      return ___R$romejs$string$charcodes$index_ts$graveAccent;
    },
    get lowercaseA() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseA;
    },
    get lowercaseB() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseB;
    },
    get lowercaseC() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseC;
    },
    get lowercaseD() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseD;
    },
    get lowercaseE() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseE;
    },
    get lowercaseF() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseF;
    },
    get lowercaseG() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseG;
    },
    get lowercaseH() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseH;
    },
    get lowercaseI() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseI;
    },
    get lowercaseJ() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseJ;
    },
    get lowercaseK() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseK;
    },
    get lowercaseL() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseL;
    },
    get lowercaseM() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseM;
    },
    get lowercaseN() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseN;
    },
    get lowercaseO() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseO;
    },
    get lowercaseP() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseP;
    },
    get lowercaseQ() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseQ;
    },
    get lowercaseR() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseR;
    },
    get lowercaseS() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseS;
    },
    get lowercaseT() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseT;
    },
    get lowercaseU() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseU;
    },
    get lowercaseV() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseV;
    },
    get lowercaseW() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseW;
    },
    get lowercaseX() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseX;
    },
    get lowercaseY() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseY;
    },
    get lowercaseZ() {
      return ___R$romejs$string$charcodes$index_ts$lowercaseZ;
    },
    get leftCurlyBrace() {
      return ___R$romejs$string$charcodes$index_ts$leftCurlyBrace;
    },
    get verticalBar() {
      return ___R$romejs$string$charcodes$index_ts$verticalBar;
    },
    get rightCurlyBrace() {
      return ___R$romejs$string$charcodes$index_ts$rightCurlyBrace;
    },
    get tilde() {
      return ___R$romejs$string$charcodes$index_ts$tilde;
    },
    get nonBreakingSpace() {
      return ___R$romejs$string$charcodes$index_ts$nonBreakingSpace;
    },
    get oghamSpaceMark() {
      return ___R$romejs$string$charcodes$index_ts$oghamSpaceMark;
    },
    get lineSeparator() {
      return ___R$romejs$string$charcodes$index_ts$lineSeparator;
    },
    get paragraphSeparator() {
      return ___R$romejs$string$charcodes$index_ts$paragraphSeparator;
    },
    isDigit: ___R$romejs$string$charcodes$index_ts$isDigit};
  const ___R$romejs$string$charcodes$index_ts$backSpace = 8;
  const ___R$romejs$string$charcodes$index_ts$tab = 9;
  const ___R$romejs$string$charcodes$index_ts$lineFeed = 10;
  const ___R$romejs$string$charcodes$index_ts$carriageReturn = 13;
  const ___R$romejs$string$charcodes$index_ts$shiftOut = 14;
  const ___R$romejs$string$charcodes$index_ts$space = 32;
  const ___R$romejs$string$charcodes$index_ts$exclamationMark = 33;
  const ___R$romejs$string$charcodes$index_ts$quotationMark = 34;
  const ___R$romejs$string$charcodes$index_ts$numberSign = 35;
  const ___R$romejs$string$charcodes$index_ts$dollarSign = 36;
  const ___R$romejs$string$charcodes$index_ts$percentSign = 37;
  const ___R$romejs$string$charcodes$index_ts$ampersand = 38;
  const ___R$romejs$string$charcodes$index_ts$apostrophe = 39;
  const ___R$romejs$string$charcodes$index_ts$leftParenthesis = 40;
  const ___R$romejs$string$charcodes$index_ts$rightParenthesis = 41;
  const ___R$romejs$string$charcodes$index_ts$asterisk = 42;
  const ___R$romejs$string$charcodes$index_ts$plusSign = 43;
  const ___R$romejs$string$charcodes$index_ts$comma = 44;
  const ___R$romejs$string$charcodes$index_ts$dash = 45;
  const ___R$romejs$string$charcodes$index_ts$dot = 46;
  const ___R$romejs$string$charcodes$index_ts$slash = 47;
  const ___R$romejs$string$charcodes$index_ts$digit0 = 48;
  const ___R$romejs$string$charcodes$index_ts$digit1 = 49;
  const ___R$romejs$string$charcodes$index_ts$digit2 = 50;
  const ___R$romejs$string$charcodes$index_ts$digit3 = 51;
  const ___R$romejs$string$charcodes$index_ts$digit4 = 52;
  const ___R$romejs$string$charcodes$index_ts$digit5 = 53;
  const ___R$romejs$string$charcodes$index_ts$digit6 = 54;
  const ___R$romejs$string$charcodes$index_ts$digit7 = 55;
  const ___R$romejs$string$charcodes$index_ts$digit8 = 56;
  const ___R$romejs$string$charcodes$index_ts$digit9 = 57;
  const ___R$romejs$string$charcodes$index_ts$colon = 58;
  const ___R$romejs$string$charcodes$index_ts$semicolon = 59;
  const ___R$romejs$string$charcodes$index_ts$lessThan = 60;
  const ___R$romejs$string$charcodes$index_ts$equalsTo = 61;
  const ___R$romejs$string$charcodes$index_ts$greaterThan = 62;
  const ___R$romejs$string$charcodes$index_ts$questionMark = 63;
  const ___R$romejs$string$charcodes$index_ts$atSign = 64;
  const ___R$romejs$string$charcodes$index_ts$uppercaseA = 65;
  const ___R$romejs$string$charcodes$index_ts$uppercaseB = 66;
  const ___R$romejs$string$charcodes$index_ts$uppercaseC = 67;
  const ___R$romejs$string$charcodes$index_ts$uppercaseD = 68;
  const ___R$romejs$string$charcodes$index_ts$uppercaseE = 69;
  const ___R$romejs$string$charcodes$index_ts$uppercaseF = 70;
  const ___R$romejs$string$charcodes$index_ts$uppercaseG = 71;
  const ___R$romejs$string$charcodes$index_ts$uppercaseH = 72;
  const ___R$romejs$string$charcodes$index_ts$uppercaseI = 73;
  const ___R$romejs$string$charcodes$index_ts$uppercaseJ = 74;
  const ___R$romejs$string$charcodes$index_ts$uppercaseK = 75;
  const ___R$romejs$string$charcodes$index_ts$uppercaseL = 76;
  const ___R$romejs$string$charcodes$index_ts$uppercaseM = 77;
  const ___R$romejs$string$charcodes$index_ts$uppercaseN = 78;
  const ___R$romejs$string$charcodes$index_ts$uppercaseO = 79;
  const ___R$romejs$string$charcodes$index_ts$uppercaseP = 80;
  const ___R$romejs$string$charcodes$index_ts$uppercaseQ = 81;
  const ___R$romejs$string$charcodes$index_ts$uppercaseR = 82;
  const ___R$romejs$string$charcodes$index_ts$uppercaseS = 83;
  const ___R$romejs$string$charcodes$index_ts$uppercaseT = 84;
  const ___R$romejs$string$charcodes$index_ts$uppercaseU = 85;
  const ___R$romejs$string$charcodes$index_ts$uppercaseV = 86;
  const ___R$romejs$string$charcodes$index_ts$uppercaseW = 87;
  const ___R$romejs$string$charcodes$index_ts$uppercaseX = 88;
  const ___R$romejs$string$charcodes$index_ts$uppercaseY = 89;
  const ___R$romejs$string$charcodes$index_ts$uppercaseZ = 90;
  const ___R$romejs$string$charcodes$index_ts$leftSquareBracket = 91;
  const ___R$romejs$string$charcodes$index_ts$backslash = 92;
  const ___R$romejs$string$charcodes$index_ts$rightSquareBracket = 93;
  const ___R$romejs$string$charcodes$index_ts$caret = 94;
  const ___R$romejs$string$charcodes$index_ts$underscore = 95;
  const ___R$romejs$string$charcodes$index_ts$graveAccent = 96;
  const ___R$romejs$string$charcodes$index_ts$lowercaseA = 97;
  const ___R$romejs$string$charcodes$index_ts$lowercaseB = 98;
  const ___R$romejs$string$charcodes$index_ts$lowercaseC = 99;
  const ___R$romejs$string$charcodes$index_ts$lowercaseD = 100;
  const ___R$romejs$string$charcodes$index_ts$lowercaseE = 101;
  const ___R$romejs$string$charcodes$index_ts$lowercaseF = 102;
  const ___R$romejs$string$charcodes$index_ts$lowercaseG = 103;
  const ___R$romejs$string$charcodes$index_ts$lowercaseH = 104;
  const ___R$romejs$string$charcodes$index_ts$lowercaseI = 105;
  const ___R$romejs$string$charcodes$index_ts$lowercaseJ = 106;
  const ___R$romejs$string$charcodes$index_ts$lowercaseK = 107;
  const ___R$romejs$string$charcodes$index_ts$lowercaseL = 108;
  const ___R$romejs$string$charcodes$index_ts$lowercaseM = 109;
  const ___R$romejs$string$charcodes$index_ts$lowercaseN = 110;
  const ___R$romejs$string$charcodes$index_ts$lowercaseO = 111;
  const ___R$romejs$string$charcodes$index_ts$lowercaseP = 112;
  const ___R$romejs$string$charcodes$index_ts$lowercaseQ = 113;
  const ___R$romejs$string$charcodes$index_ts$lowercaseR = 114;
  const ___R$romejs$string$charcodes$index_ts$lowercaseS = 115;
  const ___R$romejs$string$charcodes$index_ts$lowercaseT = 116;
  const ___R$romejs$string$charcodes$index_ts$lowercaseU = 117;
  const ___R$romejs$string$charcodes$index_ts$lowercaseV = 118;
  const ___R$romejs$string$charcodes$index_ts$lowercaseW = 119;
  const ___R$romejs$string$charcodes$index_ts$lowercaseX = 120;
  const ___R$romejs$string$charcodes$index_ts$lowercaseY = 121;
  const ___R$romejs$string$charcodes$index_ts$lowercaseZ = 122;
  const ___R$romejs$string$charcodes$index_ts$leftCurlyBrace = 123;
  const ___R$romejs$string$charcodes$index_ts$verticalBar = 124;
  const ___R$romejs$string$charcodes$index_ts$rightCurlyBrace = 125;
  const ___R$romejs$string$charcodes$index_ts$tilde = 126;
  const ___R$romejs$string$charcodes$index_ts$nonBreakingSpace = 160;
  const ___R$romejs$string$charcodes$index_ts$oghamSpaceMark = 5760;
  const ___R$romejs$string$charcodes$index_ts$lineSeparator = 8232;
  const ___R$romejs$string$charcodes$index_ts$paragraphSeparator = 8233;

  function ___R$romejs$string$charcodes$index_ts$isDigit(code) {
    return code >= ___R$romejs$string$charcodes$index_ts$digit0 && code <= ___R$romejs$string$charcodes$index_ts$digit9;
  }

  // romejs/string-utils/naturalCompare.ts

  const ___R$romejs$string$utils$naturalCompare_ts = {
    naturalCompare: ___R$romejs$string$utils$naturalCompare_ts$naturalCompare};
  function ___R$romejs$string$utils$naturalCompare_ts$naturalCompare(a, b, insensitive = true) {
    if (insensitive) {
      a = a.toLowerCase();
      b = b.toLowerCase();
    }

    const lengthA = a.length;
    const lengthB = b.length;

    let aIndex = 0;
    let bIndex = 0;

    while (aIndex < lengthA && bIndex < lengthB) {
      let charCodeA = a.charCodeAt(aIndex);
      let charCodeB = b.charCodeAt(bIndex);

      if (___R$romejs$string$charcodes$index_ts$isDigit(charCodeA)) {
        if (!___R$romejs$string$charcodes$index_ts$isDigit(charCodeB)) {
          return charCodeA - charCodeB;
        }

        let numStartA = aIndex;
        let numStartB = bIndex;

        while (charCodeA === 48 && ++numStartA < lengthA) {
          charCodeA = a.charCodeAt(numStartA);
        }
        while (charCodeB === 48 && ++numStartB < lengthB) {
          charCodeB = b.charCodeAt(numStartB);
        }

        let numEndA = numStartA;
        let numEndB = numStartB;

        while (numEndA < lengthA && ___R$romejs$string$charcodes$index_ts$isDigit(a.charCodeAt(numEndA))) {
          ++numEndA;
        }
        while (numEndB < lengthB && ___R$romejs$string$charcodes$index_ts$isDigit(b.charCodeAt(numEndB))) {
          ++numEndB;
        }

        let difference = numEndA - numStartA - numEndB + numStartB;
        if (difference) {
          return difference;
        }

        while (numStartA < numEndA) {
          difference = a.charCodeAt(numStartA++) - b.charCodeAt(numStartB++);
          if (difference) {
            return difference;
          }
        }

        aIndex = numEndA;
        bIndex = numEndB;
        continue;
      }

      if (charCodeA !== charCodeB) {
        return charCodeA - charCodeB;
      }

      ++aIndex;
      ++bIndex;
    }

    return lengthA - lengthB;
  }

  // romejs/string-utils/humanizeNumber.ts

  const ___R$romejs$string$utils$humanizeNumber_ts = {
    humanizeNumber: ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber};
  function ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(num, sep = '_') {
    if (num < 1000) {
      return String(num);
    }

    const decimals = String(num).split('.');

    let intChars = String(decimals.shift()).split('');
    let intParts = [];

    while (intChars.length > 0) {
      const part = intChars.slice(-3).join('');
      intParts.unshift(part);

      intChars = intChars.slice(0, -3);
    }

    return [intParts.join(sep), ...decimals].join('.');
  }

  // romejs/string-utils/humanizeFileSize.ts

  const ___R$romejs$string$utils$humanizeFileSize_ts = {
    humanizeFileSize: ___R$romejs$string$utils$humanizeFileSize_ts$humanizeFileSize};
  const ___R$$priv$romejs$string$utils$humanizeFileSize_ts$UNITS = ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

  function ___R$romejs$string$utils$humanizeFileSize_ts$humanizeFileSize(bytes) {
    const exponent = Math.min(
    Math.floor(Math.log10(bytes) / 3),
    ___R$$priv$romejs$string$utils$humanizeFileSize_ts$UNITS.length - 1);
    const specific = Number((bytes / Math.pow(1000, exponent)).toPrecision(3));
    const unit = ___R$$priv$romejs$string$utils$humanizeFileSize_ts$UNITS[exponent];
    return ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(specific) + unit;
  }

  // romejs/string-utils/humanizeTime.ts

  const ___R$romejs$string$utils$humanizeTime_ts = {
    humanizeTime: ___R$romejs$string$utils$humanizeTime_ts$humanizeTime};
  function ___R$romejs$string$utils$humanizeTime_ts$humanizeTime(ms, allowMilliseconds = false) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    const h = Math.floor(m / 60);

    if (h === 0 && m === 0 && s === 0) {
      if (allowMilliseconds) {
        return ms + 'ms';
      } else {
        return (ms / 1000).toFixed(2) + 's';
      }
    }

    let buf = '';
    if (h > 0) {
      buf += String(h) + 'h';
    }
    if (m > 0) {
      buf += String(m % 60) + 'm';
    }
    buf += String(s % 60) + 's';
    return buf;
  }

  // romejs/string-utils/removeSuffix.ts

  const ___R$romejs$string$utils$removeSuffix_ts = {
    removeSuffix: ___R$romejs$string$utils$removeSuffix_ts$removeSuffix};
  function ___R$romejs$string$utils$removeSuffix_ts$removeSuffix(value, suffix) {
    if (value.endsWith(suffix)) {
      return value.slice(0, -suffix.length);
    } else {
      return value;
    }
  }

  // romejs/string-utils/removePrefix.ts

  const ___R$romejs$string$utils$removePrefix_ts = {
    removePrefix: ___R$romejs$string$utils$removePrefix_ts$removePrefix};
  function ___R$romejs$string$utils$removePrefix_ts$removePrefix(value, prefix) {
    if (value.startsWith(prefix)) {
      return value.slice(prefix.length);
    } else {
      return value;
    }
  }

  // romejs/string-utils/findClosestStringMatch.ts

  const ___R$romejs$string$utils$findClosestStringMatch_ts = {
    findClosestStringMatch: ___R$romejs$string$utils$findClosestStringMatch_ts$findClosestStringMatch};
  function ___R$romejs$string$utils$findClosestStringMatch_ts$findClosestStringMatch(name, matches, minRating = 0.8) {
    if (matches.length === 0) {
      return undefined;
    }

    if (matches.length === 1) {
      return matches[0];
    }

    const ratings = ___R$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(name, matches);
    const bestMatch = ratings[0];

    if (bestMatch.rating >= minRating) {
      return bestMatch.target;
    } else {
      return undefined;
    }
  }

  // romejs/string-utils/orderByNatural.ts

  const ___R$romejs$string$utils$orderByNatural_ts = {
    orderByNatural: ___R$romejs$string$utils$orderByNatural_ts$orderByNatural};
  function ___R$romejs$string$utils$orderByNatural_ts$orderByNatural(strs, insensitive = true) {
    return strs.sort((a, b) => ___R$romejs$string$utils$naturalCompare_ts$naturalCompare(a, b, insensitive));
  }

  // romejs/string-utils/toKebabCase.ts

  const ___R$romejs$string$utils$toKebabCase_ts = {
    toKebabCase: ___R$romejs$string$utils$toKebabCase_ts$toKebabCase};
  function ___R$romejs$string$utils$toKebabCase_ts$toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[\s_]+/g, '-').toLowerCase();
  }

  // romejs/string-utils/toCamelCase.ts

  const ___R$romejs$string$utils$toCamelCase_ts = {
    toCamelCase: ___R$romejs$string$utils$toCamelCase_ts$toCamelCase};
  function ___R$romejs$string$utils$toCamelCase_ts$toCamelCase(str) {
    return str.replace(/^[_.\- ]+/, '').toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, m => m.toUpperCase());
  }

  // romejs/string-utils/index.ts


  // romejs/string-ansi/regex.ts

  const ___R$romejs$string$ansi$regex_ts = {
    get pattern() {
      return ___R$romejs$string$ansi$regex_ts$pattern;
    },
    get regex() {
      return ___R$romejs$string$ansi$regex_ts$regex;
    },
    get colorRegex() {
      return ___R$romejs$string$ansi$regex_ts$colorRegex;
    }};
  const ___R$romejs$string$ansi$regex_ts$pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');

  const ___R$romejs$string$ansi$regex_ts$regex = new RegExp(___R$romejs$string$ansi$regex_ts$pattern, 'g');

  const ___R$romejs$string$ansi$regex_ts$colorRegex = /\u001b\[[3-9][0-9]m/g;

  // romejs/string-ansi/format.ts

  const ___R$romejs$string$ansi$format_ts = {
    get formatAnsi() {
      return ___R$romejs$string$ansi$format_ts$formatAnsi;
    },
    stripAnsi: ___R$romejs$string$ansi$format_ts$stripAnsi,
    hasAnsiColor: ___R$romejs$string$ansi$format_ts$hasAnsiColor,
    hasAnsi: ___R$romejs$string$ansi$format_ts$hasAnsi};
  function ___R$$priv$romejs$string$ansi$format_ts$createEscape(num) {
    return '\x1b[' + String(num) + 'm';
  }

  const ___R$romejs$string$ansi$format_ts$formatAnsi = {
    reset(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(0) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(0);
    },

    fileHyperlink(name, filename) {
      let href = 'file://';
      const {HOSTNAME: HOSTNAME} = process.env;
      if (HOSTNAME != null) {
        href += HOSTNAME + '/';
      }
      href += filename;
      return ___R$romejs$string$ansi$format_ts$formatAnsi.hyperlink(name, href);
    },

    hyperlink(name, href) {
      return '\x1b]8;;' + href + '\x07' + name + '\x1b]8;;\x07';
    },

    rgb(str, color) {
      return '\x1b[38;2;' + String(color.r) + ';' + String(color.g) + ';' + String(color.b) + 'm' + str +
      ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    bgRgb(str, color) {
      return '\x1b[48;2;' + String(color.r) + ';' + String(color.g) + ';' + String(color.b) + 'm' + str +
      ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bold(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(1) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(22);
    },

    dim(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(2) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(22);
    },

    italic(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(3) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(23);
    },

    underline(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(4) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(24);
    },

    inverse(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(7) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(27);
    },

    hidden(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(8) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(28);
    },

    strikethrough(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(9) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(29);
    },

    black(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(30) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightBlack(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(90) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    red(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(31) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightRed(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(91) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    green(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(32) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightGreen(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(92) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    yellow(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(33) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightYellow(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(93) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    blue(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(34) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightBlue(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(94) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    magenta(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(35) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightMagenta(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(95) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    cyan(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(36) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightCyan(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(96) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    white(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(37) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    brightWhite(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(97) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(39);
    },

    bgBlack(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(40) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightBlack(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(100) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgRed(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(41) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightRed(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(101) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgGreen(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(42) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightGreen(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(102) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgYellow(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(43) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightYellow(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(103) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBlue(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(44) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightBlue(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(104) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgMagenta(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(45) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightMagenta(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(105) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgCyan(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(46) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightCyan(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(106) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgWhite(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(47) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    },

    bgBrightWhite(str) {
      return ___R$$priv$romejs$string$ansi$format_ts$createEscape(107) + str + ___R$$priv$romejs$string$ansi$format_ts$createEscape(49);
    }};

  function ___R$romejs$string$ansi$format_ts$stripAnsi(str) {
    return str.replace(___R$romejs$string$ansi$regex_ts$regex, '');
  }

  function ___R$romejs$string$ansi$format_ts$hasAnsiColor(str) {
    return ___R$romejs$string$ansi$regex_ts$colorRegex.test(str);
  }

  function ___R$romejs$string$ansi$format_ts$hasAnsi(str) {
    return ___R$romejs$string$ansi$regex_ts$regex.test(str);
  }

  // romejs/string-ansi/pad.ts

  const ___R$romejs$string$ansi$pad_ts = {
    pad: ___R$romejs$string$ansi$pad_ts$pad,
    rightPad: ___R$romejs$string$ansi$pad_ts$rightPad,
    leftPad: ___R$romejs$string$ansi$pad_ts$leftPad};
  const ___R$$priv$romejs$string$ansi$pad_ts$DEFAULT_SPACER = ' ';

  function ___R$romejs$string$ansi$pad_ts$pad(side, str, len, spacerChar = ___R$$priv$romejs$string$ansi$pad_ts$DEFAULT_SPACER) {
    const stripped = ___R$romejs$string$ansi$format_ts$stripAnsi(str);
    const remainder = len - stripped.length;

    if (remainder <= 0) {
      return str;
    }

    const spacer = spacerChar.repeat(remainder);
    if (side === 'left') {
      return spacer + str;
    } else {
      return str + spacer;
    }
  }

  function ___R$romejs$string$ansi$pad_ts$rightPad(str, len, spacer = ___R$$priv$romejs$string$ansi$pad_ts$DEFAULT_SPACER) {
    return ___R$romejs$string$ansi$pad_ts$pad('right', str, len, spacer);
  }

  function ___R$romejs$string$ansi$pad_ts$leftPad(str, len, spacer = ___R$$priv$romejs$string$ansi$pad_ts$DEFAULT_SPACER) {
    return ___R$romejs$string$ansi$pad_ts$pad('left', str, len, spacer);
  }

  // romejs/string-ansi/escapes.ts

  const ___R$romejs$string$ansi$escapes_ts = {
    get escapes() {
      return ___R$romejs$string$ansi$escapes_ts$escapes;
    }};
  const ___R$$priv$romejs$string$ansi$escapes_ts$ESC = '\x1b[';

  const ___R$romejs$string$ansi$escapes_ts$escapes = {
    clearScreen: '\x1bc',
    eraseLine: ___R$$priv$romejs$string$ansi$escapes_ts$ESC + '2K',

    cursorTo(x, y) {
      if (y === undefined) {
        return '' + ___R$$priv$romejs$string$ansi$escapes_ts$ESC + (x + 1) + 'G';
      }

      return '' + ___R$$priv$romejs$string$ansi$escapes_ts$ESC + (y + 1) + ';' + (x + 1) + 'H';
    }};

  // romejs/string-ansi/split.ts

  const ___R$romejs$string$ansi$split_ts = {
    truncateAnsi: ___R$romejs$string$ansi$split_ts$truncateAnsi,
    mapAnsiString: ___R$romejs$string$ansi$split_ts$mapAnsiString,
    splitAnsiLines: ___R$romejs$string$ansi$split_ts$splitAnsiLines};
  const ___R$$priv$romejs$string$ansi$split_ts$startRegex = new RegExp('^' + ___R$romejs$string$ansi$regex_ts$pattern);

  function ___R$$priv$romejs$string$ansi$split_ts$isAnsiStartChar(char) {
    return char === '\x1b' || char === '\x9b';
  }

  const ___R$$priv$romejs$string$ansi$split_ts$HYPERLINK_END = '\x1b]8;;\x07';

  function ___R$$priv$romejs$string$ansi$split_ts$sliceAnsi(input, index) {
    const match = input.slice(index).match(___R$$priv$romejs$string$ansi$split_ts$startRegex);

    if (match == null) {
      return undefined;
    }

    const str = match[0];

    if (str[0] === '\x1b') {
      const possibleIndex = input.indexOf(___R$$priv$romejs$string$ansi$split_ts$HYPERLINK_END, index + str.length);
      if (possibleIndex > -1) {
        return input.slice(index, possibleIndex + ___R$$priv$romejs$string$ansi$split_ts$HYPERLINK_END.length);
      }
    }

    return str;
  }

  function ___R$romejs$string$ansi$split_ts$truncateAnsi(input, maxWidth) {
    return ___R$romejs$string$ansi$split_ts$splitAnsiLines(input, maxWidth)[0];
  }

  function ___R$romejs$string$ansi$split_ts$mapAnsiString(input, callback) {
    let buff = '';
    let fakeIndex = 0;
    let realIndex = 0;

    while (realIndex < input.length) {
      const char = input[realIndex];

      if (___R$$priv$romejs$string$ansi$split_ts$isAnsiStartChar(char)) {
        const match = ___R$$priv$romejs$string$ansi$split_ts$sliceAnsi(input, realIndex);
        if (match !== undefined) {
          const strippedLength = ___R$romejs$string$ansi$format_ts$stripAnsi(match).length;
          buff += callback(match, {
            isAnsi: true,
            start: fakeIndex,
            end: fakeIndex + strippedLength});
          realIndex += match.length;
          fakeIndex += strippedLength;
          continue;
        }
      }

      buff += callback(char, {
        isAnsi: false,
        start: fakeIndex,
        end: fakeIndex + 1});
      realIndex++;
      fakeIndex++;
    }

    return buff;
  }

  function ___R$romejs$string$ansi$split_ts$splitAnsiLines(input, maxWidth) {
    const lines = [];

    let column = 0;
    let buff = '';

    function pushLine() {
      lines.push(buff);
      column = 0;
      buff = '';
    }

    let index = 0;

    while (index < input.length) {
      const char = input[index];

      if (___R$$priv$romejs$string$ansi$split_ts$isAnsiStartChar(char)) {
        const match = ___R$$priv$romejs$string$ansi$split_ts$sliceAnsi(input, index);
        if (match !== undefined) {
          buff += match;
          index += match.length;
          continue;
        }
      }

      if (char === ' ' && column === 0) {}

      if (char === '\n') {
        pushLine();
        index++;
        continue;
      }

      let word = char;
      for (let i = index + 1; i < input.length && input[i] !== ' '; i++) {
        word += input[i];
      }

      const wordLength = ___R$romejs$string$ansi$format_ts$stripAnsi(word).length;

      let pushedLine = false;
      if (maxWidth !== undefined && column + wordLength > maxWidth) {
        pushLine();
        pushedLine = true;
      }

      column += wordLength;
      buff += pushedLine ? word.trimLeft() : word;
      index += word.length;
    }

    if (buff !== '') {
      pushLine();
    }

    return lines;
  }

  // romejs/string-ansi/index.ts


  // romejs/string-markup/format.ts

  const ___R$romejs$string$markup$format_ts = {
    stripMarkupTags: ___R$romejs$string$markup$format_ts$stripMarkupTags,
    markupToAnsi: ___R$romejs$string$markup$format_ts$markupToAnsi,
    humanizeMarkupFilename: ___R$romejs$string$markup$format_ts$humanizeMarkupFilename};

  const ___R$$priv$romejs$string$markup$format_ts$EMPTY_ATTRIBUTES = new Map();

  function ___R$$priv$romejs$string$markup$format_ts$formatReduceFromInput(input, callback) {
    return ___R$$priv$romejs$string$markup$format_ts$formatReduceFromChildren(___R$romejs$string$markup$parse_ts$parseMarkup(input), callback);
  }

  function ___R$$priv$romejs$string$markup$format_ts$formatReduceFromChildren(children, callback) {
    let buff = '';
    for (const child of children) {
      if (child.type === 'Text') {
        buff += child.value;
      } else if (child.type === 'Tag') {
        const {attributes: attributes} = child;

        let res = callback(
        child.name,
        attributes,
        ___R$$priv$romejs$string$markup$format_ts$formatReduceFromChildren(child.children, callback));

        if (attributes.get('emphasis') === 'true') {
          res = callback('emphasis', ___R$$priv$romejs$string$markup$format_ts$EMPTY_ATTRIBUTES, res);
        }
        if (attributes.get('dim') === 'true') {
          res = callback('dim', ___R$$priv$romejs$string$markup$format_ts$EMPTY_ATTRIBUTES, res);
        }

        buff += res;
      } else {
        throw new Error('Unknown child node type');
      }
    }
    return buff;
  }

  function ___R$$priv$romejs$string$markup$format_ts$formatFileLink(attributes, value, opts) {
    let text = value;

    let filename = attributes.get('target') || '';
    let origFilename = filename;
    if (opts.normalizeFilename !== undefined) {
      filename = opts.normalizeFilename(filename);
    }

    if (text === '') {
      text = ___R$romejs$string$markup$format_ts$humanizeMarkupFilename([filename, origFilename], opts);

      const line = attributes.get('line');
      if (line !== undefined) {
        text += ':' + line;

        const column = attributes.get('column');

        if (column !== undefined && column !== '0') {
          text += ':' + column;
        }
      }
    }

    return {text: text, href: 'file://' + filename};
  }

  function ___R$$priv$romejs$string$markup$format_ts$formatApprox(attributes, value) {
    if (attributes.get('approx') === 'true') {
      return '~' + value;
    } else {
      return value;
    }
  }

  function ___R$romejs$string$markup$format_ts$stripMarkupTags(input, opts = {}) {
    return ___R$$priv$romejs$string$markup$format_ts$formatReduceFromInput(input, (tag, attributes, value) => {
      switch (tag) {
        case 'filelink':
          return ___R$$priv$romejs$string$markup$format_ts$formatFileLink(attributes, value, opts).text;

        case 'number':
          return ___R$$priv$romejs$string$markup$format_ts$formatApprox(attributes, value);

        case 'duration':
          return ___R$$priv$romejs$string$markup$format_ts$formatApprox(attributes, ___R$romejs$string$utils$humanizeTime_ts$humanizeTime(Number(value), true));

        default:
          return value;}
    });
  }

  function ___R$romejs$string$markup$format_ts$markupToAnsi(input, opts = {}) {
    return ___R$$priv$romejs$string$markup$format_ts$formatReduceFromInput(input, (tag, attributes, value) => {
      switch (tag) {
        case 'hyperlink':
          {
            let text = value;
            let hyperlink = attributes.get('target');

            if (hyperlink === undefined) {
              hyperlink = text;
            }

            if (text === '') {
              text = hyperlink;
            }

            return ___R$romejs$string$ansi$format_ts$formatAnsi.hyperlink(text, hyperlink);
          }

        case 'filelink':
          {
            const {text: text, href: href} = ___R$$priv$romejs$string$markup$format_ts$formatFileLink(attributes, value, opts);
            return ___R$romejs$string$ansi$format_ts$formatAnsi.hyperlink(text, href);
          }

        case 'inverse':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.inverse(' ' + value + ' ');

        case 'emphasis':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bold(value);

        case 'dim':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.dim(value);

        case 'filesize':
          return ___R$romejs$string$utils$humanizeFileSize_ts$humanizeFileSize(Number(value));

        case 'duration':
          return ___R$$priv$romejs$string$markup$format_ts$formatApprox(attributes, ___R$romejs$string$utils$humanizeTime_ts$humanizeTime(Number(value), true));

        case 'number':
          return ___R$$priv$romejs$string$markup$format_ts$formatApprox(attributes, ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(Number(value)));

        case 'italic':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.italic(value);

        case 'underline':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.underline(value);

        case 'strike':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.strikethrough(value);

        case 'black':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.black(value);

        case 'brightBlack':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.brightBlack(value);

        case 'red':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.red(value);

        case 'brightRed':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.brightRed(value);

        case 'green':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.green(value);

        case 'brightGreen':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.brightGreen(value);

        case 'yellow':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.yellow(value);

        case 'brightYellow':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.brightYellow(value);

        case 'blue':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.blue(value);

        case 'brightBlue':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.brightBlue(value);

        case 'magenta':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.magenta(value);

        case 'brightMagenta':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.brightMagenta(value);

        case 'cyan':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.cyan(value);

        case 'brightCyan':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.brightCyan(value);

        case 'white':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.white(value);

        case 'brightWhite':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.brightWhite(value);

        case 'bgBlack':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgBlack(value);

        case 'bgBrightBlack':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgBrightBlack(value);

        case 'bgRed':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgRed(value);

        case 'bgBrightRed':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgBrightRed(value);

        case 'bgGreen':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgGreen(value);

        case 'bgBrightGreen':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgBrightGreen(value);

        case 'bgYellow':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgYellow(value);

        case 'bgBrightYellow':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgBrightYellow(value);

        case 'bgBlue':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgBlue(value);

        case 'bgBrightBlue':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgBrightBlue(value);

        case 'bgMagenta':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgMagenta(value);

        case 'bgBrightMagenta':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgBrightMagenta(value);

        case 'bgCyan':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgCyan(value);

        case 'bgBrightCyan':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgBrightCyan(value);

        case 'bgWhite':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgWhite(value);

        case 'bgBrightWhite':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.bgBrightWhite(value);}
    });
  }

  function ___R$romejs$string$markup$format_ts$humanizeMarkupFilename(filenames, opts = {}) {
    if (opts.humanizeFilename !== undefined) {
      const override = opts.humanizeFilename(filenames[0]);
      if (override !== undefined) {
        return override;
      }
    }

    if (filenames.length === 0) {
      return 'unknown';
    }

    const names = [];

    for (const filename of filenames) {
      names.push(___R$romejs$path$index_ts$createUnknownFilePath(filename).format(opts.cwd));
    }

    return names.sort((a, b) => a.length - b.length)[0];
  }

  // romejs/string-markup/escape.ts

  const ___R$romejs$string$markup$escape_ts = {
    markup: ___R$romejs$string$markup$escape_ts$markup,
    safeMarkup: ___R$romejs$string$markup$escape_ts$safeMarkup,
    escapeMarkup: ___R$romejs$string$markup$escape_ts$escapeMarkup};
  function ___R$romejs$string$markup$escape_ts$markup(strs, ...values) {
    let out = '';

    for (let i = 0; i < strs.length; i++) {
      const str = strs[i];
      out += str;

      const interpolated = values[i];

      if (interpolated instanceof ___R$$priv$romejs$string$markup$escape_ts$SafeMarkup) {
        out += interpolated.value;
        continue;
      }

      if (interpolated !== undefined) {
        out += ___R$romejs$string$markup$escape_ts$escapeMarkup(String(interpolated));
      }
    }

    return out;
  }

  class ___R$$priv$romejs$string$markup$escape_ts$SafeMarkup {
    constructor(value) {
      this.value = value;
    }
  }

  function ___R$romejs$string$markup$escape_ts$safeMarkup(input) {
    return new ___R$$priv$romejs$string$markup$escape_ts$SafeMarkup(input);
  }

  function ___R$romejs$string$markup$escape_ts$escapeMarkup(input) {
    let escaped = '';
    for (let i = 0; i < input.length; i++) {
      const char = input[i];

      if (___R$romejs$string$markup$parse_ts$isTagChar(___R$romejs$ob1$index_ts$coerce0(i), input)) {
        escaped += '\\<';
      } else {
        escaped += char;
      }
    }
    return escaped;
  }

  // romejs/string-markup/index.ts


  // romejs/diagnostics/errors.ts

  const ___R$romejs$diagnostics$errors_ts = {
    get DiagnosticsError() {
      return ___R$romejs$diagnostics$errors_ts$DiagnosticsError;
    },
    getDiagnosticsFromError: ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError};
  class ___R$romejs$diagnostics$errors_ts$DiagnosticsError extends Error {
    constructor(message, diagnostics) {
      if (diagnostics.length === 0) {
        throw new Error('No diagnostics');
      }

      message += '\n';

      message += ___R$romejs$string$ansi$format_ts$stripAnsi(
      diagnostics.map(diag => '- ' + diag.message).join('\n'));

      super(___R$romejs$string$markup$escape_ts$escapeMarkup(message));
      this.diagnostics = diagnostics;
      this.name = 'DiagnosticsError';
    }
  }

  function ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err) {
    if (err instanceof ___R$romejs$diagnostics$errors_ts$DiagnosticsError) {
      return err.diagnostics;
    }

    return undefined;
  }

  // romejs/diagnostics/types.ts

  const ___R$romejs$diagnostics$types_ts = {};

  // romejs/codec-source-map/base64.ts

  const ___R$romejs$codec$source$map$base64_ts = {
    encode: ___R$romejs$codec$source$map$base64_ts$encode,
    encodeVLQ: ___R$romejs$codec$source$map$base64_ts$encodeVLQ,
    decode: ___R$romejs$codec$source$map$base64_ts$decode,
    decodeVLQ: ___R$romejs$codec$source$map$base64_ts$decodeVLQ};
  const ___R$$priv$romejs$codec$source$map$base64_ts$intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(
  '');

  function ___R$romejs$codec$source$map$base64_ts$encode(number) {
    if (0 <= number && number < ___R$$priv$romejs$codec$source$map$base64_ts$intToCharMap.length) {
      return ___R$$priv$romejs$codec$source$map$base64_ts$intToCharMap[number];
    } else {
      throw new TypeError('Must be between 0 and 63: ' + number);
    }
  }

  const ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT = 5;

  const ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_BASE = 1 << ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT;

  const ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_BASE_MASK = ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_BASE - 1;

  const ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT = ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_BASE;

  function ___R$$priv$romejs$codec$source$map$base64_ts$toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }

  function ___R$$priv$romejs$codec$source$map$base64_ts$fromVLQSigned(value) {
    const isNegative = (value & 1) === 1;
    const shifted = value >> 1;
    return isNegative ? -shifted : shifted;
  }

  function ___R$romejs$codec$source$map$base64_ts$encodeVLQ(value) {
    let encoded = '';
    let vlq = ___R$$priv$romejs$codec$source$map$base64_ts$toVLQSigned(value);

    do {
      let digit = vlq & ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_BASE_MASK;
      vlq >>>= ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT;
      }
      encoded += ___R$romejs$codec$source$map$base64_ts$encode(digit);
    } while (vlq > 0);

    return encoded;
  }

  function ___R$romejs$codec$source$map$base64_ts$decode(charCode) {
    var bigA = 65;
    var bigZ = 90;

    var littleA = 97;
    var littleZ = 122;

    var zero = 48;
    var nine = 57;

    var plus = 43;
    var slash = 47;

    var littleOffset = 26;
    var numberOffset = 52;

    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }

    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }

    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    if (charCode === plus) {
      return 62;
    }

    if (charCode === slash) {
      return 63;
    }

    return -1;
  }

  function ___R$romejs$codec$source$map$base64_ts$decodeVLQ(aStr, aIndex) {
    let strLen = aStr.length;
    let result = 0;
    let shift = 0;
    let continuation = false;
    let digit;

    do {
      if (aIndex >= strLen) {
        throw new Error('Expected more digits in base 64 VLQ value.');
      }

      digit = ___R$romejs$codec$source$map$base64_ts$decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error('Invalid base64 digit: ' + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT);
      digit &= ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += ___R$$priv$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT;
    } while (continuation);

    return [___R$$priv$romejs$codec$source$map$base64_ts$fromVLQSigned(result), aIndex];
  }

  // romejs/codec-source-map/util.ts

  function ___R$$priv$romejs$codec$source$map$util_ts$strcmp(a, b) {
    if (a === b) {
      return 0;
    }

    if (a === undefined) {
      return 1;
    }

    if (b === undefined) {
      return -1;
    }

    if (a > b) {
      return 1;
    }

    return -1;
  }

  function ___R$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated(mappingA, mappingB) {
    let cmp = ___R$romejs$ob1$index_ts$get1(mappingA.generated.line) - ___R$romejs$ob1$index_ts$get1(mappingB.generated.line);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = ___R$romejs$ob1$index_ts$get0(mappingA.generated.column) - ___R$romejs$ob1$index_ts$get0(mappingB.generated.column);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = ___R$$priv$romejs$codec$source$map$util_ts$strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    if (mappingA.original == null) {
      if (mappingB.original != null) {
        return 1;
      }
    } else if (mappingB.original == null) {
      return -1;
    } else {
      cmp = ___R$romejs$ob1$index_ts$get1(mappingA.original.line) - ___R$romejs$ob1$index_ts$get1(mappingB.original.line);
      if (cmp !== 0) {
        return cmp;
      }

      cmp = ___R$romejs$ob1$index_ts$get0(mappingA.original.column) - ___R$romejs$ob1$index_ts$get0(mappingB.original.column);
      if (cmp !== 0) {
        return cmp;
      }
    }

    return ___R$$priv$romejs$codec$source$map$util_ts$strcmp(mappingA.name, mappingB.name);
  }

  function ___R$romejs$codec$source$map$util_ts$toRelativeUrl(root, path) {
    if (root === '') {
      root = '.';
    }

    root = root.replace(/\/$/, '');

    let level = 0;
    while (path.indexOf(root + '/') !== 0) {
      const index = root.lastIndexOf('/');
      if (index < 0) {
        return path;
      }

      root = root.slice(0, index);
      if (root.match(/^([^\/]+:\/)?\/*$/)) {
        return path;
      }

      ++level;
    }

    return Array(level + 1).join('../') + path.substr(root.length + 1);
  }

  // romejs/codec-source-map/ArraySet.ts

  class ___R$romejs$codec$source$map$ArraySet_ts$default {
    constructor() {
      this.array = [];
      this.set = new Map();
    }

    static fromArray(array, allowDuplicates) {
      const set = new ___R$romejs$codec$source$map$ArraySet_ts$default();
      for (const item of array) {
        set.add(item, allowDuplicates);
      }
      return set;
    }

    add(str, allowDuplicates) {
      const isDuplicate = this.has(str);
      const idx = this.array.length;

      if (isDuplicate === false || allowDuplicates === true) {
        this.array.push(str);
      }

      if (isDuplicate === false) {
        this.set.set(str, idx);
      }
    }

    has(str) {
      return this.set.has(str);
    }

    indexOf(str) {
      const idx = this.set.get(str);
      if (idx === undefined || idx < 0) {
        throw new Error(str + ' is not in the set');
      }
      return idx;
    }

    at(idx) {
      if (idx >= 0 && idx < this.array.length) {
        return this.array[idx];
      } else {
        throw new Error('No element indexed by ' + idx);
      }
    }

    toArray() {
      return this.array.slice();
    }
  }

  // romejs/codec-source-map/MappingList.ts

  function ___R$$priv$romejs$codec$source$map$MappingList_ts$generatedPositionAfter(mappingA, mappingB) {
    const lineA = mappingA.generated.line;
    const lineB = mappingB.generated.line;
    const columnA = mappingA.generated.column;
    const columnB = mappingB.generated.column;
    return lineB > lineA ||
    lineB == lineA && columnB >= columnA ||
    ___R$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  class ___R$romejs$codec$source$map$MappingList_ts$default {
    constructor() {
      this.array = [];
      this.sorted = true;
      this.last = {
        generated: {line: ___R$romejs$ob1$index_ts$number1Neg1, column: ___R$romejs$ob1$index_ts$number0},

        original: {line: ___R$romejs$ob1$index_ts$number1Neg1, column: ___R$romejs$ob1$index_ts$number0},
        source: undefined,
        name: undefined};
    }

    add(mapping) {
      if (___R$$priv$romejs$codec$source$map$MappingList_ts$generatedPositionAfter(this.last, mapping)) {
        this.last = mapping;
        this.array.push(mapping);
      } else {
        this.sorted = false;
        this.array.push(mapping);
      }
    }

    toArray() {
      if (this.sorted === false) {
        this.array.sort(___R$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated);
        this.sorted = true;
      }
      return this.array;
    }
  }

  // romejs/codec-source-map/SourceMapGenerator.ts

  class ___R$romejs$codec$source$map$SourceMapGenerator_ts$default {
    constructor(args) {
      this.file = args.file;
      this.sourceRoot = args.sourceRoot;

      this.sourcesContents = new Map();
      this.map = undefined;
      this.sources = new ___R$romejs$codec$source$map$ArraySet_ts$default();
      this.names = new ___R$romejs$codec$source$map$ArraySet_ts$default();
      this.mappings = new ___R$romejs$codec$source$map$MappingList_ts$default();
    }

    assertUnlocked() {
      if (this.map !== undefined) {
        throw new Error('Source map has already been materialized, toJSON() should be your final call');
      }
    }

    addMapping(mapping) {
      this.assertUnlocked();

      const {name: name, source: source} = mapping;

      this.validatePosition(
      'generated',
      mapping.generated.line,
      mapping.generated.column);

      if (mapping.original) {
        this.validatePosition(
        'original',
        mapping.original.line,
        mapping.original.column);
      }

      if (source !== undefined) {
        this.sources.add(source);
      }

      if (name !== undefined) {
        this.names.add(name);
      }

      this.mappings.add(mapping);
    }

    setSourceContent(source, sourceContent) {
      this.assertUnlocked();

      if (this.sourceRoot !== undefined) {
        source = ___R$romejs$codec$source$map$util_ts$toRelativeUrl(this.sourceRoot, source);
      }

      if (sourceContent !== undefined) {
        this.sourcesContents.set(source, sourceContent);
      } else {
        this.sourcesContents.delete(source);
      }
    }

    validatePosition(key, line, column) {
      if (___R$romejs$ob1$index_ts$get1(line) <= 0) {
        throw new Error(key + ' line should be >= 1 but is ' + line);
      }

      if (___R$romejs$ob1$index_ts$get0(column) < 0) {
        throw new Error(key + ' column should be >= 0 but is ' + column);
      }
    }

    serializeMappings() {
      let previousGeneratedColumn = ___R$romejs$ob1$index_ts$number0;
      let previousGeneratedLine = ___R$romejs$ob1$index_ts$number1;
      let previousOriginalColumn = ___R$romejs$ob1$index_ts$number0;
      let previousOriginalLine = ___R$romejs$ob1$index_ts$number1;
      let previousName = 0;
      let previousSource = 0;
      let result = '';

      const mappings = this.mappings.toArray();
      for (let i = 0; i < mappings.length; i++) {
        const mapping = mappings[i];
        let next = '';

        if (mapping.generated.line !== previousGeneratedLine) {
          previousGeneratedColumn = ___R$romejs$ob1$index_ts$number0;
          while (mapping.generated.line !== previousGeneratedLine) {
            next += ';';
            previousGeneratedLine = ___R$romejs$ob1$index_ts$inc(previousGeneratedLine);
          }
        } else if (i > 0) {
          if (!___R$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }

        next += ___R$romejs$codec$source$map$base64_ts.encodeVLQ(
        ___R$romejs$ob1$index_ts$get0(mapping.generated.column) - ___R$romejs$ob1$index_ts$get0(previousGeneratedColumn));
        previousGeneratedColumn = mapping.generated.column;

        if (mapping.source !== undefined) {
          const sourceIdx = this.sources.indexOf(mapping.source);
          next += ___R$romejs$codec$source$map$base64_ts.encodeVLQ(sourceIdx - previousSource);
          previousSource = sourceIdx;

          if (mapping.original) {
            next += ___R$romejs$codec$source$map$base64_ts.encodeVLQ(
            ___R$romejs$ob1$index_ts$get1(mapping.original.line) - ___R$romejs$ob1$index_ts$get1(previousOriginalLine));
            previousOriginalLine = mapping.original.line;

            next += ___R$romejs$codec$source$map$base64_ts.encodeVLQ(
            ___R$romejs$ob1$index_ts$get0(mapping.original.column) - ___R$romejs$ob1$index_ts$get0(previousOriginalColumn));
            previousOriginalColumn = mapping.original.column;

            if (mapping.name !== undefined) {
              const nameIdx = this.names.indexOf(mapping.name);
              next += ___R$romejs$codec$source$map$base64_ts.encodeVLQ(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
        }

        result += next;
      }

      return result;
    }

    generateSourcesContent(sources, sourceRoot) {
      return sources.map(source => {
        if (sourceRoot !== undefined) {
          source = ___R$romejs$codec$source$map$util_ts$toRelativeUrl(sourceRoot, source);
        }
        const content = this.sourcesContents.get(source);
        if (content === undefined) {
          throw new Error('Expected content');
        }
        return content;
      });
    }

    toJSON() {
      if (this.map !== undefined) {
        return this.map;
      }

      const sources = this.sources.toArray();
      this.map = {
        version: 3,
        file: this.file,
        names: this.names.toArray(),
        mappings: this.serializeMappings(),
        sourceRoot: this.sourceRoot,
        sources: sources,
        sourcesContent: this.generateSourcesContent(sources, this.sourceRoot)};
      return this.map;
    }

    toComment() {
      const jsonMap = this.toString();
      const base64Map = new Buffer(jsonMap).toString('base64');
      const comment = '//# sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64Map;
      return comment;
    }

    toString() {
      return JSON.stringify(this.toJSON());
    }
  }

  // romejs/codec-source-map/SourceMapConsumer.ts

  function ___R$$priv$romejs$codec$source$map$SourceMapConsumer_ts$getCacheKey(line, column) {
    return String(line) + ':' + String(column);
  }

  class ___R$romejs$codec$source$map$SourceMapConsumer_ts$default {
    constructor(map) {
      this.map = map;
      this.mappings = undefined;
    }

    static charIsMappingSeparator(str, index) {
      const c = str.charAt(index);
      return c === ';' || c === ',';
    }

    static parseMappings(sourceMap) {
      const rawStr = sourceMap.mappings;
      const map = new Map();

      let generatedLine = ___R$romejs$ob1$index_ts$number1;
      let previousGeneratedColumn = ___R$romejs$ob1$index_ts$number0;
      let previousOriginalLine = ___R$romejs$ob1$index_ts$number1;
      let previousOriginalColumn = ___R$romejs$ob1$index_ts$number0;
      let previousSource = 0;
      let previousName = 0;
      let length = rawStr.length;
      let index = 0;
      let cachedSegments = {};
      let value;

      while (index < length) {
        const char = rawStr[index];
        if (char === ';') {
          generatedLine = ___R$romejs$ob1$index_ts$inc(generatedLine);
          index++;
          previousGeneratedColumn = ___R$romejs$ob1$index_ts$number0;
        } else if (char === ',') {
          index++;
        } else {
          const mapping = {
            generatedLine: generatedLine,
            generatedColumn: ___R$romejs$ob1$index_ts$number0,
            source: undefined,
            originalLine: ___R$romejs$ob1$index_ts$number1,
            originalColumn: ___R$romejs$ob1$index_ts$number0,
            name: undefined};

          let end = index;
          for (; end < length; end++) {
            if (___R$romejs$codec$source$map$SourceMapConsumer_ts$default.charIsMappingSeparator(rawStr, end)) {
              break;
            }
          }
          const str = rawStr.slice(index, end);

          let segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              [value, index] = ___R$romejs$codec$source$map$base64_ts$decodeVLQ(rawStr, index);
              segment.push(value);
            }

            if (segment.length === 2) {
              throw new Error('Found a source, but no line and column');
            }

            if (segment.length === 3) {
              throw new Error('Found a source and line, but no column');
            }

            cachedSegments[str] = segment;
          }

          mapping.generatedColumn = ___R$romejs$ob1$index_ts$add(previousGeneratedColumn, segment[0]);
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];

            const newOriginalLine = ___R$romejs$ob1$index_ts$add(previousOriginalLine, segment[2]);
            previousOriginalLine = newOriginalLine;

            mapping.originalLine = ___R$romejs$ob1$index_ts$add(newOriginalLine, 1);

            const newOriginalColumn = ___R$romejs$ob1$index_ts$add(previousOriginalColumn, segment[3]);
            mapping.originalColumn = newOriginalColumn;
            previousOriginalColumn = newOriginalColumn;

            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          map.set(
          ___R$$priv$romejs$codec$source$map$SourceMapConsumer_ts$getCacheKey(mapping.generatedLine, mapping.generatedColumn),
          mapping);
        }
      }

      return map;
    }

    getMappings() {
      if (this.mappings === undefined) {
        const mappings = ___R$romejs$codec$source$map$SourceMapConsumer_ts$default.parseMappings(this.map);
        this.mappings = mappings;
        return mappings;
      } else {
        return this.mappings;
      }
    }

    approxOriginalPositionFor(line, column) {
      while (___R$romejs$ob1$index_ts$get0(column) >= 0) {
        const mapping = this.exactOriginalPositionFor(line, column);
        if (mapping === undefined) {
          column = ___R$romejs$ob1$index_ts$dec(column);
          continue;
        } else {
          return mapping;
        }
      }

      return undefined;
    }

    exactOriginalPositionFor(line, column) {
      const key = ___R$$priv$romejs$codec$source$map$SourceMapConsumer_ts$getCacheKey(line, column);
      const mapping = this.getMappings().get(key);
      if (mapping === undefined) {
        return undefined;
      }

      const source = mapping.source == undefined ? this.map.file : this.map.sources[mapping.source];
      if (source === undefined) {
        throw new Error('Mapping provided unknown source');
      }

      return {
        source: source,
        line: mapping.originalLine,
        column: mapping.originalColumn,
        name: mapping.name === undefined ? undefined : this.map.names[mapping.name]};
    }
  }

  // romejs/codec-source-map/types.ts


  // romejs/codec-source-map/index.ts


  // romejs/v8/types.ts

  const ___R$romejs$v8$types_ts = {};
  const ___R$$priv$romejs$v8$types_ts$inspector = require('inspector');

  // romejs/typescript-helpers/index.ts


  function ___R$romejs$typescript$helpers$index_ts$isPlainObject(obj) {
    return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
  }

  function ___R$romejs$typescript$helpers$index_ts$isIterable(obj) {
    return typeof obj === 'object' &&
    obj != null &&
    typeof obj[Symbol.iterator] === 'function';
  }

  // romejs/v8/errors.ts

  const ___R$romejs$v8$errors_ts = {
    get ERROR_FRAMES_PROP() {
      return ___R$romejs$v8$errors_ts$ERROR_FRAMES_PROP;
    },
    get ERROR_ADVICE_PROP() {
      return ___R$romejs$v8$errors_ts$ERROR_ADVICE_PROP;
    },
    get ERROR_POP_FRAMES_PROP() {
      return ___R$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP;
    },
    createErrorFromStructure: ___R$romejs$v8$errors_ts$createErrorFromStructure,
    getErrorStructure: ___R$romejs$v8$errors_ts$getErrorStructure,
    getSourceLocationFromErrorFrame: ___R$romejs$v8$errors_ts$getSourceLocationFromErrorFrame};
  Object.keys(___R$romejs$v8$types_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$v8$errors_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$v8$types_ts[key];
      }});
  });
  const ___R$romejs$v8$errors_ts$ERROR_FRAMES_PROP = Symbol();
  const ___R$romejs$v8$errors_ts$ERROR_ADVICE_PROP = Symbol();
  const ___R$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP = Symbol();

  class ___R$$priv$romejs$v8$errors_ts$NativeStructuredError extends Error {
    constructor(struct) {
      super(struct.message);
      this.name = struct.name === undefined ? 'Error' : struct.name;
      this.stack = struct.stack;

      this[___R$romejs$v8$errors_ts$ERROR_FRAMES_PROP] = struct.frames;
      this[___R$romejs$v8$errors_ts$ERROR_ADVICE_PROP] = struct.advice;
      this[___R$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP] = struct.framesToPop;
    }
  }

  function ___R$romejs$v8$errors_ts$createErrorFromStructure(struct) {
    return new ___R$$priv$romejs$v8$errors_ts$NativeStructuredError(struct);
  }

  function ___R$romejs$v8$errors_ts$getErrorStructure(err) {
    let name = 'Error';
    let message = 'Unknown message';
    let stack = undefined;
    let frames = [];
    let advice = [];
    let framesToPop = 0;

    let looksLikeValidError = false;

    if (___R$romejs$typescript$helpers$index_ts$isPlainObject(err)) {
      if (typeof err.name === 'string') {
        looksLikeValidError = true;
        name = err.name;
      }

      if (typeof err.message === 'string') {
        looksLikeValidError = true;
        message = err.message;
      }

      if (typeof err.stack === 'string') {
        looksLikeValidError = true;
        stack = err.stack;
      }

      if (Array.isArray(err[___R$romejs$v8$errors_ts$ERROR_FRAMES_PROP])) {
        frames = err[___R$romejs$v8$errors_ts$ERROR_FRAMES_PROP];
      }

      if (Array.isArray(err[___R$romejs$v8$errors_ts$ERROR_ADVICE_PROP])) {
        advice = err[___R$romejs$v8$errors_ts$ERROR_ADVICE_PROP];
      }

      if (typeof err[___R$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP] === 'number') {
        framesToPop = err[___R$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP];
      }
    }

    if (!looksLikeValidError) {
      message = 'Not an error instance: ' + String(err);
    }

    return {
      name: name,
      message: message,
      stack: stack,
      frames: frames,
      advice: advice,
      framesToPop: framesToPop};
  }

  function ___R$romejs$v8$errors_ts$getSourceLocationFromErrorFrame(frame) {
    const pos = {
      index: ___R$romejs$ob1$index_ts$number0Neg1,
      line: frame.lineNumber === undefined ? ___R$romejs$ob1$index_ts$number1 : frame.lineNumber,
      column: frame.columnNumber === undefined ? ___R$romejs$ob1$index_ts$number0 : frame.columnNumber};

    return {
      filename: frame.filename === undefined ? 'unknown' : frame.filename,
      start: pos,
      end: pos};
  }

  // romejs/v8/sourceMapManager.ts

  const ___R$romejs$v8$sourceMapManager_ts = {
    init: ___R$romejs$v8$sourceMapManager_ts$init,
    teardown: ___R$romejs$v8$sourceMapManager_ts$teardown,
    resolveLocation: ___R$romejs$v8$sourceMapManager_ts$resolveLocation,
    addSourceMap: ___R$romejs$v8$sourceMapManager_ts$addSourceMap,
    addSourceMapFactory: ___R$romejs$v8$sourceMapManager_ts$addSourceMapFactory,
    getSourceMap: ___R$romejs$v8$sourceMapManager_ts$getSourceMap};

  let ___R$$priv$romejs$v8$sourceMapManager_ts$inited = false;
  const ___R$$priv$romejs$v8$sourceMapManager_ts$maps = new Map();

  const ___R$$priv$romejs$v8$sourceMapManager_ts$factories = new Map();

  function ___R$$priv$romejs$v8$sourceMapManager_ts$prepareStackTrace(err, frames) {
    try {
      ___R$$priv$romejs$v8$sourceMapManager_ts$addErrorFrames(err, frames);
      return ___R$$priv$romejs$v8$sourceMapManager_ts$buildStackString(err);
    } catch (err2) {
      return err.name + ': ' + err.message + '\n  Failed to generate stacktrace: ' + err2.message;
    }
  }

  function ___R$romejs$v8$sourceMapManager_ts$init() {
    if (!___R$$priv$romejs$v8$sourceMapManager_ts$inited) {
      ___R$$priv$romejs$v8$sourceMapManager_ts$inited = true;
      Error.prepareStackTrace = ___R$$priv$romejs$v8$sourceMapManager_ts$prepareStackTrace;
    }
  }

  function ___R$romejs$v8$sourceMapManager_ts$teardown() {
    Error.prepareStackTrace = undefined;
  }

  function ___R$$priv$romejs$v8$sourceMapManager_ts$buildStackString(err) {
    const {frames: frames} = ___R$romejs$v8$errors_ts$getErrorStructure(err);
    const lines = [];

    lines.push(err.name + ': ' + err.message);

    for (const frame of frames) {
      const {
        resolvedLocation: resolvedLocation,
        methodName: methodName,
        functionName: functionName,
        typeName: typeName,
        isNative: isNative,
        isAsync: isAsync,
        isEval: isEval,
        isConstructor: isConstructor,
        filename: filename,
        lineNumber: lineNumber,
        columnNumber: columnNumber} = frame;
      const parts = [];

      if (isAsync) {
        parts.push('await');
      }

      if (isEval) {
        parts.push('eval');
      }

      if (isConstructor) {
        parts.push('new');
      }

      let name = '<anonymous';
      if (functionName !== undefined) {
        name = functionName;
      }
      if (methodName !== undefined) {
        name = methodName;
      }
      if (typeName !== undefined) {
        parts.push(typeName + '.' + name);
      } else {
        parts.push(name);
      }

      if (isNative) {
        parts.push('native');
      } else if (filename !== undefined &&
      lineNumber !== undefined &&
      columnNumber !== undefined) {
        parts.push('(' + filename + ':' + lineNumber + ':' + columnNumber + ')');
      }

      if (resolvedLocation === false) {
        parts.push('generated source location');
      }

      lines.push('  at ' + parts.join(' '));
    }

    return lines.join('\n');
  }

  function ___R$$priv$romejs$v8$sourceMapManager_ts$noNull(val) {
    if (val === null) {
      return undefined;
    } else {
      return val;
    }
  }

  function ___R$$priv$romejs$v8$sourceMapManager_ts$addErrorFrames(err, frames) {
    if (err[___R$romejs$v8$errors_ts$ERROR_FRAMES_PROP]) {
      return undefined;
    }

    let builtFrames = frames.map(
    frameApi => {
      const filename = frameApi.getFileName();
      const lineNumber = frameApi.getLineNumber();
      const columnNumber = frameApi.getColumnNumber();

      const frame = {
        typeName: ___R$$priv$romejs$v8$sourceMapManager_ts$noNull(frameApi.getTypeName()),
        functionName: ___R$$priv$romejs$v8$sourceMapManager_ts$noNull(frameApi.getFunctionName()),
        methodName: ___R$$priv$romejs$v8$sourceMapManager_ts$noNull(frameApi.getMethodName()),

        isTopLevel: frameApi.isToplevel(),
        isEval: frameApi.isEval(),
        isNative: frameApi.isNative(),
        isConstructor: frameApi.isConstructor(),

        isAsync: false,

        resolvedLocation: true,

        filename: ___R$$priv$romejs$v8$sourceMapManager_ts$noNull(filename),
        lineNumber: lineNumber == null ? undefined : ___R$romejs$ob1$index_ts$coerce1(lineNumber),

        columnNumber: columnNumber == null ? undefined : ___R$romejs$ob1$index_ts$coerce1to0(columnNumber)};

      if (frame.filename !== undefined &&
      frame.lineNumber !== undefined &&
      frame.columnNumber !== undefined) {
        const {found: found, line: line, column: column, filename: filename, name: name} = ___R$romejs$v8$sourceMapManager_ts$resolveLocation(
        frame.filename,
        frame.lineNumber,
        frame.columnNumber);

        return Object.assign({}, frame, {
          functionName: frame.functionName === undefined ? name : frame.functionName,
          methodName: frame.methodName === undefined ? name : frame.methodName,
          resolvedLocation: found,
          lineNumber: line,
          columnNumber: column,
          filename: filename});
      } else {
        return frame;
      }
    });

    const framesToProp = err[___R$romejs$v8$errors_ts$ERROR_POP_FRAMES_PROP];
    if (typeof framesToProp === 'number') {
      builtFrames = builtFrames.slice(framesToProp);
    }

    err[___R$romejs$v8$errors_ts$ERROR_FRAMES_PROP] = builtFrames;
  }

  function ___R$romejs$v8$sourceMapManager_ts$resolveLocation(filename, line, column) {
    const map = ___R$romejs$v8$sourceMapManager_ts$getSourceMap(filename);
    if (map === undefined) {
      return {
        found: true,
        filename: filename,
        line: line,
        column: column,
        name: undefined};
    }

    const resolved = map.approxOriginalPositionFor(line, column);
    if (resolved === undefined) {
      return {
        found: false,
        filename: filename,
        line: line,
        column: column,
        name: undefined};
    }

    return {
      found: true,
      filename: resolved.source,
      line: resolved.line,
      column: resolved.column,
      name: resolved.name};
  }

  function ___R$romejs$v8$sourceMapManager_ts$addSourceMap(filename, map) {
    return ___R$romejs$v8$sourceMapManager_ts$addSourceMapFactory(filename, () => map);
  }

  function ___R$romejs$v8$sourceMapManager_ts$addSourceMapFactory(filename, factory) {
    ___R$romejs$v8$sourceMapManager_ts$init();

    let map;
    const factoryCapture = () => {
      map = factory();
      return map;
    };

    ___R$$priv$romejs$v8$sourceMapManager_ts$factories.set(filename, factoryCapture);

    return () => {
      if (___R$$priv$romejs$v8$sourceMapManager_ts$factories.get(filename) === factoryCapture) {
        ___R$$priv$romejs$v8$sourceMapManager_ts$factories.delete(filename);
      }

      if (___R$$priv$romejs$v8$sourceMapManager_ts$maps.get(filename) === map) {
        ___R$$priv$romejs$v8$sourceMapManager_ts$maps.delete(filename);
      }
    };
  }

  function ___R$romejs$v8$sourceMapManager_ts$getSourceMap(filename) {
    if (___R$$priv$romejs$v8$sourceMapManager_ts$maps.has(filename)) {
      return ___R$$priv$romejs$v8$sourceMapManager_ts$maps.get(filename);
    }

    const factory = ___R$$priv$romejs$v8$sourceMapManager_ts$factories.get(filename);
    if (factory !== undefined) {
      ___R$$priv$romejs$v8$sourceMapManager_ts$factories.delete(filename);
      const map = factory();
      const consumer = new ___R$romejs$codec$source$map$SourceMapConsumer_ts$default(map);
      ___R$$priv$romejs$v8$sourceMapManager_ts$maps.set(filename, consumer);
      return consumer;
    }
  }

  // romejs/v8/utils.ts

  const ___R$romejs$v8$utils_ts = {
    hrTime: ___R$romejs$v8$utils_ts$hrTime,
    urlToFilename: ___R$romejs$v8$utils_ts$urlToFilename};
  function ___R$romejs$v8$utils_ts$hrTime() {
    const hrtime = process.hrtime();
    const ts = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);
    return ts;
  }

  const ___R$$priv$romejs$v8$utils_ts$FILE_PROTOCOL = 'file://';

  function ___R$romejs$v8$utils_ts$urlToFilename(url) {
    if (url.startsWith(___R$$priv$romejs$v8$utils_ts$FILE_PROTOCOL)) {
      return url.slice(___R$$priv$romejs$v8$utils_ts$FILE_PROTOCOL.length);
    } else {
      return url;
    }
  }

  // romejs/v8/Profiler.ts

  const ___R$$priv$romejs$v8$Profiler_ts$inspector = require('inspector');
  class ___R$romejs$v8$Profiler_ts$default {
    constructor() {
      this.session = undefined;
      this.memoryInterval = undefined;
      this.memorySamples = [];
    }

    async startProfiling(samplingInterval) {
      this.session = new ___R$$priv$romejs$v8$Profiler_ts$inspector.Session();
      this.session.connect();

      this.memoryInterval = setInterval(() => {
        const time = ___R$romejs$v8$utils_ts$hrTime();
        const size = process.memoryUsage().heapUsed;
        this.memorySamples.push([time, size]);
      }, 100);

      await Promise.all([this.sendCommand('Profiler.setSamplingInterval', {
        interval: samplingInterval}), this.sendCommand('Profiler.enable'), this.sendCommand('Profiler.start')]);
    }

    async sendCommand(method, params) {
      const {session: session} = this;
      if (session === undefined) {
        return Promise.reject(new Error('No current profiler session'));
      } else {
        return new Promise((resolve, reject) => {
          session.post(method, params, (err, params) => {
            if (err === null) {
              resolve();
            } else {
              reject(err);
            }
          });
        });
      }
    }

    destroy() {
      const {session: session} = this;
      if (session !== undefined) {
        if (this.memoryInterval !== undefined) {
          clearInterval(this.memoryInterval);
        }
        this.memorySamples = [];
        session.disconnect();
      }
    }

    async stopProfiling() {
      const {session: session} = this;
      if (session === undefined) {
        return Promise.reject(new Error('No current profiler session'));
      }

      const {memorySamples: memorySamples} = this;

      const res = await new Promise((resolve, reject) => {
        session.post('Profiler.stop', (err, params) => {
          if (err === null) {
            resolve(params);
          } else {
            reject(err);
          }
        });
      });

      this.destroy();

      return {
        pid: process.pid,
        cpuProfile: res.profile,
        memorySamples: memorySamples};
    }
  }

  // romejs/v8/Trace.ts

  class ___R$romejs$v8$Trace_ts$default {
    constructor() {
      this.tid = 0;
      this.eventId = 0;
      this.events = [];
    }

    getEventId() {
      const id = this.eventId;
      this.eventId++;
      return id;
    }

    decodeProfileSourceMap(profile) {
      for (const node of profile.cpuProfile.nodes) {
        const {callFrame: callFrame} = node;
        const filename = ___R$romejs$v8$utils_ts$urlToFilename(callFrame.url);
        const sourceMap = ___R$romejs$v8$sourceMapManager_ts.getSourceMap(filename);
        if (sourceMap === undefined) {
          continue;
        }

        const resolved = sourceMap.approxOriginalPositionFor(
        ___R$romejs$ob1$index_ts$coerce0to1(___R$romejs$ob1$index_ts$coerce0(callFrame.lineNumber)),
        ___R$romejs$ob1$index_ts$coerce0(callFrame.columnNumber));
        if (resolved !== undefined) {
          callFrame.url = resolved.source;
          callFrame.lineNumber = ___R$romejs$ob1$index_ts$get0(___R$romejs$ob1$index_ts$coerce1to0(resolved.line));
          callFrame.columnNumber = ___R$romejs$ob1$index_ts$get0(resolved.column);

          if (resolved.name !== undefined) {
            callFrame.functionName = resolved.name;
          }
        }
      }
    }

    addProfile(name, profile) {
      this.decodeProfileSourceMap(profile);

      const {startTime: startTime, endTime: endTime} = profile.cpuProfile;

      const common = {
        pid: 1,
        tid: profile.pid};

      this.events.push(Object.assign({}, common, {
        ts: 0,
        ph: 'M',
        cat: '__metadata',
        name: 'thread_name',
        args: {name: name}}));

      this.events.push(Object.assign({}, common, {
        ph: 'P',
        name: 'CpuProfile',
        id: this.getEventId(),
        cat: 'disabled-by-default-v8.cpu_profiler',
        ts: endTime,
        args: {
          data: {
            cpuProfile: profile.cpuProfile}}}));

      this.events.push(Object.assign({}, common, {
        ph: 'X',
        name: 'EvaluateScript',
        id: this.getEventId(),
        cat: 'devtools.timeline',
        ts: startTime,
        dur: endTime - startTime,
        args: {
          data: {
            url: 'rome.js',
            lineNumber: 1,
            columnNumber: 1,
            frame: '0xFFF'}}}));

      for (const [time, size] of profile.memorySamples) {
        this.events.push(Object.assign({}, common, {
          ts: time,
          ph: 'I',
          cat: 'disabled-by-default-devtools.timeline',
          name: 'UpdateCounters',
          args: {
            data: {
              jsHeapSizeUsed: size}},
          s: 't'}));
      }
    }

    build() {
      return this.events;
    }
  }

  // romejs/codec-json/types.ts


  // romejs/messages/index.ts

  function ___R$$priv$romejs$messages$index_ts$sprintf(msg, ...args) {
    return msg.replace(/\$(\d+)/g, (match, num) => {
      return String(args[num]);
    });
  }

  function ___R$romejs$messages$index_ts$default(messages) {
    const obj = {};

    for (const key in messages) {
      const msg = messages[key];

      obj[key] = (...args) => {
        return ___R$$priv$romejs$messages$index_ts$sprintf.apply(null, [msg, ...args]);
      };
    }

    return obj;
  }

  // romejs/codec-json/messages.ts

  const ___R$romejs$codec$json$messages_ts$default = ___R$romejs$messages$index_ts$default({
    SINGLE_QUOTE_USAGE: 'You can only use double quoted strings',
    TRAILING_COMMA_VALUE: 'Trailing comma is only allowed after a value',
    UNCLOSED_STRING: 'Unclosed string',
    UNCLOSED_BLOCK_COMMENT: 'Unclosed block comment',
    MISTAKEN_ARRAY_IDENTITY: 'Trying to use an array element as an object property. Did you mean to make an object?',
    REDUNDANT_COMMA: 'Redundant comma',

    EMPTY_INPUT_IN_JSON: 'Empty input',
    PROPERTY_KEY_UNQUOTED_IN_JSON: 'Property keys must be quoted in JSON',
    IMPLICIT_OBJECT_IN_JSON: 'Objects must be wrapped in curly braces in JSON',
    COMMENTS_IN_JSON: 'Comments aren\'t allowed in JSON',
    TRAILING_COMMA_IN_JSON: 'Trailing commas aren\'t allowed in JSON',
    REGEX_IN_JSON: 'Regular expressions aren\'t allowed in JSON',
    UNKNOWN_WORD_IN_JSON: '$0 isn\'t a valid JSON word',
    STRING_NEWLINES_IN_JSON: 'Newlines aren\'t allowed in JSON, you insert a newline by escaping it like this "\\n"',
    UNDEFINED_IN_JSON: 'undefined isn\'t allowed in JSON, you could use null instead',
    BIGINT_IN_JSON: 'Bigints aren\'t allowed in JSON',
    NUMERIC_SEPARATORS_IN_JSON: 'Numeric separators are not allowed in JSON'});

  // romejs/codec-json/parse.ts

  function ___R$$priv$romejs$codec$json$parse_ts$isWordStartChar(char) {
    return ___R$romejs$parser$core$index_ts$isAlpha(char) || char === '_' || char === '$';
  }

  function ___R$$priv$romejs$codec$json$parse_ts$isWordChar(char) {
    return ___R$$priv$romejs$codec$json$parse_ts$isWordStartChar(char) || ___R$romejs$parser$core$index_ts$isDigit(char);
  }

  function ___R$romejs$codec$json$parse_ts$isValidWord(word) {
    if (word.length === 0 || ___R$$priv$romejs$codec$json$parse_ts$isWordStartChar(word[0]) === false) {
      return false;
    }

    for (const char of word) {
      if (___R$$priv$romejs$codec$json$parse_ts$isWordChar(char) === false) {
        return false;
      }
    }

    return true;
  }

  function ___R$$priv$romejs$codec$json$parse_ts$isStringValueChar(char, index, input) {
    if (char === '\n') {
      return false;
    }

    if (char === '"' && !___R$romejs$parser$core$index_ts$isEscaped(index, input)) {
      return false;
    }

    return true;
  }

  function ___R$romejs$codec$json$parse_ts$toPathKey(parts) {
    return parts.join('.');
  }

  function ___R$$priv$romejs$codec$json$parse_ts$isntNewline(char) {
    return char !== '\n';
  }

  function ___R$$priv$romejs$codec$json$parse_ts$isntBlockCommentEnd(char, index, input) {
    const nextChar = input[___R$romejs$ob1$index_ts$get0(index) + 1];
    return char !== '*' && nextChar !== '/';
  }

  function ___R$$priv$romejs$codec$json$parse_ts$isNumberChar(char) {
    return ___R$romejs$parser$core$index_ts$isDigit(char) || char === '_';
  }

  const ___R$romejs$codec$json$parse_ts$default = ___R$romejs$parser$core$index_ts$createParser(
  ParserCore => (() => {
    class JSONParser extends ParserCore {
      constructor(opts) {
        super(opts, '@romejs/codec-json');
        this.options = opts;

        this.hasExtensions =
        this.path !== undefined && this.path.getBasename().endsWith('.rjson');

        this.pathKeys = [];
        this.paths = new Map();
        this.pathToComments = new Map();
        this.consumeCategory =
        opts.consumeCategory === undefined ? 'json' : opts.consumeCategory;
      }

      getPathInfo(path) {
        return this.paths.get(path.join('.'));
      }

      setComments(pathComments) {
        const key = this.pathKeys.join('.');

        const existing = this.pathToComments.get(key);
        if (existing === undefined) {
          this.pathToComments.set(key, pathComments);
        } else {
          this.pathToComments.set(key, {
            inner: [...existing.inner, ...pathComments.inner],
            outer: [...existing.outer, ...pathComments.outer]});
        }
      }

      setPath(info) {
        this.paths.set(this.pathKeys.join('.'), info);
        this.pathKeys.pop();
      }

      tokenize(index, input) {
        const nextChar = input[___R$romejs$ob1$index_ts$get0(index) + 1];
        const char = input[___R$romejs$ob1$index_ts$get0(index)];

        if (char === '/' && nextChar === '/') {
          const commentValueIndex = ___R$romejs$ob1$index_ts$add(index, 2);
          const value = this.readInputFrom(commentValueIndex, ___R$$priv$romejs$codec$json$parse_ts$isntNewline);

          return this.finishValueToken(
          'LineComment',
          value,
          ___R$romejs$ob1$index_ts$add(commentValueIndex, value.length));
        }

        if (char === '/' && nextChar === '*') {
          const commentValueIndex = ___R$romejs$ob1$index_ts$add(index, 2);
          const value = this.readInputFrom(
          commentValueIndex,
          ___R$$priv$romejs$codec$json$parse_ts$isntBlockCommentEnd);

          const endIndex = ___R$romejs$ob1$index_ts$add(___R$romejs$ob1$index_ts$add(commentValueIndex, value.length), 2);

          if (this.input[___R$romejs$ob1$index_ts$get0(endIndex) - 2] !== '*' ||
          this.input[___R$romejs$ob1$index_ts$get0(endIndex) - 1] !== '/') {
            throw this.unexpected({
              message: ___R$romejs$codec$json$messages_ts$default.UNCLOSED_BLOCK_COMMENT(),
              start: this.getPositionFromIndex(endIndex)});
          }

          return this.finishValueToken('BlockComment', value, endIndex);
        }

        switch (char) {
          case '"':
            const value = this.readInputFrom(___R$romejs$ob1$index_ts$inc(index), ___R$$priv$romejs$codec$json$parse_ts$isStringValueChar);

            const end = ___R$romejs$ob1$index_ts$add(___R$romejs$ob1$index_ts$add(index, value.length), 2);
            if (input[___R$romejs$ob1$index_ts$get0(end) - 1] !== '"') {
              throw this.unexpected({
                message: ___R$romejs$codec$json$messages_ts$default.UNCLOSED_STRING(),
                start: this.getPositionFromIndex(end)});
            }

            for (let strIndex = 0; strIndex < value.length; strIndex++) {
              const char = value[strIndex];

              if (char === '\n') {
                throw this.unexpected({
                  message: ___R$romejs$codec$json$messages_ts$default.STRING_NEWLINES_IN_JSON(),
                  start: this.getPositionFromIndex(___R$romejs$ob1$index_ts$add(index, strIndex))});
              }
            }

            const unescaped = ___R$romejs$string$escape$unescapeString_ts$default(value, (message, strIndex) => {
              throw this.unexpected({
                message: message,
                start: this.getPositionFromIndex(___R$romejs$ob1$index_ts$add(index, strIndex))});
            });

            return this.finishValueToken('String', unescaped, end);

          case '\'':
            throw this.unexpected({
              message: ___R$romejs$codec$json$messages_ts$default.SINGLE_QUOTE_USAGE(),
              start: this.getPositionFromIndex(index)});

          case '/':
            throw this.unexpected({
              message: ___R$romejs$codec$json$messages_ts$default.REGEX_IN_JSON(),
              start: this.getPositionFromIndex(index)});

          case ',':
            return this.finishToken('Comma');

          case '.':
            return this.finishToken('Dot');

          case '-':
            return this.finishToken('Minus');

          case '+':
            return this.finishToken('Plus');

          case ':':
            return this.finishToken('Colon');

          case '{':
            return this.finishToken('BraceOpen');

          case '}':
            return this.finishToken('BraceClose');

          case '[':
            return this.finishToken('BracketOpen');

          case ']':
            return this.finishToken('BracketClose');

          case ' ':
          case '\t':
          case '\r':
          case '\n':
            return this.lookaheadToken(___R$romejs$ob1$index_ts$inc(index));}

        if (___R$romejs$parser$core$index_ts$isDigit(char)) {
          const value = this.removeUnderscores(
          index,
          this.readInputFrom(index, ___R$$priv$romejs$codec$json$parse_ts$isNumberChar));
          const num = Number(value);
          return this.finishValueToken('Number', num, ___R$romejs$ob1$index_ts$add(index, value.length));
        }

        if (___R$$priv$romejs$codec$json$parse_ts$isWordStartChar(char)) {
          const value = this.readInputFrom(index, ___R$$priv$romejs$codec$json$parse_ts$isWordChar);
          return this.finishValueToken('Word', value, ___R$romejs$ob1$index_ts$add(index, value.length));
        }

        return undefined;
      }

      parseObject(firstKeyStart, firstKey) {
        const obj = {};

        let innerComments = [];
        let isFirstProp = true;

        let nextLeadingComments;

        do {
          if (this.matchToken('BraceClose')) {
            break;
          }

          let leadingComments = this.eatComments();

          if (nextLeadingComments !== undefined) {
            leadingComments = [...nextLeadingComments, ...leadingComments];
            nextLeadingComments = undefined;
          }

          if (this.matchToken('Comma')) {
            throw this.unexpected({
              message: ___R$romejs$codec$json$messages_ts$default.REDUNDANT_COMMA()});
          }

          const hasKey = isFirstProp && firstKey !== undefined;
          if (!hasKey &&
          !this.matchToken('String') &&
          !this.matchToken('Word')) {
            innerComments = [...innerComments, ...leadingComments];
            break;
          }

          const keyStart = isFirstProp && firstKeyStart !== undefined ? firstKeyStart : this.getPosition();

          let key;
          if (isFirstProp && firstKey !== undefined) {
            key = firstKey;
          } else {
            key = this.parsePropertyKey();
          }
          isFirstProp = false;

          const keyEnd = this.getPosition();
          this.expectToken('Colon');

          const leadingValueComments = this.eatComments();

          this.pathKeys.push(key);

          const valueStart = this.getPosition();
          const value = this.parseExpression();
          const valueEnd = this.getPrevEndPosition();

          let trailingValueComments = this.eatComments();

          if (!this.matchToken('Comma') && !this.matchToken('BraceClose')) {
            nextLeadingComments = trailingValueComments;
            trailingValueComments = [];
          }

          this.setComments({
            inner: [],
            outer: [...leadingComments, ...leadingValueComments, ...trailingValueComments]});

          this.setPath({
            keyStart: keyStart,
            keyEnd: keyEnd,
            valueStart: valueStart,
            valueEnd: valueEnd,
            originalValue: value});

          if (key === '__proto__') {
            Object.defineProperty(obj, '__proto__', {
              value: value,
              configurable: true,
              writable: true,
              enumerable: true});
          } else {
            obj[key] = value;
          }
        } while (this.eatPropertySeparator());

        if (nextLeadingComments !== undefined) {
          innerComments = [...innerComments, ...nextLeadingComments];
        }

        if (firstKey === undefined) {
          this.expectToken('BraceClose');
        }

        this.setComments({
          inner: innerComments,
          outer: []});

        return obj;
      }

      removeUnderscores(index, raw) {
        let str = '';

        for (let i = 0; i < raw.length; i++) {
          const char = raw[i];

          if (char === '_') {
            if (!this.hasExtensions) {
              throw this.unexpected({
                message: ___R$romejs$codec$json$messages_ts$default.NUMERIC_SEPARATORS_IN_JSON(),
                start: this.getPositionFromIndex(___R$romejs$ob1$index_ts$inc(index))});
            }
          } else {
            str += char;
          }
        }

        return str;
      }

      eatComments() {
        const comments = [];

        while (true) {
          const token = this.getToken();

          if (token.type === 'LineComment') {
            comments.push({
              type: 'LineComment',
              value: token.value});
          } else if (token.type === 'BlockComment') {
            comments.push({
              type: 'BlockComment',
              value: token.value});
          } else {
            break;
          }

          if (!this.hasExtensions) {
            throw this.unexpected({message: ___R$romejs$codec$json$messages_ts$default.COMMENTS_IN_JSON()});
          }

          this.nextToken();
        }

        return comments;
      }

      parseArray() {
        this.expectToken('BracketOpen');

        const arr = [];
        let innerComments = [];
        let i = 0;

        do {
          if (this.matchToken('BracketClose')) {
            break;
          }

          const leadingComments = this.eatComments();

          if (this.matchToken('Comma')) {
            throw this.unexpected({
              message: ___R$romejs$codec$json$messages_ts$default.REDUNDANT_COMMA()});
          }

          if (this.matchToken('BracketClose')) {
            innerComments = [...innerComments, ...leadingComments];
            break;
          }

          const start = this.getPosition();
          this.pathKeys.push(i);
          i++;

          const item = this.parseExpression();
          arr.push(item);
          const end = this.getPrevEndPosition();

          const trailingComments = this.eatComments();

          this.setComments({
            outer: [...leadingComments, ...trailingComments],
            inner: []});

          this.setPath({
            originalValue: item,
            keyStart: start,
            keyEnd: end,
            valueStart: start,
            valueEnd: end});

          if (this.matchToken('Colon')) {
            throw this.unexpected({
              message: ___R$romejs$codec$json$messages_ts$default.MISTAKEN_ARRAY_IDENTITY()});
          }
        } while (this.eatPropertySeparator());

        this.expectToken('BracketClose');

        this.setComments({
          inner: innerComments,
          outer: []});

        return arr;
      }

      eatPropertySeparator() {
        const token = this.getToken();

        if (this.hasExtensions) {
          if (token.type === 'Comma') {
            this.nextToken();
          }

          if (token.type === 'BraceClose' || token.type === 'BracketClose') {
            return false;
          }

          return true;
        } else {
          if (token.type !== 'Comma') {
            return false;
          }

          const lookahead = this.lookaheadToken();
          if (lookahead.type === 'BraceClose' ||
          lookahead.type === 'BracketClose') {
            throw this.unexpected({message: ___R$romejs$codec$json$messages_ts$default.TRAILING_COMMA_IN_JSON()});
          }

          this.nextToken();
          return true;
        }
      }

      parseWord(isStart) {
        const start = this.getPosition();
        const token = this.expectToken('Word');

        switch (token.value) {
          case 'true':
            return true;

          case 'false':
            return false;

          case 'null':
            return null;

          case 'undefined':
            throw this.unexpected({message: ___R$romejs$codec$json$messages_ts$default.UNDEFINED_IN_JSON()});}

        if (isStart && this.matchToken('Colon')) {
          if (this.hasExtensions) {
            return this.parseObject(start, token.value);
          } else {
            throw this.unexpected({
              message: ___R$romejs$codec$json$messages_ts$default.IMPLICIT_OBJECT_IN_JSON()});
          }
        }

        throw this.unexpected({
          message: ___R$romejs$codec$json$messages_ts$default.UNKNOWN_WORD_IN_JSON(token.value)});
      }

      parseNumber() {
        const isNegative = this.eatToken('Minus') !== undefined;

        const token = this.expectToken('Number');
        let value = String(token.value);

        if (this.eatToken('Dot')) {
          value += '.';

          const decimal = this.expectToken('Number');
          value += String(decimal.value);
        }

        const nextToken = this.getToken();
        if (nextToken.type === 'Word' &&
        (nextToken.value === 'e' || nextToken.value === 'E')) {
          value += 'e';

          const operator = this.nextToken();
          if (operator.type === 'Minus') {
            value += '-';
          } else if (operator.type === 'Plus') {
            value += '+';
          } else {
            throw this.unexpected();
          }

          this.nextToken();
          const factor = this.expectToken('Number');
          value += String(factor.value);
        }

        const nextToken2 = this.getToken();
        if (nextToken2.type === 'Word' && nextToken2.value === 'n') {
          throw this.unexpected({
            message: ___R$romejs$codec$json$messages_ts$default.BIGINT_IN_JSON()});
        }

        let num = Number(value);
        if (isNegative) {
          num = -num;
        }
        return num;
      }

      parsePropertyKey() {
        const token = this.getToken();

        switch (token.type) {
          case 'String':
            this.nextToken();
            return token.value;

          case 'Word':
            if (this.hasExtensions) {
              this.nextToken();
              return token.value;
            } else {
              throw this.unexpected({
                message: ___R$romejs$codec$json$messages_ts$default.PROPERTY_KEY_UNQUOTED_IN_JSON()});
            }

          default:
            throw this.unexpected();}
      }

      parseString(isStart) {
        const start = this.getPosition();
        const token = this.expectToken('String');

        if (isStart && this.nextToken().type === 'Colon') {
          if (this.hasExtensions) {
            return this.parseObject(start, token.value);
          } else {
            throw this.unexpected({
              message: ___R$romejs$codec$json$messages_ts$default.IMPLICIT_OBJECT_IN_JSON()});
          }
        } else {
          return token.value;
        }
      }

      parseExpression(isStart = false) {
        const token = this.getToken();

        switch (token.type) {
          case 'String':
            return this.parseString(isStart);

          case 'Minus':
          case 'Number':
            return this.parseNumber();

          case 'Word':
            return this.parseWord(isStart);

          case 'BracketOpen':
            return this.parseArray();

          case 'BraceOpen':
            this.nextToken();
            return this.parseObject();

          default:
            throw this.unexpected();}
      }

      parseEntry() {
        if (this.matchToken('EOF')) {
          if (this.hasExtensions) {
            return {};
          } else {
            throw this.unexpected({message: ___R$romejs$codec$json$messages_ts$default.EMPTY_INPUT_IN_JSON()});
          }
        } else {
          return this.parseExpression(true);
        }
      }

      parse() {
        let expectSyntaxError = false;

        if (!this.hasExtensions) {
          try {
            const value = JSON.parse(this.input);

            let context;
            const getContext = () => {
              if (context === undefined) {
                const res = this._parse();
                context = res.context;
                return res.context;
              } else {
                return context;
              }
            };

            return {
              context: {
                category: this.consumeCategory,
                getOriginalValue(path) {
                  return getContext().getOriginalValue(path);
                },

                getDiagnosticPointer(keys, target) {
                  return getContext().getDiagnosticPointer(keys, target);
                }},
              value: value};
          } catch (err) {
            if (err instanceof SyntaxError) {
              expectSyntaxError = true;
            } else {
              throw err;
            }
          }
        }

        const res = this._parse();

        if (expectSyntaxError) {
          throw new Error('JSON.parse failed but our custom JSON parser was successful... That doesn\'t smell right');
        }

        return res;
      }

      _parse() {
        const leadingComments = this.eatComments();

        const expr = this.parseEntry();

        const trailingComments = this.eatComments();
        this.setComments({
          inner: [],
          outer: [...leadingComments, ...trailingComments]});

        this.finalize();

        const context = {
          category: this.consumeCategory,

          getDiagnosticPointer: (keys, target) => {
            const info = this.getPathInfo(keys);
            if (info === undefined) {
              return;
            }

            let start = info.keyStart;
            let end = info.valueEnd;

            if (target === 'key') {
              end = info.keyEnd;
            }

            if (target === 'value' || target === 'inner-value') {
              start = info.valueStart;
            }

            let loc = {
              filename: this.filename,
              start: start,
              end: end};

            if (target === 'inner-value') {
              const originalValue = context.getOriginalValue(keys);

              if (typeof originalValue === 'string') {
                loc = Object.assign({}, loc, {
                  start: Object.assign({}, loc.start, {
                    column: ___R$romejs$ob1$index_ts$add(loc.start.column, 1)}),
                  end: Object.assign({}, loc.end, {
                    column: ___R$romejs$ob1$index_ts$sub(loc.end.column, 1)})});
              }
            }

            return Object.assign({
              language: 'json'}, loc, {
              mtime: this.mtime,
              sourceText: undefined});
          },

          getOriginalValue: keys => {
            const info = this.getPathInfo(keys);
            if (info !== undefined) {
              return info.originalValue;
            }
          }};

        return {
          value: expr,
          context: context};
      }
    }
    return JSONParser;
  })());

  // romejs/consume/types.ts

  const ___R$romejs$consume$types_ts = {};

  // romejs/js-ast-utils/assertMultipleNodes.ts

  function ___R$romejs$js$ast$utils$assertMultipleNodes_ts$default(result) {
    if (Array.isArray(result)) {
      return result;
    } else if (result === undefined) {
      return [];
    } else if (typeof result === 'symbol') {
      throw new Error('No symbols expected here');
    } else {
      return [result];
    }
  }

  // romejs/js-ast-utils/assertSingleNode.ts

  function ___R$romejs$js$ast$utils$assertSingleNode_ts$default(result) {
    if (Array.isArray(result)) {
      if (result.length !== 1) {
        throw new Error('Expected node list length of 1 but got ' + result.length);
      }
      return result[0];
    } else if (result === undefined) {
      throw new Error('Expected node or node list but got null');
    } else if (typeof result === 'symbol') {
      throw new Error('No symbols expected here');
    } else {
      return result;
    }
  }

  // romejs/js-ast-utils/assertSingleOrMultipleNode.ts

  function ___R$romejs$js$ast$utils$assertSingleOrMultipleNode_ts$default(result) {
    if (result === undefined) {
      throw new Error('Expected node or node list but got null');
    } else if (typeof result === 'symbol') {
      throw new Error('No symbols expected here');
    } else {
      return result;
    }
  }

  // romejs/js-ast-utils/getNodeReferenceParts.ts

  function ___R$romejs$js$ast$utils$getNodeReferenceParts_ts$default(node) {
    const parts = [];

    function add(node) {
      if (node.type === 'Identifier' || node.type === 'ReferenceIdentifier') {
        parts.push(node.name);
        return false;
      } else if (node.type === 'StringLiteral') {
        parts.push(node.value);
        return false;
      } else if (node.type === 'MetaProperty') {
        parts.push(node.meta.name);
        parts.push(node.property.name);
        return false;
      } else if (node.type === 'MemberExpression') {
        const stop = add(node.object);
        if (stop) {
          return true;
        } else {
          return add(node.property);
        }
      } else if (node.type === 'ComputedMemberProperty' &&
      node.value.type === 'StringLiteral') {
        return add(node.value);
      } else if (node.type === 'StaticMemberProperty') {
        return add(node.value);
      } else {
        return true;
      }
    }

    const bailed = add(node);

    return [bailed, parts];
  }

  // romejs/js-ast-utils/doesNodeMatchPattern.ts

  function ___R$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(member, match, allowPartial = false) {
    if (member.type !== 'MemberExpression' && member.type !== 'Identifier') {
      return false;
    }

    const expectedParts = Array.isArray(match) ? match.slice() : match.split('.');

    const [bailed, actualParts] = ___R$romejs$js$ast$utils$getNodeReferenceParts_ts$default(member);

    if (bailed && !allowPartial) {
      return false;
    }

    if (actualParts.length < expectedParts.length) {
      return false;
    }

    if (allowPartial === false && actualParts.length > expectedParts.length) {
      return false;
    }

    while (actualParts.length > 0) {
      if (expectedParts.length === 0) {
        return allowPartial;
      }

      const actual = actualParts.shift();
      const expected = expectedParts.shift();

      if (expected === '*') {
        continue;
      }

      if (expected === '**') {
        const next = expectedParts.shift();

        if (next === '*' || next === '**') {
          throw new Error('The next expected part was ' + next + ' but this isn\'t allowed since we\'re processing a double star');
        }

        let found = false;

        while (actualParts.length > 0) {
          const actual = actualParts.shift();
          if (actual === next) {
            found = true;
            break;
          }
        }

        if (found) {
          continue;
        } else {
          return false;
        }
      }

      if (expected !== actual) {
        return false;
      }
    }

    return true;
  }

  // romejs/js-ast/utils.ts

  const ___R$romejs$js$ast$utils_ts$bindingKeys = new Map();
  const ___R$romejs$js$ast$utils_ts$visitorKeys = new Map();
  const ___R$romejs$js$ast$utils_ts$nodeNames = new Set();

  function ___R$romejs$js$ast$utils_ts$assertNodeTypeSet(names, desc) {
    const set = new Set(names.keys());

    const errors = [];

    for (const name of set) {
      if (name[0] === '_') {
        continue;
      }

      if (___R$romejs$js$ast$utils_ts$nodeNames.has(name) === false) {
        errors.push(name + ' is not a valid node');
      }
    }

    for (const name of ___R$romejs$js$ast$utils_ts$nodeNames) {
      if (set.has(name) === false) {
        errors.push(name + ' does not appear');
      }
    }

    if (errors.length > 0) {
      throw new Error(desc + ': ' + errors.join('\n'));
    }
  }

  function ___R$$priv$romejs$js$ast$utils_ts$declareBuilder(type, opts) {
    ___R$romejs$js$ast$utils_ts$nodeNames.add(type);

    if (opts.visitorKeys !== undefined) {
      ___R$romejs$js$ast$utils_ts$visitorKeys.set(type, Object.keys(opts.visitorKeys));
    }

    if (opts.bindingKeys !== undefined) {
      ___R$romejs$js$ast$utils_ts$bindingKeys.set(type, Object.keys(opts.bindingKeys));
    }
  }

  function ___R$romejs$js$ast$utils_ts$createQuickBuilder(type, quickKey, opts) {
    ___R$$priv$romejs$js$ast$utils_ts$declareBuilder(type, opts);

    return new ___R$$priv$romejs$js$ast$utils_ts$QuickBuilder(type, opts.visitorKeys, quickKey);
  }

  function ___R$romejs$js$ast$utils_ts$createBuilder(type, opts) {
    ___R$$priv$romejs$js$ast$utils_ts$declareBuilder(type, opts);

    return new ___R$$priv$romejs$js$ast$utils_ts$Builder(type, opts.visitorKeys);
  }

  class ___R$$priv$romejs$js$ast$utils_ts$Builder {
    constructor(type, visitorKeys) {
      this.type = type;
      this.visitorKeys = visitorKeys;
    }

    create(opts, inheritNode) {
      return Object.assign({
        loc: inheritNode === undefined ? undefined : ___R$romejs$js$ast$utils$inheritLoc_ts$default(inheritNode)}, opts, {
        type: this.type});
    }

    is(node) {
      return node !== undefined && node.type === this.type;
    }

    normalize(node) {
      if (this.is(node)) {
        return node;
      }
    }

    assert(res) {
      const node = ___R$romejs$js$ast$utils$assertSingleNode_ts$default(res);

      if (node === undefined) {
        throw new Error('Expected ' + this.type + ' Node but got undefined');
      }

      if (node.type !== this.type) {
        throw new Error('Expected ' + this.type + ' Node but got ' + node.type);
      }

      return node;
    }
  }

  class ___R$$priv$romejs$js$ast$utils_ts$QuickBuilder extends ___R$$priv$romejs$js$ast$utils_ts$Builder {
    constructor(type, visitorKeys, quickKey) {
      super(type, visitorKeys);
      this.quickKey = quickKey;
    }

    quick(arg, opts, inheritNode) {
      return this.create(Object.assign({}, opts, {
        [this.quickKey]: arg}), inheritNode);
    }
  }

  // romejs/js-ast-utils/getBindingIdentifiers.ts

  function ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node) {
    const ids = [];
    let queue = Array.isArray(node) ? node : [node];

    while (queue.length) {
      const node = queue.pop();
      if (node === undefined) {
        continue;
      }

      if (node.type === 'BindingIdentifier') {
        ids.push(node);
        continue;
      }

      const keys = ___R$romejs$js$ast$utils_ts$bindingKeys.get(node.type);
      if (keys === undefined) {
        continue;
      }

      for (const key of keys) {
        const val = node[key];
        if (val === undefined) {
          continue;
        } else if (Array.isArray(val)) {
          queue = queue.concat(val);
        } else {
          queue.push(val);
        }
      }
    }

    return ids;
  }

  // romejs/js-ast-utils/hasPotentialSideEffects.ts

  function ___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node, scope) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'ExportNamedDeclaration':
        if (node.source === undefined) {
          if (node.declaration === undefined) {
            return true;
          } else {
            return ___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.declaration, scope);
          }
        } else {
          return true;
        }

      case 'FunctionExpression':
      case 'FunctionDeclaration':
        return false;

      case 'ClassDeclaration':
        return node.meta.superClass !== undefined ||
        !___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.meta.superClass, scope);

      case 'ReferenceIdentifier':
        return scope.getRootScope().isGlobal(node.name) || scope.hasBinding(node.name);

      case 'VariableDeclaration':
        for (const declarator of node.declarations) {
          if (___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(declarator, scope)) {
            return true;
          }
        }
        return false;

      case 'VariableDeclarator':
        return ___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.id, scope) ||
        ___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.init, scope);

      case 'SpreadProperty':
      case 'SpreadElement':
        return ___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.argument, scope);

      case 'BindingAssignmentPattern':
        return ___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.right, scope);

      case 'ObjectExpression':
      case 'BindingObjectPattern':
        for (const prop of node.properties) {
          if (___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(prop, scope)) {
            return true;
          }
        }
        return false;

      case 'StaticPropertyKey':
        return false;

      case 'ComputedPropertyKey':
        return ___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.value, scope);

      case 'BindingObjectPatternProperty':
      case 'ObjectProperty':
        return ___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.key, scope) ||
        ___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(node.value, scope);

      case 'BindingArrayPattern':
      case 'ArrayExpression':
        for (const elem of node.elements) {
          if (___R$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(elem, scope)) {
            return true;
          }
        }
        return false;

      case 'StringLiteral':
      case 'NumericLiteral':
      case 'BooleanLiteral':
      case 'NullLiteral':
        return false;}

    return true;
  }

  // romejs/js-ast-utils/isBinary.ts

  function ___R$romejs$js$ast$utils$isBinary_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'BinaryExpression':
      case 'LogicalExpression':
        return true;

      default:
        return false;}
  }

  // romejs/js-ast-utils/isConditional.ts

  function ___R$romejs$js$ast$utils$isConditional_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'ConditionalExpression':
      case 'IfStatement':
        return true;

      default:
        return false;}
  }

  // romejs/js-ast-utils/isTypeNode.ts

  function ___R$romejs$js$ast$utils$isTypeNode_ts$default(node) {
    if (node.type.startsWith('Flow') ||
    node.type.startsWith('TS') ||
    node.type.endsWith('TypeAnnotation')) {
      return true;
    } else if (node.type === 'ImportDeclaration') {
      return node.importKind === 'type' || node.importKind === 'typeof';
    } else if (node.type === 'ExportDefaultDeclaration' ||
    node.type === 'ExportNamedDeclaration' ||
    node.type === 'ExportAllDeclaration') {
      return node.exportKind === 'type';
    } else if (node.type === 'ImportSpecifier') {
      return node.local.importKind === 'type' || node.local.importKind === 'typeof';
    } else {
      return false;
    }
  }

  // romejs/js-ast-utils/isFor.ts

  function ___R$romejs$js$ast$utils$isFor_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'ForStatement':
      case 'ForInStatement':
      case 'ForOfStatement':
        return true;

      default:
        return false;}
  }

  // romejs/js-ast-utils/isFunctionNode.ts

  function ___R$romejs$js$ast$utils$isFunctionNode_ts$default(node) {
    return node.type === 'FunctionDeclaration' ||
    node.type === 'FunctionExpression' ||
    node.type === 'ObjectMethod' ||
    node.type === 'ArrowFunctionExpression' ||
    node.type === 'ClassMethod';
  }

  // romejs/js-ast-utils/isNodeLike.ts

  function ___R$romejs$js$ast$utils$isNodeLike_ts$default(node) {
    if (node == null) {
      return false;
    } else {
      return typeof node === 'object' && node !== null && typeof node.type === 'string';
    }
  }

  // romejs/js-ast-utils/isStatement.ts

  function ___R$romejs$js$ast$utils$isStatement_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'BlockStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
      case 'DebuggerStatement':
      case 'DoWhileStatement':
      case 'EmptyStatement':
      case 'ExpressionStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'FunctionDeclaration':
      case 'IfStatement':
      case 'LabeledStatement':
      case 'ReturnStatement':
      case 'SwitchStatement':
      case 'ThrowStatement':
      case 'TryStatement':
      case 'VariableDeclaration':
      case 'WhileStatement':
      case 'WithStatement':
      case 'ClassDeclaration':
      case 'ExportAllDeclaration':
      case 'ExportDefaultDeclaration':
      case 'ExportNamedDeclaration':
      case 'ForOfStatement':
      case 'ImportDeclaration':
      case 'FlowDeclareClass':
      case 'FlowDeclareFunction':
      case 'FlowDeclareInterface':
      case 'FlowDeclareModule':
      case 'FlowDeclareModuleExports':
      case 'FlowDeclareOpaqueType':
      case 'FlowDeclareVariable':
      case 'FlowInterfaceDeclaration':
      case 'TypeAliasTypeAnnotation':
      case 'FlowOpaqueType':
      case 'TypeAliasTypeAnnotation':
        return true;

      default:
        return false;}
  }

  // romejs/js-ast-utils/isUnaryLike.ts

  function ___R$romejs$js$ast$utils$isUnaryLike_ts$default(node) {
    if (node === undefined) {
      return false;
    }

    switch (node.type) {
      case 'UnaryExpression':
      case 'SpreadElement':
      case 'SpreadProperty':
        return true;

      default:
        return false;}
  }

  // romejs/js-parser-utils/identifier.ts

  const ___R$romejs$js$parser$utils$identifier_ts = {
    get keywordRelationalOperator() {
      return ___R$romejs$js$parser$utils$identifier_ts$keywordRelationalOperator;
    },
    isES2015ReservedWord: ___R$romejs$js$parser$utils$identifier_ts$isES2015ReservedWord,
    isReservedWord: ___R$romejs$js$parser$utils$identifier_ts$isReservedWord,
    isStrictReservedWord: ___R$romejs$js$parser$utils$identifier_ts$isStrictReservedWord,
    isStrictBindReservedWord: ___R$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord,
    isKeyword: ___R$romejs$js$parser$utils$identifier_ts$isKeyword,
    getFullCharCodeAt: ___R$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt,
    isIdentifierStart: ___R$romejs$js$parser$utils$identifier_ts$isIdentifierStart,
    isIdentifierChar: ___R$romejs$js$parser$utils$identifier_ts$isIdentifierChar};
  const ___R$romejs$js$parser$utils$identifier_ts$keywordRelationalOperator = /^in(stanceof)?$/;

  function ___R$romejs$js$parser$utils$identifier_ts$isES2015ReservedWord(word) {
    return word === 'enum' || word === 'await';
  }

  function ___R$romejs$js$parser$utils$identifier_ts$isReservedWord(word, inModule) {
    return inModule && word === 'await' || word === 'enum';
  }

  const ___R$$priv$romejs$js$parser$utils$identifier_ts$reservedWordsStrict = new Set(['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield']);
  function ___R$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(word, inModule) {
    return ___R$romejs$js$parser$utils$identifier_ts$isReservedWord(word, inModule) || ___R$$priv$romejs$js$parser$utils$identifier_ts$reservedWordsStrict.has(word);
  }

  function ___R$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(word, inModule) {
    return ___R$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(word, inModule) ||
    word === 'eval' ||
    word === 'arguments';
  }

  const ___R$$priv$romejs$js$parser$utils$identifier_ts$keywords = new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete']);

  function ___R$romejs$js$parser$utils$identifier_ts$isKeyword(word) {
    return ___R$$priv$romejs$js$parser$utils$identifier_ts$keywords.has(word);
  }

  let ___R$$priv$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars = '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312e\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fea\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc';

  let ___R$$priv$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierChars = '\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f';

  const ___R$$priv$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStart = new RegExp('[' + ___R$$priv$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars + ']');
  const ___R$$priv$romejs$js$parser$utils$identifier_ts$nonASCIIidentifier = new RegExp('[' + ___R$$priv$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars + ___R$$priv$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierChars + ']');

  const ___R$$priv$romejs$js$parser$utils$identifier_ts$astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 55, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 698, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 1, 31, 6124, 20, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];

  const ___R$$priv$romejs$js$parser$utils$identifier_ts$astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 19719, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];

  function ___R$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(str, offset) {
    const code = str.charCodeAt(offset);
    if (code <= 55295 || code >= 57344) {
      return code;
    }

    const next = str.charCodeAt(offset + 1);
    return (code << 10) + next - 56613888;
  }

  function ___R$$priv$romejs$js$parser$utils$identifier_ts$isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) {
        return false;
      }

      pos += set[i + 1];
      if (pos >= code) {
        return true;
      }
    }
    return false;
  }

  function ___R$romejs$js$parser$utils$identifier_ts$isIdentifierStart(code) {
    if (code === undefined) {
      return false;
    }

    if (code < 65) {
      return code === 36;
    }

    if (code < 91) {
      return true;
    }

    if (code < 97) {
      return code === 95;
    }

    if (code < 123) {
      return true;
    }

    if (code <= 65535) {
      return code >= 170 && ___R$$priv$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStart.test(String.fromCharCode(code));
    }

    return ___R$$priv$romejs$js$parser$utils$identifier_ts$isInAstralSet(code, ___R$$priv$romejs$js$parser$utils$identifier_ts$astralIdentifierStartCodes);
  }

  function ___R$romejs$js$parser$utils$identifier_ts$isIdentifierChar(code) {
    if (code < 48) {
      return code === 36;
    }

    if (code < 58) {
      return true;
    }

    if (code < 65) {
      return false;
    }

    if (code < 91) {
      return true;
    }

    if (code < 97) {
      return code === 95;
    }

    if (code < 123) {
      return true;
    }

    if (code <= 65535) {
      return code >= 170 && ___R$$priv$romejs$js$parser$utils$identifier_ts$nonASCIIidentifier.test(String.fromCharCode(code));
    }

    return ___R$$priv$romejs$js$parser$utils$identifier_ts$isInAstralSet(code, ___R$$priv$romejs$js$parser$utils$identifier_ts$astralIdentifierStartCodes) ||
    ___R$$priv$romejs$js$parser$utils$identifier_ts$isInAstralSet(code, ___R$$priv$romejs$js$parser$utils$identifier_ts$astralIdentifierCodes);
  }

  // romejs/js-parser-utils/location.ts

  const ___R$romejs$js$parser$utils$location_ts = {
    createIndexTracker: ___R$romejs$js$parser$utils$location_ts$createIndexTracker};
  function ___R$romejs$js$parser$utils$location_ts$createIndexTracker() {
    return {index: ___R$romejs$ob1$index_ts$number0};
  }

  // romejs/js-parser-utils/messages.ts

  const ___R$romejs$js$parser$utils$messages_ts$default = ___R$romejs$messages$index_ts$default({
    DUPLICATE_REGEX_FLAG: 'Duplicate regular expression flag',
    INVALID_REGEX_FLAG: 'Invalid regular expression flag'});

  // romejs/js-parser-utils/regex.ts

  const ___R$romejs$js$parser$utils$regex_ts = {
    validateRegexFlags: ___R$romejs$js$parser$utils$regex_ts$validateRegexFlags};
  const ___R$$priv$romejs$js$parser$utils$regex_ts$VALID_REGEX_FLAGS = 'gmsiyu'.split('');

  function ___R$romejs$js$parser$utils$regex_ts$validateRegexFlags(flags, onUnexpected) {
    const foundFlags = new Set();

    for (let i = 0; i < flags.length; i++) {
      const flag = flags[i];

      if (___R$$priv$romejs$js$parser$utils$regex_ts$VALID_REGEX_FLAGS.includes(flag)) {
        if (foundFlags.has(flag)) {
          onUnexpected(___R$romejs$js$parser$utils$messages_ts$default.DUPLICATE_REGEX_FLAG(), i);
        } else {
          foundFlags.add(flag);
        }
      } else {
        onUnexpected(___R$romejs$js$parser$utils$messages_ts$default.INVALID_REGEX_FLAG(), i);
      }
    }

    return foundFlags;
  }

  // romejs/js-parser-utils/whitespace.ts

  const ___R$romejs$js$parser$utils$whitespace_ts = {
    get lineBreak() {
      return ___R$romejs$js$parser$utils$whitespace_ts$lineBreak;
    },
    get lineBreakG() {
      return ___R$romejs$js$parser$utils$whitespace_ts$lineBreakG;
    },
    isNewLine: ___R$romejs$js$parser$utils$whitespace_ts$isNewLine,
    get nonASCIIwhitespace() {
      return ___R$romejs$js$parser$utils$whitespace_ts$nonASCIIwhitespace;
    },
    get skipWhiteSpace() {
      return ___R$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace;
    },
    get NEWLINE() {
      return ___R$romejs$js$parser$utils$whitespace_ts$NEWLINE;
    }};
  const ___R$romejs$js$parser$utils$whitespace_ts$lineBreak = /\r\n?|\n|\u2028|\u2029/;
  const ___R$romejs$js$parser$utils$whitespace_ts$lineBreakG = new RegExp(___R$romejs$js$parser$utils$whitespace_ts$lineBreak.source, 'g');

  function ___R$romejs$js$parser$utils$whitespace_ts$isNewLine(code) {
    return code === 10 || code === 13 || code === 8232 || code === 8233;
  }

  const ___R$romejs$js$parser$utils$whitespace_ts$nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  const ___R$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  const ___R$romejs$js$parser$utils$whitespace_ts$NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

  // romejs/js-parser-utils/index.ts


  // romejs/js-ast-utils/isValidIdentifierName.ts

  function ___R$romejs$js$ast$utils$isValidIdentifierName_ts$default(name) {
    if (name.length === 0) {
      return false;
    }

    if (___R$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(name, true)) {
      return false;
    }

    if (___R$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(name, true)) {
      return false;
    }

    if (___R$romejs$js$parser$utils$identifier_ts$isES2015ReservedWord(name)) {
      return false;
    }

    if (___R$romejs$js$parser$utils$identifier_ts$isKeyword(name)) {
      return false;
    }

    if (___R$romejs$js$parser$utils$identifier_ts$isIdentifierStart(___R$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(name, 0)) === false) {
      return false;
    }

    let i = 1;
    while (i < name.length) {
      const code = ___R$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(name, i);
      if (___R$romejs$js$parser$utils$identifier_ts$isIdentifierChar(code)) {
        i += code <= 65535 ? 1 : 2;
      } else {
        return false;
      }
    }

    return true;
  }

  // romejs/js-ast-utils/inheritLoc.ts

  function ___R$romejs$js$ast$utils$inheritLoc_ts$default(node, name) {
    const {loc: loc} = node;
    if (loc === undefined) {
      return undefined;
    }

    if (name !== undefined) {
      return Object.assign({}, loc, {
        identifierName: name});
    }

    if (loc.identifierName !== undefined) {
      return loc;
    }

    if (node.type === 'Identifier') {
      return Object.assign({}, loc, {
        identifierName: node.name});
    }

    return loc;
  }

  // romejs/js-ast/base.ts

  const ___R$romejs$js$ast$base_ts = {};

  // romejs/js-ast/constants.ts

  const ___R$romejs$js$ast$constants_ts = {};

  // romejs/js-ast/unions.ts

  const ___R$romejs$js$ast$unions_ts = {};

  // romejs/js-ast/temp/AmbiguousFlowTypeCastExpression.ts

  const ___R$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts = {
    get ambiguousFlowTypeCastExpression() {
      return ___R$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression;
    }};

  const ___R$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'AmbiguousFlowTypeCastExpression', {
    bindingKeys: {},
    visitorKeys: {
      expression: true,
      typeAnnotation: true}});

  // romejs/js-ast/types/AnyKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts = {
    get anyKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts$anyKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts$anyKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'AnyKeywordTypeAnnotation',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/expressions/ArrayExpression.ts

  const ___R$romejs$js$ast$expressions$ArrayExpression_ts = {
    get arrayExpression() {
      return ___R$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression;
    }};

  const ___R$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'ArrayExpression',
  'elements',
  {
    bindingKeys: {},
    visitorKeys: {
      elements: true}});

  // romejs/js-ast/expressions/ArrowFunctionExpression.ts

  const ___R$romejs$js$ast$expressions$ArrowFunctionExpression_ts = {
    get arrowFunctionExpression() {
      return ___R$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression;
    }};

  const ___R$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ArrowFunctionExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      head: true,
      body: true}});

  // romejs/js-ast/patterns/AssignmentArrayPattern.ts

  const ___R$romejs$js$ast$patterns$AssignmentArrayPattern_ts = {
    get assignmentArrayPattern() {
      return ___R$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern;
    }};

  const ___R$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern = ___R$romejs$js$ast$utils_ts$createBuilder(
  'AssignmentArrayPattern',
  {
    bindingKeys: {},
    visitorKeys: {
      elements: true,
      rest: true,
      meta: true}});

  // romejs/js-ast/patterns/AssignmentAssignmentPattern.ts

  const ___R$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts = {
    get assignmentAssignmentPattern() {
      return ___R$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern;
    }};

  const ___R$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern = ___R$romejs$js$ast$utils_ts$createBuilder(
  'AssignmentAssignmentPattern', {
    bindingKeys: {},
    visitorKeys: {
      left: true,
      right: true,
      meta: true}});

  // romejs/js-ast/expressions/AssignmentExpression.ts

  const ___R$romejs$js$ast$expressions$AssignmentExpression_ts = {
    get assignmentExpression() {
      return ___R$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression;
    }};

  const ___R$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'AssignmentExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      left: true,
      right: true}});

  // romejs/js-ast/patterns/AssignmentIdentifier.ts

  const ___R$romejs$js$ast$patterns$AssignmentIdentifier_ts = {
    get assignmentIdentifier() {
      return ___R$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier;
    }};

  const ___R$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'AssignmentIdentifier', 'name', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/patterns/AssignmentObjectPattern.ts

  const ___R$romejs$js$ast$patterns$AssignmentObjectPattern_ts = {
    get assignmentObjectPattern() {
      return ___R$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern;
    }};

  const ___R$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern = ___R$romejs$js$ast$utils_ts$createBuilder(
  'AssignmentObjectPattern',
  {
    bindingKeys: {},
    visitorKeys: {
      properties: true,
      rest: true,
      meta: true}});

  // romejs/js-ast/patterns/AssignmentObjectPatternProperty.ts

  const ___R$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts = {
    get assignmentObjectPatternProperty() {
      return ___R$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty;
    }};

  const ___R$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty = ___R$romejs$js$ast$utils_ts$createBuilder(
  'AssignmentObjectPatternProperty', {
    bindingKeys: {},
    visitorKeys: {
      key: true,
      value: true}});

  // romejs/js-ast/expressions/AwaitExpression.ts

  const ___R$romejs$js$ast$expressions$AwaitExpression_ts = {
    get awaitExpression() {
      return ___R$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression;
    }};

  const ___R$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'AwaitExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/types/BigIntKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts = {
    get bigIntKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts$bigIntKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts$bigIntKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'BigIntKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/literals/BigIntLiteral.ts

  const ___R$romejs$js$ast$literals$BigIntLiteral_ts = {
    get bigIntLiteral() {
      return ___R$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral;
    }};

  const ___R$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral = ___R$romejs$js$ast$utils_ts$createBuilder('BigIntLiteral', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/expressions/BinaryExpression.ts

  const ___R$romejs$js$ast$expressions$BinaryExpression_ts = {
    get binaryExpression() {
      return ___R$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression;
    }};

  const ___R$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'BinaryExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      left: true,
      right: true}});

  // romejs/js-ast/patterns/BindingArrayPattern.ts

  const ___R$romejs$js$ast$patterns$BindingArrayPattern_ts = {
    get bindingArrayPattern() {
      return ___R$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern;
    }};

  const ___R$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern = ___R$romejs$js$ast$utils_ts$createBuilder(
  'BindingArrayPattern',
  {
    bindingKeys: {
      elements: true,
      rest: true},
    visitorKeys: {
      elements: true,
      rest: true,
      meta: true}});

  // romejs/js-ast/patterns/BindingAssignmentPattern.ts

  const ___R$romejs$js$ast$patterns$BindingAssignmentPattern_ts = {
    get bindingAssignmentPattern() {
      return ___R$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern;
    }};

  const ___R$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern = ___R$romejs$js$ast$utils_ts$createBuilder(
  'BindingAssignmentPattern',
  {
    bindingKeys: {
      left: true},
    visitorKeys: {
      left: true,
      right: true,
      meta: true}});

  // romejs/js-ast/patterns/BindingIdentifier.ts

  const ___R$romejs$js$ast$patterns$BindingIdentifier_ts = {
    get bindingIdentifier() {
      return ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier;
    }};

  const ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'BindingIdentifier',
  'name',
  {
    bindingKeys: {},
    visitorKeys: {
      meta: true}});

  // romejs/js-ast/patterns/BindingObjectPattern.ts

  const ___R$romejs$js$ast$patterns$BindingObjectPattern_ts = {
    get bindingObjectPattern() {
      return ___R$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern;
    }};

  const ___R$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern = ___R$romejs$js$ast$utils_ts$createBuilder(
  'BindingObjectPattern',
  {
    bindingKeys: {
      properties: true,
      rest: true},
    visitorKeys: {
      properties: true,
      rest: true,
      meta: true}});

  // romejs/js-ast/patterns/BindingObjectPatternProperty.ts

  const ___R$romejs$js$ast$patterns$BindingObjectPatternProperty_ts = {
    get bindingObjectPatternProperty() {
      return ___R$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty;
    }};

  const ___R$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty = ___R$romejs$js$ast$utils_ts$createBuilder(
  'BindingObjectPatternProperty', {
    bindingKeys: {
      value: true},
    visitorKeys: {
      key: true,
      value: true}});

  // romejs/js-ast/statements/BlockStatement.ts

  const ___R$romejs$js$ast$statements$BlockStatement_ts = {
    get blockStatement() {
      return ___R$romejs$js$ast$statements$BlockStatement_ts$blockStatement;
    }};

  const ___R$romejs$js$ast$statements$BlockStatement_ts$blockStatement = ___R$romejs$js$ast$utils_ts$createBuilder('BlockStatement', {
    bindingKeys: {},
    visitorKeys: {
      body: true,
      directives: true}});

  // romejs/js-ast/types/BooleanKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts = {
    get booleanKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts$booleanKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts$booleanKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'BooleanKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/literals/BooleanLiteral.ts

  const ___R$romejs$js$ast$literals$BooleanLiteral_ts = {
    get booleanLiteral() {
      return ___R$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral;
    }};

  const ___R$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'BooleanLiteral',
  'value',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/types/BooleanLiteralTypeAnnotation.ts

  const ___R$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts = {
    get booleanLiteralTypeAnnotation() {
      return ___R$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts$booleanLiteralTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts$booleanLiteralTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'BooleanLiteralTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/statements/BreakStatement.ts

  const ___R$romejs$js$ast$statements$BreakStatement_ts = {
    get breakStatement() {
      return ___R$romejs$js$ast$statements$BreakStatement_ts$breakStatement;
    }};

  const ___R$romejs$js$ast$statements$BreakStatement_ts$breakStatement = ___R$romejs$js$ast$utils_ts$createBuilder('BreakStatement', {
    bindingKeys: {},
    visitorKeys: {
      label: true}});

  // romejs/js-ast/expressions/CallExpression.ts

  const ___R$romejs$js$ast$expressions$CallExpression_ts = {
    get callExpression() {
      return ___R$romejs$js$ast$expressions$CallExpression_ts$callExpression;
    }};

  const ___R$romejs$js$ast$expressions$CallExpression_ts$callExpression = ___R$romejs$js$ast$utils_ts$createBuilder('CallExpression', {
    bindingKeys: {},
    visitorKeys: {
      callee: true,
      arguments: true,
      typeArguments: true}});

  // romejs/js-ast/auxiliary/CatchClause.ts

  const ___R$romejs$js$ast$auxiliary$CatchClause_ts = {
    get catchClause() {
      return ___R$romejs$js$ast$auxiliary$CatchClause_ts$catchClause;
    }};

  const ___R$romejs$js$ast$auxiliary$CatchClause_ts$catchClause = ___R$romejs$js$ast$utils_ts$createBuilder('CatchClause', {
    bindingKeys: {
      param: true},
    visitorKeys: {
      param: true,
      body: true}});

  // romejs/js-ast/classes/ClassDeclaration.ts

  const ___R$romejs$js$ast$classes$ClassDeclaration_ts = {
    get classDeclaration() {
      return ___R$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration;
    }};

  const ___R$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ClassDeclaration',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      meta: true}});

  // romejs/js-ast/classes/ClassExpression.ts

  const ___R$romejs$js$ast$classes$ClassExpression_ts = {
    get classExpression() {
      return ___R$romejs$js$ast$classes$ClassExpression_ts$classExpression;
    }};

  const ___R$romejs$js$ast$classes$ClassExpression_ts$classExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ClassExpression',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      meta: true}});

  // romejs/js-ast/classes/ClassHead.ts

  const ___R$romejs$js$ast$classes$ClassHead_ts = {
    get classHead() {
      return ___R$romejs$js$ast$classes$ClassHead_ts$classHead;
    }};

  const ___R$romejs$js$ast$classes$ClassHead_ts$classHead = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'ClassHead',
  'body',
  {
    bindingKeys: {},
    visitorKeys: {
      superClass: true,
      body: true,
      typeParameters: true,
      superTypeParameters: true,
      implements: true}});

  // romejs/js-ast/classes/ClassMethod.ts

  const ___R$romejs$js$ast$classes$ClassMethod_ts = {
    get classMethod() {
      return ___R$romejs$js$ast$classes$ClassMethod_ts$classMethod;
    }};

  const ___R$romejs$js$ast$classes$ClassMethod_ts$classMethod = ___R$romejs$js$ast$utils_ts$createBuilder('ClassMethod', {
    bindingKeys: {},
    visitorKeys: {
      key: true,
      meta: true,
      head: true,
      body: true}});

  // romejs/js-ast/classes/ClassPrivateMethod.ts

  const ___R$romejs$js$ast$classes$ClassPrivateMethod_ts = {
    get classPrivateMethod() {
      return ___R$romejs$js$ast$classes$ClassPrivateMethod_ts$classPrivateMethod;
    }};

  const ___R$romejs$js$ast$classes$ClassPrivateMethod_ts$classPrivateMethod = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ClassPrivateMethod',
  {
    bindingKeys: {},
    visitorKeys: {
      key: true,
      meta: true,
      head: true,
      body: true,
      variance: true}});

  // romejs/js-ast/classes/ClassPrivateProperty.ts

  const ___R$romejs$js$ast$classes$ClassPrivateProperty_ts = {
    get classPrivateProperty() {
      return ___R$romejs$js$ast$classes$ClassPrivateProperty_ts$classPrivateProperty;
    }};

  const ___R$romejs$js$ast$classes$ClassPrivateProperty_ts$classPrivateProperty = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ClassPrivateProperty',
  {
    bindingKeys: {},
    visitorKeys: {
      key: true,
      meta: true,
      value: true,
      typeAnnotation: true}});

  // romejs/js-ast/classes/ClassProperty.ts

  const ___R$romejs$js$ast$classes$ClassProperty_ts = {
    get classProperty() {
      return ___R$romejs$js$ast$classes$ClassProperty_ts$classProperty;
    }};

  const ___R$romejs$js$ast$classes$ClassProperty_ts$classProperty = ___R$romejs$js$ast$utils_ts$createBuilder('ClassProperty', {
    bindingKeys: {},
    visitorKeys: {
      key: true,
      meta: true,
      value: true,
      typeAnnotation: true}});

  // romejs/js-ast/classes/ClassPropertyMeta.ts

  const ___R$romejs$js$ast$classes$ClassPropertyMeta_ts = {
    get classPropertyMeta() {
      return ___R$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta;
    }};

  const ___R$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ClassPropertyMeta',
  {
    bindingKeys: {},
    visitorKeys: {
      typeAnnotation: true}});

  // romejs/js-ast/core/CommentBlock.ts

  const ___R$romejs$js$ast$core$CommentBlock_ts = {
    get commentBlock() {
      return ___R$romejs$js$ast$core$CommentBlock_ts$commentBlock;
    }};

  const ___R$romejs$js$ast$core$CommentBlock_ts$commentBlock = ___R$romejs$js$ast$utils_ts$createBuilder('CommentBlock', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/core/CommentLine.ts

  const ___R$romejs$js$ast$core$CommentLine_ts = {
    get commentLine() {
      return ___R$romejs$js$ast$core$CommentLine_ts$commentLine;
    }};

  const ___R$romejs$js$ast$core$CommentLine_ts$commentLine = ___R$romejs$js$ast$utils_ts$createBuilder('CommentLine', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/auxiliary/ComputedMemberProperty.ts

  const ___R$romejs$js$ast$auxiliary$ComputedMemberProperty_ts = {
    get computedMemberProperty() {
      return ___R$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty;
    }};

  const ___R$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'ComputedMemberProperty', 'value', {
    bindingKeys: {},
    visitorKeys: {
      value: true}});

  // romejs/js-ast/objects/ComputedPropertyKey.ts

  const ___R$romejs$js$ast$objects$ComputedPropertyKey_ts = {
    get computedPropertyKey() {
      return ___R$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey;
    }};

  const ___R$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'ComputedPropertyKey', 'value', {
    bindingKeys: {},
    visitorKeys: {
      variance: true,
      value: true}});

  // romejs/js-ast/expressions/ConditionalExpression.ts

  const ___R$romejs$js$ast$expressions$ConditionalExpression_ts = {
    get conditionalExpression() {
      return ___R$romejs$js$ast$expressions$ConditionalExpression_ts$conditionalExpression;
    }};

  const ___R$romejs$js$ast$expressions$ConditionalExpression_ts$conditionalExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ConditionalExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      test: true,
      consequent: true,
      alternate: true}});

  // romejs/js-ast/statements/ContinueStatement.ts

  const ___R$romejs$js$ast$statements$ContinueStatement_ts = {
    get continueStatement() {
      return ___R$romejs$js$ast$statements$ContinueStatement_ts$continueStatement;
    }};

  const ___R$romejs$js$ast$statements$ContinueStatement_ts$continueStatement = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ContinueStatement',
  {
    bindingKeys: {},
    visitorKeys: {
      label: true}});

  // romejs/js-ast/statements/DebuggerStatement.ts

  const ___R$romejs$js$ast$statements$DebuggerStatement_ts = {
    get debuggerStatement() {
      return ___R$romejs$js$ast$statements$DebuggerStatement_ts$debuggerStatement;
    }};

  const ___R$romejs$js$ast$statements$DebuggerStatement_ts$debuggerStatement = ___R$romejs$js$ast$utils_ts$createBuilder(
  'DebuggerStatement',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/core/Directive.ts

  const ___R$romejs$js$ast$core$Directive_ts = {
    get directive() {
      return ___R$romejs$js$ast$core$Directive_ts$directive;
    }};

  const ___R$romejs$js$ast$core$Directive_ts$directive = ___R$romejs$js$ast$utils_ts$createBuilder('Directive', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/expressions/DoExpression.ts

  const ___R$romejs$js$ast$expressions$DoExpression_ts = {
    get doExpression() {
      return ___R$romejs$js$ast$expressions$DoExpression_ts$doExpression;
    }};

  const ___R$romejs$js$ast$expressions$DoExpression_ts$doExpression = ___R$romejs$js$ast$utils_ts$createBuilder('DoExpression', {
    bindingKeys: {},
    visitorKeys: {
      body: true}});

  // romejs/js-ast/statements/DoWhileStatement.ts

  const ___R$romejs$js$ast$statements$DoWhileStatement_ts = {
    get doWhileStatement() {
      return ___R$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement;
    }};

  const ___R$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement = ___R$romejs$js$ast$utils_ts$createBuilder(
  'DoWhileStatement',
  {
    bindingKeys: {},
    visitorKeys: {
      test: true,
      body: true}});

  // romejs/js-ast/types/EmptyKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts = {
    get emptyKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts$emptyKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts$emptyKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'EmptyKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/statements/EmptyStatement.ts

  const ___R$romejs$js$ast$statements$EmptyStatement_ts = {
    get emptyStatement() {
      return ___R$romejs$js$ast$statements$EmptyStatement_ts$emptyStatement;
    }};

  const ___R$romejs$js$ast$statements$EmptyStatement_ts$emptyStatement = ___R$romejs$js$ast$utils_ts$createBuilder('EmptyStatement', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/modules/ExportAllDeclaration.ts

  const ___R$romejs$js$ast$modules$ExportAllDeclaration_ts = {
    get exportAllDeclaration() {
      return ___R$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration;
    }};

  const ___R$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ExportAllDeclaration',
  {
    bindingKeys: {},
    visitorKeys: {
      source: true}});

  // romejs/js-ast/modules/ExportDefaultDeclaration.ts

  const ___R$romejs$js$ast$modules$ExportDefaultDeclaration_ts = {
    get exportDefaultDeclaration() {
      return ___R$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration;
    }};

  const ___R$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ExportDefaultDeclaration',
  {
    bindingKeys: {},
    visitorKeys: {
      declaration: true}});

  // romejs/js-ast/modules/ExportDefaultSpecifier.ts

  const ___R$romejs$js$ast$modules$ExportDefaultSpecifier_ts = {
    get exportDefaultSpecifier() {
      return ___R$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier;
    }};

  const ___R$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ExportDefaultSpecifier',
  {
    bindingKeys: {},
    visitorKeys: {
      exported: true}});

  // romejs/js-ast/modules/ExportNamedDeclaration.ts

  const ___R$romejs$js$ast$modules$ExportNamedDeclaration_ts = {
    get exportNamedDeclaration() {
      return ___R$romejs$js$ast$modules$ExportNamedDeclaration_ts$exportNamedDeclaration;
    }};

  const ___R$romejs$js$ast$modules$ExportNamedDeclaration_ts$exportNamedDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ExportNamedDeclaration',
  {
    bindingKeys: {
      declaration: true},
    visitorKeys: {
      declaration: true,
      specifiers: true,
      source: true}});

  // romejs/js-ast/modules/ExportNamespaceSpecifier.ts

  const ___R$romejs$js$ast$modules$ExportNamespaceSpecifier_ts = {
    get exportNamespaceSpecifier() {
      return ___R$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier;
    }};

  const ___R$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ExportNamespaceSpecifier',
  {
    bindingKeys: {},
    visitorKeys: {
      exported: true}});

  // romejs/js-ast/modules/ExportSpecifier.ts

  const ___R$romejs$js$ast$modules$ExportSpecifier_ts = {
    get exportSpecifier() {
      return ___R$romejs$js$ast$modules$ExportSpecifier_ts$exportSpecifier;
    }};

  const ___R$romejs$js$ast$modules$ExportSpecifier_ts$exportSpecifier = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ExportSpecifier',
  {
    bindingKeys: {},
    visitorKeys: {
      local: true,
      exported: true}});

  // romejs/js-ast/statements/ExpressionStatement.ts

  const ___R$romejs$js$ast$statements$ExpressionStatement_ts = {
    get expressionStatement() {
      return ___R$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement;
    }};

  const ___R$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ExpressionStatement',
  {
    bindingKeys: {},
    visitorKeys: {
      expression: true}});

  // romejs/js-ast/flow/FlowArrayTypeAnnotation.ts

  const ___R$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts = {
    get flowArrayTypeAnnotation() {
      return ___R$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts$flowArrayTypeAnnotation;
    }};

  const ___R$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts$flowArrayTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowArrayTypeAnnotation',
  {
    bindingKeys: {},
    visitorKeys: {
      elementType: true}});

  // romejs/js-ast/flow/FlowClassImplements.ts

  const ___R$romejs$js$ast$flow$FlowClassImplements_ts = {
    get flowClassImplements() {
      return ___R$romejs$js$ast$flow$FlowClassImplements_ts$flowClassImplements;
    }};

  const ___R$romejs$js$ast$flow$FlowClassImplements_ts$flowClassImplements = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowClassImplements',
  {
    bindingKeys: {},
    visitorKeys: {
      id: true,
      typeParameters: true}});

  // romejs/js-ast/flow/FlowDeclareClass.ts

  const ___R$romejs$js$ast$flow$FlowDeclareClass_ts = {
    get flowDeclareClass() {
      return ___R$romejs$js$ast$flow$FlowDeclareClass_ts$flowDeclareClass;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclareClass_ts$flowDeclareClass = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclareClass',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      typeParameters: true,
      implements: true,
      mixins: true,
      extends: true,
      body: true}});

  // romejs/js-ast/flow/FlowDeclaredPredicate.ts

  const ___R$romejs$js$ast$flow$FlowDeclaredPredicate_ts = {
    get flowDeclaredPredicate() {
      return ___R$romejs$js$ast$flow$FlowDeclaredPredicate_ts$flowDeclaredPredicate;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclaredPredicate_ts$flowDeclaredPredicate = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclaredPredicate',
  {
    bindingKeys: {},
    visitorKeys: {
      value: true}});

  // romejs/js-ast/flow/FlowDeclareExportAll.ts

  const ___R$romejs$js$ast$flow$FlowDeclareExportAll_ts = {
    get flowDeclareExportAll() {
      return ___R$romejs$js$ast$flow$FlowDeclareExportAll_ts$flowDeclareExportAll;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclareExportAll_ts$flowDeclareExportAll = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclareExportAll',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/flow/FlowDeclareExportDefault.ts

  const ___R$romejs$js$ast$flow$FlowDeclareExportDefault_ts = {
    get flowDeclareExportDefault() {
      return ___R$romejs$js$ast$flow$FlowDeclareExportDefault_ts$flowDeclareExportDefault;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclareExportDefault_ts$flowDeclareExportDefault = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclareExportDefault',
  {
    bindingKeys: {},
    visitorKeys: {
      declaration: true}});

  // romejs/js-ast/flow/FlowDeclareExportNamed.ts

  const ___R$romejs$js$ast$flow$FlowDeclareExportNamed_ts = {
    get flowDeclareExportNamed() {
      return ___R$romejs$js$ast$flow$FlowDeclareExportNamed_ts$flowDeclareExportNamed;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclareExportNamed_ts$flowDeclareExportNamed = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclareExportNamed',
  {
    bindingKeys: {},
    visitorKeys: {
      specifiers: true,
      declaration: true,
      source: true}});

  // romejs/js-ast/flow/FlowDeclareFunction.ts

  const ___R$romejs$js$ast$flow$FlowDeclareFunction_ts = {
    get flowDeclareFunction() {
      return ___R$romejs$js$ast$flow$FlowDeclareFunction_ts$flowDeclareFunction;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclareFunction_ts$flowDeclareFunction = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclareFunction',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      predicate: true}});

  // romejs/js-ast/flow/FlowDeclareInterface.ts

  const ___R$romejs$js$ast$flow$FlowDeclareInterface_ts = {
    get flowDeclareInterface() {
      return ___R$romejs$js$ast$flow$FlowDeclareInterface_ts$flowDeclareInterface;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclareInterface_ts$flowDeclareInterface = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclareInterface',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      typeParameters: true,
      extends: true,
      implements: true,
      mixins: true,
      body: true}});

  // romejs/js-ast/flow/FlowDeclareModule.ts

  const ___R$romejs$js$ast$flow$FlowDeclareModule_ts = {
    get flowDeclareModule() {
      return ___R$romejs$js$ast$flow$FlowDeclareModule_ts$flowDeclareModule;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclareModule_ts$flowDeclareModule = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclareModule',
  {
    bindingKeys: {},
    visitorKeys: {
      id: true,
      body: true}});

  // romejs/js-ast/flow/FlowDeclareModuleExports.ts

  const ___R$romejs$js$ast$flow$FlowDeclareModuleExports_ts = {
    get flowDeclareModuleExports() {
      return ___R$romejs$js$ast$flow$FlowDeclareModuleExports_ts$flowDeclareModuleExports;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclareModuleExports_ts$flowDeclareModuleExports = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclareModuleExports',
  {
    bindingKeys: {},
    visitorKeys: {
      typeAnnotation: true}});

  // romejs/js-ast/flow/FlowDeclareOpaqueType.ts

  const ___R$romejs$js$ast$flow$FlowDeclareOpaqueType_ts = {
    get flowDeclareOpaqueType() {
      return ___R$romejs$js$ast$flow$FlowDeclareOpaqueType_ts$flowDeclareOpaqueType;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclareOpaqueType_ts$flowDeclareOpaqueType = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclareOpaqueType',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      typeParameters: true,
      supertype: true,
      impltype: true}});

  // romejs/js-ast/flow/FlowDeclareVariable.ts

  const ___R$romejs$js$ast$flow$FlowDeclareVariable_ts = {
    get flowDeclareVariable() {
      return ___R$romejs$js$ast$flow$FlowDeclareVariable_ts$flowDeclareVariable;
    }};

  const ___R$romejs$js$ast$flow$FlowDeclareVariable_ts$flowDeclareVariable = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowDeclareVariable',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true}});

  // romejs/js-ast/flow/FlowExistsTypeAnnotation.ts

  const ___R$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts = {
    get flowExistsTypeAnnotation() {
      return ___R$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts$flowExistsTypeAnnotation;
    }};

  const ___R$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts$flowExistsTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowExistsTypeAnnotation',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/flow/FlowFunctionTypeAnnotation.ts

  const ___R$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts = {
    get flowFunctionTypeAnnotation() {
      return ___R$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts$flowFunctionTypeAnnotation;
    }};

  const ___R$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts$flowFunctionTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowFunctionTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {
      typeParameters: true,
      params: true,
      rest: true,
      returnType: true}});

  // romejs/js-ast/patterns/PatternMeta.ts

  const ___R$romejs$js$ast$patterns$PatternMeta_ts = {
    get patternMeta() {
      return ___R$romejs$js$ast$patterns$PatternMeta_ts$patternMeta;
    }};

  const ___R$romejs$js$ast$patterns$PatternMeta_ts$patternMeta = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'PatternMeta',
  'typeAnnotation',
  {
    bindingKeys: {},
    visitorKeys: {
      typeAnnotation: true}});

  // romejs/js-ast/flow/FlowFunctionTypeParam.ts

  const ___R$romejs$js$ast$flow$FlowFunctionTypeParam_ts = {
    get flowFunctionTypeParam() {
      return ___R$romejs$js$ast$flow$FlowFunctionTypeParam_ts$flowFunctionTypeParam;
    }};

  const ___R$romejs$js$ast$flow$FlowFunctionTypeParam_ts$flowFunctionTypeParam = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowFunctionTypeParam',
  {
    bindingKeys: {},
    visitorKeys: {
      name: true,
      meta: true}});

  // romejs/js-ast/flow/FlowGenericTypeAnnotation.ts

  const ___R$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts = {
    get flowGenericTypeAnnotation() {
      return ___R$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts$flowGenericTypeAnnotation;
    }};

  const ___R$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts$flowGenericTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowGenericTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {
      id: true,
      typeParameters: true}});

  // romejs/js-ast/flow/FlowInferredPredicate.ts

  const ___R$romejs$js$ast$flow$FlowInferredPredicate_ts = {
    get flowInferredPredicate() {
      return ___R$romejs$js$ast$flow$FlowInferredPredicate_ts$flowInferredPredicate;
    }};

  const ___R$romejs$js$ast$flow$FlowInferredPredicate_ts$flowInferredPredicate = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowInferredPredicate',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/flow/FlowInterface.ts

  const ___R$romejs$js$ast$flow$FlowInterface_ts = {
    get flowInterface() {
      return ___R$romejs$js$ast$flow$FlowInterface_ts$flowInterface;
    }};

  const ___R$romejs$js$ast$flow$FlowInterface_ts$flowInterface = ___R$romejs$js$ast$utils_ts$createBuilder('FlowInterface', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/flow/FlowInterfaceDeclaration.ts

  const ___R$romejs$js$ast$flow$FlowInterfaceDeclaration_ts = {
    get flowInterfaceDeclaration() {
      return ___R$romejs$js$ast$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration;
    }};

  const ___R$romejs$js$ast$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowInterfaceDeclaration',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      typeParameters: true,
      extends: true,
      mixins: true,
      implements: true,
      body: true}});

  // romejs/js-ast/flow/FlowInterfaceExtends.ts

  const ___R$romejs$js$ast$flow$FlowInterfaceExtends_ts = {
    get flowInterfaceExtends() {
      return ___R$romejs$js$ast$flow$FlowInterfaceExtends_ts$flowInterfaceExtends;
    }};

  const ___R$romejs$js$ast$flow$FlowInterfaceExtends_ts$flowInterfaceExtends = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowInterfaceExtends',
  {
    bindingKeys: {},
    visitorKeys: {
      id: true,
      typeParameters: true}});

  // romejs/js-ast/flow/FlowInterfaceTypeAnnotation.ts

  const ___R$romejs$js$ast$flow$FlowInterfaceTypeAnnotation_ts = {
    get flowInterfaceTypeAnnotation() {
      return ___R$romejs$js$ast$flow$FlowInterfaceTypeAnnotation_ts$flowInterfaceTypeAnnotation;
    }};

  const ___R$romejs$js$ast$flow$FlowInterfaceTypeAnnotation_ts$flowInterfaceTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowInterfaceTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {
      body: true,
      extends: true}});

  // romejs/js-ast/flow/FlowNullableTypeAnnotation.ts

  const ___R$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts = {
    get flowNullableTypeAnnotation() {
      return ___R$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts$flowNullableTypeAnnotation;
    }};

  const ___R$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts$flowNullableTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowNullableTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {
      typeAnnotation: true}});

  // romejs/js-ast/flow/FlowNumericLiteral.ts

  const ___R$romejs$js$ast$flow$FlowNumericLiteral_ts = {
    get flowNumericLiteral() {
      return ___R$romejs$js$ast$flow$FlowNumericLiteral_ts$flowNumericLiteral;
    }};

  const ___R$romejs$js$ast$flow$FlowNumericLiteral_ts$flowNumericLiteral = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowNumericLiteral',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/flow/FlowObjectTypeAnnotation.ts

  const ___R$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts = {
    get flowObjectTypeAnnotation() {
      return ___R$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts$flowObjectTypeAnnotation;
    }};

  const ___R$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts$flowObjectTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowObjectTypeAnnotation',
  {
    bindingKeys: {},
    visitorKeys: {
      properties: true}});

  // romejs/js-ast/flow/FlowObjectTypeCallProperty.ts

  const ___R$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts = {
    get flowObjectTypeCallProperty() {
      return ___R$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts$flowObjectTypeCallProperty;
    }};

  const ___R$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts$flowObjectTypeCallProperty = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowObjectTypeCallProperty', {
    bindingKeys: {},
    visitorKeys: {
      value: true}});

  // romejs/js-ast/flow/FlowObjectTypeIndexer.ts

  const ___R$romejs$js$ast$flow$FlowObjectTypeIndexer_ts = {
    get flowObjectTypeIndexer() {
      return ___R$romejs$js$ast$flow$FlowObjectTypeIndexer_ts$flowObjectTypeIndexer;
    }};

  const ___R$romejs$js$ast$flow$FlowObjectTypeIndexer_ts$flowObjectTypeIndexer = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowObjectTypeIndexer',
  {
    bindingKeys: {},
    visitorKeys: {
      id: true,
      key: true,
      value: true,
      variance: true}});

  // romejs/js-ast/flow/FlowObjectTypeInternalSlot.ts

  const ___R$romejs$js$ast$flow$FlowObjectTypeInternalSlot_ts = {
    get flowObjectTypeInternalSlot() {
      return ___R$romejs$js$ast$flow$FlowObjectTypeInternalSlot_ts$flowObjectTypeInternalSlot;
    }};

  const ___R$romejs$js$ast$flow$FlowObjectTypeInternalSlot_ts$flowObjectTypeInternalSlot = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowObjectTypeInternalSlot', {
    bindingKeys: {},
    visitorKeys: {
      id: true,
      value: true}});

  // romejs/js-ast/flow/FlowObjectTypeProperty.ts

  const ___R$romejs$js$ast$flow$FlowObjectTypeProperty_ts = {
    get flowObjectTypeProperty() {
      return ___R$romejs$js$ast$flow$FlowObjectTypeProperty_ts$flowObjectTypeProperty;
    }};

  const ___R$romejs$js$ast$flow$FlowObjectTypeProperty_ts$flowObjectTypeProperty = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowObjectTypeProperty',
  {
    bindingKeys: {},
    visitorKeys: {
      key: true,
      value: true,
      variance: true}});

  // romejs/js-ast/flow/FlowObjectTypeSpreadProperty.ts

  const ___R$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts = {
    get flowObjectTypeSpreadProperty() {
      return ___R$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts$flowObjectTypeSpreadProperty;
    }};

  const ___R$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts$flowObjectTypeSpreadProperty = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowObjectTypeSpreadProperty', {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/flow/FlowOpaqueType.ts

  const ___R$romejs$js$ast$flow$FlowOpaqueType_ts = {
    get flowOpaqueType() {
      return ___R$romejs$js$ast$flow$FlowOpaqueType_ts$flowOpaqueType;
    }};

  const ___R$romejs$js$ast$flow$FlowOpaqueType_ts$flowOpaqueType = ___R$romejs$js$ast$utils_ts$createBuilder('FlowOpaqueType', {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      typeParameters: true,
      impltype: true,
      supertype: true}});

  // romejs/js-ast/flow/FlowQualifiedTypeIdentifier.ts

  const ___R$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts = {
    get flowQualifiedTypeIdentifier() {
      return ___R$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts$flowQualifiedTypeIdentifier;
    }};

  const ___R$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts$flowQualifiedTypeIdentifier = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowQualifiedTypeIdentifier', {
    bindingKeys: {},
    visitorKeys: {
      id: true,
      qualification: true}});

  // romejs/js-ast/flow/FlowThisTypeAnnotation.ts

  const ___R$romejs$js$ast$flow$FlowThisTypeAnnotation_ts = {
    get flowThisTypeAnnotation() {
      return ___R$romejs$js$ast$flow$FlowThisTypeAnnotation_ts$flowThisTypeAnnotation;
    }};

  const ___R$romejs$js$ast$flow$FlowThisTypeAnnotation_ts$flowThisTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowThisTypeAnnotation',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/flow/FlowTupleTypeAnnotation.ts

  const ___R$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts = {
    get flowTupleTypeAnnotation() {
      return ___R$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts$flowTupleTypeAnnotation;
    }};

  const ___R$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts$flowTupleTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowTupleTypeAnnotation',
  {
    bindingKeys: {},
    visitorKeys: {
      types: true}});

  // romejs/js-ast/flow/FlowTypeCastExpression.ts

  const ___R$romejs$js$ast$flow$FlowTypeCastExpression_ts = {
    get flowTypeCastExpression() {
      return ___R$romejs$js$ast$flow$FlowTypeCastExpression_ts$flowTypeCastExpression;
    }};

  const ___R$romejs$js$ast$flow$FlowTypeCastExpression_ts$flowTypeCastExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowTypeCastExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      expression: true,
      typeAnnotation: true}});

  // romejs/js-ast/flow/FlowTypeofTypeAnnotation.ts

  const ___R$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts = {
    get flowTypeofTypeAnnotation() {
      return ___R$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts$flowTypeofTypeAnnotation;
    }};

  const ___R$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts$flowTypeofTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowTypeofTypeAnnotation',
  {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/flow/FlowTypeParameter.ts

  const ___R$romejs$js$ast$flow$FlowTypeParameter_ts = {
    get flowTypeParameter() {
      return ___R$romejs$js$ast$flow$FlowTypeParameter_ts$flowTypeParameter;
    }};

  const ___R$romejs$js$ast$flow$FlowTypeParameter_ts$flowTypeParameter = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowTypeParameter',
  {
    bindingKeys: {},
    visitorKeys: {
      bound: true,
      default: true,
      variance: true}});

  // romejs/js-ast/flow/FlowTypeParameterDeclaration.ts

  const ___R$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts = {
    get flowTypeParameterDeclaration() {
      return ___R$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts$flowTypeParameterDeclaration;
    }};

  const ___R$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts$flowTypeParameterDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowTypeParameterDeclaration', {
    bindingKeys: {},
    visitorKeys: {
      params: true}});

  // romejs/js-ast/flow/FlowTypeParameterInstantiation.ts

  const ___R$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts = {
    get flowTypeParameterInstantiation() {
      return ___R$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts$flowTypeParameterInstantiation;
    }};

  const ___R$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts$flowTypeParameterInstantiation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FlowTypeParameterInstantiation', {
    bindingKeys: {},
    visitorKeys: {
      params: true}});

  // romejs/js-ast/flow/FlowVariance.ts

  const ___R$romejs$js$ast$flow$FlowVariance_ts = {
    get flowVariance() {
      return ___R$romejs$js$ast$flow$FlowVariance_ts$flowVariance;
    }};

  const ___R$romejs$js$ast$flow$FlowVariance_ts$flowVariance = ___R$romejs$js$ast$utils_ts$createBuilder('FlowVariance', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/statements/ForInStatement.ts

  const ___R$romejs$js$ast$statements$ForInStatement_ts = {
    get forInStatement() {
      return ___R$romejs$js$ast$statements$ForInStatement_ts$forInStatement;
    }};

  const ___R$romejs$js$ast$statements$ForInStatement_ts$forInStatement = ___R$romejs$js$ast$utils_ts$createBuilder('ForInStatement', {
    bindingKeys: {},
    visitorKeys: {
      left: true,
      right: true,
      body: true}});

  // romejs/js-ast/statements/ForOfStatement.ts

  const ___R$romejs$js$ast$statements$ForOfStatement_ts = {
    get forOfStatement() {
      return ___R$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement;
    }};

  const ___R$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement = ___R$romejs$js$ast$utils_ts$createBuilder('ForOfStatement', {
    bindingKeys: {},
    visitorKeys: {
      left: true,
      right: true,
      body: true}});

  // romejs/js-ast/statements/ForStatement.ts

  const ___R$romejs$js$ast$statements$ForStatement_ts = {
    get forStatement() {
      return ___R$romejs$js$ast$statements$ForStatement_ts$forStatement;
    }};

  const ___R$romejs$js$ast$statements$ForStatement_ts$forStatement = ___R$romejs$js$ast$utils_ts$createBuilder('ForStatement', {
    bindingKeys: {},
    visitorKeys: {
      init: true,
      test: true,
      update: true,
      body: true}});

  // romejs/js-ast/statements/FunctionDeclaration.ts

  const ___R$romejs$js$ast$statements$FunctionDeclaration_ts = {
    get functionDeclaration() {
      return ___R$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration;
    }};

  const ___R$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FunctionDeclaration',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      head: true,
      id: true,
      body: true}});

  // romejs/js-ast/expressions/FunctionExpression.ts

  const ___R$romejs$js$ast$expressions$FunctionExpression_ts = {
    get functionExpression() {
      return ___R$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression;
    }};

  const ___R$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'FunctionExpression',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      head: true,
      id: true,
      body: true}});

  // romejs/js-ast/auxiliary/FunctionHead.ts

  const ___R$romejs$js$ast$auxiliary$FunctionHead_ts = {
    get functionHead() {
      return ___R$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead;
    }};

  const ___R$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'FunctionHead',
  'params',
  {
    bindingKeys: {
      params: true,
      rest: true},
    visitorKeys: {
      params: true,
      thisType: true,
      rest: true,
      returnType: true,
      typeParameters: true,
      predicate: true}});

  // romejs/js-ast/auxiliary/Identifier.ts

  const ___R$romejs$js$ast$auxiliary$Identifier_ts = {
    get identifier() {
      return ___R$romejs$js$ast$auxiliary$Identifier_ts$identifier;
    }};

  const ___R$romejs$js$ast$auxiliary$Identifier_ts$identifier = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'Identifier',
  'name',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/statements/IfStatement.ts

  const ___R$romejs$js$ast$statements$IfStatement_ts = {
    get ifStatement() {
      return ___R$romejs$js$ast$statements$IfStatement_ts$ifStatement;
    }};

  const ___R$romejs$js$ast$statements$IfStatement_ts$ifStatement = ___R$romejs$js$ast$utils_ts$createBuilder('IfStatement', {
    bindingKeys: {},
    visitorKeys: {
      test: true,
      consequent: true,
      alternate: true}});

  // romejs/js-ast/modules/ImportCall.ts

  const ___R$romejs$js$ast$modules$ImportCall_ts = {
    get importCall() {
      return ___R$romejs$js$ast$modules$ImportCall_ts$importCall;
    }};

  const ___R$romejs$js$ast$modules$ImportCall_ts$importCall = ___R$romejs$js$ast$utils_ts$createBuilder('ImportCall', {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/modules/ImportDeclaration.ts

  const ___R$romejs$js$ast$modules$ImportDeclaration_ts = {
    get importDeclaration() {
      return ___R$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration;
    }};

  const ___R$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ImportDeclaration',
  {
    bindingKeys: {},
    visitorKeys: {
      specifiers: true,
      source: true}});

  // romejs/js-ast/modules/ImportDefaultSpecifier.ts

  const ___R$romejs$js$ast$modules$ImportDefaultSpecifier_ts = {
    get importDefaultSpecifier() {
      return ___R$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier;
    }};

  const ___R$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ImportDefaultSpecifier',
  {
    bindingKeys: {
      local: true},
    visitorKeys: {
      local: true}});

  // romejs/js-ast/modules/ImportNamespaceSpecifier.ts

  const ___R$romejs$js$ast$modules$ImportNamespaceSpecifier_ts = {
    get importNamespaceSpecifier() {
      return ___R$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier;
    }};

  const ___R$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ImportNamespaceSpecifier',
  {
    bindingKeys: {
      local: true},
    visitorKeys: {
      local: true}});

  // romejs/js-ast/modules/ImportSpecifier.ts

  const ___R$romejs$js$ast$modules$ImportSpecifier_ts = {
    get importSpecifier() {
      return ___R$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier;
    }};

  const ___R$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ImportSpecifier',
  {
    bindingKeys: {
      local: true},
    visitorKeys: {
      imported: true,
      local: true}});

  // romejs/js-ast/modules/ImportSpecifierLocal.ts

  const ___R$romejs$js$ast$modules$ImportSpecifierLocal_ts = {
    get importSpecifierLocal() {
      return ___R$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal;
    }};

  const ___R$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'ImportSpecifierLocal', 'name', {
    bindingKeys: {
      name: true},
    visitorKeys: {
      name: true}});

  // romejs/js-ast/core/InterpreterDirective.ts

  const ___R$romejs$js$ast$core$InterpreterDirective_ts = {
    get interpreterDirective() {
      return ___R$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective;
    }};

  const ___R$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective = ___R$romejs$js$ast$utils_ts$createBuilder(
  'InterpreterDirective',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/types/IntersectionTypeAnnotation.ts

  const ___R$romejs$js$ast$types$IntersectionTypeAnnotation_ts = {
    get intersectionTypeAnnotation() {
      return ___R$romejs$js$ast$types$IntersectionTypeAnnotation_ts$intersectionTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$IntersectionTypeAnnotation_ts$intersectionTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'IntersectionTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {
      types: true}});

  // romejs/js-ast/jsx/JSXAttribute.ts

  const ___R$romejs$js$ast$jsx$JSXAttribute_ts = {
    get jsxAttribute() {
      return ___R$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute;
    }};

  const ___R$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute = ___R$romejs$js$ast$utils_ts$createBuilder('JSXAttribute', {
    bindingKeys: {},
    visitorKeys: {
      name: true,
      value: true}});

  // romejs/js-ast/jsx/JSXElement.ts

  const ___R$romejs$js$ast$jsx$JSXElement_ts = {
    get jsxElement() {
      return ___R$romejs$js$ast$jsx$JSXElement_ts$jsxElement;
    }};

  const ___R$romejs$js$ast$jsx$JSXElement_ts$jsxElement = ___R$romejs$js$ast$utils_ts$createBuilder('JSXElement', {
    bindingKeys: {},
    visitorKeys: {
      name: true,
      typeArguments: true,
      attributes: true,
      children: true}});

  // romejs/js-ast/jsx/JSXEmptyExpression.ts

  const ___R$romejs$js$ast$jsx$JSXEmptyExpression_ts = {
    get jsxEmptyExpression() {
      return ___R$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression;
    }};

  const ___R$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'JSXEmptyExpression',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/jsx/JSXExpressionContainer.ts

  const ___R$romejs$js$ast$jsx$JSXExpressionContainer_ts = {
    get jsxExpressionContainer() {
      return ___R$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer;
    }};

  const ___R$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer = ___R$romejs$js$ast$utils_ts$createBuilder(
  'JSXExpressionContainer',
  {
    bindingKeys: {},
    visitorKeys: {
      expression: true}});

  // romejs/js-ast/jsx/JSXFragment.ts

  const ___R$romejs$js$ast$jsx$JSXFragment_ts = {
    get jsxFragment() {
      return ___R$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment;
    }};

  const ___R$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment = ___R$romejs$js$ast$utils_ts$createBuilder('JSXFragment', {
    bindingKeys: {},
    visitorKeys: {
      children: true}});

  // romejs/js-ast/jsx/JSXIdentifier.ts

  const ___R$romejs$js$ast$jsx$JSXIdentifier_ts = {
    get jsxIdentifier() {
      return ___R$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier;
    }};

  const ___R$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'JSXIdentifier',
  'name',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/jsx/JSXMemberExpression.ts

  const ___R$romejs$js$ast$jsx$JSXMemberExpression_ts = {
    get jsxMemberExpression() {
      return ___R$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression;
    }};

  const ___R$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'JSXMemberExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      object: true,
      property: true}});

  // romejs/js-ast/jsx/JSXNamespacedName.ts

  const ___R$romejs$js$ast$jsx$JSXNamespacedName_ts = {
    get jsxNamespacedName() {
      return ___R$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName;
    }};

  const ___R$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName = ___R$romejs$js$ast$utils_ts$createBuilder(
  'JSXNamespacedName',
  {
    bindingKeys: {},
    visitorKeys: {
      namespace: true,
      name: true}});

  // romejs/js-ast/jsx/JSXReferenceIdentifier.ts

  const ___R$romejs$js$ast$jsx$JSXReferenceIdentifier_ts = {
    get jsxReferenceIdentifier() {
      return ___R$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier;
    }};

  const ___R$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier = ___R$romejs$js$ast$utils_ts$createBuilder(
  'JSXReferenceIdentifier',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/jsx/JSXSpreadAttribute.ts

  const ___R$romejs$js$ast$jsx$JSXSpreadAttribute_ts = {
    get jsxSpreadAttribute() {
      return ___R$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute;
    }};

  const ___R$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute = ___R$romejs$js$ast$utils_ts$createBuilder(
  'JSXSpreadAttribute',
  {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/jsx/JSXSpreadChild.ts

  const ___R$romejs$js$ast$jsx$JSXSpreadChild_ts = {
    get jsxSpreadChild() {
      return ___R$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild;
    }};

  const ___R$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild = ___R$romejs$js$ast$utils_ts$createBuilder('JSXSpreadChild', {
    bindingKeys: {},
    visitorKeys: {
      expression: true}});

  // romejs/js-ast/jsx/JSXText.ts

  const ___R$romejs$js$ast$jsx$JSXText_ts = {
    get jsxText() {
      return ___R$romejs$js$ast$jsx$JSXText_ts$jsxText;
    }};

  const ___R$romejs$js$ast$jsx$JSXText_ts$jsxText = ___R$romejs$js$ast$utils_ts$createBuilder('JSXText', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/statements/LabeledStatement.ts

  const ___R$romejs$js$ast$statements$LabeledStatement_ts = {
    get labeledStatement() {
      return ___R$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement;
    }};

  const ___R$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement = ___R$romejs$js$ast$utils_ts$createBuilder(
  'LabeledStatement',
  {
    bindingKeys: {},
    visitorKeys: {
      label: true,
      body: true}});

  // romejs/js-ast/expressions/LogicalExpression.ts

  const ___R$romejs$js$ast$expressions$LogicalExpression_ts = {
    get logicalExpression() {
      return ___R$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression;
    }};

  const ___R$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'LogicalExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      left: true,
      right: true}});

  // romejs/js-ast/expressions/MemberExpression.ts

  const ___R$romejs$js$ast$expressions$MemberExpression_ts = {
    get memberExpression() {
      return ___R$romejs$js$ast$expressions$MemberExpression_ts$memberExpression;
    }};

  const ___R$romejs$js$ast$expressions$MemberExpression_ts$memberExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'MemberExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      object: true,
      property: true}});

  // romejs/js-ast/expressions/MetaProperty.ts

  const ___R$romejs$js$ast$expressions$MetaProperty_ts = {
    get metaProperty() {
      return ___R$romejs$js$ast$expressions$MetaProperty_ts$metaProperty;
    }};

  const ___R$romejs$js$ast$expressions$MetaProperty_ts$metaProperty = ___R$romejs$js$ast$utils_ts$createBuilder('MetaProperty', {
    bindingKeys: {},
    visitorKeys: {
      meta: true,
      property: true}});

  // romejs/js-ast/types/MixedKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts = {
    get mixedKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts$mixedKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts$mixedKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'MixedKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/temp/MockParent.ts

  const ___R$romejs$js$ast$temp$MockParent_ts = {
    get mockParent() {
      return ___R$romejs$js$ast$temp$MockParent_ts$mockParent;
    },
    get MOCK_PARENT() {
      return ___R$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT;
    }};

  const ___R$romejs$js$ast$temp$MockParent_ts$mockParent = ___R$romejs$js$ast$utils_ts$createBuilder('MockParent', {
    bindingKeys: {},
    visitorKeys: {}});

  const ___R$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT = {
    type: 'MockParent'};

  // romejs/js-ast/types/NeverKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts = {
    get neverKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts$neverKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts$neverKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'NeverKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/expressions/NewExpression.ts

  const ___R$romejs$js$ast$expressions$NewExpression_ts = {
    get newExpression() {
      return ___R$romejs$js$ast$expressions$NewExpression_ts$newExpression;
    }};

  const ___R$romejs$js$ast$expressions$NewExpression_ts$newExpression = ___R$romejs$js$ast$utils_ts$createBuilder('NewExpression', {
    bindingKeys: {},
    visitorKeys: {
      callee: true,
      arguments: true,
      typeArguments: true}});

  // romejs/js-ast/types/NullKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$NullKeywordTypeAnnotation_ts = {
    get nullKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$NullKeywordTypeAnnotation_ts$nullKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$NullKeywordTypeAnnotation_ts$nullKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'NullKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/literals/NullLiteral.ts

  const ___R$romejs$js$ast$literals$NullLiteral_ts = {
    get nullLiteral() {
      return ___R$romejs$js$ast$literals$NullLiteral_ts$nullLiteral;
    }};

  const ___R$romejs$js$ast$literals$NullLiteral_ts$nullLiteral = ___R$romejs$js$ast$utils_ts$createBuilder('NullLiteral', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/types/NumberKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts = {
    get numberKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts$numberKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts$numberKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'NumberKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/literals/NumericLiteral.ts

  const ___R$romejs$js$ast$literals$NumericLiteral_ts = {
    get numericLiteral() {
      return ___R$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral;
    }};

  const ___R$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral = ___R$romejs$js$ast$utils_ts$createBuilder('NumericLiteral', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/types/NumericLiteralTypeAnnotation.ts

  const ___R$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts = {
    get numericLiteralTypeAnnotation() {
      return ___R$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts$numericLiteralTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts$numericLiteralTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'NumericLiteralTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/objects/ObjectExpression.ts

  const ___R$romejs$js$ast$objects$ObjectExpression_ts = {
    get objectExpression() {
      return ___R$romejs$js$ast$objects$ObjectExpression_ts$objectExpression;
    }};

  const ___R$romejs$js$ast$objects$ObjectExpression_ts$objectExpression = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'ObjectExpression', 'properties', {
    bindingKeys: {},
    visitorKeys: {
      properties: true}});

  // romejs/js-ast/types/ObjectKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts = {
    get objectKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts$objectKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts$objectKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ObjectKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/objects/ObjectMethod.ts

  const ___R$romejs$js$ast$objects$ObjectMethod_ts = {
    get objectMethod() {
      return ___R$romejs$js$ast$objects$ObjectMethod_ts$objectMethod;
    }};

  const ___R$romejs$js$ast$objects$ObjectMethod_ts$objectMethod = ___R$romejs$js$ast$utils_ts$createBuilder('ObjectMethod', {
    bindingKeys: {},
    visitorKeys: {
      key: true,
      head: true,
      body: true}});

  // romejs/js-ast/objects/ObjectProperty.ts

  const ___R$romejs$js$ast$objects$ObjectProperty_ts = {
    get objectProperty() {
      return ___R$romejs$js$ast$objects$ObjectProperty_ts$objectProperty;
    }};

  const ___R$romejs$js$ast$objects$ObjectProperty_ts$objectProperty = ___R$romejs$js$ast$utils_ts$createBuilder('ObjectProperty', {
    bindingKeys: {},
    visitorKeys: {
      key: true,
      value: true}});

  // romejs/js-ast/expressions/OptionalCallExpression.ts

  const ___R$romejs$js$ast$expressions$OptionalCallExpression_ts = {
    get optionalCallExpression() {
      return ___R$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression;
    }};

  const ___R$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'OptionalCallExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      callee: true,
      arguments: true,
      typeArguments: true}});

  // romejs/js-ast/classes/PrivateName.ts

  const ___R$romejs$js$ast$classes$PrivateName_ts = {
    get privateName() {
      return ___R$romejs$js$ast$classes$PrivateName_ts$privateName;
    }};

  const ___R$romejs$js$ast$classes$PrivateName_ts$privateName = ___R$romejs$js$ast$utils_ts$createBuilder('PrivateName', {
    bindingKeys: {},
    visitorKeys: {
      id: true}});

  // romejs/js-ast/core/Program.ts

  const ___R$romejs$js$ast$core$Program_ts = {
    get MOCK_PROGRAM() {
      return ___R$romejs$js$ast$core$Program_ts$MOCK_PROGRAM;
    },
    get program() {
      return ___R$romejs$js$ast$core$Program_ts$program;
    }};

  const ___R$romejs$js$ast$core$Program_ts$MOCK_PROGRAM = {
    type: 'Program',
    directives: [],
    body: [],
    filename: 'unknown',
    mtime: undefined,
    interpreter: undefined,
    sourceType: 'module',
    diagnostics: [],
    comments: [],
    syntax: [],
    hasHoistedVars: false};

  const ___R$romejs$js$ast$core$Program_ts$program = ___R$romejs$js$ast$utils_ts$createBuilder('Program', {
    bindingKeys: {},
    visitorKeys: {
      interpreter: true,
      directives: true,
      body: true,
      comments: true}});

  // romejs/js-ast/expressions/ReferenceIdentifier.ts

  const ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts = {
    get referenceIdentifier() {
      return ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier;
    }};

  const ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'ReferenceIdentifier', 'name', {
    bindingKeys: {},
    visitorKeys: {
      meta: true}});

  // romejs/js-ast/literals/RegExpLiteral.ts

  const ___R$romejs$js$ast$literals$RegExpLiteral_ts = {
    get regExpLiteral() {
      return ___R$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral;
    }};

  const ___R$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral = ___R$romejs$js$ast$utils_ts$createBuilder('RegExpLiteral', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/statements/ReturnStatement.ts

  const ___R$romejs$js$ast$statements$ReturnStatement_ts = {
    get returnStatement() {
      return ___R$romejs$js$ast$statements$ReturnStatement_ts$returnStatement;
    }};

  const ___R$romejs$js$ast$statements$ReturnStatement_ts$returnStatement = ___R$romejs$js$ast$utils_ts$createBuilder(
  'ReturnStatement',
  {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/expressions/SequenceExpression.ts

  const ___R$romejs$js$ast$expressions$SequenceExpression_ts = {
    get sequenceExpression() {
      return ___R$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression;
    }};

  const ___R$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'SequenceExpression',
  {bindingKeys: {}, visitorKeys: {expressions: true}});

  // romejs/js-ast/auxiliary/SpreadElement.ts

  const ___R$romejs$js$ast$auxiliary$SpreadElement_ts = {
    get spreadElement() {
      return ___R$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement;
    }};

  const ___R$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'SpreadElement',
  'argument',
  {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/objects/SpreadProperty.ts

  const ___R$romejs$js$ast$objects$SpreadProperty_ts = {
    get spreadProperty() {
      return ___R$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty;
    }};

  const ___R$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty = ___R$romejs$js$ast$utils_ts$createBuilder('SpreadProperty', {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/auxiliary/StaticMemberProperty.ts

  const ___R$romejs$js$ast$auxiliary$StaticMemberProperty_ts = {
    get staticMemberProperty() {
      return ___R$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty;
    }};

  const ___R$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'StaticMemberProperty', 'value', {
    bindingKeys: {},
    visitorKeys: {
      value: true}});

  // romejs/js-ast/objects/StaticPropertyKey.ts

  const ___R$romejs$js$ast$objects$StaticPropertyKey_ts = {
    get staticPropertyKey() {
      return ___R$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey;
    }};

  const ___R$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'StaticPropertyKey',
  'value',
  {
    bindingKeys: {},
    visitorKeys: {
      variance: true,
      value: true}});

  // romejs/js-ast/types/StringKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$StringKeywordTypeAnnotation_ts = {
    get stringKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$StringKeywordTypeAnnotation_ts$stringKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$StringKeywordTypeAnnotation_ts$stringKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'StringKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/literals/StringLiteral.ts

  const ___R$romejs$js$ast$literals$StringLiteral_ts = {
    get stringLiteral() {
      return ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral;
    }};

  const ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'StringLiteral',
  'value',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/types/StringLiteralTypeAnnotation.ts

  const ___R$romejs$js$ast$types$StringLiteralTypeAnnotation_ts = {
    get stringLiteralTypeAnnotation() {
      return ___R$romejs$js$ast$types$StringLiteralTypeAnnotation_ts$stringLiteralTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$StringLiteralTypeAnnotation_ts$stringLiteralTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'StringLiteralTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/expressions/Super.ts

  const ___R$romejs$js$ast$expressions$Super_ts = {
    get _super() {
      return ___R$romejs$js$ast$expressions$Super_ts$_super;
    }};

  const ___R$romejs$js$ast$expressions$Super_ts$_super = ___R$romejs$js$ast$utils_ts$createBuilder('Super', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/auxiliary/SwitchCase.ts

  const ___R$romejs$js$ast$auxiliary$SwitchCase_ts = {
    get switchCase() {
      return ___R$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase;
    }};

  const ___R$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase = ___R$romejs$js$ast$utils_ts$createBuilder('SwitchCase', {
    bindingKeys: {},
    visitorKeys: {
      test: true,
      consequent: true}});

  // romejs/js-ast/statements/SwitchStatement.ts

  const ___R$romejs$js$ast$statements$SwitchStatement_ts = {
    get switchStatement() {
      return ___R$romejs$js$ast$statements$SwitchStatement_ts$switchStatement;
    }};

  const ___R$romejs$js$ast$statements$SwitchStatement_ts$switchStatement = ___R$romejs$js$ast$utils_ts$createBuilder(
  'SwitchStatement',
  {
    bindingKeys: {},
    visitorKeys: {
      discriminant: true,
      cases: true}});

  // romejs/js-ast/types/SymbolKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts = {
    get symbolKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts$symbolKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts$symbolKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'SymbolKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/expressions/TaggedTemplateExpression.ts

  const ___R$romejs$js$ast$expressions$TaggedTemplateExpression_ts = {
    get taggedTemplateExpression() {
      return ___R$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression;
    }};

  const ___R$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TaggedTemplateExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      tag: true,
      quasi: true,
      typeArguments: true}});

  // romejs/js-ast/auxiliary/TemplateElement.ts

  const ___R$romejs$js$ast$auxiliary$TemplateElement_ts = {
    get templateElement() {
      return ___R$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement;
    }};

  const ___R$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TemplateElement',
  {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/literals/TemplateLiteral.ts

  const ___R$romejs$js$ast$literals$TemplateLiteral_ts = {
    get templateLiteral() {
      return ___R$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral;
    }};

  const ___R$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TemplateLiteral',
  {
    bindingKeys: {},
    visitorKeys: {
      quasis: true,
      expressions: true}});

  // romejs/js-ast/types/TemplateLiteralTypeAnnotation.ts

  const ___R$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts = {
    get templateLiteralTypeAnnotation() {
      return ___R$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts$templateLiteralTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts$templateLiteralTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TemplateLiteralTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/expressions/ThisExpression.ts

  const ___R$romejs$js$ast$expressions$ThisExpression_ts = {
    get thisExpression() {
      return ___R$romejs$js$ast$expressions$ThisExpression_ts$thisExpression;
    }};

  const ___R$romejs$js$ast$expressions$ThisExpression_ts$thisExpression = ___R$romejs$js$ast$utils_ts$createBuilder('ThisExpression', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/statements/ThrowStatement.ts

  const ___R$romejs$js$ast$statements$ThrowStatement_ts = {
    get throwStatement() {
      return ___R$romejs$js$ast$statements$ThrowStatement_ts$throwStatement;
    }};

  const ___R$romejs$js$ast$statements$ThrowStatement_ts$throwStatement = ___R$romejs$js$ast$utils_ts$createBuilder('ThrowStatement', {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/statements/TryStatement.ts

  const ___R$romejs$js$ast$statements$TryStatement_ts = {
    get tryStatement() {
      return ___R$romejs$js$ast$statements$TryStatement_ts$tryStatement;
    }};

  const ___R$romejs$js$ast$statements$TryStatement_ts$tryStatement = ___R$romejs$js$ast$utils_ts$createBuilder('TryStatement', {
    bindingKeys: {},
    visitorKeys: {
      block: true,
      handler: true,
      finalizer: true}});

  // romejs/js-ast/typescript/TSArrayType.ts

  const ___R$romejs$js$ast$typescript$TSArrayType_ts = {
    get tsArrayType() {
      return ___R$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType;
    }};

  const ___R$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType = ___R$romejs$js$ast$utils_ts$createBuilder('TSArrayType', {
    bindingKeys: {},
    visitorKeys: {elementType: true}});

  // romejs/js-ast/typescript/TSAsExpression.ts

  const ___R$romejs$js$ast$typescript$TSAsExpression_ts = {
    get tsAsExpression() {
      return ___R$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression;
    }};

  const ___R$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression = ___R$romejs$js$ast$utils_ts$createBuilder('TSAsExpression', {
    bindingKeys: {},
    visitorKeys: {expression: true, typeAnnotation: true}});

  // romejs/js-ast/typescript/TSAssignmentAsExpression.ts

  const ___R$romejs$js$ast$typescript$TSAssignmentAsExpression_ts = {
    get tsAssignmentAsExpression() {
      return ___R$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression;
    }};

  const ___R$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSAssignmentAsExpression',
  {
    bindingKeys: {},
    visitorKeys: {expression: true, typeAnnotation: true}});

  // romejs/js-ast/typescript/TSAssignmentNonNullExpression.ts

  const ___R$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts = {
    get tsAssignmentNonNullExpression() {
      return ___R$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression;
    }};

  const ___R$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSAssignmentNonNullExpression', {
    bindingKeys: {},
    visitorKeys: {expression: true}});

  // romejs/js-ast/typescript/TSAssignmentTypeAssertion.ts

  const ___R$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts = {
    get tsAssignmentTypeAssertion() {
      return ___R$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion;
    }};

  const ___R$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSAssignmentTypeAssertion', {
    bindingKeys: {},
    visitorKeys: {expression: true, typeAnnotation: true}});

  // romejs/js-ast/typescript/TSCallSignatureDeclaration.ts

  const ___R$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts = {
    get tsCallSignatureDeclaration() {
      return ___R$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration;
    }};

  const ___R$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSCallSignatureDeclaration', {
    bindingKeys: {},
    visitorKeys: {
      meta: true,
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSConditionalType.ts

  const ___R$romejs$js$ast$typescript$TSConditionalType_ts = {
    get tsConditionalType() {
      return ___R$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType;
    }};

  const ___R$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSConditionalType',
  {
    bindingKeys: {},
    visitorKeys: {
      checkType: true,
      extendsType: true,
      trueType: true,
      falseType: true}});

  // romejs/js-ast/typescript/TSConstructorType.ts

  const ___R$romejs$js$ast$typescript$TSConstructorType_ts = {
    get tsConstructorType() {
      return ___R$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType;
    }};

  const ___R$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSConstructorType',
  {
    bindingKeys: {},
    visitorKeys: {
      meta: true,
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSConstructSignatureDeclaration.ts

  const ___R$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts = {
    get tsConstructSignatureDeclaration() {
      return ___R$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration;
    }};

  const ___R$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSConstructSignatureDeclaration', {
    bindingKeys: {},
    visitorKeys: {
      meta: true,
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSDeclareFunction.ts

  const ___R$romejs$js$ast$typescript$TSDeclareFunction_ts = {
    get tsDeclareFunction() {
      return ___R$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction;
    }};

  const ___R$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSDeclareFunction',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      head: true}});

  // romejs/js-ast/typescript/TSDeclareMethod.ts

  const ___R$romejs$js$ast$typescript$TSDeclareMethod_ts = {
    get tsDeclareMethod() {
      return ___R$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod;
    }};

  const ___R$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSDeclareMethod',
  {
    bindingKeys: {},
    visitorKeys: {
      meta: true,
      head: true}});

  // romejs/js-ast/typescript/TSEnumDeclaration.ts

  const ___R$romejs$js$ast$typescript$TSEnumDeclaration_ts = {
    get tsEnumDeclaration() {
      return ___R$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration;
    }};

  const ___R$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSEnumDeclaration',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      members: true}});

  // romejs/js-ast/typescript/TSEnumMember.ts

  const ___R$romejs$js$ast$typescript$TSEnumMember_ts = {
    get tsEnumMember() {
      return ___R$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember;
    }};

  const ___R$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember = ___R$romejs$js$ast$utils_ts$createBuilder('TSEnumMember', {
    bindingKeys: {},
    visitorKeys: {
      id: true,
      initializer: true}});

  // romejs/js-ast/typescript/TSExportAssignment.ts

  const ___R$romejs$js$ast$typescript$TSExportAssignment_ts = {
    get tsExportAssignment() {
      return ___R$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment;
    }};

  const ___R$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSExportAssignment',
  {bindingKeys: {}, visitorKeys: {expression: true}});

  // romejs/js-ast/typescript/TSExpressionWithTypeArguments.ts

  const ___R$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts = {
    get tsExpressionWithTypeArguments() {
      return ___R$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments;
    }};

  const ___R$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSExpressionWithTypeArguments', {
    bindingKeys: {},
    visitorKeys: {
      expression: true,
      typeParameters: true}});

  // romejs/js-ast/typescript/TSExternalModuleReference.ts

  const ___R$romejs$js$ast$typescript$TSExternalModuleReference_ts = {
    get tsExternalModuleReference() {
      return ___R$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference;
    }};

  const ___R$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSExternalModuleReference', {
    bindingKeys: {},
    visitorKeys: {expression: true}});

  // romejs/js-ast/typescript/TSFunctionType.ts

  const ___R$romejs$js$ast$typescript$TSFunctionType_ts = {
    get tsFunctionType() {
      return ___R$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType;
    }};

  const ___R$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType = ___R$romejs$js$ast$utils_ts$createBuilder('TSFunctionType', {
    bindingKeys: {},
    visitorKeys: {
      meta: true,
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSImportEqualsDeclaration.ts

  const ___R$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts = {
    get tsImportEqualsDeclaration() {
      return ___R$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration;
    }};

  const ___R$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSImportEqualsDeclaration', {
    bindingKeys: {
      id: true},
    visitorKeys: {id: true, moduleReference: true}});

  // romejs/js-ast/typescript/TSImportType.ts

  const ___R$romejs$js$ast$typescript$TSImportType_ts = {
    get tsImportType() {
      return ___R$romejs$js$ast$typescript$TSImportType_ts$tsImportType;
    }};

  const ___R$romejs$js$ast$typescript$TSImportType_ts$tsImportType = ___R$romejs$js$ast$utils_ts$createBuilder('TSImportType', {
    bindingKeys: {},
    visitorKeys: {
      argument: true,
      typeParameters: true,
      qualifier: true}});

  // romejs/js-ast/typescript/TSIndexedAccessType.ts

  const ___R$romejs$js$ast$typescript$TSIndexedAccessType_ts = {
    get tsIndexedAccessType() {
      return ___R$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType;
    }};

  const ___R$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSIndexedAccessType',
  {
    bindingKeys: {},
    visitorKeys: {
      objectType: true,
      indexType: true}});

  // romejs/js-ast/typescript/TSIndexSignature.ts

  const ___R$romejs$js$ast$typescript$TSIndexSignature_ts = {
    get tsIndexSignature() {
      return ___R$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature;
    }};

  const ___R$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSIndexSignature',
  {
    bindingKeys: {
      parameters: true,
      rest: true},
    visitorKeys: {
      typeAnnotation: true,
      parameters: true,
      rest: true}});

  // romejs/js-ast/typescript/TSInferType.ts

  const ___R$romejs$js$ast$typescript$TSInferType_ts = {
    get tsInferType() {
      return ___R$romejs$js$ast$typescript$TSInferType_ts$tsInferType;
    }};

  const ___R$romejs$js$ast$typescript$TSInferType_ts$tsInferType = ___R$romejs$js$ast$utils_ts$createBuilder('TSInferType', {
    bindingKeys: {},
    visitorKeys: {
      typeParameter: true}});

  // romejs/js-ast/typescript/TSInterfaceBody.ts

  const ___R$romejs$js$ast$typescript$TSInterfaceBody_ts = {
    get tsInterfaceBody() {
      return ___R$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody;
    }};

  const ___R$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSInterfaceBody',
  {
    bindingKeys: {},
    visitorKeys: {
      body: true}});

  // romejs/js-ast/typescript/TSInterfaceDeclaration.ts

  const ___R$romejs$js$ast$typescript$TSInterfaceDeclaration_ts = {
    get tsInterfaceDeclaration() {
      return ___R$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration;
    }};

  const ___R$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSInterfaceDeclaration',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      body: true,
      typeParameters: true,
      extends: true}});

  // romejs/js-ast/typescript/TSMappedType.ts

  const ___R$romejs$js$ast$typescript$TSMappedType_ts = {
    get tsMappedType() {
      return ___R$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType;
    }};

  const ___R$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType = ___R$romejs$js$ast$utils_ts$createBuilder('TSMappedType', {
    bindingKeys: {},
    visitorKeys: {
      typeParameter: true,
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSMethodSignature.ts

  const ___R$romejs$js$ast$typescript$TSMethodSignature_ts = {
    get tsMethodSignature() {
      return ___R$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature;
    }};

  const ___R$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSMethodSignature',
  {
    bindingKeys: {},
    visitorKeys: {
      key: true,
      meta: true,
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSModuleBlock.ts

  const ___R$romejs$js$ast$typescript$TSModuleBlock_ts = {
    get tsModuleBlock() {
      return ___R$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock;
    }};

  const ___R$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock = ___R$romejs$js$ast$utils_ts$createBuilder('TSModuleBlock', {
    bindingKeys: {},
    visitorKeys: {
      body: true}});

  // romejs/js-ast/typescript/TSModuleDeclaration.ts

  const ___R$romejs$js$ast$typescript$TSModuleDeclaration_ts = {
    get tsModuleDeclaration() {
      return ___R$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration;
    }};

  const ___R$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSModuleDeclaration',
  {
    bindingKeys: {},
    visitorKeys: {
      id: true,
      body: true}});

  // romejs/js-ast/typescript/TSNamespaceExportDeclaration.ts

  const ___R$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts = {
    get tsNamespaceExportDeclaration() {
      return ___R$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration;
    }};

  const ___R$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSNamespaceExportDeclaration', {bindingKeys: {}, visitorKeys: {id: true}});

  // romejs/js-ast/typescript/TSNonNullExpression.ts

  const ___R$romejs$js$ast$typescript$TSNonNullExpression_ts = {
    get tsNonNullExpression() {
      return ___R$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression;
    }};

  const ___R$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSNonNullExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      expression: true}});

  // romejs/js-ast/typescript/TSOptionalType.ts

  const ___R$romejs$js$ast$typescript$TSOptionalType_ts = {
    get tsOptionalType() {
      return ___R$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType;
    }};

  const ___R$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType = ___R$romejs$js$ast$utils_ts$createBuilder('TSOptionalType', {
    bindingKeys: {},
    visitorKeys: {
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSParenthesizedType.ts

  const ___R$romejs$js$ast$typescript$TSParenthesizedType_ts = {
    get tsParenthesizedType() {
      return ___R$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType;
    }};

  const ___R$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSParenthesizedType',
  {
    bindingKeys: {},
    visitorKeys: {
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSPropertySignature.ts

  const ___R$romejs$js$ast$typescript$TSPropertySignature_ts = {
    get tsPropertySignature() {
      return ___R$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature;
    }};

  const ___R$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSPropertySignature',
  {
    bindingKeys: {},
    visitorKeys: {
      key: true,
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSQualifiedName.ts

  const ___R$romejs$js$ast$typescript$TSQualifiedName_ts = {
    get tsQualifiedName() {
      return ___R$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName;
    }};

  const ___R$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSQualifiedName',
  {
    bindingKeys: {},
    visitorKeys: {
      left: true,
      right: true}});

  // romejs/js-ast/typescript/TSSignatureDeclarationMeta.ts

  const ___R$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts = {
    get tsSignatureDeclarationMeta() {
      return ___R$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta;
    }};

  const ___R$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSSignatureDeclarationMeta', {
    bindingKeys: {},
    visitorKeys: {
      parameters: true,
      rest: true,
      typeParameters: true}});

  // romejs/js-ast/typescript/TSThisType.ts

  const ___R$romejs$js$ast$typescript$TSThisType_ts = {
    get tsThisType() {
      return ___R$romejs$js$ast$typescript$TSThisType_ts$tsThisType;
    }};

  const ___R$romejs$js$ast$typescript$TSThisType_ts$tsThisType = ___R$romejs$js$ast$utils_ts$createBuilder('TSThisType', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/typescript/TSTupleType.ts

  const ___R$romejs$js$ast$typescript$TSTupleType_ts = {
    get tsTupleType() {
      return ___R$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType;
    }};

  const ___R$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType = ___R$romejs$js$ast$utils_ts$createBuilder('TSTupleType', {
    bindingKeys: {},
    visitorKeys: {
      elementTypes: true,
      rest: true}});

  // romejs/js-ast/typescript/TSTypeAssertion.ts

  const ___R$romejs$js$ast$typescript$TSTypeAssertion_ts = {
    get tsTypeAssertion() {
      return ___R$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion;
    }};

  const ___R$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSTypeAssertion',
  {
    bindingKeys: {},
    visitorKeys: {
      expression: true,
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSTypeLiteral.ts

  const ___R$romejs$js$ast$typescript$TSTypeLiteral_ts = {
    get tsTypeLiteral() {
      return ___R$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral;
    }};

  const ___R$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral = ___R$romejs$js$ast$utils_ts$createBuilder('TSTypeLiteral', {
    bindingKeys: {},
    visitorKeys: {
      members: true}});

  // romejs/js-ast/typescript/TSTypeOperator.ts

  const ___R$romejs$js$ast$typescript$TSTypeOperator_ts = {
    get tsTypeOperator() {
      return ___R$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator;
    }};

  const ___R$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator = ___R$romejs$js$ast$utils_ts$createBuilder('TSTypeOperator', {
    bindingKeys: {},
    visitorKeys: {
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSTypeParameter.ts

  const ___R$romejs$js$ast$typescript$TSTypeParameter_ts = {
    get tsTypeParameter() {
      return ___R$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter;
    }};

  const ___R$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSTypeParameter',
  {
    bindingKeys: {},
    visitorKeys: {
      default: true,
      constraint: true}});

  // romejs/js-ast/typescript/TSTypeParameterDeclaration.ts

  const ___R$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts = {
    get tsTypeParameterDeclaration() {
      return ___R$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration;
    }};

  const ___R$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSTypeParameterDeclaration', {
    bindingKeys: {},
    visitorKeys: {
      params: true}});

  // romejs/js-ast/typescript/TSTypeParameterInstantiation.ts

  const ___R$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts = {
    get tsTypeParameterInstantiation() {
      return ___R$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation;
    }};

  const ___R$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSTypeParameterInstantiation', {
    bindingKeys: {},
    visitorKeys: {
      params: true}});

  // romejs/js-ast/typescript/TSTypePredicate.ts

  const ___R$romejs$js$ast$typescript$TSTypePredicate_ts = {
    get tsTypePredicate() {
      return ___R$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate;
    }};

  const ___R$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSTypePredicate',
  {
    bindingKeys: {},
    visitorKeys: {
      parameterName: true,
      typeAnnotation: true}});

  // romejs/js-ast/typescript/TSTypeQuery.ts

  const ___R$romejs$js$ast$typescript$TSTypeQuery_ts = {
    get tsTypeQuery() {
      return ___R$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery;
    }};

  const ___R$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery = ___R$romejs$js$ast$utils_ts$createBuilder('TSTypeQuery', {
    bindingKeys: {},
    visitorKeys: {
      exprName: true}});

  // romejs/js-ast/typescript/TSTypeReference.ts

  const ___R$romejs$js$ast$typescript$TSTypeReference_ts = {
    get tsTypeReference() {
      return ___R$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference;
    }};

  const ___R$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TSTypeReference',
  {
    bindingKeys: {},
    visitorKeys: {
      typeName: true,
      typeParameters: true}});

  // romejs/js-ast/types/TypeAliasTypeAnnotation.ts

  const ___R$romejs$js$ast$types$TypeAliasTypeAnnotation_ts = {
    get typeAliasTypeAnnotation() {
      return ___R$romejs$js$ast$types$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'TypeAliasTypeAnnotation',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      typeParameters: true,
      right: true}});

  // romejs/js-ast/expressions/UnaryExpression.ts

  const ___R$romejs$js$ast$expressions$UnaryExpression_ts = {
    get unaryExpression() {
      return ___R$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression;
    }};

  const ___R$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'UnaryExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/types/UndefinedKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts = {
    get undefinedKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts$undefinedKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts$undefinedKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'UndefinedKeywordTypeAnnotation', {bindingKeys: {}, visitorKeys: {}});

  // romejs/js-ast/types/UnionTypeAnnotation.ts

  const ___R$romejs$js$ast$types$UnionTypeAnnotation_ts = {
    get unionTypeAnnotation() {
      return ___R$romejs$js$ast$types$UnionTypeAnnotation_ts$unionTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$UnionTypeAnnotation_ts$unionTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'UnionTypeAnnotation',
  {
    bindingKeys: {},
    visitorKeys: {
      types: true}});

  // romejs/js-ast/types/UnknownKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts = {
    get unknownKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts$unknownKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts$unknownKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'UnknownKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/expressions/UpdateExpression.ts

  const ___R$romejs$js$ast$expressions$UpdateExpression_ts = {
    get updateExpression() {
      return ___R$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression;
    }};

  const ___R$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'UpdateExpression',
  {
    bindingKeys: {},
    visitorKeys: {
      argument: true}});

  // romejs/js-ast/auxiliary/VariableDeclaration.ts

  const ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts = {
    get variableDeclaration() {
      return ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration;
    }};

  const ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration = ___R$romejs$js$ast$utils_ts$createBuilder(
  'VariableDeclaration',
  {
    bindingKeys: {
      declarations: true},
    visitorKeys: {
      declarations: true}});

  // romejs/js-ast/statements/VariableDeclarationStatement.ts

  const ___R$romejs$js$ast$statements$VariableDeclarationStatement_ts = {
    get variableDeclarationStatement() {
      return ___R$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement;
    }};

  const ___R$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement = ___R$romejs$js$ast$utils_ts$createQuickBuilder(
  'VariableDeclarationStatement', 'declaration', {
    bindingKeys: {
      declaration: true},
    visitorKeys: {
      declaration: true}});

  // romejs/js-ast/auxiliary/VariableDeclarator.ts

  const ___R$romejs$js$ast$auxiliary$VariableDeclarator_ts = {
    get variableDeclarator() {
      return ___R$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator;
    }};

  const ___R$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator = ___R$romejs$js$ast$utils_ts$createBuilder(
  'VariableDeclarator',
  {
    bindingKeys: {
      id: true},
    visitorKeys: {
      id: true,
      init: true}});

  // romejs/js-ast/types/VoidKeywordTypeAnnotation.ts

  const ___R$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts = {
    get voidKeywordTypeAnnotation() {
      return ___R$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts$voidKeywordTypeAnnotation;
    }};

  const ___R$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts$voidKeywordTypeAnnotation = ___R$romejs$js$ast$utils_ts$createBuilder(
  'VoidKeywordTypeAnnotation', {
    bindingKeys: {},
    visitorKeys: {}});

  // romejs/js-ast/statements/WhileStatement.ts

  const ___R$romejs$js$ast$statements$WhileStatement_ts = {
    get whileStatement() {
      return ___R$romejs$js$ast$statements$WhileStatement_ts$whileStatement;
    }};

  const ___R$romejs$js$ast$statements$WhileStatement_ts$whileStatement = ___R$romejs$js$ast$utils_ts$createBuilder('WhileStatement', {
    bindingKeys: {},
    visitorKeys: {
      test: true,
      body: true}});

  // romejs/js-ast/statements/WithStatement.ts

  const ___R$romejs$js$ast$statements$WithStatement_ts = {
    get withStatement() {
      return ___R$romejs$js$ast$statements$WithStatement_ts$withStatement;
    }};

  const ___R$romejs$js$ast$statements$WithStatement_ts$withStatement = ___R$romejs$js$ast$utils_ts$createBuilder('WithStatement', {
    bindingKeys: {},
    visitorKeys: {
      object: true,
      body: true}});

  // romejs/js-ast/expressions/YieldExpression.ts

  const ___R$romejs$js$ast$expressions$YieldExpression_ts = {
    get yieldExpression() {
      return ___R$romejs$js$ast$expressions$YieldExpression_ts$yieldExpression;
    }};

  const ___R$romejs$js$ast$expressions$YieldExpression_ts$yieldExpression = ___R$romejs$js$ast$utils_ts$createBuilder(
  'YieldExpression',
  {bindingKeys: {}, visitorKeys: {argument: true}});

  // romejs/js-ast/index.ts

  const ___R$romejs$js$ast$index_ts = {
    get visitorKeys() {
      return ___R$romejs$js$ast$utils_ts$visitorKeys;
    },
    get nodeNames() {
      return ___R$romejs$js$ast$utils_ts$nodeNames;
    },
    get assertNodeTypeSet() {
      return ___R$romejs$js$ast$utils_ts$assertNodeTypeSet;
    }};
  Object.keys(___R$romejs$js$ast$base_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$base_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$constants_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$constants_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$unions_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$unions_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$ArrayExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$ArrayExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$ArrowFunctionExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$ArrowFunctionExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$AssignmentArrayPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$AssignmentArrayPattern_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$AssignmentExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$AssignmentExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$AssignmentIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$AssignmentIdentifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$AssignmentObjectPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$AssignmentObjectPattern_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$AwaitExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$AwaitExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$literals$BigIntLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$literals$BigIntLiteral_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$BinaryExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$BinaryExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$BindingArrayPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$BindingArrayPattern_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$BindingAssignmentPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$BindingAssignmentPattern_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$BindingIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$BindingIdentifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$BindingObjectPattern_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$BindingObjectPattern_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$BindingObjectPatternProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$BindingObjectPatternProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$BlockStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$BlockStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$literals$BooleanLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$literals$BooleanLiteral_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$BreakStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$BreakStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$CallExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$CallExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$auxiliary$CatchClause_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$auxiliary$CatchClause_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$classes$ClassDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$classes$ClassDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$classes$ClassExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$classes$ClassExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$classes$ClassHead_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$classes$ClassHead_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$classes$ClassMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$classes$ClassMethod_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$classes$ClassPrivateMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$classes$ClassPrivateMethod_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$classes$ClassPrivateProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$classes$ClassPrivateProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$classes$ClassProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$classes$ClassProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$classes$ClassPropertyMeta_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$classes$ClassPropertyMeta_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$core$CommentBlock_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$core$CommentBlock_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$core$CommentLine_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$core$CommentLine_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$auxiliary$ComputedMemberProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$auxiliary$ComputedMemberProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$objects$ComputedPropertyKey_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$objects$ComputedPropertyKey_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$ConditionalExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$ConditionalExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$ContinueStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$ContinueStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$DebuggerStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$DebuggerStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$core$Directive_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$core$Directive_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$DoExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$DoExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$DoWhileStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$DoWhileStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$EmptyStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$EmptyStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ExportAllDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ExportAllDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ExportDefaultDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ExportDefaultDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ExportDefaultSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ExportDefaultSpecifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ExportNamedDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ExportNamedDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ExportNamespaceSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ExportNamespaceSpecifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ExportSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ExportSpecifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$ExpressionStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$ExpressionStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowClassImplements_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowClassImplements_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclareClass_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclareClass_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclaredPredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclaredPredicate_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclareExportAll_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclareExportAll_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclareExportDefault_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclareExportDefault_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclareExportNamed_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclareExportNamed_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclareFunction_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclareFunction_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclareInterface_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclareInterface_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclareModule_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclareModule_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclareModuleExports_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclareModuleExports_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclareOpaqueType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclareOpaqueType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowDeclareVariable_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowDeclareVariable_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowFunctionTypeParam_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowFunctionTypeParam_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowInferredPredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowInferredPredicate_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowInterface_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowInterface_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowInterfaceDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowInterfaceDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowInterfaceExtends_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowInterfaceExtends_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowInterfaceTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowInterfaceTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowNumericLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowNumericLiteral_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowObjectTypeIndexer_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowObjectTypeIndexer_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowObjectTypeInternalSlot_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowObjectTypeInternalSlot_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowObjectTypeProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowObjectTypeProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowOpaqueType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowOpaqueType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowThisTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowThisTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowTypeCastExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowTypeCastExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowTypeParameter_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowTypeParameter_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$flow$FlowVariance_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$flow$FlowVariance_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$ForInStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$ForInStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$ForOfStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$ForOfStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$ForStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$ForStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$FunctionDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$FunctionDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$FunctionExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$FunctionExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$auxiliary$FunctionHead_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$auxiliary$FunctionHead_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$auxiliary$Identifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$auxiliary$Identifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$IfStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$IfStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ImportCall_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ImportCall_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ImportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ImportDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ImportDefaultSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ImportDefaultSpecifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ImportNamespaceSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ImportNamespaceSpecifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ImportSpecifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ImportSpecifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$modules$ImportSpecifierLocal_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$modules$ImportSpecifierLocal_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$core$InterpreterDirective_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$core$InterpreterDirective_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$IntersectionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$IntersectionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXAttribute_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXAttribute_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXElement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXEmptyExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXEmptyExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXExpressionContainer_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXExpressionContainer_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXFragment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXFragment_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXIdentifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXMemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXMemberExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXNamespacedName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXNamespacedName_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXReferenceIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXReferenceIdentifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXSpreadAttribute_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXSpreadAttribute_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXSpreadChild_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXSpreadChild_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$jsx$JSXText_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$jsx$JSXText_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$LabeledStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$LabeledStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$LogicalExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$LogicalExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$MemberExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$MemberExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$MetaProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$MetaProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$temp$MockParent_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$temp$MockParent_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$NewExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$NewExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$NullKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$NullKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$literals$NullLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$literals$NullLiteral_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$literals$NumericLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$literals$NumericLiteral_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$objects$ObjectExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$objects$ObjectExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$objects$ObjectMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$objects$ObjectMethod_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$objects$ObjectProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$objects$ObjectProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$OptionalCallExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$OptionalCallExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$patterns$PatternMeta_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$patterns$PatternMeta_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$classes$PrivateName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$classes$PrivateName_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$core$Program_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$core$Program_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$ReferenceIdentifier_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$literals$RegExpLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$literals$RegExpLiteral_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$ReturnStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$ReturnStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$SequenceExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$SequenceExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$auxiliary$SpreadElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$auxiliary$SpreadElement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$objects$SpreadProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$objects$SpreadProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$auxiliary$StaticMemberProperty_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$auxiliary$StaticMemberProperty_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$objects$StaticPropertyKey_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$objects$StaticPropertyKey_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$StringKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$StringKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$literals$StringLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$literals$StringLiteral_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$StringLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$StringLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$Super_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$Super_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$auxiliary$SwitchCase_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$auxiliary$SwitchCase_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$SwitchStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$SwitchStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$TaggedTemplateExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$TaggedTemplateExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$auxiliary$TemplateElement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$auxiliary$TemplateElement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$literals$TemplateLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$literals$TemplateLiteral_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$ThisExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$ThisExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$ThrowStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$ThrowStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$TryStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$TryStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSArrayType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSArrayType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSAsExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSAsExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSAssignmentAsExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSAssignmentAsExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSConditionalType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSConditionalType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSConstructorType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSConstructorType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSDeclareFunction_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSDeclareFunction_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSDeclareMethod_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSDeclareMethod_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSEnumDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSEnumDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSEnumMember_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSEnumMember_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSExportAssignment_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSExportAssignment_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSExternalModuleReference_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSExternalModuleReference_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSFunctionType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSFunctionType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSImportType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSImportType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSIndexedAccessType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSIndexedAccessType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSIndexSignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSIndexSignature_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSInferType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSInferType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSInterfaceBody_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSInterfaceBody_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSInterfaceDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSInterfaceDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSMappedType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSMappedType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSMethodSignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSMethodSignature_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSModuleBlock_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSModuleBlock_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSModuleDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSModuleDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSNonNullExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSNonNullExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSOptionalType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSOptionalType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSParenthesizedType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSParenthesizedType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSPropertySignature_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSPropertySignature_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSQualifiedName_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSQualifiedName_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSThisType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSThisType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSTupleType_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSTupleType_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSTypeAssertion_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSTypeAssertion_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSTypeLiteral_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSTypeLiteral_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSTypeOperator_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSTypeOperator_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSTypeParameter_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSTypeParameter_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSTypePredicate_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSTypePredicate_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSTypeQuery_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSTypeQuery_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$typescript$TSTypeReference_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$typescript$TSTypeReference_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$TypeAliasTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$TypeAliasTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$UnaryExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$UnaryExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$UnionTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$UnionTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$UpdateExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$UpdateExpression_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$auxiliary$VariableDeclaration_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$VariableDeclarationStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$VariableDeclarationStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$auxiliary$VariableDeclarator_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$auxiliary$VariableDeclarator_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$WhileStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$WhileStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$statements$WithStatement_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$statements$WithStatement_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$ast$expressions$YieldExpression_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$ast$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$ast$expressions$YieldExpression_ts[key];
      }});
  });

  // romejs/js-ast-utils/isVariableIdentifier.ts

  function ___R$romejs$js$ast$utils$isVariableIdentifier_ts$default(node) {
    return node.type === 'BindingIdentifier' ||
    node.type === 'AssignmentIdentifier' ||
    node.type === 'ReferenceIdentifier' ||
    node.type === 'JSXReferenceIdentifier';
  }

  // romejs/js-ast-utils/renameBindings.ts

  function ___R$romejs$js$ast$utils$renameBindings_ts$default(path, oldToNewMapping) {
    if (oldToNewMapping.size === 0) {
      return path.node;
    }

    const oldBindingToNewName = new Map();

    const oldNameToBinding = new Map();
    for (const [oldName, newName] of oldToNewMapping) {
      if (typeof oldName === 'string') {
        const binding = path.scope.getBinding(oldName);
        oldNameToBinding.set(oldName, binding);
      } else {
        oldBindingToNewName.set(oldName, newName);
      }
    }

    const replaceNodesWithName = new Map();
    path.traverse('renameBindingsCollector', path => {
      const {node: node, scope: scope} = path;
      if (!___R$romejs$js$ast$utils$isVariableIdentifier_ts$default(node)) {
        return;
      }

      const binding = scope.getBinding(node.name);

      if (oldToNewMapping.has(node.name) &&
      binding === oldNameToBinding.get(node.name)) {
        const newName = oldToNewMapping.get(node.name);
        if (newName === undefined) {
          throw new Error('Should exist');
        }
        replaceNodesWithName.set(node, newName);
      }

      if (binding !== undefined && oldBindingToNewName.has(binding)) {
        const newName = oldBindingToNewName.get(binding);
        if (newName === undefined) {
          throw new Error('Should exist');
        }
        replaceNodesWithName.set(node, newName);
      }
    });
    if (replaceNodesWithName.size === 0) {
      return path.node;
    }

    const replaced = new Set();

    const renamedNode = path.reduce(
    {
      name: 'renameBindings',
      enter(path) {
        const {node: node} = path;

        if (node.type === 'ExportNamedDeclaration' &&
        node.declaration !== undefined &&
        (node.declaration.type === 'FunctionDeclaration' ||
        node.declaration.type === 'ClassDeclaration')) {
          const newName = replaceNodesWithName.get(node.declaration.id);

          if (newName !== undefined) {
            replaced.add(node.declaration.id);

            const oldName = node.declaration.id.name;

            return [node.declaration, ___R$romejs$js$ast$modules$ExportNamedDeclaration_ts$exportNamedDeclaration.create({
              specifiers: [___R$romejs$js$ast$modules$ExportSpecifier_ts$exportSpecifier.create({
                loc: node.declaration.id.loc,
                local: ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(newName),
                exported: ___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(oldName)})]})];
          }
        }

        if (node.type === 'ExportNamedDeclaration' &&
        node.declaration !== undefined) {
          const bindings = ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node.declaration);
          let includesAny = false;
          for (const node of bindings) {
            if (replaceNodesWithName.has(node)) {
              includesAny = true;
              break;
            }
          }

          if (includesAny) {
            return [node.declaration, ___R$romejs$js$ast$modules$ExportNamedDeclaration_ts$exportNamedDeclaration.create({
              specifiers: bindings.map(node => {
                let local = node.name;

                const newName = replaceNodesWithName.get(node);
                if (newName !== undefined) {
                  local = newName;
                  replaced.add(node);
                }

                return ___R$romejs$js$ast$modules$ExportSpecifier_ts$exportSpecifier.create({
                  loc: node.loc,
                  local: ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(local),
                  exported: ___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(node.name)});
              })})];
          }
        }

        if (___R$romejs$js$ast$utils$isVariableIdentifier_ts$default(node)) {
          const newName = replaceNodesWithName.get(node);
          if (newName !== undefined) {
            replaced.add(node);
            return Object.assign({}, node, {
              name: newName,
              loc: ___R$romejs$js$ast$utils$inheritLoc_ts$default(node, node.name)});
          }
        }

        return node;
      }},
    {
      noScopeCreation: true});

    if (replaced.size !== replaceNodesWithName.size) {
      throw new Error('Missed some bindings');
    }

    return ___R$romejs$js$ast$utils$assertSingleOrMultipleNode_ts$default(renamedNode);
  }

  // romejs/js-compiler/constants.ts

  const ___R$romejs$js$compiler$constants_ts = {
    get SCOPE_PRIVATE_PREFIX() {
      return ___R$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX;
    },
    get REDUCE_SKIP_SUBTREE() {
      return ___R$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE;
    },
    get REDUCE_REMOVE() {
      return ___R$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
    }};
  const ___R$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX = '___R$';
  const ___R$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE = Symbol();
  const ___R$romejs$js$compiler$constants_ts$REDUCE_REMOVE = Symbol();

  // romejs/js-compiler/scope/evaluators/ClassExpression.ts

  const ___R$romejs$js$compiler$scope$evaluators$ClassExpression_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('class', node);
      newScope.evaluate(node.meta.typeParameters);
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/ClassDeclaration.ts

  const ___R$romejs$js$compiler$scope$evaluators$ClassDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      if (node.id !== undefined) {
        scope.addBinding(
        new ___R$romejs$js$compiler$scope$bindings_ts$ClassBinding({
          name: node.id.name,
          node: node.id,
          scope: scope}));
      }
      return ___R$romejs$js$compiler$scope$evaluators$ClassExpression_ts$default.build(node, parent, scope);
    }};

  // romejs/js-compiler/scope/utils.ts

  function ___R$romejs$js$compiler$scope$utils_ts$addFunctionBindings(scope, node, hasArguments = true) {
    const {head: head} = node;

    scope.evaluate(head.typeParameters);

    for (const param of head.params) {
      for (const id of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(param)) {
        scope.addBinding(
        new ___R$romejs$js$compiler$scope$bindings_ts$LetBinding({
          node: id,
          name: id.name,
          scope: scope}));
      }
    }

    if (hasArguments) {
      scope.addBinding(
      new ___R$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding({
        name: 'arguments',
        node: node,
        scope: scope}));
    }

    if (head.hasHoistedVars) {
      ___R$romejs$js$compiler$scope$utils_ts$addVarBindings(scope, node);
    }
  }

  function ___R$romejs$js$compiler$scope$utils_ts$addVarBindings(scope, topNode) {
    const {context: context} = scope.getRootScope();
    scope.setHoistedVars();

    context.reduce(
    topNode,
    [{
      name: 'scopeVarFunc',
      enter: path => {
        const {node: node, parent: parent} = path;

        if (___R$romejs$js$ast$utils$isFunctionNode_ts$default(node) && node !== topNode) {
          return ___R$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE;
        }

        if (node.type === 'VariableDeclaration' && node.kind === 'var') {
          scope.evaluate(node, parent);
        }

        return node;
      }}],
    {
      scope: scope,
      noScopeCreation: true});
  }

  // romejs/js-compiler/scope/evaluators/FunctionDeclaration.ts

  const ___R$romejs$js$compiler$scope$evaluators$FunctionDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      if (node.id !== undefined) {
        scope.addBinding(
        new ___R$romejs$js$compiler$scope$bindings_ts$FunctionBinding({
          node: node.id,
          name: node.id.name,
          scope: scope}));
      }

      const newScope = scope.fork('function', node);
      ___R$romejs$js$compiler$scope$utils_ts$addFunctionBindings(newScope, node);
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/VariableDeclaration.ts

  const ___R$romejs$js$compiler$scope$evaluators$VariableDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      for (const decl of node.declarations) {
        for (const id of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(decl)) {
          if (node.kind === 'let') {
            scope.addBinding(
            new ___R$romejs$js$compiler$scope$bindings_ts$LetBinding({
              node: id,
              name: id.name,
              scope: scope}));
          }

          if (node.kind === 'const') {
            let valueNode = id === decl.id ? decl.init : undefined;
            scope.addBinding(
            new ___R$romejs$js$compiler$scope$bindings_ts$ConstBinding({
              node: id,
              name: id.name,
              scope: scope}, valueNode));
          }

          if (node.kind === 'var' &&
          (scope.kind === 'program' || scope.kind === 'function')) {
            if (!scope.hasHoistedVars) {
              throw new Error('This scope does not allow `var`iables. This is probably because `var`iables were injected into a scope that did not contain `var` in the original source.');
            }

            scope.addBinding(
            new ___R$romejs$js$compiler$scope$bindings_ts$VarBinding({
              node: id,
              name: id.name,
              scope: scope}));
          }
        }
      }
    }};

  // romejs/js-compiler/scope/evaluators/TypeAliasTypeAnnotation.ts

  const ___R$romejs$js$compiler$scope$evaluators$TypeAliasTypeAnnotation_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.evaluate(node.typeParameters);
      scope.addBinding(
      new ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding({
        node: node.id,
        name: node.id.name,
        scope: scope}, node, 'typealias'));
    }};

  // romejs/js-compiler/scope/evaluators/ExportDefaultDeclaration.ts

  const ___R$romejs$js$compiler$scope$evaluators$ExportDefaultDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      const {declaration: declaration} = node;
      const newScope = scope.evaluate(declaration, node);
      if (declaration.type === 'ClassDeclaration' ||
      declaration.type === 'FunctionDeclaration') {
        const id = declaration.id;
        if (id !== undefined) {
          newScope.getBindingAssert(id.name).setExported(true);
        }
      }
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/ExportNamedDeclaration.ts

  const ___R$romejs$js$compiler$scope$evaluators$ExportNamedDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      const newScope = scope.evaluate(node.declaration, node);
      for (const id of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node)) {
        newScope.getBindingAssert(id.name).setExported(true);
      }
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/ImportDeclaration.ts

  const ___R$romejs$js$compiler$scope$evaluators$ImportDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      const source = node.source.value;
      const {specifiers: specifiers} = node;

      if (specifiers !== undefined) {
        for (const specifier of specifiers) {
          let kind = specifier.local.importKind || node.importKind || 'value';
          let meta;

          if (specifier.type === 'ImportNamespaceSpecifier') {
            meta = {
              kind: kind,
              type: 'namespace',
              source: source};
          } else if (specifier.type === 'ImportDefaultSpecifier') {
            meta = {
              kind: kind,
              type: 'name',
              imported: 'default',
              source: source};
          } else if (specifier.type === 'ImportSpecifier') {
            meta = {
              kind: kind,
              type: 'name',
              imported: specifier.imported.name,
              source: source};
          }

          if (meta === undefined) {
            return undefined;
          }

          scope.addBinding(
          new ___R$romejs$js$compiler$scope$bindings_ts$ImportBinding({
            node: specifier.local.name,
            name: specifier.local.name.name,
            scope: scope}, meta));
        }
      }
    }};

  // romejs/js-compiler/scope/evaluators/FlowTypeParameterDeclaration.ts

  const ___R$romejs$js$compiler$scope$evaluators$FlowTypeParameterDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      for (const id of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node)) {
        scope.addBinding(
        new ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding({
          node: id,
          name: id.name,
          scope: scope}, node, 'parameter'));
      }
    }};

  // romejs/js-compiler/scope/evaluators/FlowDeclareExportNamed.ts

  const ___R$romejs$js$compiler$scope$evaluators$FlowDeclareExportNamed_ts$default = {
    creator: false,
    build(node, parent, scope) {
      const {declaration: declaration} = node;
      const newScope = scope.evaluate(declaration, node);
      if (declaration !== undefined) {
        if (declaration.type === 'FlowDeclareOpaqueType') {
          newScope.getBindingAssert(declaration.id.name).setExported(true);
        }
      }
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/SwitchCase.ts

  const ___R$romejs$js$compiler$scope$evaluators$SwitchCase_ts$default = {
    creator: false,
    build(node, parent, scope) {
      for (const child of node.consequent) {
        scope.evaluate(child, node);
      }
    }};

  // romejs/js-compiler/scope/evaluators/SwitchStatement.ts

  const ___R$romejs$js$compiler$scope$evaluators$SwitchStatement_ts$default = {
    creator: false,
    build(node, parent, scope) {
      for (const child of node.cases) {
        scope.evaluate(child, node);
      }
    }};

  // romejs/js-compiler/scope/evaluators/FlowInterfaceDeclaration.ts

  const ___R$romejs$js$compiler$scope$evaluators$FlowInterfaceDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
      new ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding({
        node: node.id,
        name: node.id.name,
        scope: scope}, node, 'interface'));
    }};

  // romejs/js-compiler/scope/evaluators/FlowOpaqueType.ts

  const ___R$romejs$js$compiler$scope$evaluators$FlowOpaqueType_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
      new ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding({
        node: node.id,
        name: node.id.name,
        scope: scope}, node, 'typealias'));
    }};

  // romejs/js-compiler/scope/evaluators/FlowDeclareOpaqueType.ts


  // romejs/js-compiler/scope/evaluators/FlowDeclareFunction.ts

  const ___R$romejs$js$compiler$scope$evaluators$FlowDeclareFunction_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
      new ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding({
        node: node.id,
        name: node.id.name,
        scope: scope}, node, 'function'));
    }};

  // romejs/js-compiler/scope/evaluators/FlowDeclareClass.ts

  const ___R$romejs$js$compiler$scope$evaluators$FlowDeclareClass_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
      new ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding({
        node: node.id,
        name: node.id.name,
        scope: scope}, node, 'class'));
    }};

  // romejs/js-compiler/scope/evaluators/TSImportEqualsDeclaration.ts

  const ___R$romejs$js$compiler$scope$evaluators$TSImportEqualsDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      const {moduleReference: moduleReference, id: id} = node;

      if (moduleReference.type === 'TSExternalModuleReference') {
        scope.addBinding(
        new ___R$romejs$js$compiler$scope$bindings_ts$ImportBinding({
          node: id,
          name: id.name,
          scope: scope}, {
          type: 'namespace',
          kind: 'value',
          source: moduleReference.expression.value}));
      } else {}
    }};

  // romejs/js-compiler/scope/evaluators/ArrowFunctionExpression.ts

  const ___R$romejs$js$compiler$scope$evaluators$ArrowFunctionExpression_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('function', node);
      ___R$romejs$js$compiler$scope$utils_ts$addFunctionBindings(newScope, node, false);
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/ClassMethod.ts

  const ___R$romejs$js$compiler$scope$evaluators$ClassMethod_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('function', node);
      ___R$romejs$js$compiler$scope$utils_ts$addFunctionBindings(newScope, node);
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/FunctionExpression.ts

  const ___R$romejs$js$compiler$scope$evaluators$FunctionExpression_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('function', node);
      if (node.id !== undefined) {
        newScope.addBinding(
        new ___R$romejs$js$compiler$scope$bindings_ts$LetBinding({
          node: node.id,
          name: node.id.name,
          scope: scope}));
      }
      ___R$romejs$js$compiler$scope$utils_ts$addFunctionBindings(newScope, node);
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/ObjectMethod.ts

  const ___R$romejs$js$compiler$scope$evaluators$ObjectMethod_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('function', node);
      ___R$romejs$js$compiler$scope$utils_ts$addFunctionBindings(newScope, node);
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/BlockStatement.ts

  const ___R$romejs$js$compiler$scope$evaluators$BlockStatement_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('block', node);
      for (const child of node.body) {
        newScope.evaluate(child, node);
      }
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/CatchClause.ts

  const ___R$romejs$js$compiler$scope$evaluators$CatchClause_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('block', node);
      if (node.param !== undefined) {
        for (const id of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node.param)) {
          scope.addBinding(
          new ___R$romejs$js$compiler$scope$bindings_ts$LetBinding({
            node: id,
            name: id.name,
            scope: scope}));
        }
      }
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/Program.ts

  const ___R$romejs$js$compiler$scope$evaluators$Program_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('program', node);
      for (const child of node.body) {
        newScope.evaluate(child, node);
      }
      if (node.hasHoistedVars) {
        ___R$romejs$js$compiler$scope$utils_ts$addVarBindings(newScope, node);
      }
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/ForStatement.ts

  const ___R$romejs$js$compiler$scope$evaluators$ForStatement_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('loop', node);
      newScope.evaluate(node.init, node);
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/ForOfStatement.ts

  const ___R$romejs$js$compiler$scope$evaluators$ForOfStatement_ts$default = {
    creator: true,
    build(node, parent, scope) {
      const newScope = scope.fork('loop', node);
      newScope.evaluate(node.left, node);
      return newScope;
    }};

  // romejs/js-compiler/scope/evaluators/VariableDeclarationStatement.ts

  const ___R$romejs$js$compiler$scope$evaluators$VariableDeclarationStatement_ts$default = {
    creator: false,
    build(node, parent, scope) {
      if (node.declare) {
        for (const {name: name} of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node)) {
          scope.addGlobal(name);
        }
      } else {
        scope.evaluate(node.declaration, node);
      }
    }};

  // romejs/js-compiler/scope/evaluators/TSInterfaceDeclaration.ts

  const ___R$romejs$js$compiler$scope$evaluators$TSInterfaceDeclaration_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
      new ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding({
        node: node.id,
        name: node.id.name,
        scope: scope}, node, 'interface'));
    }};

  // romejs/js-compiler/scope/evaluators/TSDeclareFunction.ts

  const ___R$romejs$js$compiler$scope$evaluators$TSDeclareFunction_ts$default = {
    creator: false,
    build(node, parent, scope) {
      scope.addBinding(
      new ___R$romejs$js$compiler$scope$bindings_ts$FunctionBinding({
        node: node.id,
        name: node.id.name,
        scope: scope}));
    }};

  // romejs/js-compiler/scope/evaluators/index.ts


  const ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators = new Map();

  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('TSDeclareFunction', ___R$romejs$js$compiler$scope$evaluators$TSDeclareFunction_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ClassDeclaration', ___R$romejs$js$compiler$scope$evaluators$ClassDeclaration_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FunctionDeclaration', ___R$romejs$js$compiler$scope$evaluators$FunctionDeclaration_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('VariableDeclarationStatement', ___R$romejs$js$compiler$scope$evaluators$VariableDeclarationStatement_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('VariableDeclaration', ___R$romejs$js$compiler$scope$evaluators$VariableDeclaration_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('TypeAliasTypeAnnotation', ___R$romejs$js$compiler$scope$evaluators$TypeAliasTypeAnnotation_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ExportDefaultDeclaration', ___R$romejs$js$compiler$scope$evaluators$ExportDefaultDeclaration_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ExportNamedDeclaration', ___R$romejs$js$compiler$scope$evaluators$ExportNamedDeclaration_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ImportDeclaration', ___R$romejs$js$compiler$scope$evaluators$ImportDeclaration_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowTypeParameterDeclaration', ___R$romejs$js$compiler$scope$evaluators$FlowTypeParameterDeclaration_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowDeclareExportNamed', ___R$romejs$js$compiler$scope$evaluators$FlowDeclareExportNamed_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('SwitchCase', ___R$romejs$js$compiler$scope$evaluators$SwitchCase_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('SwitchStatement', ___R$romejs$js$compiler$scope$evaluators$SwitchStatement_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowInterfaceDeclaration', ___R$romejs$js$compiler$scope$evaluators$FlowInterfaceDeclaration_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowOpaqueType', ___R$romejs$js$compiler$scope$evaluators$FlowOpaqueType_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowDeclareOpaqueType', ___R$romejs$js$compiler$scope$evaluators$FlowOpaqueType_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowDeclareFunction', ___R$romejs$js$compiler$scope$evaluators$FlowDeclareFunction_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FlowDeclareClass', ___R$romejs$js$compiler$scope$evaluators$FlowDeclareClass_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('TypeAliasTypeAnnotation', ___R$romejs$js$compiler$scope$evaluators$TypeAliasTypeAnnotation_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('TSImportEqualsDeclaration', ___R$romejs$js$compiler$scope$evaluators$TSImportEqualsDeclaration_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ArrowFunctionExpression', ___R$romejs$js$compiler$scope$evaluators$ArrowFunctionExpression_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ClassMethod', ___R$romejs$js$compiler$scope$evaluators$ClassMethod_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('FunctionExpression', ___R$romejs$js$compiler$scope$evaluators$FunctionExpression_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ObjectMethod', ___R$romejs$js$compiler$scope$evaluators$ObjectMethod_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('BlockStatement', ___R$romejs$js$compiler$scope$evaluators$BlockStatement_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ClassExpression', ___R$romejs$js$compiler$scope$evaluators$ClassExpression_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('CatchClause', ___R$romejs$js$compiler$scope$evaluators$CatchClause_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('Program', ___R$romejs$js$compiler$scope$evaluators$Program_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ForStatement', ___R$romejs$js$compiler$scope$evaluators$ForStatement_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ForOfStatement', ___R$romejs$js$compiler$scope$evaluators$ForOfStatement_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('ForInStatement', ___R$romejs$js$compiler$scope$evaluators$ForOfStatement_ts$default);
  ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set('TSInterfaceDeclaration', ___R$romejs$js$compiler$scope$evaluators$TSInterfaceDeclaration_ts$default);
  const ___R$romejs$js$compiler$scope$evaluators$index_ts$default = ___R$$priv$romejs$js$compiler$scope$evaluators$index_ts$evaluators;

  // romejs/js-compiler/scope/globals.ts

  const ___R$romejs$js$compiler$scope$globals_ts = {
    get builtin() {
      return ___R$romejs$js$compiler$scope$globals_ts$builtin;
    },
    get es5() {
      return ___R$romejs$js$compiler$scope$globals_ts$es5;
    },
    get es2015() {
      return ___R$romejs$js$compiler$scope$globals_ts$es2015;
    },
    get es2017() {
      return ___R$romejs$js$compiler$scope$globals_ts$es2017;
    },
    get browser() {
      return ___R$romejs$js$compiler$scope$globals_ts$browser;
    },
    get worker() {
      return ___R$romejs$js$compiler$scope$globals_ts$worker;
    },
    get node() {
      return ___R$romejs$js$compiler$scope$globals_ts$node;
    },
    get commonjs() {
      return ___R$romejs$js$compiler$scope$globals_ts$commonjs;
    },
    get serviceworker() {
      return ___R$romejs$js$compiler$scope$globals_ts$serviceworker;
    }};
  const ___R$romejs$js$compiler$scope$globals_ts$builtin = ['Array', 'ArrayBuffer', 'Atomics', 'BigInt', 'BigInt64Array', 'BigUint64Array', 'Boolean', 'constructor', 'DataView', 'Date', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'Error', 'escape', 'eval', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'globalThis', 'hasOwnProperty', 'Infinity', 'Int16Array', 'Int32Array', 'Int8Array', 'isFinite', 'isNaN', 'isPrototypeOf', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'parseFloat', 'parseInt', 'Promise', 'propertyIsEnumerable', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set', 'SharedArrayBuffer', 'String', 'Symbol', 'SyntaxError', 'toLocaleString', 'toString', 'TypeError', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray', 'undefined', 'unescape', 'URIError', 'valueOf', 'WeakMap', 'WeakSet'];

  const ___R$romejs$js$compiler$scope$globals_ts$es5 = ['Array', 'Boolean', 'constructor', 'Date', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'Error', 'escape', 'eval', 'EvalError', 'Function', 'hasOwnProperty', 'Infinity', 'isFinite', 'isNaN', 'isPrototypeOf', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'parseFloat', 'parseInt', 'propertyIsEnumerable', 'RangeError', 'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'toLocaleString', 'toString', 'TypeError', 'undefined', 'unescape', 'URIError', 'valueOf'];

  const ___R$romejs$js$compiler$scope$globals_ts$es2015 = ['Array', 'ArrayBuffer', 'Boolean', 'constructor', 'DataView', 'Date', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'Error', 'escape', 'eval', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'hasOwnProperty', 'Infinity', 'Int16Array', 'Int32Array', 'Int8Array', 'isFinite', 'isNaN', 'isPrototypeOf', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'parseFloat', 'parseInt', 'Promise', 'propertyIsEnumerable', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'SyntaxError', 'toLocaleString', 'toString', 'TypeError', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray', 'undefined', 'unescape', 'URIError', 'valueOf', 'WeakMap', 'WeakSet'];

  const ___R$romejs$js$compiler$scope$globals_ts$es2017 = ['Array', 'ArrayBuffer', 'Atomics', 'Boolean', 'constructor', 'DataView', 'Date', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'Error', 'escape', 'eval', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'hasOwnProperty', 'Infinity', 'Int16Array', 'Int32Array', 'Int8Array', 'isFinite', 'isNaN', 'isPrototypeOf', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'parseFloat', 'parseInt', 'Promise', 'propertyIsEnumerable', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set', 'SharedArrayBuffer', 'String', 'Symbol', 'SyntaxError', 'toLocaleString', 'toString', 'TypeError', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray', 'undefined', 'unescape', 'URIError', 'valueOf', 'WeakMap', 'WeakSet'];

  const ___R$romejs$js$compiler$scope$globals_ts$browser = ['AbortController', 'AbortSignal', 'addEventListener', 'alert', 'AnalyserNode', 'Animation', 'AnimationEffectReadOnly', 'AnimationEffectTiming', 'AnimationEffectTimingReadOnly', 'AnimationEvent', 'AnimationPlaybackEvent', 'AnimationTimeline', 'applicationCache', 'ApplicationCache', 'ApplicationCacheErrorEvent', 'atob', 'Attr', 'Audio', 'AudioBuffer', 'AudioBufferSourceNode', 'AudioContext', 'AudioDestinationNode', 'AudioListener', 'AudioNode', 'AudioParam', 'AudioProcessingEvent', 'AudioScheduledSourceNode', 'AudioWorkletGlobalScope ', 'AudioWorkletNode', 'AudioWorkletProcessor', 'BarProp', 'BaseAudioContext', 'BatteryManager', 'BeforeUnloadEvent', 'BiquadFilterNode', 'Blob', 'BlobEvent', 'blur', 'BroadcastChannel', 'btoa', 'BudgetService', 'ByteLengthQueuingStrategy', 'Cache', 'caches', 'CacheStorage', 'cancelAnimationFrame', 'cancelIdleCallback', 'CanvasCaptureMediaStreamTrack', 'CanvasGradient', 'CanvasPattern', 'CanvasRenderingContext2D', 'ChannelMergerNode', 'ChannelSplitterNode', 'CharacterData', 'clearInterval', 'clearTimeout', 'clientInformation', 'ClipboardEvent', 'close', 'closed', 'CloseEvent', 'Comment', 'CompositionEvent', 'confirm', 'console', 'ConstantSourceNode', 'ConvolverNode', 'CountQueuingStrategy', 'createImageBitmap', 'Credential', 'CredentialsContainer', 'crypto', 'Crypto', 'CryptoKey', 'CSS', 'CSSConditionRule', 'CSSFontFaceRule', 'CSSGroupingRule', 'CSSImportRule', 'CSSKeyframeRule', 'CSSKeyframesRule', 'CSSMediaRule', 'CSSNamespaceRule', 'CSSPageRule', 'CSSRule', 'CSSRuleList', 'CSSStyleDeclaration', 'CSSStyleRule', 'CSSStyleSheet', 'CSSSupportsRule', 'CustomElementRegistry', 'customElements', 'CustomEvent', 'DataTransfer', 'DataTransferItem', 'DataTransferItemList', 'defaultstatus', 'defaultStatus', 'DelayNode', 'DeviceMotionEvent', 'DeviceOrientationEvent', 'devicePixelRatio', 'dispatchEvent', 'document', 'Document', 'DocumentFragment', 'DocumentType', 'DOMError', 'DOMException', 'DOMImplementation', 'DOMMatrix', 'DOMMatrixReadOnly', 'DOMParser', 'DOMPoint', 'DOMPointReadOnly', 'DOMQuad', 'DOMRect', 'DOMRectReadOnly', 'DOMStringList', 'DOMStringMap', 'DOMTokenList', 'DragEvent', 'DynamicsCompressorNode', 'Element', 'ErrorEvent', 'event', 'Event', 'EventSource', 'EventTarget', 'external', 'fetch', 'File', 'FileList', 'FileReader', 'find', 'focus', 'FocusEvent', 'FontFace', 'FontFaceSetLoadEvent', 'FormData', 'frameElement', 'frames', 'GainNode', 'Gamepad', 'GamepadButton', 'GamepadEvent', 'getComputedStyle', 'getSelection', 'HashChangeEvent', 'Headers', 'history', 'History', 'HTMLAllCollection', 'HTMLAnchorElement', 'HTMLAreaElement', 'HTMLAudioElement', 'HTMLBaseElement', 'HTMLBodyElement', 'HTMLBRElement', 'HTMLButtonElement', 'HTMLCanvasElement', 'HTMLCollection', 'HTMLContentElement', 'HTMLDataElement', 'HTMLDataListElement', 'HTMLDetailsElement', 'HTMLDialogElement', 'HTMLDirectoryElement', 'HTMLDivElement', 'HTMLDListElement', 'HTMLDocument', 'HTMLElement', 'HTMLEmbedElement', 'HTMLFieldSetElement', 'HTMLFontElement', 'HTMLFormControlsCollection', 'HTMLFormElement', 'HTMLFrameElement', 'HTMLFrameSetElement', 'HTMLHeadElement', 'HTMLHeadingElement', 'HTMLHRElement', 'HTMLHtmlElement', 'HTMLIFrameElement', 'HTMLImageElement', 'HTMLInputElement', 'HTMLLabelElement', 'HTMLLegendElement', 'HTMLLIElement', 'HTMLLinkElement', 'HTMLMapElement', 'HTMLMarqueeElement', 'HTMLMediaElement', 'HTMLMenuElement', 'HTMLMetaElement', 'HTMLMeterElement', 'HTMLModElement', 'HTMLObjectElement', 'HTMLOListElement', 'HTMLOptGroupElement', 'HTMLOptionElement', 'HTMLOptionsCollection', 'HTMLOutputElement', 'HTMLParagraphElement', 'HTMLParamElement', 'HTMLPictureElement', 'HTMLPreElement', 'HTMLProgressElement', 'HTMLQuoteElement', 'HTMLScriptElement', 'HTMLSelectElement', 'HTMLShadowElement', 'HTMLSlotElement', 'HTMLSourceElement', 'HTMLSpanElement', 'HTMLStyleElement', 'HTMLTableCaptionElement', 'HTMLTableCellElement', 'HTMLTableColElement', 'HTMLTableElement', 'HTMLTableRowElement', 'HTMLTableSectionElement', 'HTMLTemplateElement', 'HTMLTextAreaElement', 'HTMLTimeElement', 'HTMLTitleElement', 'HTMLTrackElement', 'HTMLUListElement', 'HTMLUnknownElement', 'HTMLVideoElement', 'IDBCursor', 'IDBCursorWithValue', 'IDBDatabase', 'IDBFactory', 'IDBIndex', 'IDBKeyRange', 'IDBObjectStore', 'IDBOpenDBRequest', 'IDBRequest', 'IDBTransaction', 'IDBVersionChangeEvent', 'IdleDeadline', 'IIRFilterNode', 'Image', 'ImageBitmap', 'ImageBitmapRenderingContext', 'ImageCapture', 'ImageData', 'indexedDB', 'innerHeight', 'innerWidth', 'InputEvent', 'IntersectionObserver', 'IntersectionObserverEntry', 'Intl', 'isSecureContext', 'KeyboardEvent', 'KeyframeEffect', 'KeyframeEffectReadOnly', 'length', 'localStorage', 'location', 'Location', 'locationbar', 'matchMedia', 'MediaDeviceInfo', 'MediaDevices', 'MediaElementAudioSourceNode', 'MediaEncryptedEvent', 'MediaError', 'MediaKeyMessageEvent', 'MediaKeySession', 'MediaKeyStatusMap', 'MediaKeySystemAccess', 'MediaList', 'MediaQueryList', 'MediaQueryListEvent', 'MediaRecorder', 'MediaSettingsRange', 'MediaSource', 'MediaStream', 'MediaStreamAudioDestinationNode', 'MediaStreamAudioSourceNode', 'MediaStreamEvent', 'MediaStreamTrack', 'MediaStreamTrackEvent', 'menubar', 'MessageChannel', 'MessageEvent', 'MessagePort', 'MIDIAccess', 'MIDIConnectionEvent', 'MIDIInput', 'MIDIInputMap', 'MIDIMessageEvent', 'MIDIOutput', 'MIDIOutputMap', 'MIDIPort', 'MimeType', 'MimeTypeArray', 'MouseEvent', 'moveBy', 'moveTo', 'MutationEvent', 'MutationObserver', 'MutationRecord', 'name', 'NamedNodeMap', 'NavigationPreloadManager', 'navigator', 'Navigator', 'NetworkInformation', 'Node', 'NodeFilter', 'NodeIterator', 'NodeList', 'Notification', 'OfflineAudioCompletionEvent', 'OfflineAudioContext', 'offscreenBuffering', 'OffscreenCanvas', 'onabort', 'onafterprint', 'onanimationend', 'onanimationiteration', 'onanimationstart', 'onappinstalled', 'onauxclick', 'onbeforeinstallprompt', 'onbeforeprint', 'onbeforeunload', 'onblur', 'oncancel', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose', 'oncontextmenu', 'oncuechange', 'ondblclick', 'ondevicemotion', 'ondeviceorientation', 'ondeviceorientationabsolute', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'ondurationchange', 'onemptied', 'onended', 'onerror', 'onfocus', 'ongotpointercapture', 'onhashchange', 'oninput', 'oninvalid', 'onkeydown', 'onkeypress', 'onkeyup', 'onlanguagechange', 'onload', 'onloadeddata', 'onloadedmetadata', 'onloadstart', 'onlostpointercapture', 'onmessage', 'onmessageerror', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onoffline', 'ononline', 'onpagehide', 'onpageshow', 'onpause', 'onplay', 'onplaying', 'onpointercancel', 'onpointerdown', 'onpointerenter', 'onpointerleave', 'onpointermove', 'onpointerout', 'onpointerover', 'onpointerup', 'onpopstate', 'onprogress', 'onratechange', 'onrejectionhandled', 'onreset', 'onresize', 'onscroll', 'onsearch', 'onseeked', 'onseeking', 'onselect', 'onstalled', 'onstorage', 'onsubmit', 'onsuspend', 'ontimeupdate', 'ontoggle', 'ontransitionend', 'onunhandledrejection', 'onunload', 'onvolumechange', 'onwaiting', 'onwheel', 'open', 'openDatabase', 'opener', 'Option', 'origin', 'OscillatorNode', 'outerHeight', 'outerWidth', 'PageTransitionEvent', 'pageXOffset', 'pageYOffset', 'PannerNode', 'parent', 'Path2D', 'PaymentAddress', 'PaymentRequest', 'PaymentRequestUpdateEvent', 'PaymentResponse', 'performance', 'Performance', 'PerformanceEntry', 'PerformanceLongTaskTiming', 'PerformanceMark', 'PerformanceMeasure', 'PerformanceNavigation', 'PerformanceNavigationTiming', 'PerformanceObserver', 'PerformanceObserverEntryList', 'PerformancePaintTiming', 'PerformanceResourceTiming', 'PerformanceTiming', 'PeriodicWave', 'Permissions', 'PermissionStatus', 'personalbar', 'PhotoCapabilities', 'Plugin', 'PluginArray', 'PointerEvent', 'PopStateEvent', 'postMessage', 'Presentation', 'PresentationAvailability', 'PresentationConnection', 'PresentationConnectionAvailableEvent', 'PresentationConnectionCloseEvent', 'PresentationConnectionList', 'PresentationReceiver', 'PresentationRequest', 'print', 'ProcessingInstruction', 'ProgressEvent', 'PromiseRejectionEvent', 'prompt', 'PushManager', 'PushSubscription', 'PushSubscriptionOptions', 'queueMicrotask', 'RadioNodeList', 'Range', 'ReadableStream', 'registerProcessor', 'RemotePlayback', 'removeEventListener', 'Request', 'requestAnimationFrame', 'requestIdleCallback', 'resizeBy', 'ResizeObserver', 'ResizeObserverEntry', 'resizeTo', 'Response', 'RTCCertificate', 'RTCDataChannel', 'RTCDataChannelEvent', 'RTCDtlsTransport', 'RTCIceCandidate', 'RTCIceGatherer', 'RTCIceTransport', 'RTCPeerConnection', 'RTCPeerConnectionIceEvent', 'RTCRtpContributingSource', 'RTCRtpReceiver', 'RTCRtpSender', 'RTCSctpTransport', 'RTCSessionDescription', 'RTCStatsReport', 'RTCTrackEvent', 'screen', 'Screen', 'screenLeft', 'ScreenOrientation', 'screenTop', 'screenX', 'screenY', 'ScriptProcessorNode', 'scroll', 'scrollbars', 'scrollBy', 'scrollTo', 'scrollX', 'scrollY', 'SecurityPolicyViolationEvent', 'Selection', 'self', 'ServiceWorker', 'ServiceWorkerContainer', 'ServiceWorkerRegistration', 'sessionStorage', 'setInterval', 'setTimeout', 'ShadowRoot', 'SharedWorker', 'SourceBuffer', 'SourceBufferList', 'speechSynthesis', 'SpeechSynthesisEvent', 'SpeechSynthesisUtterance', 'StaticRange', 'status', 'statusbar', 'StereoPannerNode', 'stop', 'Storage', 'StorageEvent', 'StorageManager', 'styleMedia', 'StyleSheet', 'StyleSheetList', 'SubtleCrypto', 'SVGAElement', 'SVGAngle', 'SVGAnimatedAngle', 'SVGAnimatedBoolean', 'SVGAnimatedEnumeration', 'SVGAnimatedInteger', 'SVGAnimatedLength', 'SVGAnimatedLengthList', 'SVGAnimatedNumber', 'SVGAnimatedNumberList', 'SVGAnimatedPreserveAspectRatio', 'SVGAnimatedRect', 'SVGAnimatedString', 'SVGAnimatedTransformList', 'SVGAnimateElement', 'SVGAnimateMotionElement', 'SVGAnimateTransformElement', 'SVGAnimationElement', 'SVGCircleElement', 'SVGClipPathElement', 'SVGComponentTransferFunctionElement', 'SVGDefsElement', 'SVGDescElement', 'SVGDiscardElement', 'SVGElement', 'SVGEllipseElement', 'SVGFEBlendElement', 'SVGFEColorMatrixElement', 'SVGFEComponentTransferElement', 'SVGFECompositeElement', 'SVGFEConvolveMatrixElement', 'SVGFEDiffuseLightingElement', 'SVGFEDisplacementMapElement', 'SVGFEDistantLightElement', 'SVGFEDropShadowElement', 'SVGFEFloodElement', 'SVGFEFuncAElement', 'SVGFEFuncBElement', 'SVGFEFuncGElement', 'SVGFEFuncRElement', 'SVGFEGaussianBlurElement', 'SVGFEImageElement', 'SVGFEMergeElement', 'SVGFEMergeNodeElement', 'SVGFEMorphologyElement', 'SVGFEOffsetElement', 'SVGFEPointLightElement', 'SVGFESpecularLightingElement', 'SVGFESpotLightElement', 'SVGFETileElement', 'SVGFETurbulenceElement', 'SVGFilterElement', 'SVGForeignObjectElement', 'SVGGElement', 'SVGGeometryElement', 'SVGGradientElement', 'SVGGraphicsElement', 'SVGImageElement', 'SVGLength', 'SVGLengthList', 'SVGLinearGradientElement', 'SVGLineElement', 'SVGMarkerElement', 'SVGMaskElement', 'SVGMatrix', 'SVGMetadataElement', 'SVGMPathElement', 'SVGNumber', 'SVGNumberList', 'SVGPathElement', 'SVGPatternElement', 'SVGPoint', 'SVGPointList', 'SVGPolygonElement', 'SVGPolylineElement', 'SVGPreserveAspectRatio', 'SVGRadialGradientElement', 'SVGRect', 'SVGRectElement', 'SVGScriptElement', 'SVGSetElement', 'SVGStopElement', 'SVGStringList', 'SVGStyleElement', 'SVGSVGElement', 'SVGSwitchElement', 'SVGSymbolElement', 'SVGTextContentElement', 'SVGTextElement', 'SVGTextPathElement', 'SVGTextPositioningElement', 'SVGTitleElement', 'SVGTransform', 'SVGTransformList', 'SVGTSpanElement', 'SVGUnitTypes', 'SVGUseElement', 'SVGViewElement', 'TaskAttributionTiming', 'Text', 'TextDecoder', 'TextEncoder', 'TextEvent', 'TextMetrics', 'TextTrack', 'TextTrackCue', 'TextTrackCueList', 'TextTrackList', 'TimeRanges', 'toolbar', 'top', 'Touch', 'TouchEvent', 'TouchList', 'TrackEvent', 'TransitionEvent', 'TreeWalker', 'UIEvent', 'URL', 'URLSearchParams', 'ValidityState', 'visualViewport', 'VisualViewport', 'VTTCue', 'WaveShaperNode', 'WebAssembly', 'WebGL2RenderingContext', 'WebGLActiveInfo', 'WebGLBuffer', 'WebGLContextEvent', 'WebGLFramebuffer', 'WebGLProgram', 'WebGLQuery', 'WebGLRenderbuffer', 'WebGLRenderingContext', 'WebGLSampler', 'WebGLShader', 'WebGLShaderPrecisionFormat', 'WebGLSync', 'WebGLTexture', 'WebGLTransformFeedback', 'WebGLUniformLocation', 'WebGLVertexArrayObject', 'WebSocket', 'WheelEvent', 'window', 'Window', 'Worker', 'WritableStream', 'XMLDocument', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload', 'XMLSerializer', 'XPathEvaluator', 'XPathExpression', 'XPathResult', 'XSLTProcessor'];

  const ___R$romejs$js$compiler$scope$globals_ts$worker = ['addEventListener', 'applicationCache', 'atob', 'Blob', 'BroadcastChannel', 'btoa', 'Cache', 'caches', 'clearInterval', 'clearTimeout', 'close', 'console', 'fetch', 'FileReaderSync', 'FormData', 'Headers', 'IDBCursor', 'IDBCursorWithValue', 'IDBDatabase', 'IDBFactory', 'IDBIndex', 'IDBKeyRange', 'IDBObjectStore', 'IDBOpenDBRequest', 'IDBRequest', 'IDBTransaction', 'IDBVersionChangeEvent', 'ImageData', 'importScripts', 'indexedDB', 'location', 'MessageChannel', 'MessagePort', 'name', 'navigator', 'Notification', 'onclose', 'onconnect', 'onerror', 'onlanguagechange', 'onmessage', 'onoffline', 'ononline', 'onrejectionhandled', 'onunhandledrejection', 'performance', 'Performance', 'PerformanceEntry', 'PerformanceMark', 'PerformanceMeasure', 'PerformanceNavigation', 'PerformanceResourceTiming', 'PerformanceTiming', 'postMessage', 'Promise', 'queueMicrotask', 'removeEventListener', 'Request', 'Response', 'self', 'ServiceWorkerRegistration', 'setInterval', 'setTimeout', 'TextDecoder', 'TextEncoder', 'URL', 'URLSearchParams', 'WebSocket', 'Worker', 'WorkerGlobalScope', 'XMLHttpRequest'];

  const ___R$romejs$js$compiler$scope$globals_ts$node = ['__dirname', '__filename', 'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout', 'console', 'exports', 'global', 'Intl', 'module', 'process', 'queueMicrotask', 'require', 'setImmediate', 'setInterval', 'setTimeout', 'TextDecoder', 'TextEncoder', 'URL', 'URLSearchParams'];

  const ___R$romejs$js$compiler$scope$globals_ts$commonjs = ['exports', 'global', 'module', 'require'];

  const ___R$romejs$js$compiler$scope$globals_ts$serviceworker = ['addEventListener', 'applicationCache', 'atob', 'Blob', 'BroadcastChannel', 'btoa', 'Cache', 'caches', 'CacheStorage', 'clearInterval', 'clearTimeout', 'Client', 'clients', 'Clients', 'close', 'console', 'ExtendableEvent', 'ExtendableMessageEvent', 'fetch', 'FetchEvent', 'FileReaderSync', 'FormData', 'Headers', 'IDBCursor', 'IDBCursorWithValue', 'IDBDatabase', 'IDBFactory', 'IDBIndex', 'IDBKeyRange', 'IDBObjectStore', 'IDBOpenDBRequest', 'IDBRequest', 'IDBTransaction', 'IDBVersionChangeEvent', 'ImageData', 'importScripts', 'indexedDB', 'location', 'MessageChannel', 'MessagePort', 'name', 'navigator', 'Notification', 'onclose', 'onconnect', 'onerror', 'onfetch', 'oninstall', 'onlanguagechange', 'onmessage', 'onmessageerror', 'onnotificationclick', 'onnotificationclose', 'onoffline', 'ononline', 'onpush', 'onpushsubscriptionchange', 'onrejectionhandled', 'onsync', 'onunhandledrejection', 'performance', 'Performance', 'PerformanceEntry', 'PerformanceMark', 'PerformanceMeasure', 'PerformanceNavigation', 'PerformanceResourceTiming', 'PerformanceTiming', 'postMessage', 'Promise', 'queueMicrotask', 'registration', 'removeEventListener', 'Request', 'Response', 'self', 'ServiceWorker', 'ServiceWorkerContainer', 'ServiceWorkerGlobalScope', 'ServiceWorkerMessageEvent', 'ServiceWorkerRegistration', 'setInterval', 'setTimeout', 'skipWaiting', 'TextDecoder', 'TextEncoder', 'URL', 'URLSearchParams', 'WebSocket', 'WindowClient', 'Worker', 'WorkerGlobalScope', 'XMLHttpRequest'];

  // romejs/js-compiler/scope/Scope.ts

  let ___R$$priv$romejs$js$compiler$scope$Scope_ts$scopeCounter = 0;

  Error.stackTraceLimit = Infinity;

  class ___R$romejs$js$compiler$scope$Scope_ts$default {
    constructor({
      kind: kind,
      node: node,
      parentScope: parentScope,
      rootScope: rootScope}) {
      this.parentScope = parentScope;
      this.rootScope = rootScope;
      this.node = node;
      this.kind = kind;
      this.bindings = new Map();
      this.id = ___R$$priv$romejs$js$compiler$scope$Scope_ts$scopeCounter++;
      this.hasHoistedVars = false;
      this.globals = new Set();

      this.childScopeCache = new WeakMap();
    }

    setHoistedVars() {
      this.hasHoistedVars = true;
    }

    hasBindings() {
      return this.bindings.size > 0;
    }

    getOwnBindings() {
      return this.bindings;
    }

    getOwnBindingNames() {
      return Array.from(this.bindings.keys());
    }

    findScope(kind) {
      let scope = this;
      while (scope !== undefined) {
        if (scope.kind === kind) {
          return scope;
        } else {
          scope = scope.parentScope;
        }
      }
    }

    getRootScope() {
      const {rootScope: rootScope} = this;
      if (rootScope === undefined) {
        throw new Error('Expected rootScope');
      }
      return rootScope;
    }

    evaluate(node, parent = ___R$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT, creatorOnly = false, force = false) {
      if (node === undefined) {
        return this;
      }

      if (!force && node === this.node) {
        return this;
      }
      const cached = this.childScopeCache.get(node);
      if (cached !== undefined) {
        return cached;
      }

      let evaluator = ___R$romejs$js$compiler$scope$evaluators$index_ts$default.get(node.type);

      if (!creatorOnly && evaluator !== undefined && evaluator.creator) {
        evaluator = undefined;
      }

      if (evaluator === undefined) {
        return this;
      }

      let scope = evaluator.build(node, parent, this);

      if (scope === undefined) {
        scope = this;
      }

      this.childScopeCache.set(node, scope);
      return scope;
    }

    fork(kind, node) {
      const rootScope = this.getRootScope();
      return new ___R$romejs$js$compiler$scope$Scope_ts$default({
        kind: kind,
        node: node,
        parentScope: this,
        rootScope: rootScope});
    }

    dump(root = true) {
      if (root) {
        console.log('START');
      }
      console.log('------', this.id, this.kind);
      for (const [name, binding] of this.bindings) {
        console.log(' ', binding.id, '-', binding.constructor.name, name);
      }
      if (this.parentScope !== undefined) {
        this.parentScope.dump(false);
      }
      if (root) {
        console.log('END');
      }
    }

    getOwnBinding(name) {
      return this.bindings.get(name);
    }

    getBinding(name) {
      const binding = this.getOwnBinding(name);
      if (binding !== undefined) {
        return binding;
      }

      const {parentScope: parentScope} = this;
      if (parentScope !== undefined) {
        return parentScope.getBinding(name);
      }

      return undefined;
    }

    getBindingAssert(name) {
      const binding = this.getBinding(name);
      if (binding === undefined) {
        this.dump();
        throw new Error('Expected ' + name + ' binding');
      }
      return binding;
    }

    addBinding(binding) {
      this.bindings.set(binding.name, binding);
      return binding;
    }

    hasBinding(name) {
      return this.getBinding(name) !== undefined;
    }

    generateUid(name) {
      return this.getRootScope().generateUid(name);
    }

    addGlobal(name) {
      this.globals.add(name);
    }

    isGlobal(name) {
      if (this.globals.has(name)) {
        return true;
      }

      if (this.parentScope !== undefined) {
        return this.parentScope.isGlobal(name);
      }

      return false;
    }
  }

  const ___R$$priv$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_START = /^([\s+]|)global /;
  const ___R$$priv$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON = /:(.*?)$/;

  class ___R$romejs$js$compiler$scope$Scope_ts$RootScope extends ___R$romejs$js$compiler$scope$Scope_ts$default {
    constructor(context, ast) {
      super({
        kind: 'root',
        parentScope: undefined,
        rootScope: undefined,
        node: undefined});
      this.uids = new Set();
      this.context = context;

      this.globals = new Set([...___R$romejs$js$compiler$scope$globals_ts.builtin, ...___R$romejs$js$compiler$scope$globals_ts.es5, ...___R$romejs$js$compiler$scope$globals_ts.es2015, ...___R$romejs$js$compiler$scope$globals_ts.es2017, ...___R$romejs$js$compiler$scope$globals_ts.browser, ...___R$romejs$js$compiler$scope$globals_ts.worker, ...___R$romejs$js$compiler$scope$globals_ts.node, ...___R$romejs$js$compiler$scope$globals_ts.commonjs, ...___R$romejs$js$compiler$scope$globals_ts.serviceworker, ...context.project.config.lint.globals, ...this.parseGlobalComments(ast)]);
    }

    parseGlobalComments(ast) {
      const globals = [];

      for (const {value: value} of ast.comments) {
        if (!___R$$priv$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_START.test(value)) {
          continue;
        }

        const clean = value.replace(___R$$priv$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_START, '');

        const parts = clean.split(',');

        for (const part of parts) {
          let name = part.trim();

          if (___R$$priv$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON.test(name)) {
            const match = part.match(___R$$priv$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON);
            if (match == null) {
              throw new Error('Used RegExp.test already so know this will always match');
            }

            name = name.replace(___R$$priv$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON, '');

            const value = match[1].trim();

            if (value === 'false') {
              break;
            }
          }

          globals.push(name);
        }
      }

      return globals;
    }

    getRootScope() {
      return this;
    }

    generateUid(name) {
      const prefixed = '' + ___R$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX + (name === undefined ? '' : name);

      if (name !== undefined && !___R$romejs$js$ast$utils$isValidIdentifierName_ts$default(name)) {
        throw new Error(name + ' is not a valid identifier name');
      }

      let counter = 0;

      while (true) {
        const suffix = counter === 0 ? '' : String(counter);
        const name = prefixed + suffix;

        if (this.uids.has(name)) {
          counter++;
        } else {
          this.uids.add(name);
          return name;
        }
      }

      throw new Error('Unreachable');
    }
  }

  // romejs/js-compiler/methods/reduce.ts

  const ___R$$priv$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT = 'BAIL';
  const ___R$$priv$romejs$js$compiler$methods$reduce_ts$KEEP_EXIT = 'KEEP';

  function ___R$$priv$romejs$js$compiler$methods$reduce_ts$validateTransformReturn(transformName, node, path) {
    if (node === ___R$romejs$js$compiler$constants_ts$REDUCE_REMOVE) {
      return;
    }

    if (typeof node === 'symbol') {
      throw new Error('Returned a symbol from transform ' + transformName + ' that doesn\'t correspond to any reduce constant');
    }

    if (typeof node === 'undefined') {
      throw new Error('Returned `undefined` from transform ' +
      transformName +
      '. If you meant to delete this node then use `return' +
      ' REDUCE_REMOVE`, otherwise if you want to keep it then use `return path.node;`');
    }

    if (Array.isArray(node)) {
      if (path.opts.noArrays === true) {
        throw new Error('Cannot replace this keyed node ' + path.parent.type + '[' + path.opts.nodeKey + '] with an array of nodes - originated from transform ' + transformName);
      }
      return;
    }

    if (!___R$romejs$js$ast$utils$isNodeLike_ts$default(node)) {
      throw new Error('Expected a return value of a plain object with a `type` property or a reduce constant - originated from \'transform ' + transformName);
    }
  }

  function ___R$$priv$romejs$js$compiler$methods$reduce_ts$shouldBailReduce(node) {
    if (Array.isArray(node)) {
      return true;
    }

    if (node === ___R$romejs$js$compiler$constants_ts$REDUCE_REMOVE) {
      return true;
    }

    return false;
  }

  function ___R$$priv$romejs$js$compiler$methods$reduce_ts$runExit(path, name, callback, state) {
    let transformedNode = callback(path, state);

    ___R$$priv$romejs$js$compiler$methods$reduce_ts$validateTransformReturn(name, transformedNode, path);

    if (___R$$priv$romejs$js$compiler$methods$reduce_ts$shouldBailReduce(transformedNode)) {
      return [___R$$priv$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT, transformedNode];
    }

    if (transformedNode !== path.node) {
      path = path.fork(transformedNode);
    }

    return [___R$$priv$romejs$js$compiler$methods$reduce_ts$KEEP_EXIT, path];
  }

  function ___R$romejs$js$compiler$methods$reduce_ts$default(origNode, visitors, context, pathOpts = {}) {
    let path = new ___R$romejs$js$compiler$lib$Path_ts$default(origNode, context, pathOpts);

    for (const visitor of visitors) {
      const {enter: enter} = visitor;
      if (enter === undefined) {
        continue;
      }

      let transformedNode = enter(path);

      if (transformedNode === ___R$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE) {
        return origNode;
      }

      ___R$$priv$romejs$js$compiler$methods$reduce_ts$validateTransformReturn(visitor.name, transformedNode, path);

      if (___R$$priv$romejs$js$compiler$methods$reduce_ts$shouldBailReduce(transformedNode)) {
        return transformedNode;
      }

      if (transformedNode !== path.node) {
        path = path.fork(transformedNode);
      }
    }

    let {node: node} = path;
    const visitorKeys = ___R$romejs$js$ast$utils_ts$visitorKeys.get(node.type);
    if (visitorKeys !== undefined) {
      const ancestryPaths = pathOpts.ancestryPaths || [];
      let childAncestryPaths = [path].concat(ancestryPaths);

      for (const key of visitorKeys) {
        const oldVal = node[key];

        if (Array.isArray(oldVal)) {
          let children = oldVal;

          let childrenOffset = 0;

          let length = children.length;

          for (let i = 0; i < length; i++) {
            const correctedIndex = childrenOffset + i;

            const child = children[correctedIndex];

            if (___R$romejs$js$ast$utils$isNodeLike_ts$default(child)) {
              const newChild = ___R$romejs$js$compiler$methods$reduce_ts$default(child, visitors, context, {
                noScopeCreation: pathOpts.noScopeCreation,
                parentScope: path.scope,
                ancestryPaths: childAncestryPaths,
                listKey: correctedIndex,
                nodeKey: key});

              if (newChild !== child) {
                children = children.slice();

                if (newChild === ___R$romejs$js$compiler$constants_ts$REDUCE_REMOVE ||
                Array.isArray(newChild) && newChild.length === 0) {
                  children.splice(correctedIndex, 1);

                  childrenOffset--;
                } else if (Array.isArray(newChild)) {
                  var ___R$;
                  ___R$ = children, ___R$.splice.apply(___R$, [correctedIndex, 1, ...newChild]);

                  length += newChild.length;

                  i--;
                } else {
                  children[correctedIndex] = newChild;

                  i--;
                }

                node = Object.assign({}, node, {
                  [key]: children});

                path = path.fork(node);

                childAncestryPaths = [path].concat(ancestryPaths);
              }
            }
          }
        } else if (___R$romejs$js$ast$utils$isNodeLike_ts$default(oldVal)) {
          let newVal = ___R$romejs$js$compiler$methods$reduce_ts$default(
          oldVal,
          visitors,
          context,
          {
            noScopeCreation: pathOpts.noScopeCreation,
            parentScope: path.scope,
            ancestryPaths: childAncestryPaths,
            noArrays: true,
            nodeKey: key});

          if (newVal !== oldVal) {
            if (Array.isArray(newVal)) {
              throw new Error('Cannot replace a key value node with an array of nodes');
            }

            if (newVal === ___R$romejs$js$compiler$constants_ts$REDUCE_REMOVE) {
              newVal = undefined;
            }

            node = Object.assign({}, node, {
              [key]: newVal});

            path = path.fork(node);

            childAncestryPaths = [path].concat(ancestryPaths);
          }
        } else {
          continue;
        }
      }
    }

    for (const ref of path.hooks) {
      const {exit: exit} = ref.descriptor;
      if (exit === undefined) {
        continue;
      }

      const res = ___R$$priv$romejs$js$compiler$methods$reduce_ts$runExit(path, ref.descriptor.name, exit, ref.state);
      if (res[0] === ___R$$priv$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT) {
        return res[1];
      } else {
        path = res[1];
      }
    }

    for (const visitor of visitors) {
      if (visitor.exit !== undefined) {
        const res = ___R$$priv$romejs$js$compiler$methods$reduce_ts$runExit(path, visitor.name, visitor.exit, undefined);
        if (res[0] === ___R$$priv$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT) {
          return res[1];
        } else {
          path = res[1];
        }
      }
    }

    return path.node;
  }

  // romejs/js-compiler/lib/Context.ts


  class ___R$romejs$js$compiler$lib$Context_ts$default {
    constructor(arg) {
      const {ast: ast, project: project, options: options = {}, origin: origin} = arg;

      this.diagnostics = [];
      this.records = [];

      this.path = ___R$romejs$path$index_ts$createUnknownFilePath(ast.filename);
      this.filename = ast.filename;

      this.mtime = ast.mtime;
      this.project = project;
      this.options = options;
      this.origin = origin;
      this.cacheDependencies = new Set();
      this.sourceType = ast.sourceType;
      this.rootScope = new ___R$romejs$js$compiler$scope$Scope_ts$RootScope(this, ast);
    }

    async normalizeTransforms(transforms) {
      return Promise.all(
      transforms.map(async visitor => {
        if (typeof visitor === 'function') {
          return await visitor(this);
        } else {
          return visitor;
        }
      }));
    }

    getRootScope() {
      const {rootScope: rootScope} = this;
      if (rootScope === undefined) {
        throw new Error('Expected root scope');
      }
      return rootScope;
    }

    getCacheDependencies() {
      return Array.from(this.cacheDependencies);
    }

    addCacheDependency(filename) {
      this.cacheDependencies.add(filename);
    }

    reduce(ast, visitors, pathOpts) {
      return ___R$romejs$js$compiler$methods$reduce_ts$default(ast, visitors, this, pathOpts);
    }

    record(record) {
      this.records.push(record);
    }

    addDiagnostics(diagnostics) {
      this.diagnostics = [...this.diagnostics, ...diagnostics];
    }

    addLocDiagnostic(loc, diag) {
      let origins = [];
      if (this.origin !== undefined) {
        origins.push(this.origin);
      }
      if (diag.origins !== undefined) {
        origins = origins.concat(diag.origins);
      }

      if (loc !== undefined && loc.filename !== this.filename) {
        throw new Error('Trying to add a location from ' + loc.filename + ' on a Context from ' + this.path);
      }

      this.diagnostics.push(Object.assign({}, diag, {
        mtime: this.mtime,
        filename: this.filename,
        start: loc === undefined ? diag.start : loc.start,
        end: loc === undefined ? diag.end : loc.end,
        language: 'js',
        sourceType: this.sourceType,
        origins: origins}));
    }

    addNodeDiagnostic(node, diag) {
      return this.addLocDiagnostic(
      node === undefined ? undefined : node.loc,
      diag);
    }
  }

  // romejs/js-compiler/lib/Path.ts


  class ___R$romejs$js$compiler$lib$Path_ts$default {
    constructor(node, context, opts) {
      const ancestryPaths = opts.ancestryPaths || [];
      this.ancestryPaths = ancestryPaths;

      if (node === ___R$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT) {
        this.parentPath = this;
      } else if (ancestryPaths.length === 0) {
        this.parentPath = new ___R$romejs$js$compiler$lib$Path_ts$default(___R$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT, context, {
          isMock: true});
      } else {
        this.parentPath = ancestryPaths[0];
      }

      this.node = node;
      this.parent = this.parentPath.node;
      this.context = context;

      const parentScope = opts.parentScope === undefined ? context.getRootScope() : opts.parentScope;

      let scope = opts.scope;
      if (scope === undefined) {
        if (opts.noScopeCreation === true) {
          scope = parentScope;
        } else {
          scope = parentScope.evaluate(node, this.parent, true);
        }
      }
      this.scope = scope;

      this.nodeKey = opts.nodeKey;
      this.listKey = opts.listKey;

      this.isMock = opts.isMock === true;
      this.opts = opts;

      this.hooks = opts.hooks === undefined ? [] : opts.hooks;
    }

    callHook(descriptor, arg, optionalRet) {
      const ref = this.findHook(descriptor);
      if (ref === undefined) {
        if (optionalRet === undefined) {
          throw new Error('No hook found');
        } else {
          return optionalRet;
        }
      }
      if (descriptor.call === undefined) {
        throw new Error('Hook doesn\'t have a call method');
      }

      const {state: state, value: value} = descriptor.call(this, ref.state, arg);
      ref.state = state;
      return value;
    }

    provideHook(descriptor, state) {
      this.hooks.push({
        state: Object.assign({}, descriptor.initialState, state),
        descriptor: descriptor});

      return this.node;
    }

    findHook(descriptor) {
      for (const {hooks: hooks} of this.ancestryPaths) {
        for (const hook of hooks) {
          if (hook.descriptor === descriptor) {
            return hook;
          }
        }
      }
    }

    findAncestry(callback) {
      for (const path of this.ancestryPaths) {
        if (callback(path)) {
          return path;
        }
      }
    }

    getChildPath(key) {
      const node = this.node[key];
      if (node === undefined) {
        throw new Error('Attempted to get child path for ' + key + ' but no such node existed');
      }

      return new ___R$romejs$js$compiler$lib$Path_ts$default(node, this.context, {
        parentScope: this.scope,
        ancestryPaths: this.ancestryPaths.concat([this]),
        nodeKey: key});
    }

    getChildPaths(key) {
      const nodes = this.node[key];

      if (nodes === undefined) {
        throw new Error('Attempted to get child paths for ' + key + ' but no such node existed');
      }

      if (!Array.isArray(nodes)) {
        throw new Error('Expected child nodes for ' + key + ' to be an array');
      }

      const ancestryPaths = this.ancestryPaths.concat([this]);

      return nodes.map((node, i) => {
        return new ___R$romejs$js$compiler$lib$Path_ts$default(node, this.context, {
          parentScope: this.scope,
          ancestryPaths: ancestryPaths,
          listKey: i,
          nodeKey: key});
      });
    }

    getPathKeys() {
      const parts = [];

      let path = this;
      while (path !== undefined && !path.isMock) {
        if (path.listKey !== undefined) {
          parts.push(String(path.listKey));
        }
        if (path.nodeKey !== undefined) {
          parts.push(path.nodeKey);
        }
        path = path.parentPath;
      }

      return parts.reverse();
    }

    fork(newNode) {
      return new ___R$romejs$js$compiler$lib$Path_ts$default(newNode, this.context, this.getPathOptions());
    }

    getPathOptions() {
      return Object.assign({}, this.opts, {
        hooks: this.hooks,
        parentScope: this.scope === undefined ? undefined : this.scope.parentScope});
    }

    traverse(name, callback) {
      this.reduce({
        name: name,
        enter(path) {
          callback(path);
          return path.node;
        }});
    }

    reduce(visitors, opts) {
      return ___R$romejs$js$compiler$methods$reduce_ts$default(
      this.node,
      Array.isArray(visitors) ? visitors : [visitors],
      this.context,
      Object.assign({}, this.getPathOptions(), opts));
    }

    addDiagnostic(opts) {
      return this.context.addNodeDiagnostic(this.node, opts);
    }
  }

  // romejs/js-compiler/lib/Record.ts

  class ___R$romejs$js$compiler$lib$Record_ts$default {}

  // romejs/js-compiler/lib/Cache.ts


  let ___R$$priv$romejs$js$compiler$lib$Cache_ts$projectIdCounter = 0;
  const ___R$$priv$romejs$js$compiler$lib$Cache_ts$projectToId = new WeakMap();

  class ___R$romejs$js$compiler$lib$Cache_ts$default {
    constructor() {
      this.cache = new WeakMap();
    }

    static buildQuery(req, options) {
      const {ast: ast, project: project} = req;
      const keyParts = [];

      let projectId = ___R$$priv$romejs$js$compiler$lib$Cache_ts$projectToId.get(project);
      if (projectId === undefined) {
        projectId = ___R$$priv$romejs$js$compiler$lib$Cache_ts$projectIdCounter++;
        ___R$$priv$romejs$js$compiler$lib$Cache_ts$projectToId.set(project, projectId);
      }

      keyParts.push(String(projectId));

      if (options !== undefined && Object.keys(options).length > 0) {
        keyParts.push(JSON.stringify(options));
      }

      return {
        ast: ast,
        key: keyParts.join(';')};
    }

    get(query) {
      const astCache = this.cache.get(query.ast);
      if (astCache) {
        return astCache.get(query.key);
      }
    }

    set(query, value) {
      let astCache = this.cache.get(query.ast);
      if (astCache === undefined) {
        astCache = new Map();
        this.cache.set(query.ast, astCache);
      }
      astCache.set(query.key, value);
    }
  }

  // romejs/js-compiler/plugins/lint/undeclaredVariables.ts

  const ___R$$priv$romejs$js$compiler$plugins$lint$undeclaredVariables_ts$NODE_VARIABLES = ['require', '__dirname', '__filename', 'module', 'exports', 'babelHelpers'];

  const ___R$$priv$romejs$js$compiler$plugins$lint$undeclaredVariables_ts$BROWSER_VARIABLES = ['fetch', 'document', 'window', 'Worker', 'cancelAnimationFrame', 'requestAnimationFrame', 'WebSocket', 'alert', 'Blob', 'navigator', 'Element', 'Text', 'Document', 'performance'];
  const ___R$romejs$js$compiler$plugins$lint$undeclaredVariables_ts$default = {
    name: 'undeclaredVariables',
    enter(path) {
      const {node: node, scope: scope} = path;

      if ((node.type === 'ReferenceIdentifier' ||
      node.type === 'JSXReferenceIdentifier') &&
      !___R$romejs$js$ast$utils$isInTypeAnnotation_ts$default(path)) {
        const {name: name} = node;
        const binding = scope.getBinding(name);

        const isDefined = binding !== undefined ||
        scope.getRootScope().isGlobal(name) ||
        name in global ||
        ___R$$priv$romejs$js$compiler$plugins$lint$undeclaredVariables_ts$BROWSER_VARIABLES.includes(name) ||
        ___R$$priv$romejs$js$compiler$plugins$lint$undeclaredVariables_ts$NODE_VARIABLES.includes(name);

        if (!isDefined) {
          path.context.addNodeDiagnostic(node, {
            category: 'lint/undeclaredVariables',
            message: ___R$romejs$string$markup$escape_ts$markup`Undeclared variable <emphasis>${name}</emphasis>`});
        }
      }

      return node;
    }};

  // romejs/js-compiler/plugins/lint/index.ts

  const ___R$romejs$js$compiler$plugins$lint$index_ts$lintTransforms = [___R$romejs$js$compiler$plugins$lint$undeclaredVariables_ts$default];

  // romejs/js-generator/generators/temp/AmbiguousFlowTypeCastExpression.ts

  function ___R$romejs$js$generator$generators$temp$AmbiguousFlowTypeCastExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/types/AnyKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$AnyKeywordTypeAnnotation_ts$default(generator) {
    generator.word('any');
  }

  // romejs/js-generator/generators/expressions/ArrayExpression.ts

  function ___R$romejs$js$generator$generators$expressions$ArrayExpression_ts$default(generator, node) {
    node =
    node.type === 'BindingArrayPattern' ||
    node.type === 'AssignmentArrayPattern' ? node : ___R$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression.assert(node);

    const elems = node.elements;
    const len = elems.length;

    generator.token('[');
    generator.printInnerComments(node);

    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];
      if (elem) {
        if (i > 0) {
          generator.space();
        }
        generator.print(elem, node);
        if (i < len - 1) {
          generator.token(',');
        }
      } else {
        generator.token(',');
      }
    }

    if ((node.type === 'BindingArrayPattern' ||
    node.type === 'AssignmentArrayPattern') &&
    node.rest !== undefined) {
      if (elems.length > 0) {
        generator.token(',');
        generator.space();
      }

      generator.token('...');
      generator.print(node.rest, node);
    }

    generator.token(']');
  }

  // romejs/js-generator/generators/expressions/ArrowFunctionExpression.ts

  function ___R$romejs$js$generator$generators$expressions$ArrowFunctionExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression.assert(node);

    if (node.head.async === true) {
      generator.word('async');
      generator.space();
    }

    const firstParam = node.head.params[0];

    if (node.head.params.length === 1 &&
    firstParam !== undefined &&
    firstParam.type === 'BindingIdentifier' &&
    node.head.rest === undefined &&
    !___R$$priv$romejs$js$generator$generators$expressions$ArrowFunctionExpression_ts$hasTypes(generator, node, firstParam)) {
      generator.print(firstParam, node);
    } else {
      generator.print(node.head, node);
    }

    generator.space();
    generator.token('=>');
    generator.space();

    generator.print(node.body, node);
  }

  function ___R$$priv$romejs$js$generator$generators$expressions$ArrowFunctionExpression_ts$hasTypes(generator, node, param) {
    if (generator.options.typeAnnotations) {
      if (node.head.typeParameters !== undefined ||
      node.head.returnType !== undefined) {
        return true;
      }

      if (param.meta !== undefined) {
        if (param.meta.typeAnnotation !== undefined ||
        param.meta.optional === true) {
          return true;
        }
      }

      return param.trailingComments !== undefined && param.trailingComments.length > 0;
    } else {
      return false;
    }
  }

  // romejs/js-generator/generators/patterns/AssignmentArrayPattern.ts

  function ___R$romejs$js$generator$generators$patterns$AssignmentArrayPattern_ts$default(generator, node) {
    node = ___R$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern.assert(node);

    ___R$romejs$js$generator$generators$expressions$ArrayExpression_ts$default(generator, node);
  }

  // romejs/js-generator/generators/patterns/AssignmentAssignmentPattern.ts

  function ___R$romejs$js$generator$generators$patterns$AssignmentAssignmentPattern_ts$default(generator, node) {
    node = ___R$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/node/parentheses.ts

  const ___R$$priv$romejs$js$generator$node$parentheses_ts$PRECEDENCE = {
    '||': 0,
    '&&': 1,
    '??': 1,
    '|': 2,
    '^': 3,
    '&': 4,
    '==': 5,
    '===': 5,
    '!=': 5,
    '!==': 5,
    '<': 6,
    '>': 6,
    '<=': 6,
    '>=': 6,
    in: 6,
    instanceof: 6,
    '>>': 7,
    '<<': 7,
    '>>>': 7,
    '+': 8,
    '-': 8,
    '*': 9,
    '/': 9,
    '%': 9,
    '**': 10};

  const ___R$$priv$romejs$js$generator$node$parentheses_ts$parens = new Map();
  const ___R$romejs$js$generator$node$parentheses_ts$default = ___R$$priv$romejs$js$generator$node$parentheses_ts$parens;
  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set(
  'FlowNullableTypeAnnotation',
  (node, parent) => {
    return parent.type === 'FlowArrayTypeAnnotation';
  });

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('UpdateExpression', function UpdateExpression(node, parent) {
    return parent.type === 'MemberExpression' && parent.object === node;
  });

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('ObjectExpression', function ObjectExpression(node, parent, printStack) {
    return ___R$$priv$romejs$js$generator$node$parentheses_ts$isFirstInStatement(printStack, true, false);
  });

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('DoExpression', function DoExpression(node, parent, printStack) {
    return ___R$$priv$romejs$js$generator$node$parentheses_ts$isFirstInStatement(printStack, false, false);
  });

  function ___R$romejs$js$ast$index_ts$LogicalExpression(node, parent) {
    if (node.operator === '**' &&
    parent.type === 'BinaryExpression' &&
    parent.operator === '**') {
      return parent.left === node;
    }

    if ((parent.type === 'CallExpression' || parent.type === 'NewExpression') &&
    parent.callee === node ||
    ___R$romejs$js$ast$utils$isUnaryLike_ts$default(parent) ||
    parent.type === 'MemberExpression' && parent.object === node ||
    parent.type === 'AwaitExpression') {
      return true;
    }

    if (___R$romejs$js$ast$utils$isBinary_ts$default(parent)) {
      const parentOp = parent.operator;

      const parentPos = ___R$$priv$romejs$js$generator$node$parentheses_ts$PRECEDENCE[parentOp];

      const nodeOp = node.operator;
      const nodePos = ___R$$priv$romejs$js$generator$node$parentheses_ts$PRECEDENCE[nodeOp];

      if (parentPos === nodePos &&
      parent.right === node &&
      parent.type !== 'LogicalExpression' ||
      parentPos > nodePos) {
        return true;
      }
    }

    return false;
  }

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('LogicalExpression', ___R$romejs$js$ast$index_ts$LogicalExpression);

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('BinaryExpression', function BinaryExpression(node, parent) {
    return node.operator === 'in' &&
    (parent.type === 'VariableDeclarator' || ___R$romejs$js$ast$utils$isFor_ts$default(parent)) ||
    ___R$romejs$js$ast$index_ts$LogicalExpression(node, parent);
  });

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('SequenceExpression', function SequenceExpression(node, parent) {
    if (parent.type === 'ForStatement' ||
    parent.type === 'ThrowStatement' ||
    parent.type === 'ReturnStatement' ||
    parent.type === 'IfStatement' && parent.test === node ||
    parent.type === 'WhileStatement' && parent.test === node ||
    parent.type === 'ForInStatement' && parent.right === node ||
    parent.type === 'SwitchStatement' && parent.discriminant === node ||
    parent.type === 'ExpressionStatement' && parent.expression === node) {
      return false;
    }

    return true;
  });

  function ___R$romejs$js$ast$index_ts$YieldExpression(node, parent) {
    return ___R$romejs$js$ast$utils$isBinary_ts$default(parent) ||
    ___R$romejs$js$ast$utils$isUnaryLike_ts$default(parent) ||
    parent.type === 'CallExpression' ||
    parent.type === 'MemberExpression' ||
    parent.type === 'NewExpression' ||
    parent.type === 'ConditionalExpression' && node === parent.test;
  }

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('YieldExpression', ___R$romejs$js$ast$index_ts$YieldExpression);
  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('AwaitExpression', ___R$romejs$js$ast$index_ts$YieldExpression);

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('ClassExpression', function ClassExpression(node, parent, printStack) {
    return ___R$$priv$romejs$js$generator$node$parentheses_ts$isFirstInStatement(printStack, false, true);
  });

  function ___R$romejs$js$ast$index_ts$UnaryExpression(node, parent) {
    return parent.type === 'MemberExpression' && parent.object === node ||
    parent.type === 'CallExpression' && parent.callee === node ||
    parent.type === 'NewExpression' && parent.callee === node ||
    parent.type === 'BinaryExpression' &&
    parent.operator === '**' &&
    parent.left === node;
  }

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('UnaryExpression', ___R$romejs$js$ast$index_ts$UnaryExpression);
  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('SpreadElement', ___R$romejs$js$ast$index_ts$UnaryExpression);
  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('BindingObjectPatternRestProperty', ___R$romejs$js$ast$index_ts$UnaryExpression);
  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('SpreadProperty', ___R$romejs$js$ast$index_ts$UnaryExpression);

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('FunctionExpression', function FunctionExpression(node, parent, printStack) {
    return ___R$$priv$romejs$js$generator$node$parentheses_ts$isFirstInStatement(printStack, false, true);
  });

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('ArrowFunctionExpression', function ArrowFunctionExpression(node, parent) {
    return parent.type === 'ExportNamedDeclaration' ||
    ___R$romejs$js$ast$index_ts$ConditionalExpression(node, parent);
  });

  function ___R$romejs$js$ast$index_ts$ConditionalExpression(node, parent) {
    if (___R$romejs$js$ast$utils$isUnaryLike_ts$default(parent) ||
    ___R$romejs$js$ast$utils$isBinary_ts$default(parent) ||
    parent.type === 'ConditionalExpression' && parent.test === node ||
    parent.type === 'AwaitExpression' ||
    parent.type === 'TaggedTemplateExpression') {
      return true;
    }

    return ___R$romejs$js$ast$index_ts$UnaryExpression(node, parent);
  }

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('ConditionalExpression', ___R$romejs$js$ast$index_ts$ConditionalExpression);

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('AssignmentExpression', function AssignmentExpression(node, parent) {
    if (node.left.type === 'AssignmentObjectPattern') {
      return true;
    } else {
      return ___R$romejs$js$ast$index_ts$ConditionalExpression(node, parent);
    }
  });

  function ___R$romejs$js$ast$index_ts$UnionTypeAnnotation(node, parent) {
    return parent.type === 'FlowArrayTypeAnnotation' ||
    parent.type === 'FlowNullableTypeAnnotation' ||
    parent.type === 'IntersectionTypeAnnotation' ||
    parent.type === 'UnionTypeAnnotation';
  }

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('UnionTypeAnnotation', ___R$romejs$js$ast$index_ts$UnionTypeAnnotation);
  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('IntersectionTypeAnnotation', ___R$romejs$js$ast$index_ts$UnionTypeAnnotation);

  ___R$$priv$romejs$js$generator$node$parentheses_ts$parens.set('FlowFunctionTypeAnnotation', function FlowFunctionTypeAnnotation(node, parent, printStack) {
    for (const printNode of printStack) {
      if (printNode.type === 'ArrowFunctionExpression' &&
      printNode.head.returnType === node) {
        return true;
      }
    }

    if (node.returnType !== undefined &&
    node.returnType.type === 'FlowFunctionTypeAnnotation') {
      return true;
    }

    return parent.type === 'UnionTypeAnnotation' ||
    parent.type === 'IntersectionTypeAnnotation' ||
    parent.type === 'FlowArrayTypeAnnotation';
  });

  function ___R$$priv$romejs$js$generator$node$parentheses_ts$isFirstInStatement(printStack, considerArrow, considerDefaultExports) {
    let i = printStack.length - 1;
    let node = printStack[i];
    i--;
    let parent = printStack[i];
    while (i > 0) {
      if (parent.type === 'ExpressionStatement' && parent.expression === node ||
      parent.type === 'TaggedTemplateExpression' ||
      considerDefaultExports &&
      parent.type === 'ExportDefaultDeclaration' &&
      parent.declaration === node ||
      considerArrow &&
      parent.type === 'ArrowFunctionExpression' && parent.body === node) {
        return true;
      }

      if (parent.type === 'CallExpression' && parent.callee === node ||
      parent.type === 'SequenceExpression' &&
      parent.expressions[0] === node ||
      parent.type === 'MemberExpression' && parent.object === node ||
      ___R$romejs$js$ast$utils$isConditional_ts$default(parent) && parent.test === node ||
      ___R$romejs$js$ast$utils$isBinary_ts$default(parent) && parent.left === node ||
      parent.type === 'AssignmentExpression' && parent.left === node) {
        node = parent;
        i--;
        parent = printStack[i];
      } else {
        return false;
      }
    }

    return false;
  }

  // romejs/js-generator/node/index.ts

  const ___R$romejs$js$generator$node$index_ts = {
    hasExtraLineBetween: ___R$romejs$js$generator$node$index_ts$hasExtraLineBetween,
    getLinesBetween: ___R$romejs$js$generator$node$index_ts$getLinesBetween,
    isMultiLine: ___R$romejs$js$generator$node$index_ts$isMultiLine,
    needsParens: ___R$romejs$js$generator$node$index_ts$needsParens};
  function ___R$$priv$romejs$js$generator$node$index_ts$isOrHasCallExpression(node) {
    if (node.type === 'CallExpression') {
      return true;
    }

    if (node.type === 'ComputedMemberProperty') {
      return ___R$$priv$romejs$js$generator$node$index_ts$isOrHasCallExpression(node.value);
    }

    if (node.type === 'MemberExpression') {
      return ___R$$priv$romejs$js$generator$node$index_ts$isOrHasCallExpression(node.object) || ___R$$priv$romejs$js$generator$node$index_ts$isOrHasCallExpression(node.property);
    }

    return false;
  }

  function ___R$romejs$js$generator$node$index_ts$hasExtraLineBetween(a, b) {
    return ___R$romejs$js$generator$node$index_ts$getLinesBetween(a, b) > 1;
  }

  function ___R$romejs$js$generator$node$index_ts$getLinesBetween(a, b) {
    return a && b && a.loc && b.loc ? Math.max(0, ___R$romejs$ob1$index_ts$get1(b.loc.start.line) - ___R$romejs$ob1$index_ts$get1(a.loc.end.line)) : 0;
  }

  function ___R$romejs$js$generator$node$index_ts$isMultiLine(node) {
    return Boolean(
    node && node.loc ? node.loc.end.line > node.loc.start.line : true);
  }

  function ___R$romejs$js$generator$node$index_ts$needsParens(node, parent, printStack) {
    if (!parent) {
      return false;
    }

    if (parent.type === 'NewExpression' && parent.callee === node) {
      if (___R$$priv$romejs$js$generator$node$index_ts$isOrHasCallExpression(node)) {
        return true;
      }
    }

    const fn = ___R$romejs$js$generator$node$parentheses_ts$default.get(node.type);
    return fn ? fn(node, parent, printStack) : undefined;
  }

  // romejs/js-generator/generators/expressions/AssignmentExpression.ts

  function ___R$romejs$js$generator$generators$expressions$AssignmentExpression_ts$default(generator, node, parent) {
    node =
    node.type === 'BinaryExpression' || node.type === 'LogicalExpression' ? node : ___R$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.assert(node);

    const parens = generator.inForStatementInitCounter > 0 &&
    node.operator === 'in' &&
    !___R$romejs$js$generator$node$index_ts.needsParens(node, parent, []);
    const {left: left, right: right} = node;

    if (parens) {
      generator.token('(');
    }

    generator.print(left, node);

    generator.space();
    if (node.operator === 'in' || node.operator === 'instanceof') {
      generator.word(node.operator);
    } else {
      generator.token(node.operator);
    }
    generator.space();

    const isMultiLine = left.loc !== undefined &&
    right.loc !== undefined &&
    right.loc.start.line > left.loc.end.line;
    if (isMultiLine) {
      generator.newline();
    }

    generator.print(right, node);

    if (parens) {
      generator.token(')');
    }
  }

  // romejs/js-generator/generators/auxiliary/Identifier.ts

  function ___R$romejs$js$generator$generators$auxiliary$Identifier_ts$default(generator, node) {
    node =
    node.type === 'ReferenceIdentifier' ||
    node.type === 'BindingIdentifier' ||
    node.type === 'AssignmentIdentifier' ? node : ___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.assert(node);

    generator.word(node.name);
  }

  // romejs/js-generator/generators/patterns/AssignmentIdentifier.ts

  function ___R$romejs$js$generator$generators$patterns$AssignmentIdentifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.assert(node);

    ___R$romejs$js$generator$generators$auxiliary$Identifier_ts$default(generator, node);
  }

  // romejs/js-generator/generators/objects/ObjectExpression.ts

  function ___R$romejs$js$generator$generators$objects$ObjectExpression_ts$default(generator, node) {
    node =
    node.type === 'BindingObjectPattern' ||
    node.type === 'AssignmentObjectPattern' ? node : ___R$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.assert(node);

    const props = node.properties;

    generator.token('{');
    generator.printInnerComments(node);

    if (props.length > 0) {
      generator.printCommaList(props, node, {
        indent: true,
        statement: ___R$romejs$js$generator$node$index_ts$isMultiLine(node)});
    }

    if ((node.type === 'BindingObjectPattern' ||
    node.type === 'AssignmentObjectPattern') &&
    node.rest !== undefined) {
      if (props.length > 0) {
        generator.token(',');
        generator.space();
      }

      generator.token('...');
      generator.print(node.rest, node);
    }

    generator.token('}');
  }

  // romejs/js-generator/generators/patterns/AssignmentObjectPattern.ts

  function ___R$romejs$js$generator$generators$patterns$AssignmentObjectPattern_ts$default(generator, node) {
    node = ___R$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern.assert(node);

    ___R$romejs$js$generator$generators$objects$ObjectExpression_ts$default(generator, node);
  }

  // romejs/js-generator/generators/patterns/BindingObjectPatternProperty.ts

  function ___R$romejs$js$generator$generators$patterns$BindingObjectPatternProperty_ts$default(generator, node) {
    node =
    node.type === 'AssignmentObjectPatternProperty' ? node : ___R$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty.assert(node);

    generator.print(node.key, node);
    generator.token(':');
    generator.space();
    generator.print(node.value, node);
  }

  // romejs/js-generator/generators/patterns/AssignmentObjectPatternProperty.ts

  function ___R$romejs$js$generator$generators$patterns$AssignmentObjectPatternProperty_ts$default(generator, node) {
    node = ___R$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty.assert(node);

    ___R$romejs$js$generator$generators$patterns$BindingObjectPatternProperty_ts$default(generator, node);
  }

  // romejs/js-generator/generators/utils.ts

  function ___R$romejs$js$generator$generators$utils_ts$buildForXStatementGenerator(op) {
    return function(generator, node) {
      node = node.type === 'ForInStatement' ? node : ___R$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement.assert(node);

      generator.word('for');
      generator.space();
      if (op === 'of' && node.type === 'ForOfStatement' && node.await === true) {
        generator.word('await');
        generator.space();
      }
      generator.token('(');
      generator.print(node.left, node);
      generator.space();
      generator.word(op);
      generator.space();
      generator.print(node.right, node);
      generator.token(')');
      generator.printBlock(node);
    };
  }

  function ___R$romejs$js$generator$generators$utils_ts$buildYieldAwaitGenerator(keyword) {
    return function(generator, node) {
      node =
      node.type === 'YieldExpression' ? node : ___R$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression.assert(node);

      generator.word(keyword);

      if (node.type === 'YieldExpression' && node.delegate === true) {
        generator.token('*');
      }

      if (node.argument) {
        generator.space();
        const terminatorState = generator.startTerminatorless();
        generator.print(node.argument, node);
        generator.endTerminatorless(terminatorState);
      }
    };
  }

  function ___R$romejs$js$generator$generators$utils_ts$buildLabelStatementGenerator(prefix) {
    return function(generator, node) {
      node =
      node.type === 'ContinueStatement' ||
      node.type === 'ReturnStatement' ||
      node.type === 'BreakStatement' ? node : ___R$romejs$js$ast$statements$ThrowStatement_ts$throwStatement.assert(node);

      generator.word(prefix);

      let arg;
      if ((node.type === 'ContinueStatement' || node.type === 'BreakStatement') &&
      node.label !== undefined) {
        arg = node.label;
      }
      if ((node.type === 'ThrowStatement' || node.type === 'ReturnStatement') &&
      node.argument !== undefined) {
        arg = node.argument;
      }

      if (arg !== undefined) {
        generator.space();

        const terminatorState = generator.startTerminatorless();
        generator.print(arg, node);
        generator.endTerminatorless(terminatorState);
      }

      generator.semicolon();
    };
  }

  function ___R$romejs$js$generator$generators$utils_ts$printMethod(generator, node) {
    node = node.type === 'ClassMethod' ? node : ___R$romejs$js$ast$objects$ObjectMethod_ts$objectMethod.assert(node);

    const kind = node.kind;

    if (kind === 'method' && node.head.generator === true) {
      generator.token('*');
    }

    if (kind === 'get' || kind === 'set') {
      generator.word(kind);
      generator.space();
    }

    if (node.head.async === true) {
      generator.word('async');
      generator.space();
    }

    generator.print(node.key, node);
    generator.print(node.head, node);
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/generators/expressions/AwaitExpression.ts

  const ___R$romejs$js$generator$generators$expressions$AwaitExpression_ts$default = ___R$romejs$js$generator$generators$utils_ts$buildYieldAwaitGenerator('await');

  // romejs/js-generator/generators/types/BigIntKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$BigIntKeywordTypeAnnotation_ts$default(generator) {
    generator.word('bigint');
  }

  // romejs/js-generator/generators/literals/BigIntLiteral.ts

  function ___R$romejs$js$generator$generators$literals$BigIntLiteral_ts$default(generator, node) {
    node = ___R$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral.assert(node);

    generator.word(node.value + 'n');
  }

  // romejs/js-generator/generators/expressions/BinaryExpression.ts

  function ___R$romejs$js$generator$generators$expressions$BinaryExpression_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression.assert(node);
    ___R$romejs$js$generator$generators$expressions$AssignmentExpression_ts$default(generator, node, parent);
  }

  // romejs/js-generator/generators/patterns/BindingArrayPattern.ts

  function ___R$romejs$js$generator$generators$patterns$BindingArrayPattern_ts$default(generator, node) {
    node = ___R$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern.assert(node);

    ___R$romejs$js$generator$generators$expressions$ArrayExpression_ts$default(generator, node);
  }

  // romejs/js-generator/generators/patterns/BindingAssignmentPattern.ts

  function ___R$romejs$js$generator$generators$patterns$BindingAssignmentPattern_ts$default(generator, node) {
    node = ___R$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern.assert(node);

    const {left: left} = node;
    generator.print(node.left, node);
    if (generator.options.typeAnnotations && left.meta !== undefined) {
      if (left.meta.optional === true) {
        generator.token('?');
      }
      generator.print(left.meta.typeAnnotation, left.meta);
    }

    generator.space();
    generator.token('=');
    generator.space();
    generator.print(node.right, node);
  }

  // romejs/js-generator/generators/patterns/BindingIdentifier.ts

  function ___R$romejs$js$generator$generators$patterns$BindingIdentifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.assert(node);

    if (node.name[0] === '*') {
      return;
    }

    ___R$romejs$js$generator$generators$auxiliary$Identifier_ts$default(generator, node);
  }

  // romejs/js-generator/generators/patterns/BindingObjectPattern.ts

  function ___R$romejs$js$generator$generators$patterns$BindingObjectPattern_ts$default(generator, node) {
    node = ___R$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern.assert(node);

    ___R$romejs$js$generator$generators$objects$ObjectExpression_ts$default(generator, node);
  }

  // romejs/js-generator/generators/statements/BlockStatement.ts

  function ___R$romejs$js$generator$generators$statements$BlockStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$BlockStatement_ts$blockStatement.assert(node);

    generator.token('{');
    generator.printInnerComments(node);

    const hasDirectives = Boolean(
    node.directives && node.directives.length > 0);

    if (node.body.length > 0 || hasDirectives) {
      generator.newline();

      generator.printStatementList(node.directives, node, {indent: true});
      if (hasDirectives) {
        generator.newline();
      }

      generator.printStatementList(node.body, node, {indent: true});
      generator.removeTrailingNewline();

      generator.source('end', node.loc);

      if (!generator.endsWith('\n')) {
        generator.newline();
      }

      generator.rightBrace();
    } else {
      generator.source('end', node.loc);
      generator.token('}');
    }
  }

  // romejs/js-generator/generators/types/BooleanKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$BooleanKeywordTypeAnnotation_ts$default(generator) {
    generator.word('boolean');
  }

  // romejs/js-generator/generators/literals/BooleanLiteral.ts

  function ___R$romejs$js$generator$generators$literals$BooleanLiteral_ts$default(generator, node) {
    node = ___R$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral.assert(node);

    generator.word(node.value ? 'true' : 'false');
  }

  // romejs/js-generator/generators/types/BooleanLiteralTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$BooleanLiteralTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts$booleanLiteralTypeAnnotation.assert(node);

    ___R$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts$booleanLiteralTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/statements/BreakStatement.ts

  const ___R$romejs$js$generator$generators$statements$BreakStatement_ts$default = ___R$romejs$js$generator$generators$utils_ts$buildLabelStatementGenerator('break');

  // romejs/js-generator/generators/expressions/CallExpression.ts

  function ___R$romejs$js$generator$generators$expressions$CallExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$CallExpression_ts$callExpression.assert(node);

    const {callee: callee} = node;
    generator.print(callee, node);

    let isMultiLine = false;
    const firstArg = node.arguments[0];
    if (callee && callee.loc && firstArg && firstArg.loc) {
      isMultiLine = firstArg.loc.start.line > callee.loc.end.line;
    }

    generator.print(node.typeArguments, node);
    generator.token('(');
    generator.printCommaList(node.arguments, node, {
      statement: isMultiLine});
    generator.token(')');
  }

  // romejs/js-generator/generators/auxiliary/CatchClause.ts

  function ___R$romejs$js$generator$generators$auxiliary$CatchClause_ts$default(generator, node) {
    node = ___R$romejs$js$ast$auxiliary$CatchClause_ts$catchClause.assert(node);
    ___R$romejs$js$ast$auxiliary$CatchClause_ts$catchClause.assert(node);
    generator.word('catch');
    generator.space();
    generator.token('(');
    generator.print(node.param, node);
    generator.token(')');
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/generators/classes/ClassDeclaration.ts

  function ___R$romejs$js$generator$generators$classes$ClassDeclaration_ts$default(generator, node, parent) {
    node = node.type === 'ClassExpression' ? node : ___R$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration.assert(node);

    generator.word('class');

    if (node.id) {
      generator.space();
      generator.print(node.id, node);
    }

    generator.print(node.meta, node);

    generator.space();

    generator.token('{');
    generator.printInnerComments(node);
    generator.printInnerComments(node.meta);
    if (node.meta.body.length === 0) {
      generator.token('}');
    } else {
      generator.newline();

      generator.indent();
      generator.printStatementList(node.meta.body, node.meta);
      generator.dedent();

      if (!generator.endsWith('\n')) {
        generator.newline();
      }

      generator.rightBrace();
    }
  }

  // romejs/js-generator/generators/classes/ClassExpression.ts

  function ___R$romejs$js$generator$generators$classes$ClassExpression_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$classes$ClassExpression_ts$classExpression.assert(node);
    ___R$romejs$js$generator$generators$classes$ClassDeclaration_ts$default(generator, node, parent);
  }

  // romejs/js-generator/generators/classes/ClassHead.ts

  function ___R$romejs$js$generator$generators$classes$ClassHead_ts$default(generator, node) {
    node = ___R$romejs$js$ast$classes$ClassHead_ts$classHead.assert(node);

    generator.print(node.typeParameters, node);

    if (node.superClass) {
      generator.space();
      generator.word('extends');
      generator.space();
      generator.print(node.superClass, node);
      generator.print(node.superTypeParameters, node);
    }

    if (node.implements !== undefined &&
    node.implements.length > 0 &&
    generator.options.typeAnnotations) {
      generator.space();
      generator.word('implements');
      generator.space();
      generator.printCommaList(node.implements, node);
    }
  }

  // romejs/js-generator/generators/classes/ClassMethod.ts

  function ___R$romejs$js$generator$generators$classes$ClassMethod_ts$default(generator, node) {
    node = ___R$romejs$js$ast$classes$ClassMethod_ts$classMethod.assert(node);
    ___R$romejs$js$ast$classes$ClassMethod_ts$classMethod.assert(node);
    if (node.meta.static === true) {
      generator.word('static');
      generator.space();
    }

    ___R$romejs$js$generator$generators$utils_ts$printMethod(generator, node);
  }

  // romejs/js-generator/generators/classes/ClassPrivateMethod.ts

  function ___R$romejs$js$generator$generators$classes$ClassPrivateMethod_ts$default() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/classes/ClassPrivateProperty.ts

  function ___R$romejs$js$generator$generators$classes$ClassPrivateProperty_ts$default() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/classes/ClassProperty.ts

  function ___R$romejs$js$generator$generators$classes$ClassProperty_ts$default(generator, node) {
    node = ___R$romejs$js$ast$classes$ClassProperty_ts$classProperty.assert(node);

    if (node.value === undefined && !generator.options.typeAnnotations) {
      return;
    }

    const {meta: meta} = node;

    if (meta.static === true) {
      generator.word('static');
      generator.space();
    }

    generator.print(node.key, node);
    generator.printTypeColon(node.typeAnnotation, node);

    if (node.value) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.value, node);
    }
    generator.semicolon();
  }

  // romejs/js-generator/generators/classes/ClassPropertyMeta.ts

  function ___R$romejs$js$generator$generators$classes$ClassPropertyMeta_ts$default(generator, node) {
    node = ___R$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/core/CommentBlock.ts

  function ___R$romejs$js$generator$generators$core$CommentBlock_ts$default(generator, node) {
    node = ___R$romejs$js$ast$core$CommentBlock_ts$commentBlock.assert(node);
    ___R$romejs$js$ast$core$CommentBlock_ts$commentBlock.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/core/CommentLine.ts

  function ___R$romejs$js$generator$generators$core$CommentLine_ts$default(generator, node) {
    node = ___R$romejs$js$ast$core$CommentLine_ts$commentLine.assert(node);
    ___R$romejs$js$ast$core$CommentLine_ts$commentLine.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/auxiliary/ComputedMemberProperty.ts

  function ___R$romejs$js$generator$generators$auxiliary$ComputedMemberProperty_ts$default(generator, node) {
    node = ___R$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty.assert(node);

    generator.token('[');
    generator.print(node.value, node);
    generator.token(']');
  }

  // romejs/js-generator/generators/objects/ComputedPropertyKey.ts

  function ___R$romejs$js$generator$generators$objects$ComputedPropertyKey_ts$default(generator, node) {
    node = ___R$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey.assert(node);

    generator.token('[');
    generator.print(node.value, node);
    generator.token(']');
  }

  // romejs/js-generator/generators/expressions/ConditionalExpression.ts

  function ___R$romejs$js$generator$generators$expressions$ConditionalExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$ConditionalExpression_ts$conditionalExpression.assert(node);

    generator.print(node.test, node);
    generator.space();
    generator.token('?');
    generator.space();
    generator.print(node.consequent, node);
    generator.space();
    generator.token(':');
    generator.space();
    generator.print(node.alternate, node);
  }

  // romejs/js-generator/generators/statements/ContinueStatement.ts

  const ___R$romejs$js$generator$generators$statements$ContinueStatement_ts$default = ___R$romejs$js$generator$generators$utils_ts$buildLabelStatementGenerator('continue');

  // romejs/js-generator/generators/statements/DebuggerStatement.ts

  function ___R$romejs$js$generator$generators$statements$DebuggerStatement_ts$default(generator) {
    generator.word('debugger');
    generator.semicolon();
  }

  // romejs/js-parser/options.ts


  const ___R$$priv$romejs$js$parser$options_ts$DEFAULT_USER_OPTIONS = {
    allowReturnOutsideFunction: false,

    sourceType: 'script',

    tokens: false,

    syntax: []};

  function ___R$romejs$js$parser$options_ts$normalizeOptions(opts) {
    return Object.assign({}, ___R$$priv$romejs$js$parser$options_ts$DEFAULT_USER_OPTIONS, opts);
  }

  // romejs/js-parser/xhtmlEntities.ts

  const ___R$romejs$js$parser$xhtmlEntities_ts = {
    get xhtmlEntityNameToChar() {
      return ___R$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar;
    },
    get xhtmlEntityCharToName() {
      return ___R$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName;
    },
    escapeXHTMLEntities: ___R$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities};
  const ___R$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar = {
    quot: '"',
    amp: '&',
    apos: '\'',
    lt: '<',
    gt: '>',
    nbsp: '\xa0',
    iexcl: '\xa1',
    cent: '\xa2',
    pound: '\xa3',
    curren: '\xa4',
    yen: '\xa5',
    brvbar: '\xa6',
    sect: '\xa7',
    uml: '\xa8',
    copy: '\xa9',
    ordf: '\xaa',
    laquo: '\xab',
    not: '\xac',
    shy: '\xad',
    reg: '\xae',
    macr: '\xaf',
    deg: '\xb0',
    plusmn: '\xb1',
    sup2: '\xb2',
    sup3: '\xb3',
    acute: '\xb4',
    micro: '\xb5',
    para: '\xb6',
    middot: '\xb7',
    cedil: '\xb8',
    sup1: '\xb9',
    ordm: '\xba',
    raquo: '\xbb',
    frac14: '\xbc',
    frac12: '\xbd',
    frac34: '\xbe',
    iquest: '\xbf',
    Agrave: '\xc0',
    Aacute: '\xc1',
    Acirc: '\xc2',
    Atilde: '\xc3',
    Auml: '\xc4',
    Aring: '\xc5',
    AElig: '\xc6',
    Ccedil: '\xc7',
    Egrave: '\xc8',
    Eacute: '\xc9',
    Ecirc: '\xca',
    Euml: '\xcb',
    Igrave: '\xcc',
    Iacute: '\xcd',
    Icirc: '\xce',
    Iuml: '\xcf',
    ETH: '\xd0',
    Ntilde: '\xd1',
    Ograve: '\xd2',
    Oacute: '\xd3',
    Ocirc: '\xd4',
    Otilde: '\xd5',
    Ouml: '\xd6',
    times: '\xd7',
    Oslash: '\xd8',
    Ugrave: '\xd9',
    Uacute: '\xda',
    Ucirc: '\xdb',
    Uuml: '\xdc',
    Yacute: '\xdd',
    THORN: '\xde',
    szlig: '\xdf',
    agrave: '\xe0',
    aacute: '\xe1',
    acirc: '\xe2',
    atilde: '\xe3',
    auml: '\xe4',
    aring: '\xe5',
    aelig: '\xe6',
    ccedil: '\xe7',
    egrave: '\xe8',
    eacute: '\xe9',
    ecirc: '\xea',
    euml: '\xeb',
    igrave: '\xec',
    iacute: '\xed',
    icirc: '\xee',
    iuml: '\xef',
    eth: '\xf0',
    ntilde: '\xf1',
    ograve: '\xf2',
    oacute: '\xf3',
    ocirc: '\xf4',
    otilde: '\xf5',
    ouml: '\xf6',
    divide: '\xf7',
    oslash: '\xf8',
    ugrave: '\xf9',
    uacute: '\xfa',
    ucirc: '\xfb',
    uuml: '\xfc',
    yacute: '\xfd',
    thorn: '\xfe',
    yuml: '\xff',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02c6',
    tilde: '\u02dc',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039a',
    Lambda: '\u039b',
    Mu: '\u039c',
    Nu: '\u039d',
    Xi: '\u039e',
    Omicron: '\u039f',
    Pi: '\u03a0',
    Rho: '\u03a1',
    Sigma: '\u03a3',
    Tau: '\u03a4',
    Upsilon: '\u03a5',
    Phi: '\u03a6',
    Chi: '\u03a7',
    Psi: '\u03a8',
    Omega: '\u03a9',
    alpha: '\u03b1',
    beta: '\u03b2',
    gamma: '\u03b3',
    delta: '\u03b4',
    epsilon: '\u03b5',
    zeta: '\u03b6',
    eta: '\u03b7',
    theta: '\u03b8',
    iota: '\u03b9',
    kappa: '\u03ba',
    lambda: '\u03bb',
    mu: '\u03bc',
    nu: '\u03bd',
    xi: '\u03be',
    omicron: '\u03bf',
    pi: '\u03c0',
    rho: '\u03c1',
    sigmaf: '\u03c2',
    sigma: '\u03c3',
    tau: '\u03c4',
    upsilon: '\u03c5',
    phi: '\u03c6',
    chi: '\u03c7',
    psi: '\u03c8',
    omega: '\u03c9',
    thetasym: '\u03d1',
    upsih: '\u03d2',
    piv: '\u03d6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200c',
    zwj: '\u200d',
    lrm: '\u200e',
    rlm: '\u200f',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201a',
    ldquo: '\u201c',
    rdquo: '\u201d',
    bdquo: '\u201e',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203a',
    oline: '\u203e',
    frasl: '\u2044',
    euro: '\u20ac',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211c',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21b5',
    lArr: '\u21d0',
    uArr: '\u21d1',
    rArr: '\u21d2',
    dArr: '\u21d3',
    hArr: '\u21d4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220b',
    prod: '\u220f',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221a',
    prop: '\u221d',
    infin: '\u221e',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222a',
    int: '\u222b',
    there4: '\u2234',
    sim: '\u223c',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22a5',
    sdot: '\u22c5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230a',
    rfloor: '\u230b',
    lang: '\u2329',
    rang: '\u232a',
    loz: '\u25ca',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666'};

  const ___R$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName = {};
  for (const key in ___R$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar) {
    ___R$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName[___R$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar[key]] = key;
  }

  function ___R$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities(value, whitelist) {
    let escaped = '';
    for (const char of value) {
      const entity = ___R$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName[char];
      if (entity !== undefined &&
      (whitelist === undefined || whitelist.includes(char))) {
        escaped += '&' + entity + ';';
      } else {
        escaped += char;
      }
    }
    return escaped;
  }

  // romejs/js-parser/tokenizer/types.ts

  const ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr = true;
  const ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr = true;
  const ___R$$priv$romejs$js$parser$tokenizer$types_ts$isLoop = true;
  const ___R$$priv$romejs$js$parser$tokenizer$types_ts$isAssign = true;
  const ___R$$priv$romejs$js$parser$tokenizer$types_ts$prefix = true;
  const ___R$$priv$romejs$js$parser$tokenizer$types_ts$postfix = true;

  class ___R$romejs$js$parser$tokenizer$types_ts$TokenType {
    constructor(label, conf = {}) {
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = typeof conf.binop === 'number' ? conf.binop : undefined;
      this.updateContext = undefined;
    }

    getBinop() {
      const {binop: binop} = this;
      if (binop === undefined) {
        throw new Error('Token ' + this.label + ' doesn\'t have a binop');
      }
      return binop;
    }
  }

  const ___R$romejs$js$parser$tokenizer$types_ts$keywords = new Map();

  class ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType extends ___R$romejs$js$parser$tokenizer$types_ts$TokenType {
    constructor(name, options = {}) {
      options.keyword = name;

      super(name, options);

      ___R$romejs$js$parser$tokenizer$types_ts$keywords.set(name, this);
    }
  }

  class ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType extends ___R$romejs$js$parser$tokenizer$types_ts$TokenType {
    constructor(name, prec) {
      super(name, {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, binop: prec});
    }
  }

  const ___R$romejs$js$parser$tokenizer$types_ts$types = {
    num: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('num', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    bigint: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('bigint', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    regexp: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('regexp', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    string: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('string', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    name: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('name', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    eof: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('eof'),
    invalid: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('invalid'),
    comment: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('comment'),

    bracketL: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('[', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    bracketR: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType(']'),
    braceL: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('{', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    braceBarL: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('{|', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    braceR: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('}'),
    braceBarR: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('|}'),
    parenL: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('(', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    parenR: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType(')'),
    comma: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType(',', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    semi: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType(';', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    colon: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType(':', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    doubleColon: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('::', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    dot: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('.'),
    question: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('?', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    questionDot: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('?.'),
    arrow: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('=>', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    template: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('template'),
    ellipsis: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('...', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    backQuote: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('`', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    dollarBraceL: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('${', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    at: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('@'),
    hash: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('#'),

    eq: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('=', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, isAssign: ___R$$priv$romejs$js$parser$tokenizer$types_ts$isAssign}),
    assign: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('_=', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, isAssign: ___R$$priv$romejs$js$parser$tokenizer$types_ts$isAssign}),
    incDec: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('++/--', {prefix: ___R$$priv$romejs$js$parser$tokenizer$types_ts$prefix, postfix: ___R$$priv$romejs$js$parser$tokenizer$types_ts$postfix, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    bang: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('!', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    tilde: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('~', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    nullishCoalescing: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('??', 1),
    logicalOR: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('||', 1),
    logicalAND: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('&&', 2),
    bitwiseOR: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('|', 3),
    bitwiseXOR: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('^', 4),
    bitwiseAND: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('&', 5),
    equality: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('==/!=', 6),
    relational: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('</>', 7),
    bitShift: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('<</>>', 8),
    plusMin: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('+/-', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, binop: 9, prefix: ___R$$priv$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    modulo: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('%', 10),
    star: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('*', 10),
    slash: new ___R$romejs$js$parser$tokenizer$types_ts$BinopTokenType('/', 10),
    exponent: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('**', {
      beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr,
      binop: 11,
      rightAssociative: true}),

    jsxName: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('jsxName'),
    jsxText: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('jsxText', {beforeExpr: true}),
    jsxTagStart: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('jsxTagStart', {startsExpr: true}),
    jsxTagEnd: new ___R$romejs$js$parser$tokenizer$types_ts$TokenType('jsxTagEnd'),

    _break: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('break'),
    _case: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('case', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _catch: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('catch'),
    _continue: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('continue'),
    _debugger: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('debugger'),
    _default: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('default', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _do: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('do', {isLoop: ___R$$priv$romejs$js$parser$tokenizer$types_ts$isLoop, beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _else: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('else', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _finally: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('finally'),
    _for: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('for', {isLoop: ___R$$priv$romejs$js$parser$tokenizer$types_ts$isLoop}),
    _function: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('function', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _if: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('if'),
    _return: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('return', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _switch: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('switch'),
    _throw: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('throw', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _try: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('try'),
    _var: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('var'),
    _const: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('const'),
    _while: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('while', {isLoop: ___R$$priv$romejs$js$parser$tokenizer$types_ts$isLoop}),
    _with: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('with'),
    _new: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('new', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _this: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('this', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _super: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('super', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _class: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('class', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _extends: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('extends', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr}),
    _export: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('export'),
    _import: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('import', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _null: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('null', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _true: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('true', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _false: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('false', {startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _in: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('in', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, binop: 7}),
    _instanceof: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('instanceof', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, binop: 7}),
    _typeof: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('typeof', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _void: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('void', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr}),
    _delete: new ___R$romejs$js$parser$tokenizer$types_ts$KeywordTokenType('delete', {beforeExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$beforeExpr, prefix: ___R$$priv$romejs$js$parser$tokenizer$types_ts$prefix, startsExpr: ___R$$priv$romejs$js$parser$tokenizer$types_ts$startsExpr})};

  // romejs/js-parser/tokenizer/context.ts


  class ___R$romejs$js$parser$tokenizer$context_ts$TokContext {
    constructor(token, isExpr, preserveSpace, override) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
    }
  }

  const ___R$romejs$js$parser$tokenizer$context_ts$types = {
    braceStatement: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('{', false),
    braceExpression: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('{', true),
    templateQuasi: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('${', false),
    parenStatement: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('(', false),
    parenExpression: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('(', true),
    template: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('`', true, true, p => ___R$romejs$js$parser$tokenizer$index_ts$readTemplateToken(p)),
    functionExpression: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('function', true),
    functionStatement: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('function', false),

    jsxOpenTag: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('<tag', false),
    jsxCloseTag: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('</tag', false),
    jsxInner: new ___R$romejs$js$parser$tokenizer$context_ts$TokContext('<tag>...</tag>', true, true)};

  ___R$romejs$js$parser$tokenizer$types_ts$types.parenR.updateContext = ___R$romejs$js$parser$tokenizer$types_ts$types.braceR.updateContext = function(parser) {
    if (parser.state.context.length === 1) {
      parser.state.exprAllowed = true;
      return undefined;
    }

    let out = parser.state.context.pop();
    if (out === ___R$romejs$js$parser$tokenizer$context_ts$types.braceStatement &&
    ___R$romejs$js$parser$tokenizer$index_ts$getCurContext(parser).token === 'function') {
      out = parser.state.context.pop();
    }

    if (out === undefined) {
      throw new Error('No context found');
    }

    parser.state.exprAllowed = !out.isExpr;
  };

  ___R$romejs$js$parser$tokenizer$types_ts$types.name.updateContext = function(parser, prevType) {
    let allowed = false;
    if (prevType !== ___R$romejs$js$parser$tokenizer$types_ts$types.dot) {
      if (parser.state.tokenValue === 'of' && !parser.state.exprAllowed ||
      parser.state.tokenValue === 'yield' && parser.inScope('GENERATOR')) {
        allowed = true;
      }
    }

    parser.state.exprAllowed = allowed;

    if (parser.state.isIterator) {
      parser.state.isIterator = false;
    }
  };

  ___R$romejs$js$parser$tokenizer$types_ts$types.braceL.updateContext = function(parser, prevType) {
    parser.state.context.push(
    ___R$romejs$js$parser$tokenizer$index_ts$isBraceBlock(parser, prevType) ? ___R$romejs$js$parser$tokenizer$context_ts$types.braceStatement : ___R$romejs$js$parser$tokenizer$context_ts$types.braceExpression);
    parser.state.exprAllowed = true;
  };

  ___R$romejs$js$parser$tokenizer$types_ts$types.dollarBraceL.updateContext = function(parser) {
    parser.state.context.push(___R$romejs$js$parser$tokenizer$context_ts$types.templateQuasi);
    parser.state.exprAllowed = true;
  };

  ___R$romejs$js$parser$tokenizer$types_ts$types.parenL.updateContext = function(parser, prevType) {
    const statementParens = prevType === ___R$romejs$js$parser$tokenizer$types_ts$types._if ||
    prevType === ___R$romejs$js$parser$tokenizer$types_ts$types._for ||
    prevType === ___R$romejs$js$parser$tokenizer$types_ts$types._with ||
    prevType === ___R$romejs$js$parser$tokenizer$types_ts$types._while;
    parser.state.context.push(
    statementParens ? ___R$romejs$js$parser$tokenizer$context_ts$types.parenStatement : ___R$romejs$js$parser$tokenizer$context_ts$types.parenExpression);
    parser.state.exprAllowed = true;
  };

  ___R$romejs$js$parser$tokenizer$types_ts$types.incDec.updateContext = function() {};

  ___R$romejs$js$parser$tokenizer$types_ts$types._function.updateContext = function(parser, prevType) {
    if (prevType.beforeExpr &&
    prevType !== ___R$romejs$js$parser$tokenizer$types_ts$types.semi &&
    prevType !== ___R$romejs$js$parser$tokenizer$types_ts$types._else &&
    !(prevType === ___R$romejs$js$parser$tokenizer$types_ts$types._return &&
    ___R$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
    parser.getRawInput(
    parser.state.lastEndPos.index,
    parser.state.startPos.index))) &&
    !((prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.colon || prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.braceL) &&
    ___R$romejs$js$parser$tokenizer$index_ts$getCurContext(parser) === ___R$romejs$js$parser$tokenizer$context_ts$types.b_stat)) {
      parser.state.context.push(___R$romejs$js$parser$tokenizer$context_ts$types.functionExpression);
    } else {
      parser.state.context.push(___R$romejs$js$parser$tokenizer$context_ts$types.functionStatement);
    }

    parser.state.exprAllowed = false;
  };

  ___R$romejs$js$parser$tokenizer$types_ts$types._class.updateContext = ___R$romejs$js$parser$tokenizer$types_ts$types._function.updateContext;

  ___R$romejs$js$parser$tokenizer$types_ts$types.backQuote.updateContext = function(parser) {
    if (___R$romejs$js$parser$tokenizer$index_ts$getCurContext(parser) === ___R$romejs$js$parser$tokenizer$context_ts$types.template) {
      parser.state.context.pop();
    } else {
      parser.state.context.push(___R$romejs$js$parser$tokenizer$context_ts$types.template);
    }
    parser.state.exprAllowed = false;
  };

  ___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart.updateContext = function(parser) {
    parser.state.context.push(___R$romejs$js$parser$tokenizer$context_ts$types.jsxInner);
    parser.state.context.push(___R$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag);
    parser.state.exprAllowed = false;
  };

  ___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd.updateContext = function(parser, prevType) {
    const out = parser.state.context.pop();
    if (out === ___R$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag && prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.slash ||
    out === ___R$romejs$js$parser$tokenizer$context_ts$types.jsxCloseTag) {
      parser.state.context.pop();
      parser.state.exprAllowed = ___R$romejs$js$parser$tokenizer$index_ts$getCurContext(parser) === ___R$romejs$js$parser$tokenizer$context_ts$types.jsxInner;
    } else {
      parser.state.exprAllowed = true;
    }
  };

  // romejs/js-parser/parser/comments.ts

  const ___R$romejs$js$parser$parser$comments_ts = {
    addComment: ___R$romejs$js$parser$parser$comments_ts$addComment,
    processComment: ___R$romejs$js$parser$parser$comments_ts$processComment};
  function ___R$$priv$romejs$js$parser$parser$comments_ts$last(stack) {
    return stack[stack.length - 1];
  }

  function ___R$romejs$js$parser$parser$comments_ts$addComment(parser, comment) {
    parser.state.trailingComments.push(comment);
    parser.state.leadingComments.push(comment);
  }

  function ___R$romejs$js$parser$parser$comments_ts$processComment(parser, node) {
    if (node.type === 'Program' && node.body.length > 0) {
      return undefined;
    }

    const stack = parser.state.commentStack;

    let firstChild, lastChild, trailingComments, i, j;

    if (parser.state.trailingComments.length > 0) {
      if (parser.getLoc(parser.state.trailingComments[0]).start.index >=
      parser.getLoc(node).end.index) {
        trailingComments = parser.state.trailingComments;
        parser.state.trailingComments = [];
      } else {
        parser.state.trailingComments.length = 0;
      }
    } else {
      if (stack.length > 0) {
        const lastInStack = ___R$$priv$romejs$js$parser$parser$comments_ts$last(stack);
        if (lastInStack.trailingComments &&
        parser.getLoc(lastInStack.trailingComments[0]).start.index >=
        parser.getLoc(node).end.index) {
          trailingComments = lastInStack.trailingComments;
          lastInStack.trailingComments = undefined;
        }
      }
    }

    if (stack.length > 0 &&
    parser.getLoc(___R$$priv$romejs$js$parser$parser$comments_ts$last(stack)).start.index >= parser.getLoc(node).start.index) {
      firstChild = stack.pop();
    }

    while (stack.length > 0 &&
    parser.getLoc(___R$$priv$romejs$js$parser$parser$comments_ts$last(stack)).start.index >= parser.getLoc(node).start.index) {
      lastChild = stack.pop();
    }

    if (!lastChild && firstChild) {
      lastChild = firstChild;
    }

    if (firstChild && parser.state.leadingComments.length > 0) {
      const lastComment = ___R$$priv$romejs$js$parser$parser$comments_ts$last(parser.state.leadingComments);

      if (firstChild.type === 'ObjectProperty') {
        if (parser.getLoc(lastComment).start.index >=
        parser.getLoc(node).start.index) {
          if (parser.state.commentPreviousNode) {
            for (j = 0; j < parser.state.leadingComments.length; j++) {
              if (parser.getLoc(parser.state.leadingComments[j]).end.index <
              parser.getLoc(parser.state.commentPreviousNode).end.index) {
                parser.state.leadingComments.splice(j, 1);
                j--;
              }
            }

            if (parser.state.leadingComments.length > 0) {
              firstChild.trailingComments = parser.state.leadingComments;
              parser.state.leadingComments = [];
            }
          }
        }
      } else if (node.type === 'CallExpression' &&
      node.arguments &&
      node.arguments.length) {
        const lastArg = ___R$$priv$romejs$js$parser$parser$comments_ts$last(node.arguments);

        if (lastArg !== undefined &&
        parser.getLoc(lastComment).start.index >=
        parser.getLoc(lastArg).start.index &&
        parser.getLoc(lastComment).end.index <= parser.getLoc(node).end.index) {
          if (parser.state.commentPreviousNode) {
            if (parser.state.leadingComments.length > 0) {
              lastArg.trailingComments = parser.state.leadingComments;
              parser.state.leadingComments = [];
            }
          }
        }
      }
    }

    if (lastChild) {
      const lastLeadingComments = lastChild.leadingComments;
      if (lastLeadingComments !== undefined) {
        if (lastChild !== node &&
        lastLeadingComments.length > 0 &&
        parser.getLoc(___R$$priv$romejs$js$parser$parser$comments_ts$last(lastLeadingComments)).end.index <=
        parser.getLoc(node).start.index) {
          node.leadingComments = lastLeadingComments;
          lastChild.leadingComments = undefined;
        } else {
          for (i = lastLeadingComments.length - 2; i >= 0; --i) {
            if (parser.getLoc(lastLeadingComments[i]).end.index <=
            parser.getLoc(node).start.index) {
              node.leadingComments = lastLeadingComments.splice(0, i + 1);
              break;
            }
          }
        }
      }
    } else if (parser.state.leadingComments.length > 0) {
      if (parser.getLoc(___R$$priv$romejs$js$parser$parser$comments_ts$last(parser.state.leadingComments)).end.index <=
      parser.getLoc(node).start.index) {
        if (parser.state.commentPreviousNode) {
          for (j = 0; j < parser.state.leadingComments.length; j++) {
            if (parser.getLoc(parser.state.leadingComments[j]).end.index <
            parser.getLoc(parser.state.commentPreviousNode).end.index) {
              parser.state.leadingComments.splice(j, 1);
              j--;
            }
          }
        }
        if (parser.state.leadingComments.length > 0) {
          node.leadingComments = parser.state.leadingComments;
          parser.state.leadingComments = [];
        }
      } else {
        for (i = 0; i < parser.state.leadingComments.length; i++) {
          if (parser.getLoc(parser.state.leadingComments[i]).end.index >
          parser.getLoc(node).start.index) {
            break;
          }
        }

        const leadingComments = parser.state.leadingComments.slice(0, i);
        node.leadingComments =
        leadingComments.length === 0 ? undefined : leadingComments;

        trailingComments = parser.state.leadingComments.slice(i);
        if (trailingComments.length === 0) {
          trailingComments = undefined;
        }
      }
    }

    parser.state.commentPreviousNode = node;

    if (trailingComments) {
      if (trailingComments.length > 0 &&
      parser.getLoc(trailingComments[0]).start.index >=
      parser.getLoc(node).start.index &&
      parser.getLoc(___R$$priv$romejs$js$parser$parser$comments_ts$last(trailingComments)).end.index <=
      parser.getLoc(node).end.index) {
        node.innerComments = trailingComments;
      } else {
        node.trailingComments = trailingComments;
      }
    }

    stack.push(node);
  }

  // romejs/js-parser/parser/statement.ts

  const ___R$romejs$js$parser$parser$statement_ts = {
    parseTopLevel: ___R$romejs$js$parser$parser$statement_ts$parseTopLevel,
    parsePossibleInterpreterDirective: ___R$romejs$js$parser$parser$statement_ts$parsePossibleInterpreterDirective,
    expressionStatementToDirective: ___R$romejs$js$parser$parser$statement_ts$expressionStatementToDirective,
    isLetStart: ___R$romejs$js$parser$parser$statement_ts$isLetStart,
    parseStatement: ___R$romejs$js$parser$parser$statement_ts$parseStatement,
    isAsyncFunctionDeclarationStart: ___R$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart,
    assertModuleNodeAllowed: ___R$romejs$js$parser$parser$statement_ts$assertModuleNodeAllowed,
    parseBreakContinueStatement: ___R$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement,
    parseDebuggerStatement: ___R$romejs$js$parser$parser$statement_ts$parseDebuggerStatement,
    parseDoStatement: ___R$romejs$js$parser$parser$statement_ts$parseDoStatement,
    parseForStatement: ___R$romejs$js$parser$parser$statement_ts$parseForStatement,
    assertVarKind: ___R$romejs$js$parser$parser$statement_ts$assertVarKind,
    parseIfStatement: ___R$romejs$js$parser$parser$statement_ts$parseIfStatement,
    parseReturnStatement: ___R$romejs$js$parser$parser$statement_ts$parseReturnStatement,
    parseSwitchStatement: ___R$romejs$js$parser$parser$statement_ts$parseSwitchStatement,
    parseThrowStatement: ___R$romejs$js$parser$parser$statement_ts$parseThrowStatement,
    parseTryStatement: ___R$romejs$js$parser$parser$statement_ts$parseTryStatement,
    parseVarStatement: ___R$romejs$js$parser$parser$statement_ts$parseVarStatement,
    parseWhileStatement: ___R$romejs$js$parser$parser$statement_ts$parseWhileStatement,
    parseWithStatement: ___R$romejs$js$parser$parser$statement_ts$parseWithStatement,
    parseEmptyStatement: ___R$romejs$js$parser$parser$statement_ts$parseEmptyStatement,
    parseLabeledStatement: ___R$romejs$js$parser$parser$statement_ts$parseLabeledStatement,
    parseExpressionStatement: ___R$romejs$js$parser$parser$statement_ts$parseExpressionStatement,
    parseBlock: ___R$romejs$js$parser$parser$statement_ts$parseBlock,
    isValidDirective: ___R$romejs$js$parser$parser$statement_ts$isValidDirective,
    parseBlockBody: ___R$romejs$js$parser$parser$statement_ts$parseBlockBody,
    parseBlockOrModuleBlockBody: ___R$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody,
    parseFor: ___R$romejs$js$parser$parser$statement_ts$parseFor,
    parseForIn: ___R$romejs$js$parser$parser$statement_ts$parseForIn,
    parseVar: ___R$romejs$js$parser$parser$statement_ts$parseVar,
    parseVarHead: ___R$romejs$js$parser$parser$statement_ts$parseVarHead,
    parseFunctionDeclaration: ___R$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration,
    parseExportDefaultFunctionDeclaration: ___R$romejs$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration,
    parseFunctionExpression: ___R$romejs$js$parser$parser$statement_ts$parseFunctionExpression,
    parseFunction: ___R$romejs$js$parser$parser$statement_ts$parseFunction,
    splitFunctionParams: ___R$romejs$js$parser$parser$statement_ts$splitFunctionParams,
    parseFunctionParams: ___R$romejs$js$parser$parser$statement_ts$parseFunctionParams};
  const ___R$$priv$romejs$js$parser$parser$statement_ts$loopLabel = {kind: 'loop'};
  const ___R$$priv$romejs$js$parser$parser$statement_ts$switchLabel = {kind: 'switch'};

  function ___R$romejs$js$parser$parser$statement_ts$parseTopLevel(parser) {
    const start = parser.getPosition();
    const openContext = {
      name: 'top-level',
      start: start,
      indent: ___R$romejs$ob1$index_ts$number0,
      open: ___R$romejs$js$parser$tokenizer$types_ts$types.eof,
      close: ___R$romejs$js$parser$tokenizer$types_ts$types.eof};

    ___R$romejs$js$parser$tokenizer$index_ts$nextToken(parser);

    const interpreter = ___R$romejs$js$parser$parser$statement_ts$parsePossibleInterpreterDirective(parser);
    const {body: body, directives: directives} = ___R$romejs$js$parser$parser$statement_ts$parseBlockBody(parser, true, true, openContext);

    const loc = parser.finishLoc(start);

    return {
      type: 'Program',
      loc: loc,
      body: body,
      directives: directives,
      mtime: parser.mtime,
      diagnostics: parser.getDiagnostics(),
      filename: parser.filename,
      comments: parser.state.comments,
      sourceType: parser.sourceType,
      interpreter: interpreter,
      syntax: Array.from(parser.syntax),
      hasHoistedVars: parser.state.hasHoistedVars};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parsePossibleInterpreterDirective(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.hash) &&
    parser.input[___R$romejs$ob1$index_ts$get0(parser.state.endPos.index)] === '!') {
      const comment = ___R$romejs$js$parser$tokenizer$index_ts$skipLineComment(parser, 2);

      parser.next();

      return {
        type: 'InterpreterDirective',
        value: comment.value,
        loc: comment.loc};
    }
  }

  function ___R$romejs$js$parser$parser$statement_ts$expressionStatementToDirective(parser, stmt) {
    const expr = stmt.expression;

    const start = parser.getLoc(stmt).start;

    const raw = parser.getRawInput(
    parser.getLoc(expr).start.index,
    parser.getLoc(expr).end.index);
    const val = raw.slice(1, -1);

    const end = parser.getLoc(stmt).end;

    return {
      loc: parser.finishLocAt(start, end),
      type: 'Directive',
      value: val};
  }

  function ___R$romejs$js$parser$parser$statement_ts$isLetStart(parser, context) {
    if (!parser.isContextual('let')) {
      return false;
    }

    ___R$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.lastIndex = ___R$romejs$ob1$index_ts$get0(parser.state.index);
    const skip = ___R$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.exec(parser.input);
    if (skip == null) {
      throw new Error('Should never be true');
    }

    const next = ___R$romejs$ob1$index_ts$add(parser.state.index, skip[0].length);
    const nextCh = parser.input.charCodeAt(___R$romejs$ob1$index_ts$get0(next));

    if (nextCh === ___R$romejs$string$charcodes$index_ts.leftSquareBracket) {
      return true;
    }

    if (context !== undefined) {
      return false;
    }

    if (nextCh === ___R$romejs$string$charcodes$index_ts.leftCurlyBrace) {
      return true;
    }

    if (___R$romejs$js$parser$utils$identifier_ts$isIdentifierStart(nextCh)) {
      let pos = ___R$romejs$ob1$index_ts$add(next, 1);
      while (___R$romejs$js$parser$utils$identifier_ts$isIdentifierChar(parser.input.charCodeAt(___R$romejs$ob1$index_ts$get0(pos)))) {
        pos = ___R$romejs$ob1$index_ts$inc(pos);
      }

      const ident = parser.getRawInput(next, pos);
      if (!___R$romejs$js$parser$utils$identifier_ts$keywordRelationalOperator.test(ident)) {
        return true;
      }
    }
    return false;
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, context = undefined, topLevel = false) {
    let startType = parser.state.tokenType;
    const start = parser.getPosition();

    if (startType === ___R$romejs$js$parser$tokenizer$types_ts$types._const && parser.isSyntaxEnabled('ts')) {
      const ahead = parser.lookaheadState();
      if (ahead.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.name && ahead.tokenValue === 'enum') {
        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._const);
        parser.expectContextual('enum');
        return ___R$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(parser, start, true);
      }
    }

    let kind;
    if (___R$romejs$js$parser$parser$statement_ts$isLetStart(parser, context)) {
      startType = ___R$romejs$js$parser$tokenizer$types_ts$types._var;
      kind = 'let';
    }

    switch (startType) {
      case ___R$romejs$js$parser$tokenizer$types_ts$types._break:
        return ___R$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement(parser, start, true);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._continue:
        return ___R$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement(parser, start, false);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._debugger:
        return ___R$romejs$js$parser$parser$statement_ts$parseDebuggerStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._do:
        return ___R$romejs$js$parser$parser$statement_ts$parseDoStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._for:
        return ___R$romejs$js$parser$parser$statement_ts$parseForStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._function:
        if (parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.dot) {
          break;
        }

        if (context !== undefined) {
          if (parser.inScope('STRICT')) {
            parser.addDiagnostic({
              message: 'In strict mode code, functions can only be declared at top level or inside a block'});
          } else if (context !== 'if' && context !== 'label') {
            parser.addDiagnostic({
              message: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement'});
          }
        }

        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._function);

        const result = ___R$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(parser, start, false);

        if (context !== undefined && result.head.generator === true) {
          parser.addDiagnostic({
            message: 'Generators can only be declared at the top level or inside a block',
            loc: result.loc});
        }

        return result;

      case ___R$romejs$js$parser$tokenizer$types_ts$types._class:
        {
          if (context !== undefined) {
            parser.unexpectedToken();
          }
          return ___R$romejs$js$parser$parser$classes_ts$parseClassDeclaration(parser, start);
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types._if:
        return ___R$romejs$js$parser$parser$statement_ts$parseIfStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._return:
        return ___R$romejs$js$parser$parser$statement_ts$parseReturnStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._switch:
        return ___R$romejs$js$parser$parser$statement_ts$parseSwitchStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._throw:
        return ___R$romejs$js$parser$parser$statement_ts$parseThrowStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._try:
        return ___R$romejs$js$parser$parser$statement_ts$parseTryStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._const:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._var:
        kind =
        kind === undefined ? ___R$romejs$js$parser$parser$statement_ts$assertVarKind(String(parser.state.tokenValue)) : kind;
        if (context !== undefined && kind !== 'var') {
          parser.addDiagnostic({
            message: 'Lexical declaration cannot appear in a single-statement context'});
        }
        return ___R$romejs$js$parser$parser$statement_ts$parseVarStatement(parser, start, kind);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._while:
        return ___R$romejs$js$parser$parser$statement_ts$parseWhileStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._with:
        return ___R$romejs$js$parser$parser$statement_ts$parseWithStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.braceL:
        return ___R$romejs$js$parser$parser$statement_ts$parseBlock(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.semi:
        return ___R$romejs$js$parser$parser$statement_ts$parseEmptyStatement(parser, start);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._export:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._import:
        {
          const nextToken = parser.lookaheadState();
          if (nextToken.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.parenL || nextToken.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.dot) {
            break;
          }

          parser.next();

          let result;
          if (startType == ___R$romejs$js$parser$tokenizer$types_ts$types._import) {
            result = ___R$romejs$js$parser$parser$modules_ts$parseImport(parser, start);
          } else {
            result = ___R$romejs$js$parser$parser$modules_ts$parseExport(parser, start);
          }

          if (!topLevel) {
            parser.addDiagnostic({
              message: '\'import\' and \'export\' may only appear at the top level'});
          }

          ___R$romejs$js$parser$parser$statement_ts$assertModuleNodeAllowed(parser, result);

          return result;
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types.name:
        if (___R$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(parser)) {
          if (context !== undefined) {
            parser.addDiagnostic({
              message: 'Async functions can only be declared at the top level or inside a block'});
          }

          parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.name);

          parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._function);

          return ___R$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(parser, start, true);
        }}

    const maybeName = String(parser.state.tokenValue);
    const expr = ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'statement expression');

    if (startType === ___R$romejs$js$parser$tokenizer$types_ts$types.name &&
    expr.type === 'ReferenceIdentifier' &&
    parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      return ___R$romejs$js$parser$parser$statement_ts$parseLabeledStatement(parser, start, maybeName, expr, context);
    } else {
      return ___R$romejs$js$parser$parser$statement_ts$parseExpressionStatement(parser, start, expr);
    }
  }

  function ___R$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(parser) {
    if (!parser.isContextual('async')) {
      return false;
    }

    const {input: input} = parser;
    const {index: index} = parser.state;

    ___R$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.lastIndex = ___R$romejs$ob1$index_ts$get0(index);
    const skip = ___R$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.exec(input);

    if (!skip || skip.length === 0) {
      return false;
    }

    const next = ___R$romejs$ob1$index_ts$add(index, skip[0].length);

    return !___R$romejs$js$parser$utils$whitespace_ts$lineBreak.test(parser.getRawInput(index, next)) &&
    parser.getRawInput(next, ___R$romejs$ob1$index_ts$add(next, 8)) === 'function' &&
    (___R$romejs$ob1$index_ts$get0(next) + 8 === input.length ||
    !___R$romejs$js$parser$utils$identifier_ts$isIdentifierChar(input.charCodeAt(___R$romejs$ob1$index_ts$get0(next) + 8)));
  }

  function ___R$romejs$js$parser$parser$statement_ts$assertModuleNodeAllowed(parser, node) {
    if (node.type === 'ImportDeclaration' &&
    (node.importKind === 'type' || node.importKind === 'typeof') ||
    node.type === 'ExportNamedDeclaration' && node.exportKind === 'type' ||
    node.type === 'ExportAllDeclaration' && node.exportKind === 'type') {
      return;
    }

    if (!parser.inModule) {
      parser.addDiagnostic({
        loc: node.loc,
        message: '<emphasis>import</emphasis> and <emphasis>export</emphasis> can only appear in a module',
        advice: [{
          type: 'log',
          category: 'info',
          message: 'Change the extension to <emphasis>.mjs</emphasis> to turn this file into a module'}, {
          type: 'log',
          category: 'info',
          message: 'Add <emphasis>"type": "module"</emphasis> to your <emphasis>package.json</emphasis>'}]});
    }
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement(parser, start, isBreak) {
    const keyword = isBreak ? 'break' : 'continue';
    parser.next();

    let label;
    if (parser.isLineTerminator()) {
      label = undefined;
    } else if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
      parser.unexpectedToken();
    } else {
      label = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
      parser.semicolon();
    }

    let i;
    for (i = 0; i < parser.state.labels.length; ++i) {
      const lab = parser.state.labels[i];
      if (label === undefined || lab.name === label.name) {
        if (lab.kind !== undefined && (isBreak || lab.kind === 'loop')) {
          break;
        }

        if (label && isBreak) {
          break;
        }
      }
    }
    if (i === parser.state.labels.length) {
      parser.addDiagnostic({
        start: start,
        message: 'Unsyntactic ' + keyword});
    }

    if (isBreak) {
      return {
        loc: parser.finishLoc(start),
        type: 'BreakStatement',
        label: label};
    } else {
      return {
        loc: parser.finishLoc(start),
        type: 'ContinueStatement',
        label: label};
    }
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseDebuggerStatement(parser, start) {
    parser.next();
    parser.semicolon();
    return {loc: parser.finishLoc(start), type: 'DebuggerStatement'};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseDoStatement(parser, start) {
    parser.next();
    parser.state.labels.push(___R$$priv$romejs$js$parser$parser$statement_ts$loopLabel);
    const body = ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'do');
    parser.state.labels.pop();
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._while);
    const test = ___R$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, 'do test');
    parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.semi);
    return {
      loc: parser.finishLoc(start),
      type: 'DoWhileStatement',
      body: body,
      test: test};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseForStatement(parser, start) {
    parser.next();
    parser.state.labels.push(___R$$priv$romejs$js$parser$parser$statement_ts$loopLabel);

    let awaitAt;
    if (parser.inScope('ASYNC') && parser.eatContextual('await')) {
      awaitAt = parser.getEndPosition();
    }

    const openContext = parser.expectOpening(___R$romejs$js$parser$tokenizer$types_ts$types.parenL, ___R$romejs$js$parser$tokenizer$types_ts$types.parenR, 'for head');

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.semi)) {
      if (awaitAt) {
        parser.unexpectedToken();
      }
      return ___R$romejs$js$parser$parser$statement_ts$parseFor(parser, start, openContext, undefined);
    }

    const _isLet = ___R$romejs$js$parser$parser$statement_ts$isLetStart(parser);
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._var) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._const) || _isLet) {
      const initStart = parser.getPosition();

      const kind = ___R$romejs$js$parser$parser$statement_ts$assertVarKind(
      _isLet ? 'let' : String(parser.state.tokenValue));
      parser.next();

      const declarations = ___R$romejs$js$parser$parser$statement_ts$parseVar(parser, initStart, kind, true);

      const init = {
        loc: parser.finishLoc(initStart),
        type: 'VariableDeclaration',
        kind: kind,
        declarations: declarations};

      if ((parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._in) || parser.isContextual('of')) &&
      init.declarations.length === 1) {
        return ___R$romejs$js$parser$parser$statement_ts$parseForIn(parser, start, openContext, init, awaitAt);
      }

      if (awaitAt !== undefined) {
        parser.addDiagnostic({
          start: awaitAt,
          message: 'Can\'t have an await on a regular for loop'});
      }

      return ___R$romejs$js$parser$parser$statement_ts$parseFor(parser, start, openContext, init);
    }

    const refShorthandDefaultPos = {index: ___R$romejs$ob1$index_ts$number0};
    let init = ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'for init', true, refShorthandDefaultPos);

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._in) || parser.isContextual('of')) {
      const description = parser.isContextual('of') ? 'for-of statement' : 'for-in statement';
      const initPattern = ___R$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(parser, init, description);
      ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, init, undefined, undefined, description);
      return ___R$romejs$js$parser$parser$statement_ts$parseForIn(parser, start, openContext, initPattern, awaitAt);
    }

    if (___R$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      parser.unexpectedToken(
      parser.getPositionFromIndex(refShorthandDefaultPos.index));
    }

    if (awaitAt !== undefined) {
      parser.addDiagnostic({
        start: awaitAt,
        message: 'Can\'t have an await on a regular for loop'});
    }

    return ___R$romejs$js$parser$parser$statement_ts$parseFor(parser, start, openContext, init);
  }

  function ___R$romejs$js$parser$parser$statement_ts$assertVarKind(kind) {
    if (kind === 'let' || kind === 'var' || kind === 'const') {
      return kind;
    } else {
      throw new Error('Expected valid variable kind but got ' + kind);
    }
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseIfStatement(parser, start) {
    parser.next();
    const test = ___R$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, 'if test');
    const consequent = ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'if');
    const alternate = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types._else) ? ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'if') : undefined;
    return {
      loc: parser.finishLoc(start),
      type: 'IfStatement',
      test: test,
      consequent: consequent,
      alternate: alternate};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseReturnStatement(parser, start) {
    if (!parser.inScope('FUNCTION') &&
    parser.sourceType !== 'template' &&
    !parser.options.allowReturnOutsideFunction) {
      parser.addDiagnostic({
        message: '\'return\' outside of function'});
    }

    parser.next();

    let argument;
    if (!parser.isLineTerminator()) {
      argument = ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'return argument');
      parser.semicolon();
    }

    return {
      loc: parser.finishLoc(start),
      type: 'ReturnStatement',
      argument: argument};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseSwitchStatement(parser, start) {
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._switch);
    const discriminant = ___R$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, 'switch discriminant');
    const cases = [];
    const hasBrace = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL);
    const openContext = parser.expectOpening(___R$romejs$js$parser$tokenizer$types_ts$types.braceL, ___R$romejs$js$parser$tokenizer$types_ts$types.braceR, 'switch body');
    parser.state.labels.push(___R$$priv$romejs$js$parser$parser$statement_ts$switchLabel);

    if (hasBrace) {
      let cur;

      function pushCase() {
        if (cur === undefined) {
          return undefined;
        }

        cases.push({
          loc: parser.finishLoc(cur.start),
          type: 'SwitchCase',
          test: cur.test,
          consequent: cur.consequent});

        cur = undefined;
      }

      let sawDefault;

      while (true) {
        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
          break;
        }

        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._case) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._default)) {
          pushCase();

          const isCase = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._case);

          parser.next();

          let test;
          if (isCase) {
            test = ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'case test');
          } else {
            if (sawDefault) {
              parser.addDiagnostic({
                start: parser.state.lastStartPos,
                message: 'Multiple default clauses'});
            }
            sawDefault = true;
          }

          cur = {
            start: parser.getPosition(),
            consequent: [],
            test: test};

          parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.colon);
        } else {
          const stmt = ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, undefined);
          if (cur === undefined) {
            parser.addDiagnostic({
              loc: stmt.loc,
              message: 'Statement outside of a case or default block'});
          } else {
            cur.consequent.push(stmt);
          }
        }
      }

      pushCase();
    }

    parser.expectClosing(openContext);
    parser.state.labels.pop();

    return {
      loc: parser.finishLoc(start),
      type: 'SwitchStatement',
      discriminant: discriminant,
      cases: cases};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseThrowStatement(parser, start) {
    parser.next();
    if (___R$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
    parser.getRawInput(
    parser.state.lastEndPos.index,
    parser.state.startPos.index))) {
      parser.addDiagnostic({
        start: parser.state.lastEndPos,
        message: 'Illegal newline after throw'});
    }

    const argument = ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'throw argument');
    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'ThrowStatement',
      argument: argument};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseTryStatement(parser, start) {
    parser.next();

    const block = ___R$romejs$js$parser$parser$statement_ts$parseBlock(parser);
    let handler = undefined;

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._catch)) {
      const clauseStart = parser.getPosition();
      parser.next();

      let param;
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
        const openContext = parser.expectOpening(
        ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
        ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
        'catch clause param');
        param = ___R$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser);
        const clashes = new Map();
        ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, param, true, clashes, 'catch clause');
        parser.expectClosing(openContext);
      }

      const body = ___R$romejs$js$parser$parser$statement_ts$parseBlock(parser);
      handler = {
        loc: parser.finishLoc(clauseStart),
        type: 'CatchClause',
        body: body,
        param: param};
    }

    const finalizer = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types._finally) ? ___R$romejs$js$parser$parser$statement_ts$parseBlock(parser) : undefined;

    if (!handler && !finalizer) {
      parser.addDiagnostic({
        start: start,
        message: 'Missing catch or finally clause'});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TryStatement',
      block: block,
      finalizer: finalizer,
      handler: handler};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseVarStatement(parser, start, kind) {
    parser.next();
    const declarations = ___R$romejs$js$parser$parser$statement_ts$parseVar(parser, start, kind, false);
    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'VariableDeclarationStatement',
      declaration: {
        type: 'VariableDeclaration',
        loc: parser.finishLoc(start),
        kind: kind,
        declarations: declarations}};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseWhileStatement(parser, start) {
    parser.next();
    const test = ___R$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, 'while test');
    parser.state.labels.push(___R$$priv$romejs$js$parser$parser$statement_ts$loopLabel);
    const body = ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'while');
    parser.state.labels.pop();
    return {loc: parser.finishLoc(start), type: 'WhileStatement', test: test, body: body};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseWithStatement(parser, start) {
    parser.next();
    const object = ___R$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, 'with object');
    const body = ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'with');
    const loc = parser.finishLoc(start);

    if (parser.inScope('STRICT')) {
      parser.addDiagnostic({
        loc: loc,
        message: '\'with\' in strict mode'});
    }

    return {
      type: 'WithStatement',
      loc: loc,
      object: object,
      body: body};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseEmptyStatement(parser, start) {
    parser.next();
    return {loc: parser.finishLoc(start), type: 'EmptyStatement'};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseLabeledStatement(parser, start, maybeName, expr, context) {
    for (const label of parser.state.labels) {
      if (label.name === maybeName) {
        parser.addDiagnostic({
          loc: expr.loc,
          message: 'Label \'' + maybeName + '\' is already declared'});
      }
    }

    let kind = undefined;
    if (parser.state.tokenType.isLoop) {
      kind = 'loop';
    } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._switch)) {
      kind = 'switch';
    }
    for (let i = parser.state.labels.length - 1; i >= 0; i--) {
      const label = parser.state.labels[i];
      if (label.statementStart === start.index) {
        label.statementStart = parser.state.startPos.index;
        label.kind = kind;
      } else {
        break;
      }
    }

    parser.state.labels.push({
      name: maybeName,
      kind: kind,
      statementStart: parser.state.startPos.index});

    let statementContext = 'label';
    if (context !== undefined) {
      if (context.includes('label')) {
        statementContext = context;
      } else {
        statementContext = context + 'label';
      }
    }
    const body = ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, statementContext);

    if (body.type == 'ClassDeclaration' ||
    body.type == 'VariableDeclarationStatement' &&
    body.declaration.kind !== 'var' ||
    body.type == 'FunctionDeclaration' &&
    (parser.inScope('STRICT') ||
    body.head.generator === true ||
    body.head.async === true)) {
      parser.addDiagnostic({
        loc: body.loc,
        message: 'Invalid labeled declaration'});
    }

    parser.state.labels.pop();
    return {
      loc: parser.finishLoc(start),
      type: 'LabeledStatement',
      label: Object.assign({}, expr, {
        type: 'Identifier'}),
      body: body};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseExpressionStatement(parser, start, expr) {
    const node = ___R$romejs$js$parser$parser$type$systems_ts$parseTypeExpressionStatement(parser, start, expr);
    if (node !== undefined) {
      return node;
    }

    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'ExpressionStatement',
      expression: expr};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseBlock(parser, allowDirectives) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(___R$romejs$js$parser$tokenizer$types_ts$types.braceL, ___R$romejs$js$parser$tokenizer$types_ts$types.braceR, 'block');
    const {body: body, directives: directives} = ___R$romejs$js$parser$parser$statement_ts$parseBlockBody(
    parser,
    allowDirectives,
    false,
    openContext);
    return {
      loc: parser.finishLoc(start),
      type: 'BlockStatement',
      directives: directives,
      body: body};
  }

  function ___R$romejs$js$parser$parser$statement_ts$isValidDirective(parser, stmt) {
    return stmt.type === 'ExpressionStatement' &&
    stmt.expression.type === 'StringLiteral' &&
    !parser.isParenthesized(stmt.expression);
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseBlockBody(parser, allowDirectives = false, topLevel, openContext) {
    return ___R$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
    parser,
    allowDirectives,
    topLevel,
    openContext);
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(parser, allowDirectives, topLevel, openContext) {
    const body = [];
    const directives = [];

    let parsedNonDirective = false;
    let didSetStrict = undefined;
    let octalPosition;

    while (true) {
      if (parser.match(openContext.close) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (!parsedNonDirective && parser.state.containsOctal && !octalPosition) {
        octalPosition = parser.state.octalPosition;
      }

      const stmt = ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, undefined, topLevel);

      if (allowDirectives &&
      !parsedNonDirective &&
      stmt.type === 'ExpressionStatement' &&
      ___R$romejs$js$parser$parser$statement_ts$isValidDirective(parser, stmt)) {
        const directive = ___R$romejs$js$parser$parser$statement_ts$expressionStatementToDirective(parser, stmt);
        directives.push(directive);

        if (didSetStrict === undefined && directive.value === 'use strict') {
          ___R$romejs$js$parser$tokenizer$index_ts$setStrict(parser, true);
          didSetStrict = true;

          if (octalPosition !== undefined) {
            parser.addDiagnostic({
              index: octalPosition,
              message: 'Octal literal in strict mode'});
          }
        }

        continue;
      }

      parsedNonDirective = true;
      body.push(stmt);
    }

    if (didSetStrict) {
      parser.popScope('STRICT');
    }

    return {body: body, directives: directives};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseFor(parser, start, openContext, init) {
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.semi);

    const test = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.semi) ? undefined : ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'for test');
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.semi);

    const update = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR) ? undefined : ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'for update');
    parser.expectClosing(openContext);

    const body = ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'for');
    parser.state.labels.pop();

    return {
      loc: parser.finishLoc(start),
      type: 'ForStatement',
      init: init,
      test: test,
      update: update,
      body: body};
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseForIn(parser, start, openContext, init, awaitAt) {
    const isForIn = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._in);
    parser.next();

    const isAwait = awaitAt !== undefined;
    if (isForIn && isAwait) {
      parser.addDiagnostic({
        start: awaitAt,
        message: 'Unexpected await for `for-in`'});
    }

    if (init.type === 'VariableDeclaration' &&
    init.declarations[0].init !== undefined &&
    (!isForIn ||
    parser.inScope('STRICT') ||
    init.kind !== 'var' ||
    init.declarations[0].id.type !== 'BindingIdentifier')) {
      parser.addDiagnostic({
        loc: init.loc,
        message: (isForIn ? 'for-in' : 'for-of') + ' loop variable declaration may not have an initializer'});
    }

    const left = init;
    const right = isForIn ? ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'for right') : ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'for right');
    parser.expectClosing(openContext);

    const body = ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser, 'for');
    parser.state.labels.pop();

    if (isForIn) {
      const node = {
        loc: parser.finishLoc(start),
        type: 'ForInStatement',
        left: left,
        right: right,
        body: body};
      return node;
    } else {
      const node = {
        loc: parser.finishLoc(start),
        type: 'ForOfStatement',
        await: isAwait,
        left: left,
        right: right,
        body: body};
      return node;
    }
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseVar(parser, start, kind, isFor) {
    const declarations = [];

    for (;;) {
      const start = parser.getPosition();
      const id = ___R$romejs$js$parser$parser$statement_ts$parseVarHead(parser, start);

      if (kind === 'var') {
        parser.state.hasHoistedVars = true;
      }

      let init;
      if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.eq)) {
        init = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'var init', isFor);
      } else {
        if (kind === 'const' &&
        !(parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._in) || parser.isContextual('of'))) {
          if (!parser.isSyntaxEnabled('ts')) {
            parser.addDiagnostic({
              message: 'const with no initializer isn\'t allowed',
              loc: id.loc});
          }
        }

        if (kind !== 'const' &&
        id.type !== 'BindingIdentifier' &&
        !(isFor && (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._in) || parser.isContextual('of')))) {
          parser.addDiagnostic({
            start: parser.state.lastEndPos,
            message: 'Complex binding patterns require an initialization value'});
        }
      }

      declarations.push({
        loc: parser.finishLoc(start),
        type: 'VariableDeclarator',
        id: id,
        init: init});

      if (!parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    return declarations;
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseVarHead(parser, start) {
    const id = ___R$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser);

    ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, id, true, undefined, 'variable declaration');

    let definite;
    if (id.type === 'BindingIdentifier' && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bang)) {
      definite = true;

      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'TypeScript syntax isn\'t enabled for definite syntax'});
      }

      parser.next();
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      const typeAnnotation = ___R$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);

      return Object.assign({
        loc: parser.finishLoc(start)}, id, {
        meta: {
          type: 'PatternMeta',
          loc: parser.finishLoc(start),
          typeAnnotation: typeAnnotation,
          definite: definite}});
    } else if (definite) {
      return Object.assign({}, id, {
        meta: {
          type: 'PatternMeta',
          loc: parser.finishLoc(start),
          definite: definite}});
    } else {
      return id;
    }
  }

  function ___R$$priv$romejs$js$parser$parser$statement_ts$parseFunctionId(parser, requiredStatementId) {
    if (requiredStatementId || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
      return ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    }
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(parser, start, isAsync) {
    const ___R$ = ___R$romejs$js$parser$parser$statement_ts$parseFunction(parser, {
      start: start,
      requiredStatementId: true,
      isStatement: true,
      isAsync: isAsync});
    const shape = Object.assign({}, ___R$);
    delete shape.id;
    delete shape.body;
    const {
      id: id, body: body} = ___R$;
    if (id === undefined) {
      throw new Error('Required function name');
    }

    if (body === undefined) {
      return Object.assign({
        type: 'TSDeclareFunction'}, shape, {
        id: id});
    }

    return Object.assign({}, shape, {
      id: id,
      body: body,
      type: 'FunctionDeclaration'});
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration(parser, start, isAsync) {
    let ___R$1 = ___R$romejs$js$parser$parser$statement_ts$parseFunction(parser, {
      start: start,
      requiredStatementId: false,
      isStatement: true,
      isAsync: isAsync});
    let shape = Object.assign({}, ___R$1);
    delete shape.id;
    delete shape.body;
    let {
      id: id, body: body} = ___R$1;
    if (id === undefined) {
      id = {
        type: 'BindingIdentifier',
        name: '*default*',

        loc: shape.loc};
    }

    if (body === undefined) {
      return Object.assign({
        type: 'TSDeclareFunction'}, shape, {
        id: id});
    }

    return Object.assign({}, shape, {
      id: id,
      body: body,
      type: 'FunctionDeclaration'});
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseFunctionExpression(parser, start, isAsync) {
    const ___R$2 = ___R$romejs$js$parser$parser$statement_ts$parseFunction(parser, {
      start: start,
      requiredStatementId: false,
      isStatement: false,
      isAsync: isAsync});
    const shape = Object.assign({}, ___R$2);
    delete shape.body;
    const {
      body: body} = ___R$2;
    if (body === undefined) {
      throw new Error('Expected body');
    }

    return Object.assign({}, shape, {
      body: body,
      type: 'FunctionExpression'});
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseFunction(parser, opts) {
    const {start: start, isStatement: isStatement, requiredStatementId: requiredStatementId, isAsync: isAsync} = opts;

    const isGenerator = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.star);

    let id;
    if (isStatement) {
      id = ___R$$priv$romejs$js$parser$parser$statement_ts$parseFunctionId(parser, requiredStatementId);
    }

    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    parser.pushScope('FUNCTION_LOC', start);
    parser.pushScope('FUNCTION', true);
    parser.pushScope('METHOD', false);
    parser.pushScope('GENERATOR', isGenerator);
    parser.pushScope('ASYNC', isAsync);
    parser.pushScope('CLASS_PROPERTY', false);
    parser.pushScope('NON_ARROW_FUNCTION');
    parser.state.yieldPos = ___R$romejs$ob1$index_ts$number0;
    parser.state.awaitPos = ___R$romejs$ob1$index_ts$number0;

    if (!isStatement) {
      id = ___R$$priv$romejs$js$parser$parser$statement_ts$parseFunctionId(parser, false);
    }

    const {params: params, rest: rest, typeParameters: typeParameters} = ___R$romejs$js$parser$parser$statement_ts$parseFunctionParams(parser);
    const {head: head, body: body} = ___R$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(parser, {
      allowBodiless: isStatement,
      id: id,
      params: params,
      rest: rest,
      isArrowFunction: false,
      isMethod: false,
      isAsync: isAsync,
      isGenerator: isGenerator,
      start: start});

    parser.state.yieldPos = oldYieldPos;
    parser.state.awaitPos = oldAwaitPos;

    parser.popScope('NON_ARROW_FUNCTION');
    parser.popScope('FUNCTION');
    parser.popScope('FUNCTION_LOC');
    parser.popScope('CLASS_PROPERTY');
    parser.popScope('METHOD');
    parser.popScope('GENERATOR');
    parser.popScope('ASYNC');

    if (body !== undefined && body.type !== 'BlockStatement') {
      throw new Error('Expected block statement for functions');
    }

    return {
      head: Object.assign({}, head, {
        typeParameters: typeParameters}),
      body: body,
      id: id,
      loc: parser.finishLoc(start)};
  }

  function ___R$romejs$js$parser$parser$statement_ts$splitFunctionParams(params) {
    const firstParam = params[0];
    if (firstParam !== undefined &&
    firstParam.type === 'BindingIdentifier' &&
    firstParam.name === 'this') {
      return {
        thisType: firstParam,
        params: params.slice(1)};
    } else {
      return {
        thisType: undefined,
        params: params};
    }
  }

  function ___R$romejs$js$parser$parser$statement_ts$parseFunctionParams(parser, kind, allowTSModifiers) {
    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser);

      if (typeParameters !== undefined && (kind === 'get' || kind === 'set')) {
        parser.addDiagnostic({
          loc: typeParameters.loc,
          message: 'An accessor cannot have type parameters'});
      }
    }

    parser.pushScope('PARAMETERS', true);

    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
    'function params');
    const {list: params, rest: rest} = ___R$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty(
    parser,
    openContext,
    allowTSModifiers);

    parser.popScope('PARAMETERS');
    ___R$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(parser);
    return {params: params, rest: rest, typeParameters: typeParameters};
  }

  // romejs/js-parser/parser/expression.ts

  const ___R$romejs$js$parser$parser$expression_ts = {
    checkPropClash: ___R$romejs$js$parser$parser$expression_ts$checkPropClash,
    parseExpression: ___R$romejs$js$parser$parser$expression_ts$parseExpression,
    parseMaybeAssign: ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign,
    parseMaybeConditional: ___R$romejs$js$parser$parser$expression_ts$parseMaybeConditional,
    tryParseConditionalConsequent: ___R$romejs$js$parser$parser$expression_ts$tryParseConditionalConsequent,
    parseConditional: ___R$romejs$js$parser$parser$expression_ts$parseConditional,
    forwardNoArrowParamsConversionAt: ___R$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt,
    parseExpressionOps: ___R$romejs$js$parser$parser$expression_ts$parseExpressionOps,
    parseExpressionOp: ___R$romejs$js$parser$parser$expression_ts$parseExpressionOp,
    parseMaybeUnary: ___R$romejs$js$parser$parser$expression_ts$parseMaybeUnary,
    parseExpressionWithPossibleSubscripts: ___R$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts,
    parseSubscripts: ___R$romejs$js$parser$parser$expression_ts$parseSubscripts,
    parseExpressionSubscript: ___R$romejs$js$parser$parser$expression_ts$parseExpressionSubscript,
    parseTaggedTemplateExpression: ___R$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression,
    checkYieldAwaitInDefaultParams: ___R$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams,
    atPossibleAsync: ___R$romejs$js$parser$parser$expression_ts$atPossibleAsync,
    parseCallExpressionArguments: ___R$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments,
    shouldParseAsyncArrow: ___R$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow,
    parseAsyncArrowFromCallExpression: ___R$romejs$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression,
    parseNoCallExpr: ___R$romejs$js$parser$parser$expression_ts$parseNoCallExpr,
    parseExpressionAtom: ___R$romejs$js$parser$parser$expression_ts$parseExpressionAtom,
    parseBooleanLiteral: ___R$romejs$js$parser$parser$expression_ts$parseBooleanLiteral,
    parseMaybePrivateName: ___R$romejs$js$parser$parser$expression_ts$parseMaybePrivateName,
    parseFunctionExpressionOrMetaProperty: ___R$romejs$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty,
    parseMetaProperty: ___R$romejs$js$parser$parser$expression_ts$parseMetaProperty,
    parseImportMetaProperty: ___R$romejs$js$parser$parser$expression_ts$parseImportMetaProperty,
    parseParenExpression: ___R$romejs$js$parser$parser$expression_ts$parseParenExpression,
    parseParenAndDistinguishExpression: ___R$romejs$js$parser$parser$expression_ts$parseParenAndDistinguishExpression,
    shouldParseArrow: ___R$romejs$js$parser$parser$expression_ts$shouldParseArrow,
    parseArrowHead: ___R$romejs$js$parser$parser$expression_ts$parseArrowHead,
    parseParenItem: ___R$romejs$js$parser$parser$expression_ts$parseParenItem,
    parseNew: ___R$romejs$js$parser$parser$expression_ts$parseNew,
    parseTemplateElement: ___R$romejs$js$parser$parser$expression_ts$parseTemplateElement,
    parseTemplate: ___R$romejs$js$parser$parser$expression_ts$parseTemplate,
    parseObjectExpression: ___R$romejs$js$parser$parser$expression_ts$parseObjectExpression,
    parseObjectPattern: ___R$romejs$js$parser$parser$expression_ts$parseObjectPattern,
    isGetterOrSetterMethod: ___R$romejs$js$parser$parser$expression_ts$isGetterOrSetterMethod,
    checkGetterSetterParamCount: ___R$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount,
    parseObjectMethod: ___R$romejs$js$parser$parser$expression_ts$parseObjectMethod,
    parseObjectProperty: ___R$romejs$js$parser$parser$expression_ts$parseObjectProperty,
    parseObjectPropertyValue: ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue,
    parseObjectPropertyKey: ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey,
    parseMethod: ___R$romejs$js$parser$parser$expression_ts$parseMethod,
    parseArrowExpression: ___R$romejs$js$parser$parser$expression_ts$parseArrowExpression,
    isStrictBody: ___R$romejs$js$parser$parser$expression_ts$isStrictBody,
    parseFunctionBodyAndFinish: ___R$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish,
    parseFunctionBody: ___R$romejs$js$parser$parser$expression_ts$parseFunctionBody,
    checkFunctionNameAndParams: ___R$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams,
    parseExpressionList: ___R$romejs$js$parser$parser$expression_ts$parseExpressionList,
    parseExpressionListNonEmpty: ___R$romejs$js$parser$parser$expression_ts$parseExpressionListNonEmpty,
    parseCallArgument: ___R$romejs$js$parser$parser$expression_ts$parseCallArgument,
    parseIdentifier: ___R$romejs$js$parser$parser$expression_ts$parseIdentifier,
    parseBindingIdentifier: ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier,
    parseReferenceIdentifier: ___R$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier,
    toBindingIdentifier: ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier,
    toAssignmentIdentifier: ___R$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier,
    toReferenceIdentifier: ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier,
    toIdentifier: ___R$romejs$js$parser$parser$expression_ts$toIdentifier,
    createIdentifier: ___R$romejs$js$parser$parser$expression_ts$createIdentifier,
    parseIdentifierName: ___R$romejs$js$parser$parser$expression_ts$parseIdentifierName,
    checkReservedWord: ___R$romejs$js$parser$parser$expression_ts$checkReservedWord,
    parseAwait: ___R$romejs$js$parser$parser$expression_ts$parseAwait,
    parseYield: ___R$romejs$js$parser$parser$expression_ts$parseYield,
    parseStringLiteral: ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral,
    parseNumericLiteral: ___R$romejs$js$parser$parser$expression_ts$parseNumericLiteral};
  function ___R$romejs$js$parser$parser$expression_ts$checkPropClash(parser, prop, props) {
    if (prop.key.type === 'ComputedPropertyKey' || prop.type === 'ObjectMethod') {
      return undefined;
    }

    const key = prop.key.value;

    if (key.type !== 'Identifier' &&
    key.type !== 'StringLiteral' &&
    key.type !== 'NumericLiteral') {
      return;
    }

    const name = key.type === 'Identifier' ? key.name : String(key.value);

    if (name === '__proto__') {
      if (props.has('proto')) {
        parser.addDiagnostic({
          message: 'Redefinition of __proto__ property',
          loc: key.loc});
      } else {
        props.add('proto');
      }
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, context, noIn, refShorthandDefaultPos) {
    const startPos = parser.state.startPos;
    const expr = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, context, noIn, refShorthandDefaultPos);
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      let expressions = [expr];
      while (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        expressions.push(
        ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, context, noIn, refShorthandDefaultPos));
      }

      expressions = ___R$romejs$js$parser$parser$lval_ts$filterSpread(parser, ___R$romejs$js$parser$parser$lval_ts$toReferencedList(parser, expressions));

      return {
        loc: parser.finishLoc(startPos),
        type: 'SequenceExpression',
        expressions: expressions};
    }
    return expr;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, context, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
    const branches = parser.createBranch();

    if ((parser.isRelational('<') || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart)) &&
    parser.shouldTokenizeJSX()) {
      branches.add(
      () => {
        return ___R$$priv$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
        parser,
        context,
        noIn,
        refShorthandDefaultPos,
        afterLeftParse,
        refNeedsArrowPos);
      },
      {diagnosticsPriority: 1});

      const cLength = parser.state.context.length;
      if (parser.state.context[cLength - 1] === ___R$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag) {
        parser.state.context.length -= 2;
      }
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.relational, '<');
    }

    if (parser.isRelational('<')) {
      branches.add(() => {
        const start = parser.getPosition();
        const typeParameters = ___R$romejs$js$parser$parser$type$systems_ts$parseTypeParameters(parser);
        const arrowExpression = ___R$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
        parser,
        start,
        () => ___R$$priv$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
        parser,
        context,
        noIn,
        refShorthandDefaultPos,
        afterLeftParse,
        refNeedsArrowPos));
        parser.resetStartLocationFromNode(arrowExpression, typeParameters);

        if (arrowExpression.type === 'ArrowFunctionExpression') {
          return Object.assign({}, arrowExpression, {
            typeParameters: typeParameters});
        } else {
          parser.addDiagnostic({
            loc: typeParameters.loc,
            message: 'Expected an arrow function after this type parameter declaration'});
          return ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
          parser.createUnknownIdentifier('type params without arrow function'));
        }
      });
    }

    branches.add(() => {
      return ___R$$priv$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
      parser,
      context,
      noIn,
      refShorthandDefaultPos,
      afterLeftParse,
      refNeedsArrowPos);
    });

    return branches.pick();
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(parser, context, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
    const startPos = parser.state.startPos;

    if (parser.isContextual('yield')) {
      if (parser.inScope('GENERATOR')) {
        let left = ___R$romejs$js$parser$parser$expression_ts$parseYield(parser, noIn);
        if (afterLeftParse) {
          left = afterLeftParse(parser, left, startPos);
        }
        return left;
      } else {
        parser.state.exprAllowed = false;
      }
    }

    const oldCommaAfterSpreadAt = parser.state.commaAfterSpreadAt;
    parser.state.commaAfterSpreadAt = ___R$romejs$ob1$index_ts$number0Neg1;

    let failOnShorthandAssign;
    if (refShorthandDefaultPos) {
      failOnShorthandAssign = false;
    } else {
      refShorthandDefaultPos = ___R$romejs$js$parser$utils$location_ts$createIndexTracker();
      failOnShorthandAssign = true;
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
      parser.state.potentialArrowAt = parser.state.startPos.index;
    }

    let left = ___R$romejs$js$parser$parser$expression_ts$parseMaybeConditional(
    parser,
    context,
    noIn,
    refShorthandDefaultPos,
    refNeedsArrowPos);
    if (afterLeftParse) {
      left = afterLeftParse(parser, left, startPos);
    }

    if (parser.state.tokenType.isAssign) {
      const operator = String(parser.state.tokenValue);
      const leftPatt = ___R$romejs$js$parser$parser$lval_ts$toAssignmentPattern(parser, left, 'assignment expression');

      refShorthandDefaultPos.index = ___R$romejs$ob1$index_ts$number0;

      ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, leftPatt, undefined, undefined, 'assignment expression');

      parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

      parser.next();
      const right = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'assignment right', noIn);
      return {
        loc: parser.finishLoc(startPos),
        type: 'AssignmentExpression',
        operator: operator,
        left: leftPatt,
        right: right};
    } else if (failOnShorthandAssign && ___R$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      parser.unexpectedToken(
      parser.getPositionFromIndex(refShorthandDefaultPos.index));
    }

    parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

    return left;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseMaybeConditional(parser, context, noIn, refShorthandDefaultPos, refNeedsArrowPos) {
    const startPos = parser.state.startPos;
    const potentialArrowAt = parser.state.potentialArrowAt;
    const expr = ___R$romejs$js$parser$parser$expression_ts$parseExpressionOps(
    parser,
    context,
    noIn,
    refShorthandDefaultPos);

    if (expr.type === 'ArrowFunctionExpression' &&
    parser.getLoc(expr).start.index === potentialArrowAt) {
      return expr;
    }

    if (refShorthandDefaultPos && ___R$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      return expr;
    }

    return ___R$romejs$js$parser$parser$expression_ts$parseConditional(parser, expr, noIn, startPos, refNeedsArrowPos);
  }

  function ___R$romejs$js$parser$parser$expression_ts$tryParseConditionalConsequent(parser) {
    const brancher = parser.createBranch();

    brancher.add(() => {
      parser.state.noArrowParamsConversionAt.push(parser.state.startPos.index);
      const consequent = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'conditional consequent');
      parser.state.noArrowParamsConversionAt.pop();
      return {
        consequent: consequent,
        failed: !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)};
    });

    return brancher.pick();
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseConditional(parser, expr, noIn, startPos, refNeedsArrowPos) {
    if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.question)) {
      return expr;
    }

    if (refNeedsArrowPos) {
      const branch = parser.createBranch();

      branch.add(() => ___R$$priv$romejs$js$parser$parser$expression_ts$_parseConditional(parser, expr, noIn, startPos), {
        maxNewDiagnostics: 0});

      if (branch.hasBranch()) {
        return branch.pick();
      } else {
        refNeedsArrowPos.index = parser.state.startPos.index;
        return expr;
      }
    }

    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.question);
    const originalNoArrowAt = parser.state.noArrowAt;
    let {consequent: consequent} = ___R$romejs$js$parser$parser$expression_ts$tryParseConditionalConsequent(parser);
    parser.state.noArrowAt = originalNoArrowAt;

    if (!parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      parser.addDiagnostic({
        message: 'Missing conditional expression consequent separator'});
    }

    const alternate = ___R$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(parser, startPos, () => ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
    parser,
    'conditional alternate',
    noIn,
    undefined,
    undefined,
    undefined));

    return {
      loc: parser.finishLoc(startPos),
      type: 'ConditionalExpression',
      test: expr,
      consequent: consequent,
      alternate: alternate};
  }

  function ___R$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(parser, start, parse) {
    if (parser.state.noArrowParamsConversionAt.includes(start.index)) {
      let result;
      parser.state.noArrowParamsConversionAt.push(parser.state.startPos.index);
      result = parse();
      parser.state.noArrowParamsConversionAt.pop();
      return result;
    } else {
      return parse();
    }
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$_parseConditional(parser, expr, noIn, startPos) {
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.question)) {
      const test = expr;
      const consequent = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'conditional consequent');
      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.colon);
      const alternate = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'conditional alternate', noIn);
      return {
        loc: parser.finishLoc(startPos),
        type: 'ConditionalExpression',
        test: test,
        consequent: consequent,
        alternate: alternate};
    }
    return expr;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseExpressionOps(parser, context, noIn, refShorthandDefaultPos) {
    const startPos = parser.state.startPos;
    const potentialArrowAt = parser.state.potentialArrowAt;
    const expr = ___R$romejs$js$parser$parser$expression_ts$parseMaybeUnary(parser, context, refShorthandDefaultPos);

    if (expr.type === 'ArrowFunctionExpression' &&
    parser.getLoc(expr).start.index === potentialArrowAt) {
      return expr;
    }
    if (refShorthandDefaultPos && ___R$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      return expr;
    }

    return ___R$romejs$js$parser$parser$expression_ts$parseExpressionOp(parser, context, expr, startPos, -1, noIn);
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseExpressionOp(parser, context, left, leftStartPos, minPrec, noIn = false) {
    if (___R$romejs$js$parser$tokenizer$types_ts$types._in.getBinop() > minPrec &&
    !parser.hasPrecedingLineBreak() &&
    parser.isContextual('as')) {
      const _const = ___R$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(parser);

      let typeAnnotation;
      if (_const) {
        ___R$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, left);
        typeAnnotation = _const;
      } else {
        typeAnnotation = ___R$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(parser);
      }

      const node = {
        type: 'TSAsExpression',
        loc: parser.finishLoc(leftStartPos),
        typeAnnotation: typeAnnotation,
        expression: left};

      return ___R$romejs$js$parser$parser$expression_ts$parseExpressionOp(
      parser,
      context,
      node,
      leftStartPos,
      minPrec,
      noIn);
    }

    const prec = parser.state.tokenType.binop;
    if (prec !== undefined && (!noIn || !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._in))) {
      if (prec > minPrec) {
        const operator = String(parser.state.tokenValue);

        if (operator === '**' &&
        left.type === 'UnaryExpression' &&
        !parser.isParenthesized(left)) {
          parser.addDiagnostic({
            loc: left.argument.loc,
            message: 'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.'});
        }

        const op = parser.state.tokenType;
        parser.next();

        const startPos = parser.state.startPos;

        const right = ___R$romejs$js$parser$parser$expression_ts$parseExpressionOp(
        parser,
        context,
        ___R$romejs$js$parser$parser$expression_ts$parseMaybeUnary(parser, context),
        startPos,
        op.rightAssociative ? prec - 1 : prec,
        noIn);

        let node;
        if (operator === '||' || operator === '&&' || operator === '??') {
          node = {
            loc: parser.finishLoc(leftStartPos),
            type: 'LogicalExpression',
            left: left,
            right: right,
            operator: operator};
        } else {
          node = {
            loc: parser.finishLoc(leftStartPos),
            type: 'BinaryExpression',
            left: left,
            right: right,
            operator: operator};
        }

        return ___R$romejs$js$parser$parser$expression_ts$parseExpressionOp(
        parser,
        context,
        node,
        leftStartPos,
        minPrec,
        noIn);
      }
    }

    return left;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseMaybeUnary(parser, context, refShorthandDefaultPos) {
    if (parser.isSyntaxEnabled('ts') &&
    !parser.isSyntaxEnabled('jsx') &&
    parser.isRelational('<')) {
      return ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAssertion(parser);
    }

    if (parser.isContextual('await') && parser.inScope('ASYNC')) {
      return ___R$romejs$js$parser$parser$expression_ts$parseAwait(parser);
    }

    if (parser.state.tokenType.prefix) {
      const start = parser.getPosition();
      const update = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.incDec);
      const operator = String(parser.state.tokenValue);
      const prefix = true;

      parser.next();

      const argument = ___R$romejs$js$parser$parser$expression_ts$parseMaybeUnary(parser, context);

      if (refShorthandDefaultPos && ___R$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
        parser.unexpectedToken(
        parser.getPositionFromIndex(refShorthandDefaultPos.index));
      }

      if (update) {
        ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, argument, undefined, undefined, 'prefix operation');
      } else if (parser.inScope('STRICT') && operator === 'delete') {
        if (argument.type === 'ReferenceIdentifier') {
          parser.addDiagnostic({
            loc: argument.loc,
            message: 'Deleting local variable in strict mode'});
        } else if (argument.type === 'MemberExpression' &&
        argument.property.value.type === 'PrivateName') {
          parser.addDiagnostic({
            loc: argument.property.loc,
            message: 'Deleting a private field is not allowed'});
        }
      }

      let node;
      if (update) {
        if (operator !== '++' && operator !== '--') {
          throw new Error('Expected ++/-- operator only for UpdateExpression');
        }

        node = {
          loc: parser.finishLoc(start),
          type: 'UpdateExpression',
          argument: argument,
          operator: operator,
          prefix: prefix};
      } else {
        if (operator === '++' || operator === '--') {
          throw new Error('BinaryExpression cannot have ++/-- operator');
        }

        node = {
          loc: parser.finishLoc(start),
          type: 'UnaryExpression',
          argument: argument,
          operator: operator,
          prefix: prefix};
      }

      return node;
    }

    const startPos = parser.state.startPos;

    let expr = ___R$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(
    parser,
    context,
    refShorthandDefaultPos);
    if (refShorthandDefaultPos && ___R$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      return expr;
    }

    while (parser.state.tokenType.postfix && !parser.canInsertSemicolon()) {
      const operator = String(parser.state.tokenValue);
      ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, expr, undefined, undefined, 'postfix operation');
      parser.next();

      const updateNode = {
        loc: parser.finishLoc(startPos),
        type: 'UpdateExpression',
        operator: operator,
        prefix: false,
        argument: expr};
      expr = updateNode;
    }

    return expr;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(parser, context, refShorthandDefaultPos) {
    const startPos = parser.state.startPos;
    const potentialArrowAt = parser.state.potentialArrowAt;
    const expr = ___R$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, context, refShorthandDefaultPos);

    if (expr.type === 'ArrowFunctionExpression' &&
    parser.getLoc(expr).start.index === potentialArrowAt) {
      return expr;
    }

    if (refShorthandDefaultPos && ___R$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      return expr;
    }

    return ___R$romejs$js$parser$parser$expression_ts$parseSubscripts(parser, expr, startPos);
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseSubscripts(parser, base, startPos, noCalls) {
    const maybeAsyncArrow = ___R$romejs$js$parser$parser$expression_ts$atPossibleAsync(parser, base);

    if (base.type === 'ReferenceIdentifier' &&
    base.name === 'async' &&
    parser.state.noArrowAt.includes(startPos.index)) {
      const openContext = parser.expectOpening(
      ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'call arguments');
      const callee = base;
      const {args: args} = ___R$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(parser, openContext, false);
      base = {
        type: 'CallExpression',
        loc: parser.finishLoc(startPos),
        callee: callee,
        arguments: args};
    } else if (base.type === 'ReferenceIdentifier' &&
    base.name === 'async' &&
    parser.isRelational('<')) {
      const branch = parser.createBranch();
      branch.add(() => ___R$romejs$js$parser$parser$flow_ts$parseAsyncArrowWithFlowTypeParameters(parser, startPos));
      branch.add(() => ___R$$priv$romejs$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
      parser,
      base,
      startPos,
      noCalls,
      maybeAsyncArrow));
      return branch.pick();
    }

    return ___R$$priv$romejs$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
    parser,
    base,
    startPos,
    noCalls,
    maybeAsyncArrow);
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(parser, base, startPos, noCalls, maybeAsyncArrow) {
    const state = {
      optionalChainMember: false,
      stop: false};
    do {
      base = ___R$romejs$js$parser$parser$expression_ts$parseExpressionSubscript(
      parser,
      base,
      startPos,
      noCalls,
      state,
      maybeAsyncArrow);
    } while (!state.stop);
    return base;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseExpressionSubscript(parser, base, startPos, noCalls = false, state, maybeAsyncArrow) {
    if (!parser.hasPrecedingLineBreak() && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bang)) {
      parser.state.exprAllowed = false;
      parser.next();

      return {
        type: 'TSNonNullExpression',
        loc: parser.finishLoc(startPos),
        expression: base};
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.questionDot)) {
      state.optionalChainMember = true;

      if (noCalls && parser.lookaheadState().tokenType == ___R$romejs$js$parser$tokenizer$types_ts$types.parenL) {
        state.stop = true;
        return base;
      }

      parser.next();

      if (parser.isRelational('<')) {
        if (noCalls) {
          state.stop = true;
          return base;
        }

        const callee = base;
        const typeArguments = ___R$romejs$js$parser$parser$type$systems_ts$parseTypeCallArguments(parser);
        const openContext = parser.expectOpening(
        ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
        ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
        'call arguments');
        const {args: args} = ___R$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(parser, openContext, false);
        return {
          loc: parser.finishLoc(startPos),
          type: 'OptionalCallExpression',
          arguments: args,
          callee: callee,
          typeArguments: typeArguments};
      }

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
        const propStart = parser.getPosition();
        const openContext = parser.expectOpening(
        ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL,
        ___R$romejs$js$parser$tokenizer$types_ts$types.bracketR,
        'computed property');
        const object = base;
        const property = ___R$romejs$js$parser$parser$expression_ts$parseExpression(
        parser,
        'optional member expression property');
        parser.expectClosing(openContext);
        return {
          loc: parser.finishLoc(startPos),
          type: 'MemberExpression',
          object: object,
          property: {
            type: 'ComputedMemberProperty',
            loc: parser.finishLoc(propStart),
            optional: true,
            value: property}};
      }

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
        const openContext = parser.expectOpening(
        ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
        ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
        'call arguments');
        const callee = base;
        const {args: args} = ___R$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(parser, openContext, false);

        return {
          loc: parser.finishLoc(startPos),
          type: 'OptionalCallExpression',
          callee: callee,
          arguments: args};
      }

      const object = base;
      const property = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

      return {
        loc: parser.finishLoc(startPos),
        type: 'MemberExpression',
        object: object,
        property: {
          type: 'StaticMemberProperty',
          loc: property.loc,
          optional: true,
          value: property}};
    }

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      const object = base;
      const property = ___R$romejs$js$parser$parser$expression_ts$parseMaybePrivateName(parser);

      return {
        loc: parser.finishLoc(startPos),
        type: 'MemberExpression',
        object: object,
        property: {
          type: 'StaticMemberProperty',
          loc: property.loc,
          value: property}};
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      const propStart = parser.getPosition();
      const openContext = parser.expectOpening(
      ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL,
      ___R$romejs$js$parser$tokenizer$types_ts$types.bracketR,
      'computed property');
      const object = base;
      const property = ___R$romejs$js$parser$parser$expression_ts$parseExpression(
      parser,
      'member expression computed property');
      parser.expectClosing(openContext);

      return {
        loc: parser.finishLoc(startPos),
        type: 'MemberExpression',
        object: object,
        property: {
          type: 'ComputedMemberProperty',
          loc: parser.finishLoc(propStart),
          value: property}};
    }

    if (parser.isRelational('<') && ___R$romejs$js$parser$parser$type$systems_ts$isTypeSystemEnabled(parser)) {
      const possibleCallExpression = parser.tryBranch(() => {
        const typeArguments = ___R$romejs$js$parser$parser$type$systems_ts$parseTypeCallArguments(parser);

        if (!noCalls && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
          const openContext = parser.expectOpening(
          ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
          ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
          'call arguments');
          const {args: args} = ___R$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(parser, openContext, false);
          const node = {
            loc: parser.finishLoc(startPos),
            type: 'CallExpression',
            arguments: args,
            callee: base,
            typeArguments: typeArguments};
          return node;
        }

        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.backQuote)) {
          return ___R$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression(
          parser,
          startPos,
          base,
          state,
          typeArguments);
        }
      });

      if (possibleCallExpression !== undefined) {
        return possibleCallExpression;
      }
    }

    if (!noCalls && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
      const oldYieldPos = parser.state.yieldPos;
      const oldAwaitPos = parser.state.awaitPos;
      parser.state.maybeInArrowParameters = true;
      parser.state.yieldPos = ___R$romejs$ob1$index_ts$number0;
      parser.state.awaitPos = ___R$romejs$ob1$index_ts$number0;

      const openContext = parser.expectOpening(
      ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'call arguments');
      const callee = base;

      const oldCommaAfterSpreadAt = parser.state.commaAfterSpreadAt;
      parser.state.commaAfterSpreadAt = ___R$romejs$ob1$index_ts$number0Neg1;

      let {args: args, params: params} = ___R$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(
      parser,
      openContext,
      maybeAsyncArrow);

      if (maybeAsyncArrow && ___R$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(parser)) {
        state.stop = true;

        ___R$romejs$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread(parser);

        const node = ___R$romejs$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression(
        parser,
        startPos,
        params === undefined ? args : params);
        ___R$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(parser);
        parser.state.yieldPos = oldYieldPos;
        parser.state.awaitPos = oldAwaitPos;
        return node;
      } else {
        args = ___R$romejs$js$parser$parser$lval_ts$toReferencedListDeep(parser, args);

        parser.state.yieldPos = oldYieldPos || parser.state.yieldPos;
        parser.state.awaitPos = oldAwaitPos || parser.state.awaitPos;
      }

      parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

      return {
        type: 'CallExpression',
        loc: parser.finishLoc(startPos),
        callee: callee,
        arguments: args};
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.backQuote)) {
      return ___R$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression(parser, startPos, base, state);
    }

    state.stop = true;
    return base;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression(parser, startPos, tag, state, typeArguments) {
    if (state.optionalChainMember) {
      parser.addDiagnostic({
        message: 'Tagged Template Literals are not allowed in optionalChain'});
    }

    const quasi = ___R$romejs$js$parser$parser$expression_ts$parseTemplate(parser, true);
    return {
      loc: parser.finishLoc(startPos),
      type: 'TaggedTemplateExpression',
      tag: tag,
      quasi: quasi,
      typeArguments: typeArguments};
  }

  function ___R$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(parser) {
    if (___R$romejs$ob1$index_ts$get0(parser.state.yieldPos) > 0 &&
    (parser.state.awaitPos === ___R$romejs$ob1$index_ts$number0 ||
    parser.state.yieldPos < parser.state.awaitPos)) {
      parser.addDiagnostic({
        index: parser.state.yieldPos,
        message: 'Yield cannot be used as name inside a generator function'});
    }

    if (___R$romejs$ob1$index_ts$get0(parser.state.awaitPos) > 0) {
      parser.addDiagnostic({
        index: parser.state.awaitPos,
        message: 'Await cannot be used as name inside an async function'});
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$atPossibleAsync(parser, base) {
    const loc = parser.getLoc(base);
    return base.type === 'ReferenceIdentifier' &&
    base.name === 'async' &&
    parser.state.lastEndPos.index === loc.end.index &&
    !parser.canInsertSemicolon() &&
    parser.getRawInput(loc.start.index, loc.end.index) === 'async';
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(parser, openContext, possibleAsyncArrow, refTrailingCommaPos) {
    let callArgs = [];
    let funcParams = [];

    let innerParenStart;
    let first = true;

    let forceAsyncArrow = false;

    while (true) {
      if (parser.match(openContext.close) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (!parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
          break;
        }

        if (parser.eat(openContext.close)) {
          break;
        }
      }

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) && !innerParenStart) {
        innerParenStart = parser.state.startPos;
      }

      const elt = ___R$romejs$js$parser$parser$expression_ts$parseCallArgument(
      parser,
      'call expression argument',
      false,
      possibleAsyncArrow ? ___R$romejs$js$parser$utils$location_ts$createIndexTracker() : undefined,
      possibleAsyncArrow ? ___R$romejs$js$parser$utils$location_ts$createIndexTracker() : undefined,
      possibleAsyncArrow ? refTrailingCommaPos : undefined);
      if (elt === undefined) {
        throw new Error('Expected element');
      }

      if (elt.type === 'AmbiguousFlowTypeCastExpression') {
        if (possibleAsyncArrow) {
          forceAsyncArrow = true;

          if (callArgs.length > 0) {
            funcParams = callArgs.slice();
            callArgs = [];
          }

          funcParams.push(elt);
        } else {
          parser.addDiagnostic({
            message: 'Function parameter type annotation? Possibly forgot curlies around an object. Possibly forgot async keyword.',
            loc: elt.loc});
        }
        continue;
      }

      if (funcParams.length > 0) {
        funcParams.push(elt);
      } else {
        callArgs.push(elt);
      }
    }

    if (forceAsyncArrow && !___R$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(parser)) {
      parser.addDiagnostic({
        message: 'Expected arrow because we are a possible async arrow and type annotated parameters were present'});
    }

    if (possibleAsyncArrow &&
    innerParenStart !== undefined &&
    ___R$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(parser)) {
      parser.addDiagnostic({
        start: innerParenStart,
        message: 'Inner paren inside of an async arrow function params'});
    }

    return {
      args: callArgs,
      params: funcParams.length === 0 ? undefined : funcParams};
  }

  function ___R$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(parser) {
    return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon) ||
    parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.arrow) && !parser.canInsertSemicolon();
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression(parser, start, args) {
    let returnType;

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
      parser.state.noAnonFunctionType = true;
      returnType = ___R$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
      parser.state.noAnonFunctionType = oldNoAnonFunctionType;
    }

    const oldYield = parser.state.yieldInPossibleArrowParameters;
    parser.state.yieldInPossibleArrowParameters = undefined;
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.arrow);
    const node = ___R$romejs$js$parser$parser$expression_ts$parseArrowExpression(
    parser,
    start,
    {
      assignmentList: args},
    true);
    parser.state.yieldInPossibleArrowParameters = oldYield;
    return Object.assign({}, node, {
      head: Object.assign({}, node.head, {
        returnType: returnType})});
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseNoCallExpr(parser, context) {
    const startPos = parser.state.startPos;
    return ___R$romejs$js$parser$parser$expression_ts$parseSubscripts(
    parser,
    ___R$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, context),
    startPos,
    true);
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, context, refShorthandDefaultPos) {
    if (parser.state.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.slash) {
      ___R$romejs$js$parser$tokenizer$index_ts$readRegexp(parser);
    }

    const canBeArrow = parser.state.potentialArrowAt === parser.state.startPos.index;

    if (parser.isRelational('<') &&
    parser.input.charCodeAt(___R$romejs$ob1$index_ts$get0(parser.state.index)) !==
    ___R$romejs$string$charcodes$index_ts.exclamationMark) {
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart);
      return ___R$romejs$js$parser$parser$jsx_ts$parseJSXElement(parser);
    }

    switch (parser.state.tokenType) {
      case ___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart:
        return ___R$romejs$js$parser$parser$jsx_ts$parseJSXElement(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._super:
        return ___R$$priv$romejs$js$parser$parser$expression_ts$parseSuper(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._import:
        return ___R$$priv$romejs$js$parser$parser$expression_ts$parseImportOrMetaProperty(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._this:
        {
          const start = parser.getPosition();
          parser.next();
          return {
            type: 'ThisExpression',
            loc: parser.finishLoc(start)};
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types.name:
        {
          const start = parser.getPosition();
          const containsEsc = parser.state.escapePosition !== undefined;
          const id = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);

          if (!containsEsc &&
          id.name === 'async' &&
          parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._function) &&
          !parser.canInsertSemicolon()) {
            parser.next();
            return ___R$romejs$js$parser$parser$statement_ts$parseFunctionExpression(parser, start, true);
          }

          if (canBeArrow &&
          !containsEsc &&
          id.name === 'async' &&
          parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
            const oldYield = parser.state.yieldInPossibleArrowParameters;
            parser.state.yieldInPossibleArrowParameters = undefined;
            const params = [___R$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(parser)];
            parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.arrow);

            const node = ___R$romejs$js$parser$parser$expression_ts$parseArrowExpression(
            parser,
            start,
            {assignmentList: params},
            true);
            parser.state.yieldInPossibleArrowParameters = oldYield;
            return node;
          }

          if (canBeArrow && !parser.canInsertSemicolon() && parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.arrow)) {
            const oldYield = parser.state.yieldInPossibleArrowParameters;
            parser.state.yieldInPossibleArrowParameters = undefined;
            const node = ___R$romejs$js$parser$parser$expression_ts$parseArrowExpression(parser, start, {
              assignmentList: [___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(id)]});
            parser.state.yieldInPossibleArrowParameters = oldYield;
            return node;
          }

          return ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(id);
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types._do:
        return ___R$$priv$romejs$js$parser$parser$expression_ts$parseDoExpression(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.regexp:
        return ___R$$priv$romejs$js$parser$parser$expression_ts$parseRegExpLiteral(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.num:
        return ___R$romejs$js$parser$parser$expression_ts$parseNumericLiteral(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.bigint:
        return ___R$$priv$romejs$js$parser$parser$expression_ts$parseBigIntLiteral(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.string:
        return ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._null:
        return ___R$$priv$romejs$js$parser$parser$expression_ts$parseNullLiteral(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._true:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._false:
        return ___R$romejs$js$parser$parser$expression_ts$parseBooleanLiteral(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.parenL:
        return ___R$romejs$js$parser$parser$expression_ts$parseParenAndDistinguishExpression(parser, context, canBeArrow);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL:
        return ___R$$priv$romejs$js$parser$parser$expression_ts$parseArrayExpression(parser, refShorthandDefaultPos);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.braceL:
        return ___R$romejs$js$parser$parser$expression_ts$parseObjectExpression(parser, refShorthandDefaultPos);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._function:
        return ___R$romejs$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._class:
        {
          const start = parser.getPosition();
          return ___R$romejs$js$parser$parser$classes_ts$parseClassExpression(parser, start);
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types._new:
        return ___R$romejs$js$parser$parser$expression_ts$parseNew(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.backQuote:
        return ___R$romejs$js$parser$parser$expression_ts$parseTemplate(parser, false);

      default:
        {
          const start = parser.getPosition();
          parser.addDiagnostic({
            message: 'Unknown start to an ' + context});
          parser.next();
          return ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
          parser.createUnknownIdentifier(context, start));
        }}
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseBooleanLiteral(parser) {
    const start = parser.getPosition();
    const value = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._true);
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'BooleanLiteral',
      value: value};
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseMaybePrivateName(parser) {
    const isPrivate = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.hash);

    if (isPrivate) {
      const start = parser.getPosition();
      parser.next();
      parser.assertNoSpace('Unexpected space between # and identifier');
      const id = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
      return {
        loc: parser.finishLoc(start),
        type: 'PrivateName',
        id: id};
    } else {
      return ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty(parser) {
    const start = parser.getPosition();
    parser.next();

    const meta = ___R$romejs$js$parser$parser$expression_ts$createIdentifier(parser, start, 'function');

    if (parser.inScope('GENERATOR') && parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      return ___R$romejs$js$parser$parser$expression_ts$parseMetaProperty(parser, start, meta, 'sent');
    }

    const node = ___R$romejs$js$parser$parser$statement_ts$parseFunctionExpression(parser, start, false);

    if (node.type !== 'FunctionExpression') {
      throw new Error('Expected parseFunction to return a FunctionExpression');
    }

    return node;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseMetaProperty(parser, start, meta, propertyName) {
    if (meta.name === 'function' &&
    propertyName === 'sent' &&
    !parser.isContextual(propertyName)) {
      parser.unexpectedToken();
    }

    const escapePosition = parser.state.escapePosition;
    const property = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

    if (property.name === propertyName) {
      parser.banUnicodeEscape(escapePosition, propertyName);
    } else {
      parser.addDiagnostic({
        loc: property.loc,
        message: 'The only valid meta property for ' + meta.name + ' is ' + meta.name + '.' + propertyName});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'MetaProperty',
      meta: meta,
      property: property};
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseImportMetaProperty(parser) {
    const start = parser.getPosition();
    const id = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.dot);
    const node = ___R$romejs$js$parser$parser$expression_ts$parseMetaProperty(parser, start, id, 'meta');

    if (!parser.inModule) {
      parser.addDiagnostic({
        loc: node.loc,
        message: 'import.meta may appear only with \'sourceType: "module"\''});
    }

    return node;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseParenExpression(parser, context) {
    const openContext = parser.expectOpening(___R$romejs$js$parser$tokenizer$types_ts$types.parenL, ___R$romejs$js$parser$tokenizer$types_ts$types.parenR, context);
    const val = ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, context);
    parser.expectClosing(openContext);
    return val;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseParenAndDistinguishExpression(parser, context, canBeArrow) {
    if (parser.state.noArrowAt.includes(parser.state.startPos.index)) {
      canBeArrow = false;
    }

    const startPos = parser.state.startPos;

    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
    'paren expression');

    const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    const oldYield = parser.state.yieldInPossibleArrowParameters;
    parser.state.maybeInArrowParameters = true;
    parser.state.yieldInPossibleArrowParameters = undefined;
    parser.state.yieldPos = ___R$romejs$ob1$index_ts$number0;
    parser.state.awaitPos = ___R$romejs$ob1$index_ts$number0;

    const innerStart = parser.getPosition();
    const exprList = [];
    const refShorthandDefaultPos = ___R$romejs$js$parser$utils$location_ts$createIndexTracker();
    const refNeedsArrowPos = ___R$romejs$js$parser$utils$location_ts$createIndexTracker();
    let first = true;
    let spreadStart;
    let optionalCommaStart;

    while (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR)) {
      if (first) {
        first = false;
      } else {
        if (!parser.expect(
        ___R$romejs$js$parser$tokenizer$types_ts$types.comma,
        refNeedsArrowPos.index === ___R$romejs$ob1$index_ts$number0 ? undefined : parser.getPositionFromIndex(refNeedsArrowPos.index))) {
          break;
        }

        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR)) {
          optionalCommaStart = parser.state.startPos;
          break;
        }
      }

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
        const spreadNodeStartPos = parser.state.startPos;
        spreadStart = parser.state.startPos;
        exprList.push(
        ___R$romejs$js$parser$parser$expression_ts$parseParenItem(parser, ___R$romejs$js$parser$parser$lval_ts$parseSpread(parser), spreadNodeStartPos));

        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma) &&
        parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.parenR) {
          ___R$romejs$js$parser$parser$lval_ts$raiseRestNotLast(parser);
          parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma);
        }
      } else {
        exprList.push(
        ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
        parser,
        context,
        false,
        refShorthandDefaultPos,
        ___R$romejs$js$parser$parser$expression_ts$parseParenItem,
        refNeedsArrowPos));
      }
    }

    const innerEnd = parser.getPosition();
    parser.expectClosing(openContext);

    parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;

    const arrowStart = startPos;
    if (canBeArrow && ___R$romejs$js$parser$parser$expression_ts$shouldParseArrow(parser)) {
      const {valid: valid, returnType: returnType, predicate: predicate} = ___R$romejs$js$parser$parser$expression_ts$parseArrowHead(parser);

      if (valid) {
        ___R$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(parser);
        parser.state.yieldPos = oldYieldPos;
        parser.state.awaitPos = oldAwaitPos;

        for (const param of exprList) {
          if (parser.isParenthesized(param)) {
            parser.addDiagnostic({
              loc: param.loc,
              message: 'Function parameters can\'t be parenthesized'});
          }
        }

        const arrow = ___R$romejs$js$parser$parser$expression_ts$parseArrowExpression(parser, arrowStart, {
          assignmentList: exprList});
        parser.state.yieldInPossibleArrowParameters = oldYield;
        return Object.assign({}, arrow, {
          head: Object.assign({}, arrow.head, {
            predicate: predicate,
            returnType: returnType})});
      }
    }

    parser.state.yieldInPossibleArrowParameters = oldYield;

    parser.state.yieldPos = oldYieldPos || parser.state.yieldPos;
    parser.state.awaitPos = oldAwaitPos || parser.state.awaitPos;

    if (exprList.length === 0) {
      parser.addDiagnostic({
        start: innerStart,
        end: innerEnd,
        message: 'Parenthesized expression didnt contain anything'});

      exprList.push(
      ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
      parser.createUnknownIdentifier(
      'empty parenthesized expression',
      innerStart,
      innerEnd)));
    }

    if (optionalCommaStart !== undefined) {
      parser.unexpectedToken(optionalCommaStart);
    }

    if (spreadStart !== undefined) {
      parser.unexpectedToken(spreadStart);
    }

    if (___R$romejs$ob1$index_ts$get0(refShorthandDefaultPos.index) > 0) {
      parser.unexpectedToken(
      parser.getPositionFromIndex(refShorthandDefaultPos.index));
    }

    if (___R$romejs$ob1$index_ts$get0(refNeedsArrowPos.index) > 0) {
      parser.unexpectedToken(parser.getPositionFromIndex(refNeedsArrowPos.index));
    }

    const filterList = ___R$romejs$js$parser$parser$lval_ts$filterSpread(
    parser,
    ___R$romejs$js$parser$parser$lval_ts$toReferencedListDeep(parser, exprList, true));

    let val = filterList[0];
    if (filterList.length > 1) {
      val = {
        loc: parser.finishLocAt(innerStart, innerEnd),
        type: 'SequenceExpression',
        expressions: filterList};
    }

    parser.addParenthesized(val);

    return val;
  }

  function ___R$romejs$js$parser$parser$expression_ts$shouldParseArrow(parser) {
    return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon) || !parser.canInsertSemicolon();
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseArrowHead(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
      parser.state.noAnonFunctionType = true;

      const branch = parser.createBranch();

      branch.add(() => {
        const res = ___R$romejs$js$parser$parser$type$systems_ts$parseTypeAnnotationAndPredicate(parser);

        if (parser.canInsertSemicolon()) {
          return;
        }

        if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.arrow)) {
          return res;
        }
      });

      if (branch.hasBranch()) {
        const typeInfo = branch.pick();
        parser.state.noAnonFunctionType = oldNoAnonFunctionType;

        if (typeInfo === undefined) {
          throw new Error('hasBranchResult call above should have refined this condition');
        }

        return {
          valid: true,
          predicate: typeInfo[1],
          returnType: typeInfo[0]};
      } else {
        parser.state.noAnonFunctionType = oldNoAnonFunctionType;
        return {
          valid: false,
          predicate: undefined,
          returnType: undefined};
      }
    } else {
      return {
        valid: parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.arrow),
        predicate: undefined,
        returnType: undefined};
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseParenItem(parser, node, startPos) {
    let optional = undefined;
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.question)) {
      optional = true;
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      const typeAnnotation = ___R$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
      return {
        loc: parser.finishLoc(startPos),
        type: 'AmbiguousFlowTypeCastExpression',
        expression: node,
        typeAnnotation: typeAnnotation,
        optional: optional};
    }

    if (optional) {
      return {
        loc: parser.finishLoc(startPos),
        type: 'AmbiguousFlowTypeCastExpression',
        expression: node,
        typeAnnotation: undefined,
        optional: optional};
    }

    return node;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseNew(parser) {
    const start = parser.getPosition();
    const meta = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      const metaProp = ___R$romejs$js$parser$parser$expression_ts$parseMetaProperty(parser, start, meta, 'target');

      if (!parser.inScope('NON_ARROW_FUNCTION') &&
      !parser.inScope('CLASS_PROPERTY')) {
        parser.addDiagnostic({
          loc: metaProp.loc,
          message: 'new.target can only be used in functions or class properties'});
      }

      return metaProp;
    }

    const callee = ___R$romejs$js$parser$parser$expression_ts$parseNoCallExpr(parser, 'new callee');

    if (callee.type === 'ImportCall') {
      parser.addDiagnostic({
        loc: callee.loc,
        message: 'Cannot use new with import(...)'});
    }

    const optionalMember = ___R$$priv$romejs$js$parser$parser$expression_ts$getFirstOptionalChainMember(callee);
    if (optionalMember !== undefined) {
      const memberLoc = parser.getLoc(optionalMember);

      parser.addDiagnostic({
        message: 'constructors in/after an Optional Chain are not allowed',
        advice: [{
          type: 'log',
          category: 'info',
          message: 'Optional chain member responsible'}, {
          type: 'frame',
          filename: parser.filename,
          start: memberLoc.start,
          end: memberLoc.end}]});
    }

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.questionDot)) {
      parser.addDiagnostic({
        message: 'constructors in/after an Optional Chain are not allowed'});
    }

    let optional = undefined;
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.questionDot)) {
      optional = true;
    }

    let typeArguments = undefined;
    if (___R$romejs$js$parser$parser$type$systems_ts$isTypeSystemEnabled(parser) && parser.isRelational('<')) {
      typeArguments = parser.tryBranch(___R$romejs$js$parser$parser$type$systems_ts$parseTypeCallArguments);
    }

    let args = [];
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      const openContext = parser.expectOpening(
      ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'new argument');
      args = ___R$romejs$js$parser$parser$expression_ts$parseExpressionListNonEmpty(
      parser,
      'new expression argument',
      openContext);
      args = ___R$romejs$js$parser$parser$lval_ts$toReferencedList(parser, args);
    } else if (parser.isSyntaxEnabled('ts') && typeArguments !== undefined) {
      parser.addDiagnostic({
        message: 'In TypeScript, a new expression with type arguments must have parens'});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'NewExpression',
      callee: callee,
      typeArguments: typeArguments,
      arguments: args,
      optional: optional};
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$getFirstOptionalChainMember(node) {
    if (node.type === 'OptionalCallExpression') {
      return node;
    }

    if (node.type === 'MemberExpression') {
      if (node.property.optional) {
        return node;
      }

      if (node.property.type === 'StaticMemberProperty') {
        return ___R$$priv$romejs$js$parser$parser$expression_ts$getFirstOptionalChainMember(node.object);
      }
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseTemplateElement(parser, isTagged) {
    const start = parser.getPosition();
    const tokenValue = parser.state.tokenValue;

    if (tokenValue === undefined) {
      if (isTagged) {
        parser.state.invalidTemplateEscapePosition = undefined;
      } else {
        parser.addDiagnostic({
          index: parser.state.invalidTemplateEscapePosition,
          message: 'Invalid escape sequence in template'});
      }
    }

    const raw = parser.getRawInput(parser.state.startPos.index, parser.state.endPos.index).replace(/\r\n?/g, '\n');
    const cooked = tokenValue === undefined ? raw : String(tokenValue);

    parser.next();
    const tail = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.backQuote);
    return {
      loc: parser.finishLoc(start),
      type: 'TemplateElement',
      raw: raw,
      cooked: cooked,
      tail: tail};
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseTemplate(parser, isTagged) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.backQuote,
    ___R$romejs$js$parser$tokenizer$types_ts$types.backQuote,
    'template literal');
    const expressions = [];
    let curElt = ___R$romejs$js$parser$parser$expression_ts$parseTemplateElement(parser, isTagged);
    const quasis = [curElt];

    while (true) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof) || curElt.tail === true) {
        break;
      }

      const exprPpenContext = parser.expectOpening(
      ___R$romejs$js$parser$tokenizer$types_ts$types.dollarBraceL,
      ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'template expression value');
      expressions.push(___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'template expression value'));
      parser.expectClosing(exprPpenContext);

      curElt = ___R$romejs$js$parser$parser$expression_ts$parseTemplateElement(parser, isTagged);
      quasis.push(curElt);
    }

    parser.expectClosing(openContext);

    return {
      loc: parser.finishLoc(start),
      type: 'TemplateLiteral',
      expressions: expressions,
      quasis: quasis};
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseObjectExpression(parser, refShorthandDefaultPos) {
    const propHash = new Set();
    let first = true;

    const start = parser.getPosition();
    const properties = [];

    const openContext = parser.expectOpening(___R$romejs$js$parser$tokenizer$types_ts$types.braceL, ___R$romejs$js$parser$tokenizer$types_ts$types.braceR, 'object');

    while (true) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (!parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
          break;
        }

        if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
        const prop = Object.assign({}, ___R$romejs$js$parser$parser$lval_ts$parseSpread(parser), {
          type: 'SpreadProperty'});
        properties.push(prop);
        continue;
      }

      const start = parser.getPosition();
      let isGenerator = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.star);
      let isAsync = false;

      let key;
      let escapePosition;

      if (parser.isContextual('async')) {
        if (isGenerator) {
          parser.unexpectedToken();
        }

        const asyncId = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon) ||
        parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) ||
        parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR) ||
        parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eq) ||
        parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
          key = {
            type: 'StaticPropertyKey',
            loc: asyncId.loc,
            value: asyncId};
        } else {
          if (parser.hasPrecedingLineBreak()) {
            parser.addDiagnostic({
              message: 'There shouldn\'t be any newlines between async and the rest of the function'});
          }

          isAsync = true;
          if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.star)) {
            parser.next();
            isGenerator = true;
          }
          escapePosition = parser.state.escapePosition;
          key = ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);
        }
      } else {
        escapePosition = parser.state.escapePosition;
        key = ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);
      }

      const prop = ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue(parser, {
        key: key,
        start: start,
        isGenerator: isGenerator,
        isAsync: isAsync,
        isPattern: false,
        refShorthandDefaultPos: refShorthandDefaultPos,
        escapePosition: escapePosition});
      if (prop === undefined) {
        continue;
      }
      if (prop.type === 'BindingObjectPatternProperty') {
        throw new Error('Impossible');
      }

      ___R$romejs$js$parser$parser$expression_ts$checkPropClash(parser, prop, propHash);
      properties.push(prop);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'ObjectExpression',
      properties: properties};
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseObjectPattern(parser, refShorthandDefaultPos) {
    const propHash = new Set();
    let first = true;

    const start = parser.getPosition();
    const properties = [];
    let rest;

    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
    'object pattern');

    let firstRestLocation = undefined;

    while (true) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
        break;
      }

      if (first) {
        first = false;
      } else {
        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma);

        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      let isGenerator = false;
      let isAsync = false;
      let start = parser.getPosition();

      if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
        const argument = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
        rest = argument;

        if (firstRestLocation !== undefined) {
          parser.addDiagnostic({
            loc: argument.loc,
            message: 'Cannot have multiple rest elements when destructuring'});
        }

        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
          break;
        }

        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma) &&
        parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.braceR) {
          parser.addDiagnostic({
            message: 'A trailing comma is not permitted after the rest element'});
          parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma);
          break;
        } else {
          firstRestLocation = argument.loc;
          continue;
        }
      }

      start = parser.getPosition();

      const key = ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);
      const prop = ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue(parser, {
        key: key,
        start: start,
        isGenerator: isGenerator,
        isAsync: isAsync,
        isPattern: true,
        refShorthandDefaultPos: refShorthandDefaultPos,
        escapePosition: undefined});

      if (prop === undefined) {
        continue;
      }

      ___R$romejs$js$parser$parser$expression_ts$checkPropClash(parser, prop, propHash);

      if (prop.type !== 'BindingObjectPatternProperty') {
        parser.addDiagnostic({
          message: 'Invalid property node for object pattern',
          loc: prop.loc});
        continue;
      }

      properties.push(prop);
    }

    parser.expectClosing(openContext);

    if (firstRestLocation !== undefined) {
      ___R$romejs$js$parser$parser$lval_ts$raiseRestNotLast(parser, firstRestLocation);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'BindingObjectPattern',
      properties: properties,
      rest: rest};
  }

  function ___R$romejs$js$parser$parser$expression_ts$isGetterOrSetterMethod(parser, key, keyVal, isPattern) {
    return !isPattern &&
    key.type === 'StaticPropertyKey' &&
    keyVal.type === 'Identifier' &&
    (keyVal.name === 'get' || keyVal.name === 'set') &&
    (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string) ||
    parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.num) ||
    parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL) ||
    parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name) ||
    !!parser.state.tokenType.keyword);
  }

  function ___R$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(parser, method, kind) {
    const head = method.type === 'FlowFunctionTypeAnnotation' ? method : method.head;

    if (kind === 'get') {
      if (head.rest !== undefined || head.params.length !== 0) {
        parser.addDiagnostic({
          loc: method.loc,
          message: 'getter should have no parameters'});
      }
    } else if (kind === 'set') {
      if (head.rest !== undefined) {
        parser.addDiagnostic({
          loc: head.rest.loc,
          message: 'setter function argument must not be a rest parameter'});
      } else if (head.params.length !== 1) {
        parser.addDiagnostic({
          loc: method.loc,
          message: 'setter should have exactly one param'});
      }
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseObjectMethod(parser, {
    key: key,
    start: start,
    isGenerator: isGenerator,
    isAsync: isAsync,
    isPattern: isPattern,
    escapePosition: escapePosition}) {
    if (isAsync || isGenerator || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      if (isPattern) {
        parser.addDiagnostic({
          message: 'Object methods aren\'t allowed in object patterns'});
      }

      const partial = ___R$romejs$js$parser$parser$expression_ts$parseMethod(parser, {
        kind: 'method',
        isClass: false,
        isGenerator: isGenerator,
        isAsync: isAsync,
        isConstructor: false});

      const {body: body} = partial;
      if (body === undefined || body.type !== 'BlockStatement') {
        throw new Error('Expected body');
      }

      return Object.assign({}, partial, {
        body: body,
        loc: parser.finishLoc(start),
        key: key,
        type: 'ObjectMethod',
        kind: 'method'});
    }

    if (___R$romejs$js$parser$parser$expression_ts$isGetterOrSetterMethod(parser, key, key.value, isPattern)) {
      if (isAsync) {
        parser.addDiagnostic({
          message: 'An object setter/getter can\'t be async'});
      }

      if (isGenerator) {
        parser.addDiagnostic({
          message: 'An object setter/getter can\'t be a generator'});
      }

      const kind = key.value.name;
      if (kind !== 'get' && kind !== 'set') {
        throw new Error('Name should be get or set as we already validated it as such');
      }
      parser.banUnicodeEscape(escapePosition, kind);

      const newKey = ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);

      const partial = ___R$romejs$js$parser$parser$expression_ts$parseMethod(parser, {
        kind: kind,
        isClass: false,
        isGenerator: false,
        isAsync: false,
        isConstructor: false});

      const {body: body, head: head} = partial;
      if (body === undefined || body.type !== 'BlockStatement') {
        throw new Error('Expected body');
      }

      const method = {
        head: head,
        body: body,
        loc: parser.finishLoc(start),
        key: newKey,
        type: 'ObjectMethod',
        kind: kind};
      ___R$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(parser, method, method.kind);
      return method;
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseObjectProperty(parser, key, start, isPattern, refShorthandDefaultPos) {
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      if (isPattern) {
        const value = ___R$romejs$js$parser$parser$lval_ts$parseMaybeDefault(parser);
        return {
          loc: parser.finishLoc(start),
          key: key,
          type: 'BindingObjectPatternProperty',
          value: value};
      } else {
        const value = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
        parser,
        'object property value',
        false,
        refShorthandDefaultPos);
        return {
          loc: parser.finishLoc(start),
          key: key,
          type: 'ObjectProperty',
          value: value};
      }
    }

    if (key.type === 'StaticPropertyKey' && key.value.type === 'Identifier') {
      ___R$romejs$js$parser$parser$expression_ts$checkReservedWord(
      parser,
      key.value.name,
      parser.getLoc(key.value),
      true,
      true);

      if (isPattern) {
        let value = ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
        parser.cloneNode(key.value));

        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eq) && refShorthandDefaultPos) {
          if (refShorthandDefaultPos.index === ___R$romejs$ob1$index_ts$number0) {
            refShorthandDefaultPos.index = parser.state.startPos.index;
          }

          value = ___R$romejs$js$parser$parser$lval_ts$parseMaybeDefault(parser, start, value);
        }

        return {
          loc: parser.finishLoc(start),
          type: 'BindingObjectPatternProperty',
          key: key,
          value: value};
      }

      return {
        loc: parser.finishLoc(start),
        type: 'ObjectProperty',
        key: key,
        value: ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(parser.cloneNode(key.value))};
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue(parser, {
    key: key,
    start: start,
    isGenerator: isGenerator,
    isAsync: isAsync,
    isPattern: isPattern,
    refShorthandDefaultPos: refShorthandDefaultPos,
    escapePosition: escapePosition}) {
    if (key.variance !== undefined) {
      parser.addDiagnostic({
        loc: key.variance.loc,
        message: 'variance not allowed here'});
    }

    let typeParameters = ___R$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser);
    if (typeParameters !== undefined && !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      parser.unexpectedToken();
    }

    let node = ___R$romejs$js$parser$parser$expression_ts$parseObjectMethod(parser, {
      key: key,
      start: start,
      isGenerator: isGenerator,
      isAsync: isAsync,
      isPattern: isPattern,
      escapePosition: escapePosition}) ||
    ___R$romejs$js$parser$parser$expression_ts$parseObjectProperty(parser, key, start, isPattern, refShorthandDefaultPos);

    if (node === undefined) {
      parser.unexpectedToken();
      return undefined;
    }

    if (typeParameters === undefined) {
      return node;
    } else {
      if (node.type === 'ObjectProperty' ||
      node.type === 'BindingObjectPatternProperty') {
        parser.addDiagnostic({
          loc: typeParameters.loc,
          message: 'Object property cannot have type parameters'});
        return node;
      }

      return Object.assign({}, node, {
        head: Object.assign({}, node.head, {
          typeParameters: typeParameters})});
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser) {
    const start = parser.getPosition();
    const variance = ___R$romejs$js$parser$parser$flow_ts$parseFlowVariance(parser);

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      const openContext = parser.expectOpening(
      ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL,
      ___R$romejs$js$parser$tokenizer$types_ts$types.bracketR,
      'property name');

      const value = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'property name');
      parser.expectClosing(openContext);
      return {
        type: 'ComputedPropertyKey',
        loc: parser.finishLoc(start),
        value: value,
        variance: variance};
    } else {
      parser.pushScope('PROPERTY_NAME', true);

      let value;
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.num)) {
        value = ___R$romejs$js$parser$parser$expression_ts$parseNumericLiteral(parser);
      } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
        value = ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
      } else {
        value = ___R$romejs$js$parser$parser$expression_ts$parseMaybePrivateName(parser);
      }

      parser.popScope('PROPERTY_NAME');

      return {
        type: 'StaticPropertyKey',
        loc: parser.finishLoc(start),
        value: value,
        variance: variance};
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseMethod(parser, opts) {
    const {kind: kind, isClass: isClass, isGenerator: isGenerator, isAsync: isAsync, isConstructor: isConstructor} = opts;

    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    parser.pushScope('FUNCTION', true);
    parser.pushScope('NON_ARROW_FUNCTION');
    parser.pushScope('METHOD', kind);
    parser.pushScope('GENERATOR', isGenerator);
    parser.state.yieldPos = ___R$romejs$ob1$index_ts$number0;
    parser.state.awaitPos = ___R$romejs$ob1$index_ts$number0;

    const allowTSModifiers = isConstructor;
    const {typeParameters: typeParameters, rest: rest, params: params} = ___R$romejs$js$parser$parser$statement_ts$parseFunctionParams(
    parser,
    kind,
    allowTSModifiers);
    const {body: body, head: head} = ___R$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(parser, {
      allowBodiless: isClass,
      isArrowFunction: false,
      isAsync: isAsync,
      isGenerator: isGenerator,
      isMethod: true,
      id: undefined,
      params: params,
      rest: rest,
      start: parser.getPosition()});

    parser.popScope('METHOD');
    parser.popScope('GENERATOR');
    parser.popScope('FUNCTION');
    parser.popScope('NON_ARROW_FUNCTION');
    parser.state.yieldPos = oldYieldPos;
    parser.state.awaitPos = oldAwaitPos;

    return {
      head: Object.assign({}, head, {
        typeParameters: typeParameters}),
      body: body};
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$createFunctionHead(parser, params, rest, opts) {
    const nonRestParams = [];

    for (const param of params) {
      switch (param.type) {
        case 'BindingIdentifier':
        case 'BindingAssignmentPattern':
        case 'BindingObjectPattern':
        case 'BindingArrayPattern':
          nonRestParams.push(param);
          break;

        default:
          throw new Error('TODO');}
    }

    return Object.assign({
      type: 'FunctionHead',
      rest: rest}, ___R$romejs$js$parser$parser$statement_ts$splitFunctionParams(nonRestParams), opts);
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseArrowExpression(parser, start, opts, isAsync = false) {
    if (parser.state.yieldInPossibleArrowParameters) {
      parser.addDiagnostic({
        start: parser.state.yieldInPossibleArrowParameters,
        message: 'Yield cannot be used as name inside a generator function'});
    }

    parser.pushScope('FUNCTION', true);

    let params = [];
    let rest = opts.rest;

    if (opts.bindingList !== undefined) {
      params = opts.bindingList;
    }

    if (opts.assignmentList !== undefined) {
      ({params: params, rest: rest} = ___R$romejs$js$parser$parser$lval_ts$toFunctionParamsBindingList(
      parser,
      opts.assignmentList,
      'arrow function parameters'));
    }

    const oldYieldPos = parser.state.yieldPos;
    const oldAwaitPos = parser.state.awaitPos;
    const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
    parser.pushScope('GENERATOR', false);
    parser.state.maybeInArrowParameters = false;
    parser.state.yieldPos = ___R$romejs$ob1$index_ts$number0;
    parser.state.awaitPos = ___R$romejs$ob1$index_ts$number0;

    const headEnd = parser.getPosition();

    const {body: body, hasHoistedVars: hasHoistedVars} = ___R$romejs$js$parser$parser$expression_ts$parseFunctionBody(parser, {
      allowBodiless: false,
      isArrowFunction: true,
      isMethod: false,
      isAsync: isAsync,
      isGenerator: false,
      params: params,
      rest: rest,
      id: undefined,
      start: start});

    parser.popScope('GENERATOR');
    parser.popScope('FUNCTION');
    parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    parser.state.yieldPos = oldYieldPos;
    parser.state.awaitPos = oldAwaitPos;

    return {
      loc: parser.finishLoc(start),
      type: 'ArrowFunctionExpression',
      body: body,
      head: ___R$$priv$romejs$js$parser$parser$expression_ts$createFunctionHead(parser, params, rest, {
        loc: parser.finishLocAt(start, headEnd),
        hasHoistedVars: hasHoistedVars,
        async: isAsync})};
  }

  function ___R$romejs$js$parser$parser$expression_ts$isStrictBody(parser, body) {
    if (body.type === 'BlockStatement' && body.directives !== undefined) {
      for (const directive of body.directives) {
        if (directive.value === 'use strict') {
          return true;
        }
      }
    }

    return false;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(parser, opts) {
    let returnType = undefined;
    let predicate;

    if (!opts.isArrowFunction && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      [returnType, predicate] = ___R$romejs$js$parser$parser$type$systems_ts$parseTypeAnnotationAndPredicate(parser);
    }

    if (opts.allowBodiless &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL) &&
    parser.isLineTerminator()) {
      return {
        head: ___R$$priv$romejs$js$parser$parser$expression_ts$createFunctionHead(parser, opts.params, opts.rest, {
          loc: parser.finishLoc(opts.start),
          hasHoistedVars: false,
          generator: opts.isGenerator,
          async: opts.isAsync,
          returnType: returnType,
          predicate: predicate}),
        body: undefined};
    }

    const headEnd = parser.getPosition();
    const {body: body, hasHoistedVars: hasHoistedVars} = ___R$romejs$js$parser$parser$expression_ts$parseFunctionBody(parser, opts);
    return {
      head: ___R$$priv$romejs$js$parser$parser$expression_ts$createFunctionHead(parser, opts.params, opts.rest, {
        loc: parser.finishLocAt(opts.start, headEnd),
        hasHoistedVars: hasHoistedVars,
        generator: opts.isGenerator,
        async: opts.isAsync,
        returnType: returnType,
        predicate: predicate}),
      body: body};
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseFunctionBody(parser, opts) {
    if (opts.isArrowFunction) {
      return ___R$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(parser, opts.start, () => ___R$$priv$romejs$js$parser$parser$expression_ts$_parseFunctionBody(parser, opts));
    } else {
      return ___R$$priv$romejs$js$parser$parser$expression_ts$_parseFunctionBody(parser, opts);
    }
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$_parseFunctionBody(parser, opts) {
    const {isArrowFunction: isArrowFunction, isAsync: isAsync, isGenerator: isGenerator} = opts;

    const isExpression = isArrowFunction && !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL);

    parser.pushScope('PARAMETERS', false);
    parser.pushScope('ASYNC', isAsync);

    let hasHoistedVars = false;
    let body;
    if (isExpression) {
      body = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'function body');
    } else {
      const oldLabels = parser.state.labels;
      parser.pushScope('GENERATOR', isGenerator);
      parser.state.labels = [];

      const oldhasHoistedVars = parser.state.hasHoistedVars;
      parser.state.hasHoistedVars = false;

      body = ___R$romejs$js$parser$parser$statement_ts$parseBlock(parser, true);
      hasHoistedVars = parser.state.hasHoistedVars;

      parser.popScope('GENERATOR');

      parser.state.hasHoistedVars = oldhasHoistedVars;
      parser.state.labels = oldLabels;
    }

    parser.popScope('ASYNC');
    ___R$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams(parser, opts, body);
    parser.popScope('PARAMETERS');

    if (!___R$$priv$romejs$js$parser$parser$expression_ts$isSimpleParamList(opts.params) &&
    body.type === 'BlockStatement' &&
    body.directives !== undefined) {
      const firstDirective = body.directives[0];
      if (firstDirective !== undefined && firstDirective.value === 'use strict') {
        parser.addDiagnostic({
          loc: firstDirective.loc,
          message: 'Illegal \'use strict\' directive in function with non-simple parameter list'});
      }
    }

    return {body: body, hasHoistedVars: hasHoistedVars};
  }

  function ___R$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams(parser, opts, body, force) {
    const {isArrowFunction: isArrowFunction, isMethod: isMethod, id: id, params: params, start: start} = opts;

    if (isArrowFunction &&
    force !== true &&
    parser.state.noArrowParamsConversionAt.includes(start.index)) {
      return undefined;
    }

    const _isStrictBody = ___R$romejs$js$parser$parser$expression_ts$isStrictBody(parser, body);
    const isStrict = parser.inScope('STRICT') || _isStrictBody;

    const isSimpleParams = ___R$$priv$romejs$js$parser$parser$expression_ts$isSimpleParamList(params);
    const shouldCheckLVal = isStrict || isArrowFunction || isMethod || !isSimpleParams;

    parser.pushScope('STRICT', isStrict);

    if (shouldCheckLVal) {
      const clashes = new Map();

      if (id !== undefined) {
        ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, id, true, undefined, 'function name');
      }

      for (const param of params) {
        if (_isStrictBody && param.type !== 'BindingIdentifier') {
          parser.addDiagnostic({
            loc: param.loc,
            message: 'Non-simple parameter in strict mode'});
        }
        ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, param, true, clashes, 'function parameter list');
      }
    }

    parser.popScope('STRICT');
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$isSimpleParamList(params) {
    for (const param of params) {
      if (param.type !== 'Identifier') {
        return false;
      }
    }
    return true;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseExpressionList(parser, context, openContext, allowEmpty, refShorthandDefaultPos) {
    const elts = [];
    let first = true;

    while (true) {
      if (parser.match(openContext.close) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        break;
      }

      if (first) {
        first = false;
      } else {
        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma);

        if (parser.match(openContext.close)) {
          break;
        }
      }

      elts.push(
      ___R$romejs$js$parser$parser$expression_ts$parseCallArgument(parser, context, allowEmpty, refShorthandDefaultPos));
    }

    parser.expectClosing(openContext);

    return elts;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseExpressionListNonEmpty(parser, context, openContext, refShorthandDefaultPos) {
    const val = ___R$romejs$js$parser$parser$expression_ts$parseExpressionList(
    parser,
    context,
    openContext,
    false,
    refShorthandDefaultPos);

    return val;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseCallArgument(parser, context, maybeAllowEmpty, refShorthandDefaultPos, refNeedsArrowPos, refTrailingCommaPos) {
    const allowEmpty = Boolean(maybeAllowEmpty);

    let elt;
    if (allowEmpty && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      elt = undefined;
    } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      const spreadNodeStart = parser.state.startPos;

      elt = ___R$romejs$js$parser$parser$expression_ts$parseParenItem(
      parser,
      ___R$romejs$js$parser$parser$lval_ts$parseSpread(parser, refShorthandDefaultPos, refNeedsArrowPos),
      spreadNodeStart);

      if (refTrailingCommaPos && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        refTrailingCommaPos.index = parser.state.startPos.index;
      }
    } else {
      elt = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
      parser,
      context,
      false,
      refShorthandDefaultPos,
      ___R$romejs$js$parser$parser$expression_ts$parseParenItem,
      refNeedsArrowPos);
    }

    return elt;
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, liberal) {
    const start = parser.getPosition();
    const name = ___R$romejs$js$parser$parser$expression_ts$parseIdentifierName(parser, liberal);
    return ___R$romejs$js$parser$parser$expression_ts$createIdentifier(parser, start, name);
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser, liberal) {
    return ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, liberal));
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(parser, liberal) {
    return ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, liberal));
  }

  function ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(node) {
    return Object.assign({}, node, {
      type: 'BindingIdentifier'});
  }

  function ___R$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier(node) {
    return Object.assign({}, node, {
      type: 'AssignmentIdentifier'});
  }

  function ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(node) {
    return Object.assign({}, node, {
      type: 'ReferenceIdentifier'});
  }

  function ___R$romejs$js$parser$parser$expression_ts$toIdentifier(node) {
    return Object.assign({}, node, {
      type: 'Identifier'});
  }

  function ___R$romejs$js$parser$parser$expression_ts$createIdentifier(parser, start, name) {
    return {
      type: 'Identifier',
      name: name,
      loc: parser.finishLoc(start)};
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseIdentifierName(parser, liberal = false) {
    const loc = parser.finishLocAt(parser.state.startPos, parser.state.endPos);

    if (!liberal) {
      ___R$romejs$js$parser$parser$expression_ts$checkReservedWord(
      parser,
      String(parser.state.tokenValue),
      loc,
      !!parser.state.tokenType.keyword,
      false);
    }

    let name;

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
      name = String(parser.state.tokenValue);
    } else if (parser.state.tokenType.keyword !== undefined) {
      name = parser.state.tokenType.keyword;

      if ((name === 'class' || name === 'function') &&
      (parser.state.lastEndPos.index !== ___R$romejs$ob1$index_ts$inc(parser.state.lastStartPos.index) ||
      parser.input.charCodeAt(___R$romejs$ob1$index_ts$get0(parser.state.lastStartPos.index)) !==
      ___R$romejs$string$charcodes$index_ts.dot)) {
        parser.state.context.pop();
      }
    } else {
      parser.addDiagnostic({
        message: 'Expected an identifier here'});
      name = '';
    }

    if (!liberal) {
      ___R$romejs$js$parser$parser$expression_ts$checkReservedWord(
      parser,
      name,
      loc,
      parser.state.tokenType.keyword !== undefined,
      false);
    }

    parser.next();
    return name;
  }

  function ___R$romejs$js$parser$parser$expression_ts$checkReservedWord(parser, word, loc, checkKeywords, isBinding) {
    if (parser.isSyntaxEnabled('ts')) {
      return undefined;
    }

    if (parser.inScope('GENERATOR') && word === 'yield') {
      parser.addDiagnostic({
        loc: loc,
        message: 'Can not use \'yield\' as identifier inside a generator'});
    }

    if (parser.inScope('ASYNC') && word === 'await') {
      parser.addDiagnostic({
        loc: loc,
        message: 'Can not use keyword \'await\' outside an async function'});
    }

    if (parser.inScope('CLASS_PROPERTY') && word === 'arguments') {
      parser.addDiagnostic({
        loc: loc,
        message: '\'arguments\' is not allowed in class field initializer'});
    }

    if (checkKeywords && ___R$romejs$js$parser$utils$identifier_ts$isKeyword(word)) {
      parser.addDiagnostic({
        loc: loc,
        message: 'Unexpected keyword \'' + word + '\''});
    }

    let isReserved = false;
    if (parser.inScope('STRICT')) {
      if (isBinding) {
        isReserved = ___R$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(word, parser.inModule);
      } else {
        isReserved = ___R$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(word, parser.inModule);
      }
    } else {
      isReserved = ___R$romejs$js$parser$utils$identifier_ts$isReservedWord(word, parser.inModule);
    }

    if (isReserved) {
      if (!parser.inScope('ASYNC') && word === 'await') {
        parser.addDiagnostic({
          loc: loc,
          message: 'Can not use keyword \'await\' outside an async function'});
      } else {
        parser.addDiagnostic({
          loc: loc,
          message: word + ' is a reserved word'});
      }
    }
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseAwait(parser) {
    if (!parser.state.awaitPos) {
      parser.state.awaitPos = parser.state.index;
    }

    if (!parser.inScope('ASYNC')) {
      parser.addDiagnostic({
        message: 'Can\'t use await outside of an async function'});
    }

    const start = parser.getPosition();
    parser.next();

    if (parser.inScope('PARAMETERS')) {
      parser.addDiagnostic({
        message: 'await is not allowed in async function parameters'});
    }

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.star)) {
      parser.addDiagnostic({
        start: start,
        message: 'await* has been removed from the async functions proposal. Use Promise.all() instead.'});
    }

    const argument = ___R$romejs$js$parser$parser$expression_ts$parseMaybeUnary(parser, 'await argument');
    return {
      type: 'AwaitExpression',
      loc: parser.finishLoc(start),
      argument: argument};
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseYield(parser, noIn) {
    if (!parser.state.yieldPos) {
      parser.state.yieldPos = parser.state.index;
    }

    const start = parser.getPosition();

    if (parser.inScope('PARAMETERS')) {
      parser.addDiagnostic({
        start: start,
        message: 'yield is not allowed in generator parameters'});
    }

    if (parser.state.maybeInArrowParameters &&
    parser.state.yieldInPossibleArrowParameters === undefined) {
      parser.state.yieldInPossibleArrowParameters = start;
    }

    parser.next();

    let delegate;
    let argument;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.semi) ||
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.star) && !parser.state.tokenType.startsExpr ||
    parser.canInsertSemicolon()) {
      delegate = false;
    } else {
      delegate = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.star);
      argument = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'yield argument', noIn);
    }

    return {
      type: 'YieldExpression',
      loc: parser.finishLoc(start),
      delegate: delegate,
      argument: argument};
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$parseNullLiteral(parser) {
    const start = parser.getPosition();
    parser.next();
    return {
      type: 'NullLiteral',
      loc: parser.finishLoc(start)};
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser) {
    const start = parser.getPosition();
    const value = String(parser.state.tokenValue);
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'StringLiteral',
      value: value};
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$parseBigIntLiteral(parser) {
    const start = parser.getPosition();
    const value = String(parser.state.tokenValue);
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'BigIntLiteral',
      value: value};
  }

  function ___R$romejs$js$parser$parser$expression_ts$parseNumericLiteral(parser) {
    const start = parser.getPosition();
    const value = Number(parser.state.tokenValue);
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'NumericLiteral',
      value: value};
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$parseRegExpLiteral(parser) {
    const start = parser.getPosition();
    const value = parser.state.tokenValue;
    if (!(value instanceof ___R$romejs$js$parser$tokenizer$index_ts$RegExpTokenValue)) {
      throw new Error('Expected regex token value');
    }
    parser.next();

    const {flags: flags} = value;
    return {
      loc: parser.finishLoc(start),
      type: 'RegExpLiteral',
      pattern: value.pattern,
      global: flags.has('g'),
      multiline: flags.has('m'),
      sticky: flags.has('y'),
      insensitive: flags.has('i'),
      noDotNewline: flags.has('s'),
      unicode: flags.has('u')};
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$parseImportOrMetaProperty(parser) {
    if (parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.dot) {
      return ___R$romejs$js$parser$parser$expression_ts$parseImportMetaProperty(parser);
    } else {
      return ___R$$priv$romejs$js$parser$parser$expression_ts$parseImportCall(parser);
    }
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$parseImportCall(parser) {
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._import);

    const start = parser.getPosition();
    const openContext = parser.expectOpening(___R$romejs$js$parser$tokenizer$types_ts$types.parenL, ___R$romejs$js$parser$tokenizer$types_ts$types.parenR, 'array');

    let argument;

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR)) {
      parser.addDiagnostic({
        message: 'import() requires exactly one argument'});

      argument = ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
      parser.createUnknownIdentifier('import call argument'));
    } else {
      const callArg = ___R$romejs$js$parser$parser$expression_ts$parseCallArgument(
      parser,
      'call expression argument',
      false);
      if (callArg === undefined) {
        throw new Error('Expected argument, parseExpressionListItem was passed maybeAllowEmpty: false');
      } else {
        argument = callArg;
      }
    }

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      parser.addDiagnostic({
        start: parser.state.lastStartPos,
        end: parser.state.lastEndPos,
        message: 'Trailing comma is disallowed inside import(...) arguments'});
    }

    if (argument.type === 'SpreadElement') {
      parser.addDiagnostic({
        loc: argument.loc,
        message: 'Spread is not allowed in import()'});
    }

    parser.expectClosing(openContext);

    const spreadOrExpression = argument.type === 'AmbiguousFlowTypeCastExpression' ? argument.expression : argument;

    const expression = spreadOrExpression.type === 'SpreadElement' ? spreadOrExpression.argument : spreadOrExpression;

    return {
      type: 'ImportCall',
      loc: parser.finishLoc(start),
      argument: expression};
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$parseSuper(parser) {
    if (!parser.inScope('METHOD') &&
    !parser.inScope('CLASS_PROPERTY') &&
    parser.sourceType !== 'template') {
      parser.addDiagnostic({
        message: 'super is only allowed in object methods and classes'});
    }

    const start = parser.getPosition();
    parser.next();

    if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL) &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      parser.addDiagnostic({
        message: 'Invalid super suffix operator'});
    }

    const loc = parser.finishLoc(start);

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) &&
    (parser.getLastScope('METHOD') !== 'constructor' ||
    parser.getLastScope('CLASS') !== 'derived') &&
    parser.sourceType !== 'template') {
      parser.addDiagnostic({
        loc: loc,
        message: 'super() is only valid inside a class constructor of a subclass',
        advice: [{
          type: 'log',
          category: 'info',
          message: 'Maybe a typo in the method name (\'constructor\') or not extending another class?'}]});
    }

    return {
      type: 'Super',
      loc: loc};
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$parseDoExpression(parser) {
    const start = parser.getPosition();
    parser.next();
    const oldLabels = parser.state.labels;
    parser.state.labels = [];
    parser.pushScope('FUNCTION', false);
    const body = ___R$romejs$js$parser$parser$statement_ts$parseBlock(parser, false);
    parser.popScope('FUNCTION');
    parser.state.labels = oldLabels;
    return {
      type: 'DoExpression',
      body: body,
      loc: parser.finishLoc(start)};
  }

  function ___R$$priv$romejs$js$parser$parser$expression_ts$parseArrayExpression(parser, refShorthandDefaultPos) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL, ___R$romejs$js$parser$tokenizer$types_ts$types.bracketR, 'array');

    const elements = ___R$romejs$js$parser$parser$lval_ts$toReferencedListOptional(
    parser,
    ___R$romejs$js$parser$parser$expression_ts$parseExpressionList(
    parser,
    'array element',
    openContext,
    true,
    refShorthandDefaultPos));

    return {
      loc: parser.finishLoc(start),
      type: 'ArrayExpression',
      elements: elements};
  }

  // romejs/js-parser/parser/lval.ts

  const ___R$romejs$js$parser$parser$lval_ts = {
    toAssignmentPattern: ___R$romejs$js$parser$parser$lval_ts$toAssignmentPattern,
    toTargetAssignmentPattern: ___R$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern,
    toTargetBindingPattern: ___R$romejs$js$parser$parser$lval_ts$toTargetBindingPattern,
    toParamBindingPattern: ___R$romejs$js$parser$parser$lval_ts$toParamBindingPattern,
    toBindingPattern: ___R$romejs$js$parser$parser$lval_ts$toBindingPattern,
    toAssignmentObjectProperty: ___R$romejs$js$parser$parser$lval_ts$toAssignmentObjectProperty,
    toAssignableList: ___R$romejs$js$parser$parser$lval_ts$toAssignableList,
    toFunctionParamsBindingList: ___R$romejs$js$parser$parser$lval_ts$toFunctionParamsBindingList,
    toReferencedList: ___R$romejs$js$parser$parser$lval_ts$toReferencedList,
    toReferencedListOptional: ___R$romejs$js$parser$parser$lval_ts$toReferencedListOptional,
    toReferencedItem: ___R$romejs$js$parser$parser$lval_ts$toReferencedItem,
    filterSpread: ___R$romejs$js$parser$parser$lval_ts$filterSpread,
    toReferencedListDeep: ___R$romejs$js$parser$parser$lval_ts$toReferencedListDeep,
    toReferencedListDeepOptional: ___R$romejs$js$parser$parser$lval_ts$toReferencedListDeepOptional,
    parseSpread: ___R$romejs$js$parser$parser$lval_ts$parseSpread,
    parseTargetBindingPattern: ___R$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern,
    parseBindingList: ___R$romejs$js$parser$parser$lval_ts$parseBindingList,
    parseBindingListNonEmpty: ___R$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty,
    parseBindingListItem: ___R$romejs$js$parser$parser$lval_ts$parseBindingListItem,
    parseBindingListItemTypes: ___R$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes,
    parseMaybeDefault: ___R$romejs$js$parser$parser$lval_ts$parseMaybeDefault,
    checkLVal: ___R$romejs$js$parser$parser$lval_ts$checkLVal,
    checkToRestConversion: ___R$romejs$js$parser$parser$lval_ts$checkToRestConversion,
    hasCommaAfterRest: ___R$romejs$js$parser$parser$lval_ts$hasCommaAfterRest,
    raiseRestNotLast: ___R$romejs$js$parser$parser$lval_ts$raiseRestNotLast,
    checkCommaAfterRestFromSpread: ___R$romejs$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread};
  const ___R$$priv$romejs$js$parser$parser$lval_ts$VALID_REST_ARGUMENT_TYPES = ['Identifier', 'MemberExpression'];

  function ___R$romejs$js$parser$parser$lval_ts$toAssignmentPattern(parser, node, contextDescription) {
    switch (node.type) {
      case 'AssignmentObjectPattern':
      case 'AssignmentArrayPattern':
      case 'AssignmentAssignmentPattern':
      case 'AssignmentObjectPatternProperty':
      case 'AssignmentIdentifier':
      case 'MemberExpression':
        return node;

      case 'AmbiguousFlowTypeCastExpression':
        return ___R$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
        parser,
        ___R$romejs$js$parser$parser$type$systems_ts$ambiguousTypeCastToParameter(parser, node),
        contextDescription);

      case 'BindingIdentifier':
      case 'ReferenceIdentifier':
        return ___R$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier(node);

      case 'TSAsExpression':
        return Object.assign({}, node, {
          type: 'TSAssignmentAsExpression',
          expression: ___R$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
          parser,
          node.expression,
          contextDescription)});

      case 'TSNonNullExpression':
        return Object.assign({}, node, {
          type: 'TSAssignmentNonNullExpression',
          expression: ___R$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
          parser,
          node.expression,
          contextDescription)});

      case 'TSTypeAssertion':
        return Object.assign({}, node, {
          type: 'TSAssignmentTypeAssertion',
          expression: ___R$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
          parser,
          node.expression,
          contextDescription)});

      case 'ObjectExpression':
        {
          const props = [];
          let rest;
          for (let index = 0; index < node.properties.length; index++) {
            const prop = node.properties[index];
            if (prop.type === 'SpreadProperty') {
              const arg = ___R$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
              parser,
              prop.argument,
              contextDescription);
              if (arg.type === 'AssignmentIdentifier') {
                rest = arg;
              } else {
                parser.addDiagnostic({
                  loc: arg.loc,
                  message: 'Invalid rest operator\'s argument'});
              }
              continue;
            }

            const isLast = index === node.properties.length - 1;
            props.push(___R$romejs$js$parser$parser$lval_ts$toAssignmentObjectProperty(parser, prop, isLast));
          }
          return {
            type: 'AssignmentObjectPattern',
            loc: node.loc,
            properties: props,
            rest: rest};
        }

      case 'ArrayExpression':
        {
          const {list: elements, rest: rest} = ___R$romejs$js$parser$parser$lval_ts$toAssignableList(
          parser,
          node.elements,
          contextDescription);
          return {
            type: 'AssignmentArrayPattern',
            loc: node.loc,
            elements: elements,
            rest: rest};
        }

      case 'AssignmentExpression':
        {
          if (node.operator !== '=') {
            parser.addDiagnostic({
              loc: parser.getLoc(node.left),
              message: 'Only \'=\' operator can be used for specifying default value.'});
          }

          return {
            type: 'AssignmentAssignmentPattern',
            left: ___R$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(parser, node.left, contextDescription),
            right: node.right,
            loc: node.loc};
        }

      default:
        {
          const message = 'Invalid left-hand side in ' + contextDescription + ' ' + node.type;
          parser.addDiagnostic({
            loc: node.loc,
            message: message});
          return ___R$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier(
          parser.createUnknownIdentifier(contextDescription));
        }}
  }

  function ___R$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(parser, node, contextDescription) {
    const binding = ___R$romejs$js$parser$parser$lval_ts$toAssignmentPattern(parser, node, contextDescription);

    switch (binding.type) {
      case 'AssignmentIdentifier':
      case 'AssignmentArrayPattern':
      case 'AssignmentObjectPattern':
      case 'MemberExpression':
      case 'TSAssignmentAsExpression':
      case 'TSAssignmentNonNullExpression':
      case 'TSAssignmentTypeAssertion':
        return binding;

      default:
        parser.addDiagnostic({
          loc: node.loc,
          message: 'Not a valid assignment target'});
        return {
          type: 'AssignmentIdentifier',
          loc: node.loc,
          name: 'X'};}
  }

  function ___R$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(parser, node, contextDescription) {
    const binding = ___R$romejs$js$parser$parser$lval_ts$toBindingPattern(parser, node, contextDescription);

    switch (binding.type) {
      case 'BindingIdentifier':
      case 'BindingArrayPattern':
      case 'BindingObjectPattern':
        return binding;

      default:
        throw new Error('TODO ' + binding.type);}
  }

  function ___R$romejs$js$parser$parser$lval_ts$toParamBindingPattern(parser, node, contextDescription) {
    const binding = ___R$romejs$js$parser$parser$lval_ts$toBindingPattern(parser, node, contextDescription);

    switch (binding.type) {
      case 'BindingIdentifier':
      case 'BindingArrayPattern':
      case 'BindingObjectPattern':
      case 'BindingAssignmentPattern':
        return binding;

      default:
        throw new Error('TODO ' + binding.type);}
  }

  function ___R$romejs$js$parser$parser$lval_ts$toBindingPattern(parser, node, contextDescription) {
    const binding = ___R$romejs$js$parser$parser$lval_ts$toAssignmentPattern(parser, node, contextDescription);

    if (binding.type === 'MemberExpression') {
      parser.addDiagnostic({
        loc: node.loc,
        message: 'Binding member expression'});

      return {
        type: 'BindingIdentifier',
        name: 'X',
        loc: node.loc};
    }

    switch (binding.type) {
      case 'AssignmentObjectPattern':
        {
          const newNode = Object.assign({}, binding, {
            type: 'BindingObjectPattern',
            rest: binding.rest === undefined ? undefined : ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(binding.rest),
            properties: binding.properties.map(prop => {
              const bindingProp = ___R$romejs$js$parser$parser$lval_ts$toBindingPattern(
              parser,
              prop,
              contextDescription);

              if (bindingProp.type !== 'BindingObjectPatternProperty') {
                throw new Error('impossible condition');
              }

              return bindingProp;
            })});
          return newNode;
        }

      case 'AssignmentAssignmentPattern':
        {
          const newNode = Object.assign({}, binding, {
            type: 'BindingAssignmentPattern',
            left: ___R$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(parser, binding.left, contextDescription)});
          return newNode;
        }

      case 'AssignmentArrayPattern':
        {
          const newNode = Object.assign({}, binding, {
            type: 'BindingArrayPattern',
            elements: binding.elements.map(elem => elem === undefined ? elem : ___R$romejs$js$parser$parser$lval_ts$toParamBindingPattern(parser, elem, contextDescription)),
            rest: binding.rest === undefined ? undefined : ___R$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(parser, binding.rest, contextDescription)});
          return newNode;
        }

      case 'AssignmentIdentifier':
        {
          const newNode = Object.assign({}, binding, {
            type: 'BindingIdentifier'});
          return newNode;
        }

      case 'AssignmentObjectPatternProperty':
        {
          const newNode = Object.assign({}, binding, {
            type: 'BindingObjectPatternProperty',
            value: ___R$romejs$js$parser$parser$lval_ts$toBindingPattern(parser, binding.value, contextDescription)});
          return newNode;
        }

      default:
        throw new Error('Unknown node ' + node.type);}
  }

  function ___R$romejs$js$parser$parser$lval_ts$toAssignmentObjectProperty(parser, prop, isLast) {
    switch (prop.type) {
      case 'ObjectMethod':
        {
          const error = prop.kind === 'get' || prop.kind === 'set' ? 'Object pattern can\'t contain getter or setter' : 'Object pattern can\'t contain methods';

          parser.addDiagnostic({
            loc: prop.key.loc,
            message: error});

          const fakeProp = {
            type: 'AssignmentObjectPatternProperty',
            loc: prop.loc,
            key: {
              type: 'StaticPropertyKey',
              value: {
                type: 'Identifier',
                name: 'X',
                loc: prop.loc},
              loc: prop.loc},
            value: {
              type: 'AssignmentIdentifier',
              name: 'X',
              loc: prop.loc}};

          return fakeProp;
        }

      case 'ObjectProperty':
        return Object.assign({}, prop, {
          type: 'AssignmentObjectPatternProperty',
          value: ___R$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
          parser,
          prop.value,
          'assignment object property value')});

      default:
        parser.addDiagnostic({
          loc: prop.loc,
          message: 'Not a valid assignment object pattern property'});
        return {
          type: 'AssignmentObjectPatternProperty',
          loc: prop.loc,
          key: {
            type: 'StaticPropertyKey',
            loc: prop.loc,
            value: {
              type: 'Identifier',
              loc: prop.loc,
              name: 'X'}},
          value: {
            type: 'AssignmentIdentifier',
            loc: prop.loc,
            name: 'X'}};}
  }

  function ___R$romejs$js$parser$parser$lval_ts$toAssignableList(parser, exprList, contextDescription) {
    const newList = [];
    let rest;

    let end = exprList.length;

    if (end > 0) {
      let last = exprList[end - 1];

      if (last !== undefined && last.type === 'SpreadElement') {
        const arg = ___R$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
        parser,
        last.argument,
        contextDescription);
        rest = arg;
        end--;
      }

      if (last !== undefined &&
      last.type === 'AmbiguousFlowTypeCastExpression' &&
      last.expression.type === 'SpreadElement') {
        rest = ___R$romejs$js$parser$parser$type$systems_ts$ambiguousTypeCastToParameter(parser, Object.assign({}, last, {
          expression: last.expression.argument}));
        end--;
      }
    }

    for (let i = 0; i < end; i++) {
      const expr = exprList[i];
      if (expr === undefined) {
        continue;
      }

      if (expr.type === 'AmbiguousFlowTypeCastExpression') {
        exprList[i] = ___R$romejs$js$parser$parser$type$systems_ts$ambiguousTypeCastToParameter(parser, expr);
      }

      if (expr.type === 'TSAsExpression' || expr.type === 'TSTypeAssertion') {
        parser.addDiagnostic({
          loc: expr.loc,
          message: 'Unexpected type cast in parameter position'});
      }
    }

    for (let i = 0; i < end; i++) {
      const elt = exprList[i];
      if (elt === undefined) {
        continue;
      }

      if (elt.type === 'SpreadElement') {
        ___R$romejs$js$parser$parser$lval_ts$raiseRestNotLast(parser, parser.getLoc(elt));
      }

      const assign = ___R$romejs$js$parser$parser$lval_ts$toAssignmentPattern(parser, elt, contextDescription);
      newList.push(assign);
    }

    return {list: newList, rest: rest};
  }

  function ___R$romejs$js$parser$parser$lval_ts$toFunctionParamsBindingList(parser, exprList, contextDescription) {
    const bindingList = [];

    const {list: assignmentList, rest: assignmentRest} = ___R$romejs$js$parser$parser$lval_ts$toAssignableList(
    parser,
    exprList,
    contextDescription);

    const bindingRest = assignmentRest === undefined ? assignmentRest : ___R$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(parser, assignmentRest, contextDescription);

    for (const item of assignmentList) {
      if (item === undefined) {
        continue;
      }

      if (item.type === 'AssignmentAssignmentPattern') {
        const binding = ___R$romejs$js$parser$parser$lval_ts$toBindingPattern(parser, item, contextDescription);
        if (binding.type !== 'BindingAssignmentPattern') {
          throw new Error('TODO');
        }

        bindingList.push(binding);
        continue;
      }

      const binding = ___R$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(parser, item, contextDescription);
      bindingList.push(binding);
    }

    return {params: bindingList, rest: bindingRest};
  }

  function ___R$romejs$js$parser$parser$lval_ts$toReferencedList(parser, exprList, isParenthesizedExpr) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];
      exprList[i] = ___R$romejs$js$parser$parser$lval_ts$toReferencedItem(
      parser,
      expr,
      exprList.length > 1,
      isParenthesizedExpr);
    }

    return exprList;
  }

  function ___R$romejs$js$parser$parser$lval_ts$toReferencedListOptional(parser, exprList, isParenthesizedExpr) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];
      if (expr !== undefined) {
        exprList[i] = ___R$romejs$js$parser$parser$lval_ts$toReferencedItem(
        parser,
        expr,
        exprList.length > 1,
        isParenthesizedExpr);
      }
    }

    return exprList;
  }

  function ___R$romejs$js$parser$parser$lval_ts$toReferencedItem(parser, expr, multiple, isParenthesizedExpr) {
    if (expr.type !== 'AmbiguousFlowTypeCastExpression') {
      return expr;
    }

    if (parser.isSyntaxEnabled('ts')) {
      parser.addDiagnostic({
        loc: expr.loc,
        message: 'Flow type cast expressions aren\'t allowed in TypeScript'});
    }

    if (!parser.isParenthesized(expr) && (multiple || !isParenthesizedExpr)) {
      parser.addDiagnostic({
        loc: expr.loc,
        message: 'The type cast expression is expected to be wrapped with parentheses'});
    }

    if (expr.optional) {
      parser.addDiagnostic({
        loc: expr.loc,
        message: 'Type cast expressions cannot be optional. Did you mean for this to be a function parameter?'});
    }

    const {typeAnnotation: typeAnnotation, expression: expression} = expr;

    if (typeAnnotation === undefined) {
      parser.addDiagnostic({
        loc: expr.loc,
        message: 'Type cast expression has no type annotation. Did you mean for this to be a function parameter?'});
      return expression;
    }

    if (expression.type === 'SpreadElement') {
      throw new Error('I don\'t think a SpreadElement is ever allowed to hit this path?');
    }

    const node = {
      type: 'FlowTypeCastExpression',
      loc: expr.loc,
      typeAnnotation: typeAnnotation,
      expression: expression};
    return node;
  }

  function ___R$romejs$js$parser$parser$lval_ts$filterSpread(parser, elems) {
    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];
      if (elem.type === 'SpreadElement') {
        parser.addDiagnostic({
          message: 'Is this even ever possible?',
          loc: elem.loc});

        elems[i] = ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
        parser.createUnknownIdentifier('spread substitute'));
      }
    }

    return elems;
  }

  function ___R$romejs$js$parser$parser$lval_ts$toReferencedListDeep(parser, exprList, isParenthesizedExpr) {
    const refList = ___R$romejs$js$parser$parser$lval_ts$toReferencedList(parser, exprList, isParenthesizedExpr);
    ___R$$priv$romejs$js$parser$parser$lval_ts$toReferencedListDeepItems(parser, refList);
    return refList;
  }

  function ___R$romejs$js$parser$parser$lval_ts$toReferencedListDeepOptional(parser, exprList, isParenthesizedExpr) {
    const refList = ___R$romejs$js$parser$parser$lval_ts$toReferencedListOptional(
    parser,
    exprList,
    isParenthesizedExpr);
    ___R$$priv$romejs$js$parser$parser$lval_ts$toReferencedListDeepItems(parser, refList);
    return refList;
  }

  function ___R$$priv$romejs$js$parser$parser$lval_ts$toReferencedListDeepItems(parser, exprList) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];
      if (expr !== undefined && expr.type === 'ArrayExpression') {
        ___R$romejs$js$parser$parser$lval_ts$toReferencedListDeepOptional(parser, expr.elements);
      }
    }
  }

  function ___R$romejs$js$parser$parser$lval_ts$parseSpread(parser, refShorthandDefaultPos, refNeedsArrowPos) {
    const start = parser.getPosition();
    parser.next();

    const argument = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
    parser,
    'spread argument',
    false,
    refShorthandDefaultPos,
    undefined,
    refNeedsArrowPos);

    if (___R$romejs$ob1$index_ts$get0(parser.state.commaAfterSpreadAt) === -1 && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      parser.state.commaAfterSpreadAt = parser.state.index;
    }

    return {
      loc: parser.finishLoc(start),
      type: 'SpreadElement',
      argument: argument};
  }

  function ___R$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser) {
    switch (parser.state.tokenType) {
      case ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL:
        return ___R$$priv$romejs$js$parser$parser$lval_ts$parseArrayPattern(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.braceL:
        return ___R$romejs$js$parser$parser$expression_ts$parseObjectPattern(parser, ___R$romejs$js$parser$utils$location_ts$createIndexTracker());}

    return ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
  }

  function ___R$$priv$romejs$js$parser$parser$lval_ts$parseArrayPattern(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.bracketR,
    'array pattern');
    const {list: elements, rest: rest} = ___R$romejs$js$parser$parser$lval_ts$parseBindingList(parser, openContext, true);
    return {
      loc: parser.finishLoc(start),
      type: 'BindingArrayPattern',
      elements: elements,
      rest: rest};
  }

  function ___R$romejs$js$parser$parser$lval_ts$parseBindingList(parser, openContext, allowEmpty = false, allowTSModifiers = false) {
    const elts = [];
    let rest;

    let first = true;
    while (true) {
      if (parser.match(openContext.close) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (!parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
          parser.addDiagnostic({
            message: 'Expected a comma to separate items in ' + openContext.name});
          break;
        }
      }

      if (allowEmpty && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        elts.push(undefined);
      } else if (parser.match(openContext.close)) {
        parser.expectClosing(openContext);
        break;
      } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
        parser.next();

        rest = ___R$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes(
        parser,
        parser.getPosition(),
        ___R$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser));

        if (!___R$romejs$js$parser$parser$lval_ts$hasCommaAfterRest(parser)) {
          parser.expectClosing(openContext);
          break;
        }
      } else {
        elts.push(___R$romejs$js$parser$parser$lval_ts$parseBindingListItem(parser, allowTSModifiers));
      }
    }
    return {list: elts, rest: rest};
  }

  function ___R$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty(parser, openContext, allowTSModifiers) {
    const list = ___R$romejs$js$parser$parser$lval_ts$parseBindingList(parser, openContext, false, allowTSModifiers);

    return list;
  }

  function ___R$romejs$js$parser$parser$lval_ts$parseBindingListItem(parser, allowTSModifiers) {
    const start = parser.getPosition();

    let accessibility;
    let readonly = false;
    if (allowTSModifiers) {
      accessibility = ___R$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier(parser);
      readonly = ___R$romejs$js$parser$parser$typescript_ts$hasTSModifier(parser, ['readonly']);
    }

    const left = ___R$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes(
    parser,
    start,
    ___R$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser));
    const elt = ___R$romejs$js$parser$parser$lval_ts$parseMaybeDefault(parser, start, left);

    if (accessibility !== undefined || readonly) {
      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'Accessibility and readonly syntax found but TS is not enabled'});
      }

      if (elt.type !== 'BindingIdentifier' &&
      elt.type !== 'BindingAssignmentPattern') {
        parser.addDiagnostic({
          start: start,
          message: 'A parameter property may not be declared using a binding pattern.'});
      }

      return Object.assign({}, elt, {
        loc: parser.finishLoc(start),
        meta: {
          type: 'PatternMeta',
          loc: parser.finishLoc(start),
          accessibility: accessibility,
          readonly: readonly}});
    }

    return elt;
  }

  function ___R$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes(parser, start, param) {
    let typeAnnotation;
    let optional;

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.question)) {
      if (param.type !== 'BindingIdentifier') {
        parser.addDiagnostic({
          loc: param.loc,
          message: 'A binding pattern parameter cannot be optional in an implementation signature.'});
      }

      optional = true;
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___R$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
    }

    return Object.assign({}, param, {
      meta: {
        type: 'PatternMeta',
        loc: parser.finishLoc(start),
        optional: optional,
        typeAnnotation: typeAnnotation}});
  }

  function ___R$romejs$js$parser$parser$lval_ts$parseMaybeDefault(parser, start = parser.getPosition(), left = ___R$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(parser)) {
    let target;

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.eq)) {
      const right = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
      parser,
      'assignment pattern right');
      const assign = {
        loc: parser.finishLoc(start),
        type: 'BindingAssignmentPattern',
        left: left,
        right: right};
      target = assign;
    } else {
      target = left;
    }

    if (target.type === 'BindingAssignmentPattern' &&
    target.meta !== undefined &&
    target.meta.typeAnnotation !== undefined &&
    parser.getLoc(target.right).start.index <
    parser.getLoc(target.meta.typeAnnotation).start.index) {
      parser.addDiagnostic({
        loc: target.meta.typeAnnotation.loc,
        message: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`'});
    }

    return target;
  }

  const ___R$$priv$romejs$js$parser$parser$lval_ts$ALLOWED_PARENTHESIZED_LVAL_TYPES = ['Identifier', 'MemberExpression', 'TSAsExpression', 'TSTypeAssertion', 'TSAssignmentTypeAssertion', 'TSAssignmentAsExpression', 'TSAssignmentNonNullExpression'];

  function ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, expr, maybeIsBinding, checkClashes, contextDescription) {
    const isBinding = maybeIsBinding === undefined ? false : maybeIsBinding;

    if (parser.isParenthesized(expr) &&
    !___R$$priv$romejs$js$parser$parser$lval_ts$ALLOWED_PARENTHESIZED_LVAL_TYPES.includes(expr.type)) {
      let adviceMsg;
      if (expr.type === 'BindingObjectPattern') {
        adviceMsg = 'Did you use `({a}) = 0` instead of `({a} = 0)`?';
      } else if (expr.type === 'BindingArrayPattern') {
        adviceMsg = 'Did you use `([a]) = 0` instead of `([a] = 0)`?';
      }
      const advice = [];
      if (adviceMsg !== undefined) {
        advice.push({
          type: 'log',
          category: 'info',
          message: adviceMsg});
      }

      parser.addDiagnostic({
        message: 'Invalid parenthesized binding',
        advice: advice,
        loc: expr.loc});
    }

    switch (expr.type) {
      case 'FlowTypeCastExpression':
        return undefined;

      case 'TSAsExpression':
      case 'TSNonNullExpression':
      case 'TSTypeAssertion':
        ___R$romejs$js$parser$parser$lval_ts$checkLVal(
        parser,
        expr.expression,
        isBinding,
        checkClashes,
        contextDescription);
        return undefined;

      case 'BindingIdentifier':
      case 'ReferenceIdentifier':
      case 'AssignmentIdentifier':
        if (parser.inScope('STRICT') &&
        ___R$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(expr.name, parser.inModule)) {
          parser.addDiagnostic({
            loc: expr.loc,
            message: expr.name + ' is a reserved word'});
        }

        if (checkClashes !== undefined) {
          const clash = checkClashes.get(expr.name);

          if (clash === undefined) {
            checkClashes.set(expr.name, expr);
          } else {
            const loc = parser.getLoc(clash);
            parser.addDiagnostic({
              loc: expr.loc,
              message: 'Argument name clash in strict mode',
              advice: [{
                type: 'log',
                category: 'info',
                message: 'Collides with this existing definition'}, {
                type: 'frame',
                filename: parser.filename,
                start: loc.start,
                end: loc.end}]});
          }
        }
        break;

      case 'AssignmentObjectPattern':
      case 'BindingObjectPattern':
        if (expr.rest !== undefined) {
          ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, expr.rest, isBinding, checkClashes, 'rest property');
        }

        for (let prop of expr.properties) {
          if (prop.type === 'BindingObjectPatternProperty') {
            ___R$romejs$js$parser$parser$lval_ts$checkLVal(
            parser,
            prop.value,
            isBinding,
            checkClashes,
            'object destructuring pattern');
          } else {
            ___R$romejs$js$parser$parser$lval_ts$checkLVal(
            parser,
            prop,
            isBinding,
            checkClashes,
            'object destructuring pattern');
          }
        }
        break;

      case 'AssignmentObjectPatternProperty':
      case 'BindingObjectPatternProperty':
        break;

      case 'AssignmentArrayPattern':
      case 'BindingArrayPattern':
        if (expr.rest !== undefined) {
          ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, expr.rest, isBinding, checkClashes, 'rest element');
        }

        for (const elem of expr.elements) {
          if (elem) {
            ___R$romejs$js$parser$parser$lval_ts$checkLVal(
            parser,
            elem,
            isBinding,
            checkClashes,
            'array destructuring pattern');
          }
        }
        break;

      case 'BindingAssignmentPattern':
        ___R$romejs$js$parser$parser$lval_ts$checkLVal(
        parser,
        expr.left,
        isBinding,
        checkClashes,
        'assignment pattern');
        break;}
  }

  function ___R$romejs$js$parser$parser$lval_ts$checkToRestConversion(parser, node) {
    if (___R$$priv$romejs$js$parser$parser$lval_ts$VALID_REST_ARGUMENT_TYPES.includes(node.argument.type) === false) {
      parser.addDiagnostic({
        loc: node.argument.loc,
        message: 'Invalid rest operator\'s argument'});
    }
  }

  function ___R$romejs$js$parser$parser$lval_ts$hasCommaAfterRest(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      ___R$romejs$js$parser$parser$lval_ts$raiseRestNotLast(parser);
      return true;
    }

    return false;
  }

  function ___R$romejs$js$parser$parser$lval_ts$raiseRestNotLast(parser, loc, start) {
    parser.addDiagnostic({
      start: start,
      loc: loc,
      message: 'The rest element has to be the last element when destructuring'});
  }

  function ___R$romejs$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread(parser) {
    if (___R$romejs$ob1$index_ts$get0(parser.state.commaAfterSpreadAt) > -1) {
      ___R$romejs$js$parser$parser$lval_ts$raiseRestNotLast(
      parser,
      undefined,
      parser.getPositionFromIndex(parser.state.commaAfterSpreadAt));
    }
  }

  // romejs/js-parser/parser/jsx.ts

  const ___R$romejs$js$parser$parser$jsx_ts = {
    parseJSXText: ___R$romejs$js$parser$parser$jsx_ts$parseJSXText,
    parseJSXElement: ___R$romejs$js$parser$parser$jsx_ts$parseJSXElement};
  function ___R$$priv$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(node) {
    if (node === undefined) {
      return '';
    }

    switch (node.type) {
      case 'JSXIdentifier':
      case 'JSXReferenceIdentifier':
        return node.name;

      case 'JSXNamespacedName':
        return node.namespace.name + ':' + node.name.name;

      case 'JSXMemberExpression':
        return ___R$$priv$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(node.object) +
        '.' +
        ___R$$priv$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(node.property);}
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(parser) {
    const start = parser.getPosition();
    let name;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.jsxName)) {
      name = String(parser.state.tokenValue);
    } else if (parser.state.tokenType.keyword !== undefined) {
      name = parser.state.tokenType.keyword;
    } else {
      parser.addDiagnostic({
        message: 'Unknown JSX identifier token'});
      name = '';
    }
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'JSXIdentifier',
      name: name};
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXNamespacedName(parser) {
    const start = parser.getPosition();

    const namespace = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(parser);
    if (!parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      return namespace;
    }

    const name = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(parser);
    return {
      loc: parser.finishLoc(start),
      type: 'JSXNamespacedName',
      name: name,
      namespace: namespace};
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXElementName(parser) {
    const start = parser.getPosition();

    const namespacedName = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXNamespacedName(parser);

    let node;
    if (namespacedName.type === 'JSXIdentifier') {
      node = Object.assign({}, namespacedName, {
        type: 'JSXReferenceIdentifier'});
    } else {
      node = namespacedName;
    }

    while (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      const property = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(parser);
      node = {
        loc: parser.finishLoc(start),
        type: 'JSXMemberExpression',
        object: node,
        property: property};
    }

    return node;
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXAttributeValue(parser) {
    let node;
    switch (parser.state.tokenType) {
      case ___R$romejs$js$parser$tokenizer$types_ts$types.braceL:
        node = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXExpressionContainer(parser);
        if (node.expression.type === 'JSXEmptyExpression') {
          parser.addDiagnostic({
            loc: node.loc,
            message: 'JSX attributes must only be assigned a non-empty expression'});
        }
        return node;

      case ___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart:
        return ___R$romejs$js$parser$parser$jsx_ts$parseJSXElement(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.string:
        return ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);

      default:
        {
          parser.addDiagnostic({
            message: 'JSX value should be either an expression or a quoted JSX text'});
          return {
            type: 'StringLiteral',
            loc: parser.finishLoc(parser.getPosition()),
            value: '?'};
        }}
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXEmptyExpression(parser) {
    return {
      loc: parser.finishLoc(parser.state.lastEndPos),
      type: 'JSXEmptyExpression'};
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXSpreadChild(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
    'jsx spread child');
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis);
    const expression = ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'jsx spread child expression');
    parser.expectClosing(openContext);

    return {
      loc: parser.finishLoc(start),
      type: 'JSXSpreadChild',
      expression: expression};
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXExpressionContainer(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
    'jsx expression container');
    let expression;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
      expression = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXEmptyExpression(parser);
    } else {
      expression = ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'jsx inner expression container');
    }
    parser.expectClosing(openContext);
    return {
      loc: parser.finishLoc(start),
      type: 'JSXExpressionContainer',
      expression: expression};
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXAttribute(parser) {
    const start = parser.getPosition();

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
      const openContext = parser.expectOpening(
      ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
      ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
      'jsx attribute spread');
      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis);
      const argument = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'jsx attribute spread');
      parser.expectClosing(openContext);
      return {
        loc: parser.finishLoc(start),
        type: 'JSXSpreadAttribute',
        argument: argument};
    }

    const name = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXNamespacedName(parser);
    const value = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.eq) ? ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXAttributeValue(parser) : undefined;
    return {
      loc: parser.finishLoc(start),
      type: 'JSXAttribute',
      name: name,
      value: value};
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXOpeningElementAt(parser, start) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd)) {
      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd);
      return {
        typeArguments: undefined,
        name: undefined,
        loc: {
          filename: parser.filename,
          start: start,
          end: parser.getPosition()},
        attributes: [],
        selfClosing: false};
    }

    const attributes = [];
    const name = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXElementName(parser);

    let typeArguments;
    if (parser.isRelational('<')) {
      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'JSX element type arguments are only allowed in TS'});
      }

      typeArguments = ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(parser);
    }

    while (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.slash) &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd) &&
    !parser.atEOF()) {
      attributes.push(___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXAttribute(parser));
    }
    const selfClosing = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.slash);
    if (!parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd)) {
      parser.addDiagnostic({
        message: 'Unclosed JSX element open'});
    }
    return {
      typeArguments: typeArguments,
      name: name,
      attributes: attributes,
      selfClosing: selfClosing,
      loc: parser.getLoc(name)};
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXClosingElementAt(parser, start) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd)) {
      if (!parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd)) {
        parser.addDiagnostic({
          message: 'Unclosed JSX fragment close'});
      }

      return undefined;
    }

    const name = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXElementName(parser);

    if (!parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd)) {
      parser.addDiagnostic({
        message: 'Unclosed JSX element close'});
    }

    return name;
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$getJSXOpenElementAdvice(parser, def) {
    let message = 'Originated from this opening tag';

    if (def.name !== undefined) {
      message = 'Originated from opening tag of <emphasis>' + ___R$$priv$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
      def.name) + '</emphasis>';
    }

    const {loc: loc} = def;
    return [{
      type: 'log',
      category: 'info',
      message: message}, {
      type: 'frame',
      filename: parser.filename,
      start: loc.start,
      end: loc.end}];
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$getJSXCloseElementAdvice(parser, name, loc) {
    let message;
    if (name === undefined) {
      message = 'But found a closing fragment instead';
    } else {
      message = 'But found a closing tag of <emphasis>' + ___R$$priv$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
      name) + '</emphasis> instead';
    }

    return [{
      type: 'log',
      category: 'info',
      message: message}, {
      type: 'frame',
      filename: parser.filename,
      start: loc.start,
      end: loc.end}];
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$recoverFromUnclosedJSX(parser) {
    parser.state.context.pop();
    parser.state.exprAllowed = false;
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXElementAt(parser, start) {
    const children = [];
    const openingDef = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXOpeningElementAt(parser, start);

    let closingNameLoc;
    let closingName;

    if (openingDef.selfClosing === false) {
      contents: while (true) {
        switch (parser.state.tokenType) {
          case ___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart:
            {
              const start = parser.getPosition();
              parser.next();
              if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.slash)) {
                closingName = ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXClosingElementAt(parser, start);
                closingNameLoc = {
                  filename: parser.filename,
                  start: start,
                  end: parser.getPosition()};
                break contents;
              }
              children.push(___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXElementAt(parser, start));
              break;
            }

          case ___R$romejs$js$parser$tokenizer$types_ts$types.jsxText:
            children.push(___R$romejs$js$parser$parser$jsx_ts$parseJSXText(parser));
            break;

          case ___R$romejs$js$parser$tokenizer$types_ts$types.braceL:
            if (parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis) {
              children.push(___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXSpreadChild(parser));
            } else {
              children.push(___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXExpressionContainer(parser));
            }
            break;

          case ___R$romejs$js$parser$tokenizer$types_ts$types.eof:
            parser.addDiagnostic({
              message: 'Unclosed JSX element',
              advice: ___R$$priv$romejs$js$parser$parser$jsx_ts$getJSXOpenElementAdvice(parser, openingDef)});
            break contents;

          default:
            parser.addDiagnostic({
              message: 'Unknown JSX children start',
              advice: ___R$$priv$romejs$js$parser$parser$jsx_ts$getJSXOpenElementAdvice(parser, openingDef)});

            ___R$$priv$romejs$js$parser$parser$jsx_ts$recoverFromUnclosedJSX(parser);

            break contents;}
      }

      if (closingNameLoc === undefined) {
        closingName = openingDef.name;
        closingNameLoc = openingDef.loc;
      }

      if (openingDef.name === undefined && closingName !== undefined) {
        parser.addDiagnostic({
          loc: openingDef.loc,
          message: 'Expected JSX closing fragment tag',
          advice: ___R$$priv$romejs$js$parser$parser$jsx_ts$getJSXCloseElementAdvice(parser, closingName, closingNameLoc)});
      }

      if (openingDef.name !== undefined && closingName === undefined) {
        parser.addDiagnostic({
          loc: openingDef.loc,
          message: 'Expected a corresponding JSX closing tag for <emphasis>' + ___R$$priv$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
          openingDef.name) + '</emphasis>',
          advice: ___R$$priv$romejs$js$parser$parser$jsx_ts$getJSXCloseElementAdvice(parser, closingName, closingNameLoc)});
      }

      if (openingDef.name !== undefined && closingName !== undefined) {
        if (___R$$priv$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(closingName) !==
        ___R$$priv$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(openingDef.name)) {
          parser.addDiagnostic({
            loc: openingDef.loc,
            message: 'Expected a corresponding JSX closing tag for <emphasis>' + ___R$$priv$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
            openingDef.name) + '</emphasis>',
            advice: ___R$$priv$romejs$js$parser$parser$jsx_ts$getJSXCloseElementAdvice(parser, closingName, closingNameLoc)});
        }
      }
    }

    ___R$$priv$romejs$js$parser$parser$jsx_ts$checkAccidentalFragment(parser);

    const openingName = openingDef.name;
    if (openingName === undefined) {
      return {
        loc: parser.finishLoc(start),
        type: 'JSXFragment',
        children: children};
    } else {
      return {
        loc: parser.finishLoc(start),
        type: 'JSXElement',
        name: openingName,
        typeArguments: openingDef.typeArguments,
        attributes: openingDef.attributes,
        selfClosing: openingDef.selfClosing,
        children: children};
    }
  }

  function ___R$$priv$romejs$js$parser$parser$jsx_ts$checkAccidentalFragment(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.relational) && parser.state.tokenValue === '<') {
      parser.addDiagnostic({
        message: 'Adjacent JSX elements must be wrapped in an enclosing tag. ' +
        'Did you want a JSX fragment <>...</>?'});
    }
  }

  function ___R$romejs$js$parser$parser$jsx_ts$parseJSXText(parser) {
    const start = parser.getPosition();
    const value = String(parser.state.tokenValue);
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'JSXText',
      value: value};
  }

  function ___R$romejs$js$parser$parser$jsx_ts$parseJSXElement(parser) {
    if (!parser.isSyntaxEnabled('jsx')) {
      if (parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'JSX isn\'t allowed in regular TypeScript files',
          advice: [{
            type: 'log',
            category: 'info',
            message: 'Change the file extension to <emphasis>.tsx</emphasis> to enable JSX support'}]});
      } else {
        parser.addDiagnostic({
          message: 'JSX syntax isn\'t enabled',
          advice: [{
            type: 'log',
            category: 'info',
            message: 'Are you using <emphasis>TypeScript</emphasis>? Change the file extension to <emphasis>.tsx</emphasis>'}, {
            type: 'log',
            category: 'info',
            message: 'Are you using <emphasis>Flow</emphasis>? Add a <emphasis>@flow</emphasis> comment annotation to the top of the file'}, {
            type: 'log',
            category: 'info',
            message: 'Not using either? Change the file extension to <emphasis>.jsx</emphasis>'}]});
      }
    }

    const start = parser.getPosition();
    parser.next();
    return ___R$$priv$romejs$js$parser$parser$jsx_ts$parseJSXElementAt(parser, start);
  }

  // romejs/js-parser/parser/flow.ts

  const ___R$romejs$js$parser$parser$flow_ts = {
    hasTypeImportKind: ___R$romejs$js$parser$parser$flow_ts$hasTypeImportKind,
    isMaybeDefaultImport: ___R$romejs$js$parser$parser$flow_ts$isMaybeDefaultImport,
    parseFlowTypeParameterInstantiationCallOrNew: ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiationCallOrNew,
    parseFlowTypeAndPredicateInitialiser: ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAndPredicateInitialiser,
    parseFlowDeclare: ___R$romejs$js$parser$parser$flow_ts$parseFlowDeclare,
    parseFlowInterface: ___R$romejs$js$parser$parser$flow_ts$parseFlowInterface,
    checkReservedType: ___R$romejs$js$parser$parser$flow_ts$checkReservedType,
    parseFlowRestrictedIdentifier: ___R$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier,
    parseFlowTypeAliasTypeAnnotation: ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAliasTypeAnnotation,
    parseFlowOpaqueType: ___R$romejs$js$parser$parser$flow_ts$parseFlowOpaqueType,
    parseFlowTypeParameterDeclaration: ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration,
    parseFlowTypeParameterInstantiation: ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation,
    parseFlowTypeAnnotation: ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotation,
    parseFlowClassImplemented: ___R$romejs$js$parser$parser$flow_ts$parseFlowClassImplemented,
    parseFlowVariance: ___R$romejs$js$parser$parser$flow_ts$parseFlowVariance,
    parseAsyncArrowWithFlowTypeParameters: ___R$romejs$js$parser$parser$flow_ts$parseAsyncArrowWithFlowTypeParameters,
    parseFlowObjectTypeInternalSlot: ___R$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeInternalSlot};
  const ___R$$priv$romejs$js$parser$parser$flow_ts$primitiveTypes = ['any', 'bool', 'boolean', 'empty', 'false', 'mixed', 'null', 'number', 'bigint', 'static', 'string', 'true', 'typeof', 'void', 'interface', 'extends', '_'];

  const ___R$$priv$romejs$js$parser$parser$flow_ts$exportSuggestions = new Map([['const', 'declare export var'], ['let', 'declare export var'], ['type', 'export type'], ['interface', 'export interface']]);

  function ___R$$priv$romejs$js$parser$parser$flow_ts$checkNotUnderscore(parser, id) {
    if (id.name === '_') {
      parser.addDiagnostic({
        loc: id.loc,
        message: '`_` is only allowed as a type argument to call or new'});
    }
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$isEsModuleType(bodyElement) {
    return bodyElement.type === 'ExportAllDeclaration' ||
    bodyElement.type === 'ExportNamedDeclaration' &&
    (!bodyElement.declaration ||
    bodyElement.declaration.type !== 'TypeAliasTypeAnnotation' &&
    bodyElement.declaration.type !== 'FlowInterfaceDeclaration');
  }

  function ___R$romejs$js$parser$parser$flow_ts$hasTypeImportKind(kind) {
    return kind === 'type' || kind === 'typeof';
  }

  function ___R$romejs$js$parser$parser$flow_ts$isMaybeDefaultImport(state) {
    return (state.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.name || !!state.tokenType.keyword) &&
    state.tokenValue !== 'from';
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiationCallOrNew(parser) {
    const start = parser.getPosition();
    const params = [];

    parser.pushScope('TYPE', true);

    if (parser.expectRelational('<')) {
      while (!parser.isRelational('>')) {
        params.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeOrImplicitInstantiation(parser));

        if (!parser.isRelational('>') && !parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
          break;
        }
      }
      parser.expectRelational('>');
    }

    parser.popScope('TYPE');

    return {
      type: 'FlowTypeParameterInstantiation',
      loc: parser.finishLoc(start),
      params: params};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeOrImplicitInstantiation(parser) {
    if (parser.state.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.name && parser.state.tokenValue === '_') {
      const startPos = parser.state.startPos;
      const node = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
      return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowGenericType(parser, startPos, node);
    } else {
      return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
    }
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser, tok) {
    parser.pushScope('TYPE', true);
    parser.expect(tok || ___R$romejs$js$parser$tokenizer$types_ts$types.colon);
    const type = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
    parser.popScope('TYPE');
    return type;
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPredicate(parser) {
    const start = parser.getPosition();
    const moduloPos = parser.state.startPos;
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.modulo);
    const checksPos = parser.state.startPos;
    parser.expectContextual('checks');

    if (moduloPos.line !== checksPos.line ||
    ___R$romejs$ob1$index_ts$get0(moduloPos.column) !== ___R$romejs$ob1$index_ts$get0(checksPos.column) - 1) {
      parser.addDiagnostic({
        start: moduloPos,
        message: 'Spaces between \xb4%\xb4 and \xb4checks\xb4 are not allowed here.'});
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      const openContext = parser.expectOpening(
      ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
      ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
      'flow declared predicate');
      const value = ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'flow declared predicate');
      parser.expectClosing(openContext);
      return {
        loc: parser.finishLoc(start),
        type: 'FlowDeclaredPredicate',
        value: value};
    } else {
      return {
        loc: parser.finishLoc(start),
        type: 'FlowInferredPredicate'};
    }
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAndPredicateInitialiser(parser) {
    ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(
    parser,
    ' flow type and predicate initializer',
    parser.getPosition());

    parser.pushScope('TYPE', true);
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.colon);
    let type = undefined;
    let predicate = undefined;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.modulo)) {
      parser.popScope('TYPE');
      predicate = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPredicate(parser);
    } else {
      type = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
      parser.popScope('TYPE');
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.modulo)) {
        predicate = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPredicate(parser);
      }
    }
    return [type, predicate];
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareClass(parser, start) {
    parser.next();
    return Object.assign({}, ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceish(parser, true), {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareClass'});
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareFunction(parser, start) {
    parser.next();

    const id = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);

    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    }

    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
    'flow function type params');
    const {params: params, rest: rest} = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser);
    parser.expectClosing(openContext);

    const [returnType, predicate] = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAndPredicateInitialiser(parser);

    parser.semicolon();

    if (predicate !== undefined && predicate.type === 'FlowInferredPredicate') {
      parser.addDiagnostic({
        loc: predicate.loc,
        message: 'Predicate function declarations need to declare a predicate expression'});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareFunction',
      id: {
        type: 'BindingIdentifier',
        name: id.name,
        loc: parser.finishLoc(start),

        meta: {
          type: 'PatternMeta',
          loc: parser.finishLoc(start),
          typeAnnotation: {
            loc: parser.finishLoc(start),
            type: 'FlowFunctionTypeAnnotation',
            params: params,
            rest: rest,
            returnType: returnType,
            typeParameters: typeParameters}}},
      predicate: predicate};
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowDeclare(parser, start, insideModule = false) {
    ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'type declaration', start);

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._class)) {
      return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareClass(parser, start);
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._function)) {
      return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareFunction(parser, start);
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._var)) {
      return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareVariable(parser, start);
    }

    if (parser.isContextual('module')) {
      if (parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.dot) {
        return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareModuleExports(parser, start);
      } else {
        if (insideModule) {
          parser.addDiagnostic({
            message: '`declare module` cannot be used inside another `declare module`'});
        }
        return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareModule(parser, start);
      }
    }

    if (parser.isContextual('type')) {
      return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareTypeAlias(parser, start);
    }

    if (parser.isContextual('opaque')) {
      return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareOpaqueType(parser, start);
    }

    if (parser.isContextual('interface')) {
      return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareInterface(parser, start);
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._export)) {
      return ___R$$priv$romejs$js$parser$parser$flow_ts$parseExportNamedDeclaration(parser, start, insideModule);
    }

    parser.addDiagnostic({
      message: 'Unknown start to Flow declaration'});

    return {
      type: 'FlowDeclareVariable',
      loc: parser.finishLoc(start),
      id: ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
      parser.createUnknownIdentifier('flow declaration', start))};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareVariable(parser, start) {
    parser.next();
    const id = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotatableIdentifier(
    parser,
    true);
    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareVariable',
      id: id};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareModule(parser, start) {
    parser.next();

    let id;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
      id = ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
    } else {
      id = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    }

    const bodyStart = parser.getPosition();
    const body = [];
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
    'flow declare module body');

    while (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
      let bodyNodeStart = parser.getPosition();

      let bodyNode;
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._import)) {
        const lookahead = parser.lookaheadState();
        if (lookahead.tokenValue !== 'type' &&
        lookahead.tokenValue !== 'typeof') {
          parser.addDiagnostic({
            message: 'Imports within a `declare module` body must always be `import type` or `import typeof`'});
        }
        parser.next();
        bodyNode = ___R$romejs$js$parser$parser$modules_ts$parseImport(parser, bodyNodeStart);
      } else {
        if (!parser.expectContextual(
        'declare',
        'Only declares and type imports are allowed inside declare module')) {
          break;
        }

        bodyNode = ___R$romejs$js$parser$parser$flow_ts$parseFlowDeclare(parser, bodyNodeStart, true);
      }

      body.push(bodyNode);
    }

    parser.expectClosing(openContext);

    const bodyNode = {
      loc: parser.finishLoc(bodyStart),
      type: 'BlockStatement',
      body: body};

    let kind;
    let hasModuleExport = false;
    const errorMessage = 'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module';

    for (const bodyElement of body) {
      if (___R$$priv$romejs$js$parser$parser$flow_ts$isEsModuleType(bodyElement)) {
        if (kind === 'commonjs') {
          parser.addDiagnostic({
            loc: bodyElement.loc,
            message: errorMessage});
        }
        kind = 'es';
      } else if (bodyElement.type === 'FlowDeclareModuleExports') {
        if (hasModuleExport) {
          parser.addDiagnostic({
            loc: bodyElement.loc,
            message: 'Duplicate `declare module.exports` statement'});
        }

        if (kind === 'es') {
          parser.addDiagnostic({
            loc: bodyElement.loc,
            message: errorMessage});
        }

        kind = 'commonjs';
        hasModuleExport = true;
      }
    }

    return {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareModule',
      id: id,
      kind: kind === undefined ? 'commonjs' : kind,
      body: bodyNode};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseExportNamedDeclaration(parser, start, insideModule) {
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._export);

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types._default)) {
      let declaration;
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._function) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._class)) {
        declaration = ___R$romejs$js$parser$parser$flow_ts$parseFlowDeclare(parser, parser.getPosition());
      } else {
        declaration = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
        parser.semicolon();
      }

      return {
        loc: parser.finishLoc(start),
        type: 'FlowDeclareExportDefault',
        declaration: declaration};
    } else {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._const) ||
      ___R$romejs$js$parser$parser$statement_ts$isLetStart(parser) ||
      (parser.isContextual('type') || parser.isContextual('interface')) &&
      !insideModule) {
        const label = String(parser.state.tokenValue);
        const suggestion = String(___R$$priv$romejs$js$parser$parser$flow_ts$exportSuggestions.get(label));
        parser.addDiagnostic({
          message: '`declare export ' + label + '` is not supported. Use `' + suggestion + '` instead'});
      }

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._var) ||
      parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._function) ||
      parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._class) ||
      parser.isContextual('opaque')) {
        const declaration = ___R$romejs$js$parser$parser$flow_ts$parseFlowDeclare(parser, parser.getPosition());

        return {
          loc: parser.finishLoc(start),
          type: 'FlowDeclareExportNamed',
          declaration: declaration};
      }

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.star) ||
      parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL) ||
      parser.isContextual('interface') ||
      parser.isContextual('type') ||
      parser.isContextual('opaque')) {
        const node = ___R$romejs$js$parser$parser$modules_ts$parseExport(parser, start);

        if (node !== undefined) {
          if (node.type === 'ExportNamedDeclaration') {
            return Object.assign({}, node, {
              type: 'FlowDeclareExportNamed'});
          } else if (node.type === 'ExportAllDeclaration') {
            return Object.assign({}, node, {
              type: 'FlowDeclareExportAll'});
          }
        }
      }
    }

    parser.addDiagnostic({
      start: start,
      message: 'No valid start for Flow declare export declaration found'});

    return {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareExportDefault',
      declaration: Object.assign({}, parser.createUnknownStringLiteral(
      'flow declare export declaration',
      start), {
        type: 'StringLiteralTypeAnnotation'})};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareModuleExports(parser, start) {
    parser.expectContextual('module');
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.dot);
    parser.expectContextual('exports');
    const typeAnnotation = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotation(parser);
    parser.semicolon();

    return {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareModuleExports',
      typeAnnotation: typeAnnotation};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareTypeAlias(parser, start) {
    parser.next();
    return Object.assign({}, ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAliasTypeAnnotation(parser, start), {
      declare: true});
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareOpaqueType(parser, start) {
    parser.next();
    return Object.assign({}, ___R$romejs$js$parser$parser$flow_ts$parseFlowOpaqueType(parser, start, true), {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareOpaqueType'});
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowDeclareInterface(parser, start) {
    parser.next();
    return Object.assign({}, ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceish(parser), {
      loc: parser.finishLoc(start),
      type: 'FlowDeclareInterface'});
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceish(parser, isClass = false) {
    const id = ___R$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser, !isClass);

    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    }

    const _extends = [];
    const mixins = [];
    const _implements = [];

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types._extends)) {
      do {
        _extends.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (!isClass && parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma));
    }

    if (parser.isContextual('mixins')) {
      parser.next();
      do {
        mixins.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma));
    }

    if (parser.isContextual('implements')) {
      parser.next();
      do {
        _implements.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma));
    }

    const body = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectType(parser, {
      allowStatic: isClass,
      allowExact: false,
      allowSpread: false,
      allowProto: isClass,
      allowInexact: false});
    return {
      body: body,
      extends: _extends,
      mixins: mixins,
      id: id,
      typeParameters: typeParameters,
      implements: _implements};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceType(parser) {
    const start = parser.getPosition();
    parser.expectContextual('interface');

    const _extends = [];
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types._extends)) {
      do {
        _extends.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceExtends(parser));
      } while (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma));
    }

    const body = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectType(parser, {
      allowStatic: false,
      allowExact: false,
      allowSpread: false,
      allowProto: false,
      allowInexact: false});

    return {
      type: 'FlowInterfaceTypeAnnotation',
      loc: parser.finishLoc(start),
      extends: _extends,
      body: body};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceExtends(parser) {
    const start = parser.getPosition();

    const id = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowQualifiedTypeIdentifier(parser);
    let typeParameters = undefined;
    if (parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation(parser);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'FlowInterfaceExtends',
      id: id,
      typeParameters: typeParameters};
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowInterface(parser, start) {
    ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'interface declaration', start);
    return Object.assign({}, ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceish(parser), {
      loc: parser.finishLoc(start),
      type: 'FlowInterfaceDeclaration'});
  }

  function ___R$romejs$js$parser$parser$flow_ts$checkReservedType(parser, word, loc) {
    if (___R$$priv$romejs$js$parser$parser$flow_ts$primitiveTypes.includes(word)) {
      parser.addDiagnostic({
        loc: loc,
        message: 'Cannot overwrite primitive type ' + word});
    }
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser, liberal) {
    ___R$romejs$js$parser$parser$flow_ts$checkReservedType(
    parser,
    String(parser.state.tokenValue),
    parser.finishLocAt(parser.state.startPos, parser.state.endPos));
    return ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser, liberal);
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAliasTypeAnnotation(parser, start) {
    ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'type alias', start);

    const id = ___R$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser);
    let typeParameters;

    if (parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    } else {
      typeParameters = undefined;
    }

    const right = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.eq);
    parser.semicolon();

    return {
      loc: parser.finishLoc(start),
      type: 'TypeAliasTypeAnnotation',
      id: id,
      typeParameters: typeParameters,
      right: right};
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowOpaqueType(parser, start, declare) {
    ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'opaque type', start);
    parser.expectContextual('type');
    const id = ___R$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser, true);

    let typeParameters;
    if (parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, true);
    } else {
      typeParameters = undefined;
    }

    let supertype = undefined;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      supertype = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.colon);
    }

    let impltype = undefined;
    if (!declare) {
      impltype = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.eq);
    }
    parser.semicolon();

    return {
      loc: parser.finishLoc(start),
      type: 'FlowOpaqueType',
      id: id,
      typeParameters: typeParameters,
      supertype: supertype,
      impltype: impltype};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeParameter(parser, allowDefault = true, requireDefault = false) {
    const start = parser.getPosition();

    const variance = ___R$romejs$js$parser$parser$flow_ts$parseFlowVariance(parser);

    const ident = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotatableIdentifier(parser);
    const name = ident.name;
    const bound = ident.meta !== undefined ? ident.meta.typeAnnotation : undefined;

    let def;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eq)) {
      if (!allowDefault) {
        parser.addDiagnostic({
          message: 'Default type parameters arent allowed here'});
      }

      parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.eq);
      def = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
    } else if (requireDefault) {
      parser.addDiagnostic({
        message: 'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.'});
    }

    return {
      loc: parser.finishLoc(start),
      type: 'FlowTypeParameter',
      default: def,
      name: name,
      variance: variance,
      bound: bound};
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, allowDefault) {
    const start = parser.getPosition();
    ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'type parameter declaration', start);

    const params = [];

    parser.pushScope('TYPE', true);

    parser.expectRelational('<');

    let defaultRequired = false;

    do {
      const param = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeParameter(parser, allowDefault, defaultRequired);

      if (param.default) {
        defaultRequired = true;
      }

      params.push(param);

      if (!parser.isRelational('>') && !parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    } while (!parser.isRelational('>'));

    parser.expectRelational('>');

    parser.popScope('TYPE');

    return {
      loc: parser.finishLoc(start),
      type: 'FlowTypeParameterDeclaration',
      params: params};
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation(parser) {
    const start = parser.getPosition();
    ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'type parameter instantiation', start);

    const params = [];

    parser.pushScope('TYPE', true);

    parser.expectRelational('<');
    const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
    parser.state.noAnonFunctionType = false;

    while (!parser.isRelational('>')) {
      params.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser));

      if (!parser.isRelational('>') && !parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    parser.state.noAnonFunctionType = oldNoAnonFunctionType;
    parser.expectRelational('>');

    parser.popScope('TYPE');

    return {
      loc: parser.finishLoc(start),
      type: 'FlowTypeParameterInstantiation',
      params: params};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectPropertyKey(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.num)) {
      return ___R$romejs$js$parser$parser$expression_ts$parseNumericLiteral(parser);
    } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
      return ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
    } else {
      return ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
    }
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeIndexer(parser, start, isStatic, variance) {
    let id;
    let key;

    if (parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.colon) {
      id = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectPropertyKey(parser);
      key = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);
    } else {
      id = undefined;
      key = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
    }
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR);
    const value = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);

    return {
      loc: parser.finishLoc(start),
      type: 'FlowObjectTypeIndexer',
      static: isStatic,
      key: key,
      id: id,
      value: value,
      variance: variance};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeMethodish(parser, start) {
    let typeParameters = undefined;

    if (parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, false);
    }

    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
    'function object method params');
    const {params: params, rest: rest} = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser);
    parser.expectClosing(openContext);
    const returnType = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);

    return {
      loc: parser.finishLoc(start),
      type: 'FlowFunctionTypeAnnotation',
      params: params,
      rest: rest,
      typeParameters: typeParameters,
      returnType: returnType};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeCallProperty(parser, start, isStatic) {
    const valueNode = parser.getPosition();
    const value = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeMethodish(parser, valueNode);
    return {
      loc: parser.finishLoc(start),
      type: 'FlowObjectTypeCallProperty',
      static: isStatic,
      value: value};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectType(parser, opts) {
    const {allowExact: allowExact, allowSpread: allowSpread, allowProto: allowProto, allowInexact: allowInexact} = opts;
    let {allowStatic: allowStatic} = opts;

    parser.pushScope('TYPE', true);

    const start = parser.getPosition();

    const properties = [];

    let openContext;
    let exact;
    let inexact;
    if (allowExact && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceBarL)) {
      openContext = parser.expectOpening(
      ___R$romejs$js$parser$tokenizer$types_ts$types.braceBarL,
      ___R$romejs$js$parser$tokenizer$types_ts$types.braceBarR,
      'flow exact object');
      exact = true;
    } else {
      openContext = parser.expectOpening(___R$romejs$js$parser$tokenizer$types_ts$types.braceL, ___R$romejs$js$parser$tokenizer$types_ts$types.braceR, 'flow object');
      exact = false;
    }

    while (true) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof) || parser.match(openContext.close)) {
        break;
      }

      const start = parser.getPosition();
      let isStatic = false;
      let protoStart = undefined;

      if (allowProto && parser.isContextual('proto')) {
        const lookahead = parser.lookaheadState();

        if (lookahead.tokenType !== ___R$romejs$js$parser$tokenizer$types_ts$types.colon &&
        lookahead.tokenType !== ___R$romejs$js$parser$tokenizer$types_ts$types.question) {
          parser.next();
          protoStart = parser.state.startPos;
          allowStatic = false;
        }
      }

      if (allowStatic && parser.isContextual('static')) {
        const lookahead = parser.lookaheadState();

        if (lookahead.tokenType !== ___R$romejs$js$parser$tokenizer$types_ts$types.colon &&
        lookahead.tokenType !== ___R$romejs$js$parser$tokenizer$types_ts$types.question) {
          parser.next();
          isStatic = true;
        }
      }

      const variance = ___R$romejs$js$parser$parser$flow_ts$parseFlowVariance(parser);

      if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
        if (protoStart !== undefined) {
          parser.unexpectedToken(protoStart);
        }

        if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
          if (variance) {
            parser.addDiagnostic({
              loc: variance.loc,
              message: 'Variance not allowed'});
          }

          properties.push(
          ___R$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeInternalSlot(parser, start, isStatic));
        } else {
          properties.push(
          ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeIndexer(parser, start, isStatic, variance));
        }
      } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.isRelational('<')) {
        if (protoStart !== undefined) {
          parser.unexpectedToken(protoStart);
        }

        if (variance) {
          parser.addDiagnostic({
            loc: variance.loc,
            message: 'Variance not allowed'});
        }

        properties.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeCallProperty(parser, start, isStatic));
      } else {
        let kind = 'init';

        if (parser.isContextual('get') || parser.isContextual('set')) {
          const lookahead = parser.lookaheadState();
          if (lookahead.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.name ||
          lookahead.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.string ||
          lookahead.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.num) {
            const value = String(parser.state.tokenValue);
            if (value !== 'get' && value !== 'set') {
              throw new Error('Expected get or set as we already validated it above');
            }
            kind = value;
            parser.next();
          }
        }

        const propOrInexact = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeProperty(parser, {
          start: start,
          isStatic: isStatic,
          protoStart: protoStart,
          variance: variance,
          kind: kind,
          allowSpread: allowSpread,
          allowInexact: allowInexact});

        if (propOrInexact === undefined) {
          inexact = true;
        } else {
          properties.push(propOrInexact);
        }
      }

      ___R$$priv$romejs$js$parser$parser$flow_ts$flowObjectTypeSemicolon(parser);
    }

    parser.expectClosing(openContext);
    parser.popScope('TYPE');

    return {
      loc: parser.finishLoc(start),
      type: 'FlowObjectTypeAnnotation',
      properties: properties,
      exact: exact,
      inexact: inexact};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeProperty(parser, opts) {
    const {
      start: start,
      isStatic: isStatic,
      protoStart: protoStart,
      variance: variance,
      kind: kind,
      allowSpread: allowSpread,
      allowInexact: allowInexact} = opts;

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      if (!allowSpread) {
        parser.addDiagnostic({
          message: 'Spread operator cannot appear in class or interface definitions'});
      }

      if (protoStart !== undefined) {
        parser.unexpectedToken(protoStart);
      }

      if (variance) {
        parser.addDiagnostic({
          loc: variance.loc,
          message: 'Spread properties cannot have variance'});
      }

      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis);

      const isInexactToken = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma) || parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.semi);

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
        if (allowInexact) {
          return undefined;
        }

        parser.addDiagnostic({
          message: 'Explicit inexact syntax is only allowed inside inexact objects'});
      }

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceBarR)) {
        parser.addDiagnostic({
          message: 'Explicit inexact syntax cannot appear inside an explicit exact object type'});
      }

      if (isInexactToken) {
        parser.addDiagnostic({
          message: 'Explicit inexact syntax must appear at the end of an inexact object'});
      }

      const argument = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
      return {
        loc: parser.finishLoc(start),
        type: 'FlowObjectTypeSpreadProperty',
        argument: argument};
    } else {
      const proto = protoStart !== undefined;
      const key = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectPropertyKey(parser);
      let value = undefined;
      let optional = false;

      if (parser.isRelational('<') || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
        if (protoStart !== undefined) {
          parser.unexpectedToken(protoStart);
        }

        if (variance) {
          parser.addDiagnostic({
            loc: variance.loc,
            message: 'Type methods can\'t have variance'});
        }

        value = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeMethodish(parser, start);

        if (kind === 'get' || kind === 'set') {
          ___R$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(parser, value, kind);
        }
      } else {
        if (kind !== 'init') {
          parser.unexpectedToken();
        }

        if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.question)) {
          optional = true;
        }
        value = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);
      }

      return {
        loc: parser.finishLoc(start),
        type: 'FlowObjectTypeProperty',
        key: key,
        static: isStatic,
        kind: kind,
        value: value,
        variance: variance,
        optional: optional,
        proto: proto};
    }
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$flowObjectTypeSemicolon(parser) {
    if (!parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.semi) &&
    !parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma) &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR) &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceBarR)) {
      parser.unexpectedToken();
    }
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowQualifiedTypeIdentifier(parser, start = parser.getPosition(), id) {
    let node = id === undefined ? ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser) : id;

    while (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      const id = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
      node = {
        loc: parser.finishLoc(start),
        type: 'FlowQualifiedTypeIdentifier',
        id: id,
        qualification: node};
    }

    return node;
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowGenericType(parser, start, _id) {
    let typeParameters = undefined;
    const id = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowQualifiedTypeIdentifier(parser, start, _id);

    if (parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation(parser);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'FlowGenericTypeAnnotation',
      id: id,
      typeParameters: typeParameters};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeofType(parser) {
    const start = parser.getPosition();
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._typeof);
    const argument = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPrimaryType(parser);
    return {
      loc: parser.finishLoc(start),
      type: 'FlowTypeofTypeAnnotation',
      argument: argument};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTupleType(parser) {
    const start = parser.getPosition();
    const types = [];
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.bracketR,
    'flow tuple type');

    while (parser.state.index < parser.length && !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR)) {
      types.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser));
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR)) {
        break;
      }

      if (!parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    }
    parser.expectClosing(openContext);
    return {
      loc: parser.finishLoc(start),
      type: 'FlowTupleTypeAnnotation',
      types: types};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParam(parser) {
    let name = undefined;
    let optional = false;
    let typeAnnotation = undefined;
    const start = parser.getPosition();
    const lh = parser.lookaheadState();
    if (lh.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.colon || lh.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.question) {
      name = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
      if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.question)) {
        optional = true;
      }
      typeAnnotation = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);
    } else {
      typeAnnotation = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
    }
    return {
      loc: parser.finishLoc(start),
      type: 'FlowFunctionTypeParam',
      name: name,
      meta: {
        type: 'PatternMeta',
        loc: parser.finishLoc(start),
        optional: optional,
        typeAnnotation: typeAnnotation}};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$reinterpretTypeAsFlowFunctionTypeParam(parser, type) {
    const loc = parser.finishLoc(parser.getLoc(type).start);
    return {
      type: 'FlowFunctionTypeParam',
      loc: loc,
      name: undefined,
      meta: {
        type: 'PatternMeta',
        loc: loc,
        optional: false,
        typeAnnotation: type}};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser) {
    const params = [];
    let rest;

    while (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR) && !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      params.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParam(parser));

      if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR) && !parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      const param = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParam(parser);
      rest = param;
    }

    return {params: params, rest: rest};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$flowIdentToTypeAnnotation(parser, start, id) {
    switch (id.name) {
      case 'any':
        return {
          loc: parser.finishLoc(start),
          type: 'AnyKeywordTypeAnnotation'};

      case 'bool':
      case 'boolean':
        return {
          loc: parser.finishLoc(start),
          type: 'BooleanKeywordTypeAnnotation'};

      case 'mixed':
        return {
          loc: parser.finishLoc(start),
          type: 'MixedKeywordTypeAnnotation'};

      case 'empty':
        return {
          loc: parser.finishLoc(start),
          type: 'EmptyKeywordTypeAnnotation'};

      case 'number':
        return {
          loc: parser.finishLoc(start),
          type: 'NumberKeywordTypeAnnotation'};

      case 'string':
        return {
          loc: parser.finishLoc(start),
          type: 'StringKeywordTypeAnnotation'};

      case 'bigint':
        return {
          loc: parser.finishLoc(start),
          type: 'BigIntKeywordTypeAnnotation'};

      default:
        ___R$$priv$romejs$js$parser$parser$flow_ts$checkNotUnderscore(parser, id);
        return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowGenericType(parser, start, id);}
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPrimaryType(parser) {
    const start = parser.getPosition();
    let type;
    let isGroupedType = false;
    const oldNoAnonFunctionType = parser.state.noAnonFunctionType;

    switch (parser.state.tokenType) {
      case ___R$romejs$js$parser$tokenizer$types_ts$types.name:
        if (parser.isContextual('interface')) {
          return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowInterfaceType(parser);
        }

        return ___R$$priv$romejs$js$parser$parser$flow_ts$flowIdentToTypeAnnotation(parser, start, ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser));

      case ___R$romejs$js$parser$tokenizer$types_ts$types.braceL:
        return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectType(parser, {
          allowStatic: false,
          allowExact: false,
          allowSpread: true,
          allowProto: false,
          allowInexact: true});

      case ___R$romejs$js$parser$tokenizer$types_ts$types.braceBarL:
        return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectType(parser, {
          allowStatic: false,
          allowExact: true,
          allowSpread: true,
          allowProto: false,
          allowInexact: false});

      case ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL:
        return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTupleType(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.relational:
        if (parser.state.tokenValue === '<') {
          const typeParameters = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, false);
          const openContext = parser.expectOpening(
          ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
          ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
          'flow function params');
          const {params: params, rest: rest} = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser);
          parser.expectClosing(openContext);

          parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.arrow);

          const returnType = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);

          return {
            loc: parser.finishLoc(start),
            type: 'FlowFunctionTypeAnnotation',
            typeParameters: typeParameters,
            params: params,
            rest: rest,
            returnType: returnType};
        }
        break;

      case ___R$romejs$js$parser$tokenizer$types_ts$types.parenL:
        {
          const openContext = parser.expectOpening(
          ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
          ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
          'flow function params');

          if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR) && !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
            if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
              const token = parser.lookaheadState().tokenType;
              isGroupedType = token !== ___R$romejs$js$parser$tokenizer$types_ts$types.question && token !== ___R$romejs$js$parser$tokenizer$types_ts$types.colon;
            } else {
              isGroupedType = true;
            }
          }

          if (isGroupedType) {
            parser.state.noAnonFunctionType = false;
            type = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
            parser.state.noAnonFunctionType = oldNoAnonFunctionType;

            if (parser.state.noAnonFunctionType ||
            !(parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma) ||
            parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR) &&
            parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.arrow)) {
              parser.expectClosing(openContext);
              return type;
            } else {
              parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma);
            }
          }

          let params;
          let rest;
          if (type) {
            const firstParam = ___R$$priv$romejs$js$parser$parser$flow_ts$reinterpretTypeAsFlowFunctionTypeParam(parser, type);
            ({params: params, rest: rest} = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser));
            params = [firstParam, ...params];
          } else {
            ({params: params, rest: rest} = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowFunctionTypeParams(parser));
          }

          parser.expectClosing(openContext);
          parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.arrow);

          const returnType = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);

          return {
            loc: parser.finishLoc(start),
            type: 'FlowFunctionTypeAnnotation',
            typeParameters: undefined,
            params: params,
            rest: rest,
            returnType: returnType};
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types.num:
      case ___R$romejs$js$parser$tokenizer$types_ts$types.string:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._true:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._false:
      case ___R$romejs$js$parser$tokenizer$types_ts$types.plusMin:
        return ___R$romejs$js$parser$parser$type$systems_ts$parseTypeLiteralAnnotation(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._void:
        parser.next();
        return {
          type: 'VoidKeywordTypeAnnotation',
          loc: parser.finishLoc(start)};

      case ___R$romejs$js$parser$tokenizer$types_ts$types._null:
        parser.next();
        return {
          type: 'NullKeywordTypeAnnotation',
          loc: parser.finishLoc(start)};

      case ___R$romejs$js$parser$tokenizer$types_ts$types._this:
        parser.next();
        return {
          type: 'FlowThisTypeAnnotation',
          loc: parser.finishLoc(start)};

      case ___R$romejs$js$parser$tokenizer$types_ts$types.star:
        parser.next();
        return {
          type: 'FlowExistsTypeAnnotation',
          loc: parser.finishLoc(start)};

      default:
        if (parser.state.tokenType.keyword === 'typeof') {
          return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeofType(parser);
        } else if (parser.state.tokenType.keyword !== undefined) {
          const label = parser.state.tokenType.label;
          parser.next();
          const id = ___R$romejs$js$parser$parser$expression_ts$createIdentifier(parser, start, label);
          return ___R$$priv$romejs$js$parser$parser$flow_ts$flowIdentToTypeAnnotation(parser, start, id);
        }}

    parser.addDiagnostic({
      message: 'Unknown flow primarty type start'});

    return {
      type: 'MixedKeywordTypeAnnotation',
      loc: parser.finishLoc(start)};
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPostfixType(parser) {
    const startPos = parser.state.startPos;
    let type = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPrimaryType(parser);
    while (!parser.canInsertSemicolon() && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      const elementType = type;
      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL);
      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR);
      type = {
        loc: parser.finishLoc(startPos),
        type: 'FlowArrayTypeAnnotation',
        elementType: elementType};
    }
    return type;
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPrefixType(parser) {
    const start = parser.getPosition();
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.question)) {
      return {
        loc: parser.finishLoc(start),
        type: 'FlowNullableTypeAnnotation',
        typeAnnotation: ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPrefixType(parser)};
    } else {
      return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPostfixType(parser);
    }
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowAnonFunctionWithoutParens(parser) {
    const param = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowPrefixType(parser);

    if (!parser.state.noAnonFunctionType && parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.arrow)) {
      const start = parser.getLoc(param).start;
      const params = [___R$$priv$romejs$js$parser$parser$flow_ts$reinterpretTypeAsFlowFunctionTypeParam(parser, param)];
      const returnType = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser);
      return {
        loc: parser.finishLoc(start),
        type: 'FlowFunctionTypeAnnotation',
        params: params,
        returnType: returnType};
    }

    return param;
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowIntersectionType(parser) {
    const start = parser.getPosition();
    parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.bitwiseAND);

    const type = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowAnonFunctionWithoutParens(parser);
    const types = [type];
    while (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.bitwiseAND)) {
      types.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowAnonFunctionWithoutParens(parser));
    }

    if (types.length === 1) {
      return type;
    } else {
      return {
        loc: parser.finishLoc(start),
        type: 'IntersectionTypeAnnotation',
        types: types};
    }
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$eatUnionBitwise(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.logicalOR)) {
      parser.addDiagnostic({
        message: 'Unexpected ||, did you mean just |?'});
      parser.next();
    } else {
      parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.bitwiseOR);
    }
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowUnionType(parser) {
    const start = parser.getPosition();
    ___R$$priv$romejs$js$parser$parser$flow_ts$eatUnionBitwise(parser);

    const type = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowIntersectionType(parser);
    const types = [type];

    while (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.logicalOR) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bitwiseOR)) {
      ___R$$priv$romejs$js$parser$parser$flow_ts$eatUnionBitwise(parser);
      types.push(___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowIntersectionType(parser));
    }

    if (types.length === 1) {
      return type;
    } else {
      return {
        loc: parser.finishLoc(start),
        type: 'UnionTypeAnnotation',
        types: types};
    }
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowType(parser) {
    parser.pushScope('TYPE', true);
    const type = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowUnionType(parser);
    parser.popScope('TYPE');

    parser.state.exprAllowed =
    parser.state.exprAllowed || parser.state.noAnonFunctionType;
    return type;
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotation(parser) {
    const start = parser.getPosition();
    ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'type annotation', start);
    return ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);
  }

  function ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotatableIdentifier(parser, allowPrimitiveOverride = false) {
    const start = parser.getPosition();
    const ident = allowPrimitiveOverride ? ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser) : ___R$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser);

    let typeAnnotation = undefined;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotation(parser);
    }

    if (typeAnnotation === undefined) {
      return ident;
    } else {
      return Object.assign({}, ident, {
        loc: parser.finishLoc(start),
        meta: {
          type: 'PatternMeta',
          loc: parser.finishLoc(start),
          typeAnnotation: typeAnnotation}});
    }
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowClassImplemented(parser) {
    const implemented = [];

    do {
      const start = parser.getPosition();
      const id = ___R$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser, true);

      let typeParameters;
      if (parser.isRelational('<')) {
        typeParameters = ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation(parser);
      }

      implemented.push({
        loc: parser.finishLoc(start),
        type: 'FlowClassImplements',
        id: ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(id),
        typeParameters: typeParameters});
    } while (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma));

    return implemented;
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowVariance(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.plusMin)) {
      const start = parser.getPosition();
      ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'variance', start);
      let kind;
      if (parser.state.tokenValue === '+') {
        kind = 'plus';
      } else {
        kind = 'minus';
      }
      parser.next();
      return {
        loc: parser.finishLoc(start),
        type: 'FlowVariance',
        kind: kind};
    }
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseAsyncArrowWithFlowTypeParameters(parser, startPos) {
    const {params: params, rest: rest, typeParameters: typeParameters} = ___R$romejs$js$parser$parser$statement_ts$parseFunctionParams(parser);

    const {returnType: returnType, valid: valid, predicate: predicate} = ___R$romejs$js$parser$parser$expression_ts$parseArrowHead(parser);
    if (!valid) {
      parser.addDiagnostic({
        message: 'Invalid async arrow with type parameters'});
      return undefined;
    }

    const func = ___R$romejs$js$parser$parser$expression_ts$parseArrowExpression(
    parser,
    startPos,
    {
      bindingList: params,
      rest: rest},
    true);

    return Object.assign({}, func, {
      head: Object.assign({}, func.head, {
        returnType: returnType,
        predicate: predicate,
        typeParameters: typeParameters})});
  }

  function ___R$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeInternalSlot(parser, start, isStatic) {
    const id = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectPropertyKey(parser);
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR);
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR);

    let optional = false;
    let value;
    if (parser.isRelational('<') || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL)) {
      value = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowObjectTypeMethodish(parser, start);
    } else {
      optional = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.question);
      value = ___R$$priv$romejs$js$parser$parser$flow_ts$parseFlowTypeInitialiser(parser);
    }

    return {
      type: 'FlowObjectTypeInternalSlot',
      optional: optional,
      value: value,
      id: id,
      loc: parser.finishLoc(start)};
  }

  // romejs/js-parser/parser/typescript.ts

  const ___R$romejs$js$parser$parser$typescript_ts = {
    parseTSModifier: ___R$romejs$js$parser$parser$typescript_ts$parseTSModifier,
    hasTSModifier: ___R$romejs$js$parser$parser$typescript_ts$hasTSModifier,
    parseTSTypeParameters: ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters,
    tryTSNextParseConstantContext: ___R$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext,
    tsCheckLiteralForConstantContext: ___R$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext,
    tryTSParseIndexSignature: ___R$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature,
    parseTSTypeOrTypePredicateAnnotation: ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation,
    parseTSTypeAnnotation: ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation,
    parseTSTypeAssertion: ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAssertion,
    parseTSHeritageClause: ___R$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause,
    parseTSInterfaceDeclaration: ___R$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration,
    parseTSTypeAliasTypeAnnotation: ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAliasTypeAnnotation,
    tsNextThenParseType: ___R$romejs$js$parser$parser$typescript_ts$tsNextThenParseType,
    parseTSEnumDeclaration: ___R$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration,
    parseTSModuleBlock: ___R$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock,
    parseTSModuleOrNamespaceDeclaration: ___R$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration,
    parseTSAmbientExternalModuleDeclaration: ___R$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration,
    parseTSImportEqualsDeclaration: ___R$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration,
    parseTSDeclare: ___R$romejs$js$parser$parser$typescript_ts$parseTSDeclare,
    parseTSAbstractClass: ___R$romejs$js$parser$parser$typescript_ts$parseTSAbstractClass,
    parseTSExportDefaultAbstractClass: ___R$romejs$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass,
    parseTSTypeArguments: ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments,
    isTSDeclarationStart: ___R$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart,
    parseTSAccessModifier: ___R$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier,
    isTSAbstractClass: ___R$romejs$js$parser$parser$typescript_ts$isTSAbstractClass,
    parseTSExport: ___R$romejs$js$parser$parser$typescript_ts$parseTSExport};

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$keywordTypeFromName(value) {
    switch (value) {
      case 'any':
        return 'AnyKeywordTypeAnnotation';

      case 'boolean':
        return 'BooleanKeywordTypeAnnotation';

      case 'bigint':
        return 'BigIntKeywordTypeAnnotation';

      case 'never':
        return 'NeverKeywordTypeAnnotation';

      case 'number':
        return 'NumberKeywordTypeAnnotation';

      case 'object':
        return 'ObjectKeywordTypeAnnotation';

      case 'string':
        return 'StringKeywordTypeAnnotation';

      case 'symbol':
        return 'SymbolKeywordTypeAnnotation';

      case 'undefined':
        return 'UndefinedKeywordTypeAnnotation';

      case 'unknown':
        return 'UnknownKeywordTypeAnnotation';

      default:
        return undefined;}
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsIdentifier(parser) {
    return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name);
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsNextTokenCanFollowModifier(parser) {
    parser.next();
    return !parser.hasPrecedingLineBreak() &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR) &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon) &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eq) &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.question) &&
    !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bang);
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSModifier(parser, allowedModifiers) {
    if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
      return undefined;
    }

    const modifier = String(parser.state.tokenValue);
    if (allowedModifiers.includes(modifier) &&
    ___R$$priv$romejs$js$parser$parser$typescript_ts$tryTSParse(parser, ___R$$priv$romejs$js$parser$parser$typescript_ts$tsNextTokenCanFollowModifier)) {
      return modifier;
    }
  }

  function ___R$romejs$js$parser$parser$typescript_ts$hasTSModifier(parser, allowedModifiers) {
    return ___R$romejs$js$parser$parser$typescript_ts$parseTSModifier(parser, allowedModifiers) !== undefined;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(parser, kind) {
    switch (kind) {
      case 'EnumMembers':
      case 'TypeMembers':
        return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR);

      case 'HeritageClauseElement':
        return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL);

      case 'TupleElementTypes':
        return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR);

      case 'TypeParametersOrArguments':
        return parser.isRelational('>');}

    throw new Error('Unreachable');
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSList(parser, kind, parseElement) {
    const result = [];
    while (!___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(parser, kind)) {
      result.push(parseElement(parser));
    }
    return result;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(parser, kind, parseElement) {
    const result = [];

    while (true) {
      if (___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(parser, kind)) {
        break;
      }

      const element = parseElement(parser);
      if (element == undefined) {
        break;
      }

      result.push(element);

      if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        continue;
      }

      if (___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(parser, kind)) {
        break;
      }

      if (parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        break;
      }
    }

    return result;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSBracketedList(parser, kind, parseElement, bracket, skipFirstToken) {
    if (!skipFirstToken) {
      if (bracket) {
        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL);
      } else {
        parser.expectRelational('<');
      }
    }

    const result = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(parser, kind, parseElement);

    if (bracket) {
      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR);
    } else {
      parser.expectRelational('>');
    }

    return result;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSImportType(parser) {
    const start = parser.getPosition();
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._import);
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
    'ts import type');

    if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
      parser.addDiagnostic({
        message: 'Argument in a type import must be a string literal'});
    }

    const argument = ___R$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, 'ts import argument');
    parser.expectClosing(openContext);

    let qualifier;
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      qualifier = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, true);
    }

    let typeParameters;
    if (parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(parser);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSImportType',
      argument: argument,
      qualifier: qualifier,
      typeParameters: typeParameters};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, allowReservedWords) {
    let entity = ___R$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(
    parser);
    while (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      const start = parser.getLoc(entity).start;
      const right = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, allowReservedWords);
      entity = {
        loc: parser.finishLoc(start),
        type: 'TSQualifiedName',
        left: entity,
        right: right};
    }
    return entity;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeReference(parser) {
    const start = parser.getPosition();
    const typeName = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, false);
    let typeParameters;
    if (!parser.hasPrecedingLineBreak() && parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(parser);
    }
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeReference',
      typeName: typeName,
      typeParameters: typeParameters};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSThisTypePredicate(parser, lhs) {
    parser.next();
    const start = parser.getLoc(lhs).start;
    const parameterName = lhs;
    const typeAnnotation = ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser, false);

    return {
      loc: parser.finishLoc(start),
      type: 'TSTypePredicate',
      parameterName: parameterName,
      typeAnnotation: typeAnnotation};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSThisTypeNode(parser) {
    const start = parser.getPosition();
    parser.next();
    return {
      loc: parser.finishLoc(start),
      type: 'TSThisType'};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeQuery(parser) {
    const start = parser.getPosition();
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._typeof);
    let exprName;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._import)) {
      exprName = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSImportType(parser);
    } else {
      exprName = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, true);
    }
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeQuery',
      exprName: exprName};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeParameter(parser) {
    const start = parser.getPosition();
    const name = ___R$romejs$js$parser$parser$expression_ts$parseIdentifierName(parser);
    const constraint = ___R$$priv$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(parser, ___R$romejs$js$parser$tokenizer$types_ts$types._extends);
    const _default = ___R$$priv$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.eq);
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeParameter',
      name: name,
      constraint: constraint,
      default: _default};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(parser) {
    if (parser.isRelational('<')) {
      return ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters(parser);
    }
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters(parser) {
    const start = parser.getPosition();

    parser.expectRelational('<');

    const params = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSBracketedList(
    parser,
    'TypeParametersOrArguments',
    ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeParameter,
    false,
    true);

    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeParameterDeclaration',
      params: params};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(parser) {
    if (parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types._const) {
      parser.next();
      return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeReference(parser);
    }
  }

  function ___R$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, node) {
    switch (node.type) {
      case 'StringLiteral':
      case 'TemplateLiteral':
      case 'NumericLiteral':
      case 'BooleanLiteral':
      case 'SpreadElement':
      case 'ObjectMethod':
      case 'ObjectExpression':
        break;

      case 'ArrayExpression':
        for (const elem of node.elements) {
          if (elem) {
            ___R$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, elem);
          }
        }
        break;

      case 'ObjectProperty':
        ___R$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, node.value);
        break;

      case 'UnaryExpression':
        ___R$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, node.argument);
        break;

      default:
        parser.addDiagnostic({
          loc: node.loc,
          message: 'Only literal values are allowed in constant contexts'});}
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(parser, returnToken) {
    const start = parser.getPosition();

    const returnTokenRequired = returnToken === ___R$romejs$js$parser$tokenizer$types_ts$types.arrow;
    const typeParameters = ___R$$priv$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(parser);
    const {list: parameters, rest: rest} = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSBindingListForSignature(parser);

    let typeAnnotation;
    if (returnTokenRequired) {
      typeAnnotation = ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, returnToken);
    } else if (parser.match(returnToken)) {
      typeAnnotation = ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, returnToken);
    }

    return {
      typeAnnotation: typeAnnotation,
      meta: {
        type: 'TSSignatureDeclarationMeta',
        loc: parser.finishLoc(start),
        typeParameters: typeParameters,
        parameters: parameters,
        rest: rest}};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSBindingListForSignature(parser) {
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
    'ts signature parameters');
    const {list: patterns, rest: rest} = ___R$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty(parser, openContext);
    const validPatterns = [];

    for (const pattern of patterns) {
      if (pattern.type === 'BindingIdentifier' ||
      pattern.type === 'BindingObjectPattern' ||
      pattern.type === 'BindingArrayPattern') {
        validPatterns.push(pattern);
      } else {
        parser.addDiagnostic({
          loc: pattern.loc,
          message: 'Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ' + pattern.type});
      }
    }

    return {list: validPatterns, rest: rest};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(parser) {
    if (!parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      parser.semicolon();
    }
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSConstructSignatureDeclaration(parser) {
    const start = parser.getPosition();
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._new);
    const {meta: meta, typeAnnotation: typeAnnotation} = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
    parser,
    ___R$romejs$js$parser$tokenizer$types_ts$types.colon);
    parser.semicolon();
    return {
      type: 'TSConstructSignatureDeclaration',
      loc: parser.finishLoc(start),
      meta: meta,
      typeAnnotation: typeAnnotation};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSCallSignatureDeclaration(parser) {
    const start = parser.getPosition();
    const {meta: meta, typeAnnotation: typeAnnotation} = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
    parser,
    ___R$romejs$js$parser$tokenizer$types_ts$types.colon);
    parser.semicolon();
    return {
      type: 'TSCallSignatureDeclaration',
      loc: parser.finishLoc(start),
      meta: meta,
      typeAnnotation: typeAnnotation};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyIndexSignature(parser) {
    parser.next();
    return parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.name) && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon);
  }

  function ___R$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature(parser, start) {
    if (!(parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL) &&
    ___R$$priv$romejs$js$parser$parser$typescript_ts$lookaheadTS(parser, ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyIndexSignature))) {
      return undefined;
    }

    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL);

    const idStart = parser.getPosition();
    const id = Object.assign({}, ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser), {
      typeAnnotation: ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser),
      loc: parser.finishLoc(idStart)});

    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR);
    const parameters = [id];

    const typeAnnotation = ___R$$priv$romejs$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(parser);

    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'TSIndexSignature',
      typeAnnotation: typeAnnotation,
      parameters: parameters,
      rest: undefined};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSPropertyOrMethodSignature(parser, start, readonly) {
    const key = ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);
    const optional = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.question);

    if (!readonly && (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.isRelational('<'))) {
      const {meta: meta, typeAnnotation: typeAnnotation} = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
      parser,
      ___R$romejs$js$parser$tokenizer$types_ts$types.colon);
      ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(parser);
      return {
        loc: parser.finishLoc(start),
        type: 'TSMethodSignature',
        optional: optional,
        meta: meta,
        key: key,
        typeAnnotation: typeAnnotation};
    } else {
      const typeAnnotation = ___R$$priv$romejs$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(parser);
      ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(parser);
      return {
        loc: parser.finishLoc(start),
        type: 'TSPropertySignature',
        optional: optional,
        readonly: readonly,
        typeAnnotation: typeAnnotation,
        key: key};
    }
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeMember(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.isRelational('<')) {
      return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSCallSignatureDeclaration(parser);
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._new) &&
    ___R$$priv$romejs$js$parser$parser$typescript_ts$lookaheadTS(parser, ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsStartOfConstructSignature)) {
      return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSConstructSignatureDeclaration(parser);
    }

    const start = parser.getPosition();
    const readonly = ___R$romejs$js$parser$parser$typescript_ts$hasTSModifier(parser, ['readonly']);

    const idx = ___R$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature(parser, start);
    if (idx) {
      return Object.assign({}, idx, {
        readonly: readonly});
    }

    return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSPropertyOrMethodSignature(parser, start, readonly);
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsStartOfConstructSignature(parser) {
    parser.next();
    return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.isRelational('<');
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeLiteral(parser) {
    const start = parser.getPosition();
    const members = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(parser);
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeLiteral',
      members: members};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(parser) {
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
    'ts object type members');
    const members = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSList(parser, 'TypeMembers', ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeMember);
    parser.expectClosing(openContext);
    return members;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsStartOfMappedType(parser) {
    parser.next();

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.plusMin)) {
      return parser.isContextual('readonly');
    }

    if (parser.isContextual('readonly')) {
      parser.next();
    }

    if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      return false;
    }

    parser.next();

    if (!___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsIdentifier(parser)) {
      return false;
    }

    parser.next();

    return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._in);
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSMappedTypeParameter(parser) {
    const start = parser.getPosition();
    const name = ___R$romejs$js$parser$parser$expression_ts$parseIdentifierName(parser);
    const constraint = ___R$$priv$romejs$js$parser$parser$typescript_ts$tsExpectThenParseType(parser, ___R$romejs$js$parser$tokenizer$types_ts$types._in);
    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeParameter',
      name: name,
      constraint: constraint};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$toPlusMin(val) {
    const str = String(val);
    if (str === '+' || str === '-') {
      return str;
    } else {
      throw new Error('Expected +/-');
    }
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSMappedType(parser) {
    const start = parser.getPosition();

    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
    'ts mapped type');

    let readonly;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.plusMin)) {
      readonly = ___R$$priv$romejs$js$parser$parser$typescript_ts$toPlusMin(parser.state.tokenValue);
      parser.next();
      parser.expectContextual('readonly');
    } else if (parser.eatContextual('readonly')) {
      readonly = true;
    }

    const paramOpenContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.bracketR,
    'ts mapped type parameter');
    const typeParameter = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSMappedTypeParameter(parser);
    parser.expectClosing(paramOpenContext);

    let optional;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.plusMin)) {
      optional = ___R$$priv$romejs$js$parser$parser$typescript_ts$toPlusMin(parser.state.tokenValue);
      parser.next();
      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.question);
    } else if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.question)) {
      optional = true;
    }

    const typeAnnotation = ___R$$priv$romejs$js$parser$parser$typescript_ts$tryTSParseType(parser);
    parser.semicolon();
    parser.expectClosing(openContext);

    return {
      loc: parser.finishLoc(start),
      type: 'TSMappedType',
      typeParameter: typeParameter,
      typeAnnotation: typeAnnotation,
      optional: optional,
      readonly: readonly};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTupleType(parser) {
    const start = parser.getPosition();
    const elementDefs = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSBracketedList(
    parser,
    'TupleElementTypes',
    ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTupleElementType,
    true,
    false);

    let seenOptionalElement = false;
    const elementTypes = [];
    let rest;
    for (const {type: type, isRest: isRest} of elementDefs) {
      if (rest !== undefined) {
        continue;
      }

      if (type.type === 'TSOptionalType') {
        seenOptionalElement = true;
      } else if (seenOptionalElement && !isRest) {
        parser.addDiagnostic({
          loc: type.loc,
          message: 'A required element cannot follow an optional element.'});
      }

      if (isRest) {
        rest = type;
      } else {
        elementTypes.push(type);
      }
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSTupleType',
      elementTypes: elementTypes,
      rest: rest};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTupleElementType(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      parser.next();

      const typeAnnotation = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
      ___R$romejs$js$parser$parser$lval_ts$hasCommaAfterRest(parser);

      return {
        isRest: true,
        type: typeAnnotation};
    }

    const typeAnnotation = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSType(parser);

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.question)) {
      const start = parser.getLoc(typeAnnotation).start;
      return {
        isRest: false,
        type: {
          loc: parser.finishLoc(start),
          type: 'TSOptionalType',
          typeAnnotation: typeAnnotation}};
    }

    return {
      isRest: false,
      type: typeAnnotation};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSParenthesizedType(parser) {
    const start = parser.getPosition();
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
    'ts parenthesized type');
    const typeAnnotation = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
    parser.expectClosing(openContext);
    return {
      loc: parser.finishLoc(start),
      type: 'TSParenthesizedType',
      typeAnnotation: typeAnnotation};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSFunctionType(parser) {
    const start = parser.getPosition();
    const {meta: meta, typeAnnotation: typeAnnotation} = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
    parser,
    ___R$romejs$js$parser$tokenizer$types_ts$types.arrow);

    if (typeAnnotation === undefined) {
      throw new Error('Type annotation return type required as we passed tt.arrow above');
    }

    return {
      type: 'TSFunctionType',
      loc: parser.finishLoc(start),
      meta: meta,
      typeAnnotation: typeAnnotation};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSConstructorType(parser) {
    const start = parser.getPosition();
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._new);

    const {meta: meta, typeAnnotation: typeAnnotation} = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
    parser,
    ___R$romejs$js$parser$tokenizer$types_ts$types.arrow);

    if (typeAnnotation === undefined) {
      throw new Error('Type annotation return type required as we passed tt.arrow above');
    }

    return {
      type: 'TSConstructorType',
      loc: parser.finishLoc(start),
      meta: meta,
      typeAnnotation: typeAnnotation};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTemplateLiteralType(parser) {
    const templateNode = ___R$romejs$js$parser$parser$expression_ts$parseTemplate(parser, false);

    if (templateNode.expressions.length > 0) {
      parser.addDiagnostic({
        loc: parser.getLoc(templateNode.expressions[0]),
        message: 'Template literal types cannot have any substitution'});
    }

    return {
      type: 'TemplateLiteralTypeAnnotation',
      value: templateNode.quasis[0].raw,
      loc: templateNode.loc};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSNonArrayType(parser) {
    switch (parser.state.tokenType) {
      case ___R$romejs$js$parser$tokenizer$types_ts$types.name:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._void:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._null:
        {
          let type;
          if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._void)) {
            type = 'VoidKeywordTypeAnnotation';
          } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._null)) {
            type = 'NullKeywordTypeAnnotation';
          } else {
            type = ___R$$priv$romejs$js$parser$parser$typescript_ts$keywordTypeFromName(String(parser.state.tokenValue));
          }
          if (type !== undefined && parser.lookaheadState().tokenType !== ___R$romejs$js$parser$tokenizer$types_ts$types.dot) {
            const start = parser.getPosition();
            parser.next();
            return {
              type: type,
              loc: parser.finishLoc(start)};
          }
          return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeReference(parser);
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types.string:
      case ___R$romejs$js$parser$tokenizer$types_ts$types.num:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._true:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._false:
      case ___R$romejs$js$parser$tokenizer$types_ts$types.plusMin:
        return ___R$romejs$js$parser$parser$type$systems_ts$parseTypeLiteralAnnotation(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._this:
        {
          const thisKeyword = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSThisTypeNode(parser);
          if (parser.isContextual('is') && !parser.hasPrecedingLineBreak()) {
            return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSThisTypePredicate(parser, thisKeyword);
          } else {
            return thisKeyword;
          }
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types._typeof:
        return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeQuery(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types._import:
        return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSImportType(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.braceL:
        if (___R$$priv$romejs$js$parser$parser$typescript_ts$lookaheadTS(parser, ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsStartOfMappedType)) {
          return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSMappedType(parser);
        } else {
          return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeLiteral(parser);
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL:
        return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTupleType(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.parenL:
        return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSParenthesizedType(parser);

      case ___R$romejs$js$parser$tokenizer$types_ts$types.backQuote:
        return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTemplateLiteralType(parser);}

    parser.addDiagnostic({
      message: 'Unknown TS non array type start'});

    return {
      type: 'TSTypeReference',
      loc: parser.finishLoc(parser.getPosition()),
      typeName: ___R$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
      parser.createUnknownIdentifier('ts non array type start'))};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSArrayTypeOrHigher(parser) {
    let type = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSNonArrayType(parser);

    while (!parser.hasPrecedingLineBreak() && parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR)) {
        const start = parser.getLoc(type).start;
        const elementType = type;
        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR);
        type = {
          loc: parser.finishLoc(start),
          type: 'TSArrayType',
          elementType: elementType};
      } else {
        const start = parser.getLoc(type).start;
        const objectType = type;
        const indexType = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR);
        type = {
          loc: parser.finishLoc(start),
          type: 'TSIndexedAccessType',
          objectType: objectType,
          indexType: indexType};
      }
    }
    return type;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeOperator(parser, operator) {
    const start = parser.getPosition();
    parser.expectContextual(operator);

    const typeAnnotation = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher(parser);

    const node = {
      loc: parser.finishLoc(start),
      type: 'TSTypeOperator',
      typeAnnotation: typeAnnotation,
      operator: operator};

    if (operator === 'readonly') {
      ___R$$priv$romejs$js$parser$parser$typescript_ts$tsCheckTypeAnnotationForReadOnly(parser, typeAnnotation);
    }

    return node;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsCheckTypeAnnotationForReadOnly(parser, node) {
    switch (node.type) {
      case 'TSTupleType':
      case 'TSArrayType':
        return undefined;

      default:
        parser.addDiagnostic({
          loc: node.loc,
          message: '\'readonly\' type modifier is only permitted on array and tuple literal types.'});
        break;}
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSInferType(parser) {
    const inferStart = parser.getPosition();
    parser.expectContextual('infer');

    const start = parser.getPosition();
    const typeParameter = {
      type: 'TSTypeParameter',
      name: ___R$romejs$js$parser$parser$expression_ts$parseIdentifierName(parser),
      loc: parser.finishLoc(start)};

    return {
      loc: parser.finishLoc(inferStart),
      type: 'TSInferType',
      typeParameter: typeParameter};
  }

  const ___R$$priv$romejs$js$parser$parser$typescript_ts$TS_TYPE_OPERATORS = ['keyof', 'unique', 'readonly'];

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher(parser) {
    let operator;

    for (const op of ___R$$priv$romejs$js$parser$parser$typescript_ts$TS_TYPE_OPERATORS) {
      if (parser.isContextual(op)) {
        operator = op;
        break;
      }
    }

    if (operator !== undefined) {
      return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeOperator(parser, operator);
    } else if (parser.isContextual('infer')) {
      return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSInferType(parser);
    } else {
      return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSArrayTypeOrHigher(parser);
    }
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(parser, kind, parseConstituentType, operator) {
    parser.eat(operator);
    let type = parseConstituentType(parser);

    if (parser.match(operator)) {
      const types = [type];
      while (parser.eat(operator)) {
        types.push(parseConstituentType(parser));
      }

      const start = parser.getLoc(type).start;
      if (kind === 'UnionTypeAnnotation') {
        type = {
          loc: parser.finishLoc(start),
          type: 'UnionTypeAnnotation',
          types: types};
      } else if (kind === 'IntersectionTypeAnnotation') {
        type = {
          loc: parser.finishLoc(start),
          type: 'IntersectionTypeAnnotation',
          types: types};
      }
    }

    return type;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseIntersectionTypeAnnotationOrHigher(parser) {
    return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
    parser,
    'IntersectionTypeAnnotation',
    ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher,
    ___R$romejs$js$parser$tokenizer$types_ts$types.bitwiseAND);
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseUnionTypeAnnotationOrHigher(parser) {
    return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
    parser,
    'UnionTypeAnnotation',
    ___R$$priv$romejs$js$parser$parser$typescript_ts$parseIntersectionTypeAnnotationOrHigher,
    ___R$romejs$js$parser$tokenizer$types_ts$types.bitwiseOR);
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsStartOfFunctionType(parser) {
    if (parser.isRelational('<')) {
      return true;
    }
    return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) &&
    ___R$$priv$romejs$js$parser$parser$typescript_ts$lookaheadTS(parser, ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyStartOfFunctionType);
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsSkipParameterStart(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._this)) {
      parser.next();
      return true;
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
      let braceStackCounter = 1;
      parser.next();

      while (braceStackCounter > 0) {
        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
          braceStackCounter++;
        } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
          braceStackCounter--;
        }
        parser.next();
      }
      return true;
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
      let braceStackCounter = 1;
      parser.next();

      while (braceStackCounter > 0) {
        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketL)) {
          braceStackCounter++;
        } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bracketR)) {
          braceStackCounter--;
        }
        parser.next();
      }
      return true;
    }

    return false;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyStartOfFunctionType(parser) {
    parser.next();
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis)) {
      return true;
    }
    if (___R$$priv$romejs$js$parser$parser$typescript_ts$tsSkipParameterStart(parser)) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon) ||
      parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma) ||
      parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.question) ||
      parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eq)) {
        return true;
      }
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenR)) {
        parser.next();
        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.arrow)) {
          return true;
        }
      }
    }
    return false;
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, returnToken) {
    const start = parser.getPosition();
    parser.pushScope('TYPE', true);
    parser.expect(returnToken);

    let typePredicateVariable;
    if (___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsIdentifier(parser)) {
      typePredicateVariable = ___R$$priv$romejs$js$parser$parser$typescript_ts$tryTSParse(parser, ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypePredicatePrefix);
    }
    if (typePredicateVariable === undefined) {
      parser.popScope('TYPE');
      return ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser, false, start);
    }

    const type = ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser, false);

    const typePredicateStart = parser.getLoc(typePredicateVariable).start;
    parser.popScope('TYPE');

    return {
      loc: parser.finishLoc(typePredicateStart),
      type: 'TSTypePredicate',
      parameterName: typePredicateVariable,
      typeAnnotation: type};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(parser) {
    return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon) ? ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser) : undefined;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tryTSParseType(parser) {
    return ___R$$priv$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.colon);
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSTypePredicatePrefix(parser) {
    const id = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
    if (parser.isContextual('is') && !parser.hasPrecedingLineBreak()) {
      parser.next();
      return id;
    }
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser, eatColon = true, start = parser.getPosition()) {
    parser.pushScope('TYPE', true);

    if (eatColon) {
      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.colon);
    }

    const typeAnnotation = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
    parser.popScope('TYPE');
    return typeAnnotation;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSType(parser) {
    parser.pushScope('TYPE', true);

    const type = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSNonConditionalType(parser);
    if (parser.hasPrecedingLineBreak() || !parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types._extends)) {
      parser.popScope('TYPE');
      return type;
    }

    const start = parser.getLoc(type).start;
    const checkType = type;

    const extendsType = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSNonConditionalType(parser);
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.question);

    const trueType = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.colon);

    const falseType = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
    parser.popScope('TYPE');

    return {
      loc: parser.finishLoc(start),
      type: 'TSConditionalType',
      checkType: checkType,
      extendsType: extendsType,
      trueType: trueType,
      falseType: falseType};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSNonConditionalType(parser) {
    if (___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsStartOfFunctionType(parser)) {
      return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSFunctionType(parser);
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._new)) {
      return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSConstructorType(parser);
    }

    return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseUnionTypeAnnotationOrHigher(parser);
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAssertion(parser) {
    const start = parser.getPosition();
    const _const = ___R$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(parser);
    const typeAnnotation = _const || ___R$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(parser);
    parser.expectRelational('>');

    const expression = ___R$romejs$js$parser$parser$expression_ts$parseMaybeUnary(parser, 'ts type assertion');
    if (_const) {
      ___R$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(parser, expression);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeAssertion',
      expression: expression,
      typeAnnotation: typeAnnotation};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause(parser, descriptor) {
    const originalStart = parser.state.startPos;
    const delimitedList = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(
    parser,
    'HeritageClauseElement',
    ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSExpressionWithTypeArguments);

    if (!delimitedList.length) {
      parser.addDiagnostic({
        start: originalStart,
        message: '\'' + descriptor + '\' list cannot be empty.'});
    }

    return delimitedList;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSExpressionWithTypeArguments(parser) {
    const start = parser.getPosition();

    const expression = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, false);

    let typeParameters;
    if (parser.isRelational('<')) {
      typeParameters = ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(parser);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSExpressionWithTypeArguments',
      expression: expression,
      typeParameters: typeParameters};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(parser, start) {
    parser.pushScope('TYPE', true);
    const id = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    const typeParameters = ___R$$priv$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(parser);

    let _extends;
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types._extends)) {
      _extends = ___R$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause(parser, 'extends');
    }

    const bodyStart = parser.getPosition();
    const bodyItems = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(parser);
    const body = {
      loc: parser.finishLoc(bodyStart),
      type: 'TSInterfaceBody',
      body: bodyItems};

    parser.popScope('TYPE');
    return {
      loc: parser.finishLoc(start),
      type: 'TSInterfaceDeclaration',
      id: id,
      body: body,
      typeParameters: typeParameters,
      extends: _extends};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAliasTypeAnnotation(parser, start) {
    const id = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    const typeParameters = ___R$$priv$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(parser);
    const typeAnnotation = ___R$$priv$romejs$js$parser$parser$typescript_ts$tsExpectThenParseType(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.eq);
    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'TypeAliasTypeAnnotation',
      id: id,
      typeParameters: typeParameters,
      right: typeAnnotation};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsInNoContext(parser, cb) {
    const oldContext = parser.state.context;
    parser.state.context = [oldContext[0]];
    const res = cb(parser);
    parser.state.context = oldContext;
    return res;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(parser, token) {
    if (parser.match(token)) {
      return ___R$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(parser);
    }
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsExpectThenParseType(parser, token) {
    return ___R$$priv$romejs$js$parser$parser$typescript_ts$tsDoThenParseType(parser, () => {
      parser.expect(token);
    });
  }

  function ___R$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(parser) {
    return ___R$$priv$romejs$js$parser$parser$typescript_ts$tsDoThenParseType(parser, () => parser.next());
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsDoThenParseType(parser, cb) {
    cb();
    return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSType(parser);
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSEnumMember(parser) {
    const start = parser.getPosition();

    const id = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string) ? ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser) : ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

    let initializer;
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.eq)) {
      initializer = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
      parser,
      'ts enum member initializer');
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSEnumMember',
      initializer: initializer,
      id: id};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(parser, start, isConst) {
    parser.addDiagnosticFilter({
      message: 'enum is a reserved word',
      start: start});

    const id = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);

    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
    'ts enum declaration');

    const members = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(
    parser,
    'EnumMembers',
    ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSEnumMember);
    parser.expectClosing(openContext);

    return {
      loc: parser.finishLoc(start),
      type: 'TSEnumDeclaration',
      members: members,
      id: id,
      const: isConst};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(parser) {
    const start = parser.getPosition();

    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
    'ts module block');

    const {body: body} = ___R$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
    parser,
    false,
    true,
    openContext);
    return {
      loc: parser.finishLoc(start),
      type: 'TSModuleBlock',
      body: body};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, start) {
    const id = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);

    let body;
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.dot)) {
      body = ___R$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, parser.getPosition());
    } else {
      body = ___R$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(parser);
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSModuleDeclaration',
      id: id,
      body: body};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(parser, start) {
    let global;
    let id;
    if (parser.isContextual('global')) {
      global = true;
      id = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
      id = ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
    } else {
      throw parser.unexpected();
    }

    let body;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
      body = ___R$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(parser);
    } else {
      parser.semicolon();
    }

    return {
      loc: parser.finishLoc(start),
      type: 'TSModuleDeclaration',
      id: id,
      global: global,
      body: body};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(parser, start, isExport = false) {
    const id = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.eq);

    const moduleReference = ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSModuleReference(parser);
    parser.semicolon();

    return {
      loc: parser.finishLoc(start),
      type: 'TSImportEqualsDeclaration',
      id: id,
      moduleReference: moduleReference};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsExternalModuleReference(parser) {
    return parser.isContextual('require') &&
    parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.parenL;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSModuleReference(parser) {
    return ___R$$priv$romejs$js$parser$parser$typescript_ts$tsIsExternalModuleReference(parser) ? ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSExternalModuleReference(parser) : ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSEntityName(parser, false);
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSExternalModuleReference(parser) {
    const start = parser.getPosition();
    parser.expectContextual('require');
    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.parenR,
    'ts external module reference');

    let expression;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
      expression = ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
    } else {
      parser.addDiagnostic({
        message: 'Invalid TS external module reference expression'});

      ___R$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, 'ts external module reference expression');

      expression = {
        loc: parser.finishLoc(start),
        type: 'StringLiteral',
        value: ''};
    }

    parser.expectClosing(openContext);

    return {
      loc: parser.finishLoc(start),
      type: 'TSExternalModuleReference',
      expression: expression};
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$lookaheadTS(parser, f) {
    const state = parser.cloneState();
    const res = f(parser);
    parser.state = state;
    return res;
  }

  function ___R$$priv$romejs$js$parser$parser$typescript_ts$tryTSParse(parser, f) {
    const state = parser.cloneState();
    const result = f(parser);
    if (result === undefined || result === false) {
      parser.state = state;
      return undefined;
    } else {
      return result;
    }
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSDeclare(parser, start) {
    let starttype = parser.state.tokenType;
    let kind;
    if (parser.isContextual('let')) {
      starttype = ___R$romejs$js$parser$tokenizer$types_ts$types._var;
      kind = 'let';
    }

    if (starttype === ___R$romejs$js$parser$tokenizer$types_ts$types._const &&
    parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._const) &&
    parser.isLookaheadContextual('enum')) {
      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._const);
      parser.expectContextual('enum');
      return Object.assign({
        declare: true}, ___R$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(parser, start, true));
    }

    switch (starttype) {
      case ___R$romejs$js$parser$tokenizer$types_ts$types._function:
        return Object.assign({}, ___R$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(parser, start, false), {
          declare: true});

      case ___R$romejs$js$parser$tokenizer$types_ts$types._class:
        return Object.assign({}, ___R$romejs$js$parser$parser$classes_ts$parseClassDeclaration(parser, start), {
          declare: true});

      case ___R$romejs$js$parser$tokenizer$types_ts$types._const:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._var:
        kind =
        kind === undefined ? ___R$romejs$js$parser$parser$statement_ts$assertVarKind(String(parser.state.tokenValue)) : kind;
        return Object.assign({
          declare: true}, ___R$romejs$js$parser$parser$statement_ts$parseVarStatement(parser, start, kind));

      case ___R$romejs$js$parser$tokenizer$types_ts$types.name:
        {
          const value = String(parser.state.tokenValue);

          if (value === 'global') {
            return Object.assign({
              declare: true}, ___R$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(parser, start));
          } else if (___R$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(parser)) {
            const id = ___R$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(parser);
            const decl = ___R$romejs$js$parser$parser$type$systems_ts$parseTypeExpressionStatement(parser, start, id);

            if (decl === undefined) {
              throw new Error('Should have returned a node');
            }

            if (decl.type !== 'TSInterfaceDeclaration' &&
            decl.type !== 'TypeAliasTypeAnnotation' &&
            decl.type !== 'TSEnumDeclaration' &&
            decl.type !== 'FunctionDeclaration' &&
            decl.type !== 'ClassDeclaration' &&
            decl.type !== 'VariableDeclarationStatement' &&
            decl.type !== 'TSDeclareFunction' &&
            decl.type !== 'TSModuleDeclaration') {
              throw new Error('Encountered a non-TS declare node when calling parseTypeExpressionStatement');
            }

            return Object.assign({}, decl, {
              declare: true});
          }
        }}

    parser.addDiagnostic({
      message: 'Unknown typescript declare start'});

    const loc = parser.finishLoc(start);
    return {
      type: 'VariableDeclarationStatement',
      loc: loc,
      declaration: {
        type: 'VariableDeclaration',
        loc: loc,
        kind: 'var',
        declarations: [{
          type: 'VariableDeclarator',
          loc: loc,
          id: ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
          parser.createUnknownIdentifier('typescript declare start', start)),
          init: undefined}]}};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSAbstractClass(parser, start) {
    return Object.assign({}, ___R$romejs$js$parser$parser$classes_ts$parseClassDeclaration(parser, start), {
      abstract: true});
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass(parser, start) {
    return Object.assign({}, ___R$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(parser, start), {
      abstract: true});
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(parser) {
    const start = parser.getPosition();
    parser.pushScope('TYPE', true);

    const params = ___R$$priv$romejs$js$parser$parser$typescript_ts$tsInNoContext(parser, () => {
      parser.expectRelational('<');
      return ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(
      parser,
      'TypeParametersOrArguments',
      ___R$$priv$romejs$js$parser$parser$typescript_ts$parseTSType);
    });

    parser.state.exprAllowed = false;
    parser.popScope('TYPE');
    parser.expectRelational('>');

    return {
      loc: parser.finishLoc(start),
      type: 'TSTypeParameterInstantiation',
      params: params};
  }

  function ___R$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(parser) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
      switch (parser.state.tokenValue) {
        case 'abstract':
        case 'declare':
        case 'enum':
        case 'interface':
        case 'module':
        case 'namespace':
        case 'type':
          return true;}
    }

    return false;
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier(parser) {
    return ___R$romejs$js$parser$parser$typescript_ts$parseTSModifier(parser, ['public', 'protected', 'private']);
  }

  function ___R$romejs$js$parser$parser$typescript_ts$isTSAbstractClass(parser) {
    return parser.isContextual('abstract') &&
    parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types._class;
  }

  function ___R$romejs$js$parser$parser$typescript_ts$parseTSExport(parser, start) {
    if (!parser.isSyntaxEnabled('ts')) {
      return undefined;
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._import)) {
      parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._import);
      return ___R$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(parser, start, true);
    }

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.eq)) {
      const expression = ___R$romejs$js$parser$parser$expression_ts$parseExpression(parser, 'ts export assignment');
      parser.semicolon();
      return {
        loc: parser.finishLoc(start),
        type: 'TSExportAssignment',
        expression: expression};
    }

    if (parser.eatContextual('as')) {
      parser.expectContextual('namespace');
      const id = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
      parser.semicolon();
      return {
        loc: parser.finishLoc(start),
        type: 'TSNamespaceExportDeclaration',
        id: id};
    }
  }

  // romejs/js-parser/parser/classes.ts

  const ___R$romejs$js$parser$parser$classes_ts = {
    parseClassExpression: ___R$romejs$js$parser$parser$classes_ts$parseClassExpression,
    parseExportDefaultClassDeclaration: ___R$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration,
    parseClassDeclaration: ___R$romejs$js$parser$parser$classes_ts$parseClassDeclaration,
    parseClass: ___R$romejs$js$parser$parser$classes_ts$parseClass};
  function ___R$romejs$js$parser$parser$classes_ts$parseClassExpression(parser, start) {
    return Object.assign({}, ___R$romejs$js$parser$parser$classes_ts$parseClass(parser, start, true), {
      type: 'ClassExpression'});
  }

  function ___R$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(parser, start) {
    let ___R$ = ___R$romejs$js$parser$parser$classes_ts$parseClass(parser, start, true);
    let shape = Object.assign({}, ___R$);
    delete shape.id;
    let {
      id: id} = ___R$;
    if (id === undefined) {
      id = {
        type: 'BindingIdentifier',
        name: '*default*',

        loc: shape.loc};
    }

    return Object.assign({}, shape, {
      type: 'ClassDeclaration',
      id: id});
  }

  function ___R$romejs$js$parser$parser$classes_ts$parseClassDeclaration(parser, start) {
    const ___R$1 = ___R$romejs$js$parser$parser$classes_ts$parseClass(parser, start, false);
    const shape = Object.assign({}, ___R$1);
    delete shape.id;
    const {
      id: id} = ___R$1;
    if (id === undefined) {
      throw new Error('Expected id');
    }

    return Object.assign({}, shape, {
      type: 'ClassDeclaration',
      id: id});
  }

  function ___R$romejs$js$parser$parser$classes_ts$parseClass(parser, start, optionalId) {
    parser.pushScope('METHOD', false);
    parser.pushScope('STRICT', true);

    parser.next();
    const {id: id, typeParameters: typeParameters} = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassId(parser, optionalId);
    const {superClass: superClass, superTypeParameters: superTypeParameters, implemented: implemented} = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassSuper(
    parser);

    parser.pushScope('CLASS', superClass === undefined ? 'normal' : 'derived');

    const body = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassBody(parser);

    parser.popScope('CLASS');
    parser.popScope('STRICT');
    parser.popScope('METHOD');

    const meta = {
      type: 'ClassHead',
      loc: parser.finishLocAt(start, parser.getEndPosition()),
      body: body,
      typeParameters: typeParameters,
      superClass: superClass,
      superTypeParameters: superTypeParameters,
      implements: implemented};

    return {
      loc: parser.finishLoc(start),
      id: id,
      meta: meta};
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$isClassProperty(parser) {
    return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.bang) ||
    parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon) ||
    parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eq) ||
    parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.semi) ||
    parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR);
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$isClassMethod(parser) {
    return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.parenL) || parser.isRelational('<');
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      return false;
    }

    if (meta.static) {
      return false;
    }

    if (key.type === 'StaticPropertyKey' &&
    key.value.type === 'Identifier' &&
    key.value.name === 'constructor') {
      return true;
    }

    if (key.value.type === 'StringLiteral' && key.value.value === 'constructor') {
      return true;
    }

    return false;
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassBody(parser) {
    parser.pushScope('STRICT', true);
    parser.state.classLevel = ___R$romejs$ob1$index_ts$inc(parser.state.classLevel);

    const state = {hadConstructor: false};

    const body = [];

    const openContext = parser.expectOpening(___R$romejs$js$parser$tokenizer$types_ts$types.braceL, ___R$romejs$js$parser$tokenizer$types_ts$types.braceR, 'class body');

    while (true) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        break;
      }

      if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.semi)) {
        continue;
      }

      const member = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassMember(parser, state);
      if (member !== undefined) {
        body.push(member);
      }
    }

    parser.expectClosing(openContext);

    parser.state.classLevel = ___R$romejs$ob1$index_ts$dec(parser.state.classLevel);
    parser.popScope('STRICT');

    return body;
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassMember(parser, state) {
    const start = parser.getPosition();
    const escapePosition = parser.state.escapePosition;

    let accessibility;
    if (parser.isSyntaxEnabled('ts')) {
      accessibility = ___R$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier(parser);
    }

    let isStatic = false;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name) && parser.state.tokenValue === 'static') {
      const keyId = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
      const key = {
        type: 'StaticPropertyKey',
        value: keyId,
        loc: keyId.loc};

      const meta = {
        type: 'ClassPropertyMeta',
        loc: parser.finishLocAt(start, parser.getEndPosition()),
        static: false,
        typeAnnotation: undefined,
        accessibility: accessibility,
        optional: false,
        abstract: false,
        readonly: false};

      if (___R$$priv$romejs$js$parser$parser$classes_ts$isClassMethod(parser)) {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassMethod(parser, {
          start: start,
          meta: meta,
          key: key,
          kind: 'method',
          isStatic: false,
          isAsync: false,
          isGenerator: false,
          isConstructor: false});
      }

      if (___R$$priv$romejs$js$parser$parser$classes_ts$isClassProperty(parser)) {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassProperty(parser, start, key, meta);
      }

      if (escapePosition !== undefined) {
        parser.addDiagnostic({
          index: escapePosition,
          message: 'No escapes allowed in static contextual keyword'});
      }

      isStatic = true;
    }

    return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassMemberWithIsStatic(
    parser,
    start,
    state,
    isStatic,
    accessibility);
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassMemberWithIsStatic(parser, start, state, isStatic, accessibility) {
    let abstract = false;
    let readonly = false;

    const mod = ___R$romejs$js$parser$parser$typescript_ts$parseTSModifier(parser, ['abstract', 'readonly']);
    switch (mod) {
      case 'readonly':
        readonly = true;
        abstract = ___R$romejs$js$parser$parser$typescript_ts$hasTSModifier(parser, ['abstract']);
        break;

      case 'abstract':
        abstract = true;
        readonly = ___R$romejs$js$parser$parser$typescript_ts$hasTSModifier(parser, ['readonly']);
        break;}

    const nameOpts = {
      start: start,
      static: isStatic,
      accessibility: accessibility,
      readonly: readonly,
      abstract: abstract};

    if (!abstract && !isStatic && accessibility === undefined) {
      const indexSignature = ___R$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature(parser, start);
      if (indexSignature) {
        return Object.assign({}, indexSignature, {
          readonly: readonly});
      }
    }

    if (readonly) {
      const {key: key, meta: meta} = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, nameOpts);
      if (key.value.type === 'PrivateName') {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(parser, start, key.value, meta);
      } else {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$pushClassProperty(parser, start, key, meta);
      }
    }

    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.star)) {
      const {meta: meta, key: key} = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, nameOpts);

      if (key.value.type === 'PrivateName') {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(parser, {
          start: start,
          key: key.value,
          variance: undefined,
          meta: meta,
          isGenerator: true,
          isAsync: false,
          kind: 'method'});
      }

      if (___R$$priv$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta)) {
        parser.addDiagnostic({
          loc: key.loc,
          message: 'Constructor can\'t be a generator'});
      }

      return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassMethod(parser, {
        start: start,
        key: key,
        meta: meta,
        kind: 'method',
        isStatic: false,
        isGenerator: true,
        isAsync: false,
        isConstructor: false});
    }

    const escapePosition = parser.state.escapePosition;
    const {meta: meta, key: key} = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, nameOpts);

    if (___R$$priv$romejs$js$parser$parser$classes_ts$isClassMethod(parser)) {
      if (key.value.type === 'PrivateName') {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(parser, {
          start: start,
          key: key.value,
          meta: meta,
          isGenerator: false,
          isAsync: false,
          kind: 'method',
          variance: undefined});
      }

      const isConstructor = ___R$$priv$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta);

      let kind = 'method';
      if (isConstructor) {
        kind = 'constructor';

        if (state.hadConstructor && !parser.isSyntaxEnabled('ts')) {
          parser.addDiagnostic({
            loc: key.loc,
            message: 'Duplicate constructor in the same class'});
        }
        state.hadConstructor = true;
      }

      return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassMethod(parser, {
        start: start,
        key: key,
        meta: meta,
        kind: kind,
        isStatic: isStatic,
        isGenerator: false,
        isAsync: false,
        isConstructor: isConstructor});
    }

    if (___R$$priv$romejs$js$parser$parser$classes_ts$isClassProperty(parser)) {
      if (key.value.type === 'PrivateName') {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(parser, start, key.value, meta);
      } else {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$pushClassProperty(parser, start, key, meta);
      }
    }

    if (key.value.type === 'Identifier' &&
    key.value.name === 'async' &&
    !parser.isLineTerminator()) {
      parser.banUnicodeEscape(escapePosition, 'async');

      const isGenerator = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.star);

      const {meta: meta, key: key} = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, nameOpts);

      if (key.value.type === 'PrivateName') {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(parser, {
          start: start,
          key: key.value,
          meta: meta,
          isGenerator: isGenerator,
          isAsync: true,
          kind: 'method',
          variance: undefined});
      } else {
        const method = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassMethod(parser, {
          start: start,
          key: key,
          meta: meta,
          kind: 'method',
          isStatic: isStatic,
          isGenerator: isGenerator,
          isAsync: true,
          isConstructor: false});

        if (___R$$priv$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta)) {
          parser.addDiagnostic({
            loc: key.loc,
            message: 'Constructor can\'t be an async function'});
        }

        return method;
      }
    }

    if (key.value.type === 'Identifier' &&
    (key.value.name === 'get' || key.value.name === 'set') &&
    !(parser.isLineTerminator() && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.star))) {
      const kind = key.value.name;
      parser.banUnicodeEscape(escapePosition, kind);

      const {meta: meta, key: methodKey} = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, nameOpts);

      if (methodKey.value.type === 'PrivateName') {
        const method = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(parser, {
          start: start,
          key: methodKey.value,
          meta: meta,
          isGenerator: false,
          isAsync: false,
          kind: kind,
          variance: undefined});
        ___R$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(parser, method, method.kind);
        return method;
      } else {
        const method = ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassMethod(parser, {
          start: start,
          key: methodKey,
          meta: meta,
          kind: kind,
          isStatic: false,
          isGenerator: false,
          isAsync: false,
          isConstructor: false});

        if (___R$$priv$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta)) {
          parser.addDiagnostic({
            loc: methodKey.loc,
            message: 'Constructor can\'t have get/set modifier'});
        }

        ___R$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(parser, method, method.kind);
        return method;
      }
    }

    if (parser.isLineTerminator()) {
      if (key.value.type === 'PrivateName') {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(parser, start, key.value, meta);
      } else {
        return ___R$$priv$romejs$js$parser$parser$classes_ts$pushClassProperty(parser, start, key, meta);
      }
    }

    parser.addDiagnostic({
      message: 'Unknown class property start'});
    return undefined;
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(parser, opts) {
    let typeAnnotation;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___R$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
    }

    const key = ___R$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(parser);

    if (key.type === 'StaticPropertyKey' &&
    opts.static === true &&
    key.value.type === 'Identifier' &&
    key.value.name === 'prototype') {
      parser.addDiagnostic({
        loc: key.loc,
        message: 'Classes may not have static property named prototype'});
    }

    if (key.value.type === 'PrivateName' && key.value.id.name === 'constructor') {
      parser.addDiagnostic({
        loc: key.loc,
        message: 'Classes may not have a private field named \'#constructor\''});
    }

    let optional = false;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.question)) {
      optional = true;

      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'Optional syntax but ts is not enabled'});
      }

      parser.next();
    }

    return {
      key: key,
      meta: Object.assign({
        type: 'ClassPropertyMeta',
        loc: parser.finishLocAt(opts.start, parser.getEndPosition()),
        typeAnnotation: typeAnnotation,
        optional: optional}, opts)};
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$pushClassProperty(parser, start, key, meta) {
    if (___R$$priv$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(parser, key, meta)) {
      parser.addDiagnostic({
        loc: key.loc,
        message: 'Classes may not have a non-static field named \'constructor\''});
    }

    return ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassProperty(parser, start, key, meta);
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassMethod(parser, opts) {
    const {start: start, key: key, meta: meta, kind: kind, isGenerator: isGenerator, isAsync: isAsync, isConstructor: isConstructor} = opts;

    if (key.variance !== undefined) {
      parser.addDiagnostic({
        loc: key.variance.loc,
        message: 'variance not allowed here'});
    }

    const typeParameters = ___R$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser);

    const method = Object.assign({}, ___R$romejs$js$parser$parser$expression_ts$parseMethod(parser, {
      kind: kind,
      isClass: true,
      isGenerator: isGenerator,
      isAsync: isAsync,
      isConstructor: isConstructor}), {
      loc: parser.finishLoc(start),
      kind: kind,
      key: key,
      meta: meta,
      typeParameters: typeParameters});

    const {body: body} = method;

    if (body === undefined) {
      return Object.assign({}, method, {
        type: 'TSDeclareMethod',
        body: undefined});
    } else {
      if (body.type !== 'BlockStatement') {
        throw new Error('Expected BlockStatement body');
      }

      if (key.value.type === 'PrivateName') {
        throw new Error('Expected to hit other private methods instead');
      }

      return Object.assign({}, method, {
        key: key,
        body: body,
        type: 'ClassMethod'});
    }
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(parser, opts) {
    const {start: start, key: key, variance: variance, meta: meta, isGenerator: isGenerator, isAsync: isAsync, kind: kind} = opts;

    if (variance !== undefined) {
      parser.addDiagnostic({
        loc: variance.loc,
        message: 'variance not allowed here'});
    }

    const typeParameters = ___R$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser);
    const method = ___R$romejs$js$parser$parser$expression_ts$parseMethod(parser, {
      kind: kind,
      isClass: true,
      isGenerator: isGenerator,
      isAsync: isAsync,
      isConstructor: false});

    const {body: body} = method;
    if (body === undefined || body.type !== 'BlockStatement') {
      throw new Error('Expected body');
    }

    return Object.assign({}, method, {
      body: body,
      loc: parser.finishLoc(start),
      meta: meta,
      key: key,
      kind: kind,
      type: 'ClassPrivateMethod',
      variance: variance,
      head: Object.assign({}, method.head, {
        typeParameters: typeParameters})});
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(parser, start, key, meta) {
    parser.pushScope('CLASS_PROPERTY', true);

    let typeAnnotation;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___R$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
    }

    const value = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.eq) ? ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'class private property value') : undefined;
    parser.semicolon();
    parser.popScope('CLASS_PROPERTY');

    return {
      loc: parser.finishLoc(start),
      meta: meta,
      key: key,
      type: 'ClassPrivateProperty',
      value: value,
      typeAnnotation: typeAnnotation};
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassProperty(parser, start, key, meta) {
    let definite;
    if (!meta.optional && parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.bang)) {
      definite = true;

      if (!parser.isSyntaxEnabled('ts')) {
        parser.addDiagnostic({
          message: 'Definite syntax but ts is not enabled'});
      }
    }

    let typeAnnotation;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
      typeAnnotation = ___R$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser);
    }

    parser.pushScope('CLASS_PROPERTY', true);

    let value;
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eq)) {
      parser.next();
      value = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'class property value');
    }
    parser.semicolon();

    parser.popScope('CLASS_PROPERTY');

    if (key.value.type === 'PrivateName') {
      throw new Error('PrivateName encountered in regular parseClassProperty, expects method is parsePrivateClassProperty');
    }

    return {
      loc: parser.finishLoc(start),
      meta: meta,
      key: key,
      type: 'ClassProperty',
      definite: definite,
      typeAnnotation: typeAnnotation,
      value: value};
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassId(parser, optionalId) {
    let idAllowed = true;

    if (optionalId === true && parser.isContextual('implements')) {
      idAllowed = false;
    }

    let id;
    if (idAllowed) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
        id = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
      } else if (!optionalId) {
        parser.addDiagnostic({
          message: 'A class name is required'});
        id = ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
        parser.createUnknownIdentifier('required class name'));
      }
    }

    const typeParameters = ___R$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser, true);
    return {id: id, typeParameters: typeParameters};
  }

  function ___R$$priv$romejs$js$parser$parser$classes_ts$parseClassSuper(parser) {
    let superClass = parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types._extends) ? ___R$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(parser, 'class heritage') : undefined;
    let superTypeParameters;

    if (superClass !== undefined) {
      superTypeParameters = ___R$romejs$js$parser$parser$type$systems_ts$maybeParseTypeArguments(parser);
    }

    let implemented;
    if (parser.isContextual('implements')) {
      parser.next();
      implemented = ___R$romejs$js$parser$parser$type$systems_ts$parseClassImplements(parser);
    }

    return {superClass: superClass, superTypeParameters: superTypeParameters, implemented: implemented};
  }

  // romejs/js-parser/parser/type-systems.ts

  const ___R$romejs$js$parser$parser$type$systems_ts = {
    isTypeSystemEnabled: ___R$romejs$js$parser$parser$type$systems_ts$isTypeSystemEnabled,
    parseTypeLiteralAnnotation: ___R$romejs$js$parser$parser$type$systems_ts$parseTypeLiteralAnnotation,
    addFlowOrTSDiagnostic: ___R$romejs$js$parser$parser$type$systems_ts$addFlowOrTSDiagnostic,
    addFlowDiagnostic: ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic,
    addTSDiagnostic: ___R$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic,
    parseClassImplements: ___R$romejs$js$parser$parser$type$systems_ts$parseClassImplements,
    parsePrimaryTypeAnnotation: ___R$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation,
    parseInterface: ___R$romejs$js$parser$parser$type$systems_ts$parseInterface,
    parseDeclare: ___R$romejs$js$parser$parser$type$systems_ts$parseDeclare,
    parseTypeAnnotationAndPredicate: ___R$romejs$js$parser$parser$type$systems_ts$parseTypeAnnotationAndPredicate,
    parseTypeAlias: ___R$romejs$js$parser$parser$type$systems_ts$parseTypeAlias,
    parseTypeParameters: ___R$romejs$js$parser$parser$type$systems_ts$parseTypeParameters,
    maybeParseTypeParameters: ___R$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters,
    parseTypeArguments: ___R$romejs$js$parser$parser$type$systems_ts$parseTypeArguments,
    parseTypeCallArguments: ___R$romejs$js$parser$parser$type$systems_ts$parseTypeCallArguments,
    maybeParseTypeArguments: ___R$romejs$js$parser$parser$type$systems_ts$maybeParseTypeArguments,
    parseTypeExpressionStatement: ___R$romejs$js$parser$parser$type$systems_ts$parseTypeExpressionStatement,
    ambiguousTypeCastToParameter: ___R$romejs$js$parser$parser$type$systems_ts$ambiguousTypeCastToParameter};
  function ___R$romejs$js$parser$parser$type$systems_ts$isTypeSystemEnabled(parser) {
    return parser.isSyntaxEnabled('flow') || parser.isSyntaxEnabled('ts');
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parseTypeLiteralAnnotation(parser) {
    const start = parser.getPosition();

    switch (parser.state.tokenType) {
      case ___R$romejs$js$parser$tokenizer$types_ts$types.string:
        {
          const value = String(parser.state.tokenValue);
          parser.next();
          return {
            loc: parser.finishLoc(start),
            type: 'StringLiteralTypeAnnotation',
            value: value};
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types.num:
        {
          const value = Number(parser.state.tokenValue);
          parser.next();
          return {
            loc: parser.finishLoc(start),
            type: 'NumericLiteralTypeAnnotation',
            value: value};
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types._true:
      case ___R$romejs$js$parser$tokenizer$types_ts$types._false:
        {
          const value = parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._true);
          parser.next();
          return {
            loc: parser.finishLoc(start),
            type: 'BooleanLiteralTypeAnnotation',
            value: value};
        }

      case ___R$romejs$js$parser$tokenizer$types_ts$types.plusMin:
        {
          if (parser.state.tokenValue === '-') {
            parser.next();

            if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.num)) {
              parser.addDiagnostic({
                message: 'Unexpected token, expected "number"'});
              parser.next();
              return {
                loc: parser.finishLoc(start),
                type: 'NumericLiteralTypeAnnotation',
                value: 0};
            }

            const value = Number(parser.state.tokenValue);
            parser.next();
            return {
              loc: parser.finishLoc(start),
              type: 'NumericLiteralTypeAnnotation',
              value: -value};
          } else {
            parser.addDiagnostic({
              message: 'Numeric literal type annotations cannot stand with a +, omit it instead'});
            parser.next();
            return ___R$romejs$js$parser$parser$type$systems_ts$parseTypeLiteralAnnotation(parser);
          }
        }

      default:
        throw new Error('Caller should have already validated the range of token types');}
  }

  function ___R$$priv$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(parser, label, flow, ts) {
    if (parser.isSyntaxEnabled('flow')) {
      return flow(parser);
    } else if (parser.isSyntaxEnabled('ts')) {
      return ts(parser);
    } else {
      const branches = parser.createBranch();

      parser.syntax.add('flow');
      branches.add(flow);
      parser.syntax.delete('flow');

      let isFlowOrTS = branches.hasOptimalBranch();

      parser.syntax.add('ts');
      branches.add(ts);
      parser.syntax.delete('ts');

      let isOnlyTS = !isFlowOrTS && branches.hasOptimalBranch();

      const start = parser.getPosition();
      const node = branches.pick();

      if (isOnlyTS) {
        ___R$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, label, start);
      } else {
        ___R$romejs$js$parser$parser$type$systems_ts$addFlowOrTSDiagnostic(parser, label, start);
      }

      return node;
    }
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$addFlowOrTSDiagnostic(parser, label, start) {
    if (parser.isSyntaxEnabled('ts') || parser.isSyntaxEnabled('flow')) {
      return;
    }

    parser.addDiagnostic({
      start: start,
      message: 'A ' + label + ' is only valid inside of a TypeScript or Flow file',
      advice: [{
        type: 'log',
        category: 'info',
        message: 'Did you mean <emphasis>TypeScript</emphasis>? Change the file extension to <emphasis>.ts</emphasis> or <emphasis>.tsx</emphasis>'}, {
        type: 'log',
        category: 'info',
        message: 'Did you mean <emphasis>Flow</emphasis>? Add a <emphasis>@flow</emphasis> comment annotation to the top of the file'}]});
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, label, start) {
    if (parser.isSyntaxEnabled('flow')) {
      return;
    }

    parser.addDiagnostic({
      start: start,
      message: 'A ' + label + ' is only valid inside of a Flow file',
      advice: [{
        type: 'log',
        category: 'info',
        message: 'To enable <emphasis>Flow</emphasis> support, add a <emphasis>@flow</emphasis> comment annotation to the top of the file'}]});
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, label, start) {
    if (parser.isSyntaxEnabled('ts')) {
      return;
    }

    parser.addDiagnostic({
      start: start,
      message: 'A ' + label + ' is only valid inside of a TypeScript file',
      advice: [{
        type: 'log',
        category: 'info',
        message: 'To enable <emphasis>TypeScript</emphasis> support, the file extension should end in <emphasis>.ts</emphasis> or <emphasis>.tsx</emphasis>'}]});
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parseClassImplements(parser) {
    return ___R$$priv$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
    parser,
    'class implements',
    ___R$romejs$js$parser$parser$flow_ts$parseFlowClassImplemented,
    () => ___R$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause(parser, 'implements'));
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parsePrimaryTypeAnnotation(parser) {
    return ___R$$priv$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(parser, 'type annotation', ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAnnotation, () => ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(parser, true));
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parseInterface(parser, start) {
    parser.addDiagnosticFilter({
      message: 'interface is a reserved word',
      start: start});

    return ___R$$priv$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
    parser,
    'interface',
    () => ___R$romejs$js$parser$parser$flow_ts$parseFlowInterface(parser, start),
    () => ___R$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(parser, start));
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parseDeclare(parser, start) {
    return ___R$$priv$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
    parser,
    'type declaration',
    () => ___R$romejs$js$parser$parser$flow_ts$parseFlowDeclare(parser, start),
    () => ___R$romejs$js$parser$parser$typescript_ts$parseTSDeclare(parser, start));
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parseTypeAnnotationAndPredicate(parser) {
    return ___R$$priv$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
    parser,
    'type annotation and a predicate',
    () => {
      return ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAndPredicateInitialiser(parser);
    },
    () => {
      return [___R$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.colon), undefined];
    });
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parseTypeAlias(parser, start) {
    return ___R$$priv$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
    parser,
    'type alias',
    () => ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeAliasTypeAnnotation(parser, start),
    () => ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeAliasTypeAnnotation(parser, start));
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parseTypeParameters(parser, allowDefault = false) {
    return ___R$$priv$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
    parser,
    'type parameters',
    () => ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterDeclaration(parser, allowDefault),
    ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters);
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$maybeParseTypeParameters(parser, allowDefault) {
    if (parser.isRelational('<')) {
      return ___R$romejs$js$parser$parser$type$systems_ts$parseTypeParameters(parser, allowDefault);
    }
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parseTypeArguments(parser) {
    return ___R$$priv$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
    parser,
    'type arguments',
    ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiation,
    ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments);
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parseTypeCallArguments(parser) {
    return ___R$$priv$romejs$js$parser$parser$type$systems_ts$parseFlowOrTS(
    parser,
    'type call arguments',
    ___R$romejs$js$parser$parser$flow_ts$parseFlowTypeParameterInstantiationCallOrNew,
    ___R$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments);
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$maybeParseTypeArguments(parser) {
    if (parser.isRelational('<')) {
      return ___R$romejs$js$parser$parser$type$systems_ts$parseTypeArguments(parser);
    }
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$parseTypeExpressionStatement(parser, start, expr) {
    if (expr.type !== 'ReferenceIdentifier') {
      return undefined;
    }

    if (parser.isSyntaxEnabled('ts') && parser.hasPrecedingLineBreak()) {
      return undefined;
    }

    switch (expr.name) {
      case 'declare':
        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._class) ||
        parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name) ||
        parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._function) ||
        parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._const) ||
        parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._var) ||
        parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._export)) {
          return ___R$romejs$js$parser$parser$type$systems_ts$parseDeclare(parser, start);
        } else {
          break;
        }

      case 'interface':
        return ___R$romejs$js$parser$parser$type$systems_ts$parseInterface(parser, start);

      case 'type':
        return ___R$romejs$js$parser$parser$type$systems_ts$parseTypeAlias(parser, start);

      case 'opaque':
        ___R$romejs$js$parser$parser$type$systems_ts$addFlowDiagnostic(parser, 'opaque type', start);
        return ___R$romejs$js$parser$parser$flow_ts$parseFlowOpaqueType(parser, start, false);

      case 'abstract':
        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._class)) {
          ___R$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'abstract class', start);
          return ___R$romejs$js$parser$parser$typescript_ts$parseTSAbstractClass(parser, start);
        } else {
          break;
        }

      case 'enum':
        {
          if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
            ___R$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'enum declaration', start);
            return ___R$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(parser, start, false);
          } else {
            break;
          }
        }

      case 'module':
        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
          ___R$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'ambient external module declaration', start);
          return ___R$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(parser, start);
        } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name) && !parser.isLineTerminator()) {
          ___R$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'module or namespace declaration', start);
          return ___R$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, start);
        } else {
          break;
        }

      case 'namespace':
        if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
          return undefined;
        }

        ___R$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'module or namespace declaration', start);
        return ___R$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(parser, start);

      case 'global':
        if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
          ___R$romejs$js$parser$parser$type$systems_ts$addTSDiagnostic(parser, 'module declaration', start);
          const global = true;
          const id = ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(expr);
          const body = ___R$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(parser);
          return {
            loc: parser.finishLoc(start),
            type: 'TSModuleDeclaration',
            global: global,
            id: id,
            body: body};
        }}
  }

  function ___R$romejs$js$parser$parser$type$systems_ts$ambiguousTypeCastToParameter(parser, node) {
    const start = parser.getPosition();
    const expr = ___R$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(parser, node.expression, 'parameter');

    const meta = {
      type: 'PatternMeta',
      loc: parser.finishLoc(start),
      optional: node.optional,
      typeAnnotation: node.typeAnnotation};

    return Object.assign({}, expr, {
      loc: parser.finishLoc(start),

      meta: meta});
  }

  // romejs/js-parser/parser/modules.ts

  const ___R$romejs$js$parser$parser$modules_ts = {
    parseExport: ___R$romejs$js$parser$parser$modules_ts$parseExport,
    parseImport: ___R$romejs$js$parser$parser$modules_ts$parseImport};

  function ___R$romejs$js$parser$parser$modules_ts$parseExport(parser, start) {
    const tsNode = ___R$romejs$js$parser$parser$typescript_ts$parseTSExport(parser, start);
    if (tsNode !== undefined) {
      return tsNode;
    }

    let exportKind = 'value';
    let source;
    let declaration;
    let specifiers;

    if (___R$$priv$romejs$js$parser$parser$modules_ts$shouldParseExportStar(parser)) {
      return ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportStar(parser, start);
    } else if (___R$$priv$romejs$js$parser$parser$modules_ts$isExportDefaultSpecifier(parser)) {
      let specifiers = [];

      const defStart = parser.getPosition();
      const defExported = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

      specifiers.push({
        loc: parser.finishLoc(defStart),
        type: 'ExportDefaultSpecifier',
        exported: defExported});

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.comma) &&
      parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.star) {
        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma);
        const specifierStart = parser.getPosition();
        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.star);
        parser.expectContextual('as');
        const exported = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser);
        specifiers.push({
          loc: parser.finishLoc(specifierStart),
          type: 'ExportNamespaceSpecifier',
          exported: exported});
      } else {
        specifiers = [...specifiers, ...___R$$priv$romejs$js$parser$parser$modules_ts$parseExportSpecifiersMaybe(parser)];
      }

      source = ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportFrom(parser, true);
    } else if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types._default)) {
      const declaration = ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportDefaultExpression(parser);
      ___R$$priv$romejs$js$parser$parser$modules_ts$checkExport(parser, specifiers, declaration, true, true);

      const node = {
        loc: parser.finishLoc(start),
        type: 'ExportDefaultDeclaration',
        declaration: declaration};
      return node;
    } else if (___R$$priv$romejs$js$parser$parser$modules_ts$shouldParseExportDeclaration(parser)) {
      ({declaration: declaration, source: source, specifiers: specifiers, exportKind: exportKind} = ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportDeclaration(
      parser));
    } else if (parser.isContextual('async') &&
    !___R$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(parser)) {
      const next = parser.lookaheadState();

      parser.addDiagnostic({
        start: next.startPos,
        end: next.endPos,
        message: 'Started with `export async` so we expected to receive an async function but no function keyword was found'});
      declaration = undefined;
      specifiers = [];
      source = undefined;
    } else {
      declaration = undefined;
      specifiers = ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(parser);
      source = ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportFrom(parser, false);
    }

    ___R$$priv$romejs$js$parser$parser$modules_ts$checkExport(
    parser,
    specifiers,
    declaration,
    true,
    false,
    source !== undefined);

    if (declaration !== undefined) {
      if (declaration.type !== 'VariableDeclarationStatement' &&
      declaration.type !== 'ClassDeclaration' &&
      declaration.type !== 'FunctionDeclaration' &&
      declaration.type !== 'TSModuleDeclaration' &&
      declaration.type !== 'TSEnumDeclaration' &&
      declaration.type !== 'FlowInterfaceDeclaration' &&
      declaration.type !== 'TypeAliasTypeAnnotation' &&
      declaration.type !== 'TSInterfaceDeclaration' &&
      declaration.type !== 'TSDeclareFunction' &&
      declaration.type !== 'FlowOpaqueType') {
        parser.addDiagnostic({
          loc: declaration.loc,
          message: 'Invalid export declaration'});
        return declaration;
      }
    }

    const node = {
      loc: parser.finishLoc(start),
      type: 'ExportNamedDeclaration',
      exportKind: exportKind,
      specifiers: specifiers,
      source: source,
      declaration: declaration};
    return node;
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportDefaultExpression(parser) {
    if (parser.isSyntaxEnabled('ts')) {
      if (___R$romejs$js$parser$parser$typescript_ts$isTSAbstractClass(parser)) {
        const start = parser.getPosition();
        parser.next();
        return ___R$romejs$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass(parser, start);
      }

      if (parser.state.tokenValue === 'interface' && !parser.isLineTerminator()) {
        const start = parser.getPosition();
        parser.next();
        return ___R$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(parser, start);
      }
    }

    const start = parser.getPosition();
    const isAsync = ___R$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(parser);
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types._function) || isAsync) {
      if (isAsync) {
        parser.eatContextual('async');
        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types._function);
      }

      return ___R$romejs$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration(parser, start, isAsync);
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._class)) {
      return ___R$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(parser, start);
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._const) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._var) || ___R$romejs$js$parser$parser$statement_ts$isLetStart(parser)) {
      parser.addDiagnostic({
        message: 'Only expressions, functions or classes are allowed as the `default` export.'});
    }

    const res = ___R$romejs$js$parser$parser$expression_ts$parseMaybeAssign(parser, 'export default declaration');
    parser.semicolon();
    return res;
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportDeclaration(parser) {
    if (parser.isContextual('type')) {
      const start = parser.getPosition();
      parser.next();

      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
        const specifiers = ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(parser);
        const source = ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportFrom(parser, false);
        return {
          exportKind: 'type',
          specifiers: specifiers,
          source: source};
      } else {
        return {
          exportKind: 'type',
          declaration: ___R$romejs$js$parser$parser$type$systems_ts$parseTypeAlias(parser, start)};
      }
    }

    if (parser.isContextual('opaque')) {
      const declarationNode = parser.getPosition();
      parser.next();

      return {
        exportKind: 'type',
        declaration: ___R$romejs$js$parser$parser$flow_ts$parseFlowOpaqueType(parser, declarationNode, false)};
    }

    if (parser.isContextual('interface')) {
      const declarationNode = parser.getPosition();
      parser.next();
      return {
        exportKind: 'type',
        declaration: ___R$romejs$js$parser$parser$type$systems_ts$parseInterface(parser, declarationNode)};
    }

    return {
      exportKind: 'value',
      declaration: ___R$romejs$js$parser$parser$statement_ts$parseStatement(parser)};
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$isExportDefaultSpecifier(parser) {
    const lookahead = parser.lookaheadState();
    if (lookahead.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.comma ||
    lookahead.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.name && lookahead.tokenValue === 'from') {
      return true;
    }

    if (parser.isSyntaxEnabled('ts') && ___R$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(parser)) {
      return false;
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name) &&
    (parser.state.tokenValue === 'type' ||
    parser.state.tokenValue === 'interface' ||
    parser.state.tokenValue == 'opaque')) {
      return false;
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name)) {
      return parser.state.tokenValue !== 'async' && parser.state.tokenValue !== 'let';
    }

    if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._default)) {
      return false;
    }

    return false;
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportSpecifiersMaybe(parser) {
    if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
      return ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(parser);
    } else {
      return [];
    }
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportFrom(parser, expect) {
    let source;

    if (parser.eatContextual('from')) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
        source = ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
      } else {
        const expr = ___R$romejs$js$parser$parser$expression_ts$parseExpressionAtom(parser, 'export from');

        parser.addDiagnostic({
          loc: expr.loc,
          message: 'Import from only allows strings'});

        source = {
          type: 'StringLiteral',
          value: '',
          loc: expr.loc};
      }
    } else if (expect) {
      parser.addDiagnostic({
        message: 'Expected `from` for an export node'});

      source = {
        type: 'StringLiteral',
        value: '',
        loc: parser.finishLoc(parser.getPosition())};
    }

    parser.semicolon();

    return source;
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$shouldParseExportStar(parser) {
    return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.star) ||
    parser.isContextual('type') &&
    parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.star;
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportStar(parser, start) {
    let exportKind;
    if (parser.eatContextual('type')) {
      exportKind = 'type';
    }

    parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.star);

    if (parser.isContextual('as')) {
      const {source: source, specifiers: specifiers} = ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportNamespace(parser, exportKind);
      return {
        loc: parser.finishLoc(start),
        type: 'ExportNamedDeclaration',
        exportKind: exportKind,
        specifiers: specifiers,
        source: source};
    } else {
      const source = ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportFrom(parser, true);
      if (source === undefined) {
        throw new Error('Passed `true` above which expects there to be a string');
      }
      return {
        loc: parser.finishLoc(start),
        type: 'ExportAllDeclaration',
        exportKind: exportKind,
        source: source};
    }
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportNamespace(parser, exportKind) {
    if (exportKind === 'type') {
      parser.addDiagnostic({
        message: 'Can\'t have a type export namespacer specifier'});
    }

    const specifierStart = parser.state.lastStartPos;
    parser.next();
    const exported = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

    let specifiers = [];

    specifiers.push({
      loc: parser.finishLoc(specifierStart),
      type: 'ExportNamespaceSpecifier',
      exported: exported});

    specifiers = [...specifiers, ...___R$$priv$romejs$js$parser$parser$modules_ts$parseExportSpecifiersMaybe(parser)];

    const source = ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportFrom(parser, true);

    return {source: source, specifiers: specifiers};
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$shouldParseExportDeclaration(parser) {
    return ___R$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(parser) ||
    parser.isContextual('type') ||
    parser.isContextual('interface') ||
    parser.isContextual('opaque') ||
    parser.state.tokenType.keyword === 'var' ||
    parser.state.tokenType.keyword === 'const' ||
    parser.state.tokenType.keyword === 'function' ||
    parser.state.tokenType.keyword === 'class' ||
    ___R$romejs$js$parser$parser$statement_ts$isLetStart(parser) ||
    ___R$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(parser) ||
    parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.at);
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$checkExport(parser, specifiers, declaration, checkNames = false, isDefault = false, isFrom = false) {
    if (checkNames === false) {
      return undefined;
    }

    if (isDefault) {
      if (declaration !== undefined) {
        ___R$$priv$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, declaration, 'default');
      }
      return undefined;
    }

    if (specifiers !== undefined && specifiers.length > 0) {
      for (const specifier of specifiers) {
        ___R$$priv$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, specifier, specifier.exported.name);

        if (specifier.type === 'ExportSpecifier') {
          const {local: local} = specifier;
          if (!isFrom && local !== undefined) {
            ___R$romejs$js$parser$parser$expression_ts$checkReservedWord(
            parser,
            local.name,
            parser.getLoc(local),
            true,
            false);
          }
        }
      }
      return undefined;
    }

    if (declaration !== undefined) {
      if (declaration.type === 'FunctionDeclaration') {
        if (declaration.id === undefined) {
          throw new Error('Expected declaration.id');
        }

        ___R$$priv$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, declaration, declaration.id.name);
      }

      if (declaration.type === 'ClassDeclaration') {
        if (declaration.id === undefined) {
          throw new Error('Expected declaration.id');
        }

        ___R$$priv$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, declaration, declaration.id.name);
      }

      if (declaration.type === 'VariableDeclaration') {
        for (const node of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(declaration)) {
          ___R$$priv$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, node, node.name);
        }
      }
    }
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$checkDuplicateExports(parser, node, name) {
    if (parser.isSyntaxEnabled('ts')) {
      return undefined;
    }

    const existing = parser.state.exportedIdentifiers.get(name);
    if (existing !== undefined) {
      parser.addDiagnostic({
        loc: node.loc,
        message: name === 'default' ? 'Only one default export allowed per module.' : '`' + name + '` has already been exported. Exported identifiers must be unique.',
        advice: [{
          type: 'log',
          category: 'info',
          message: 'First defined here'}, {
          type: 'frame',
          filename: existing.filename,
          start: existing.start,
          end: existing.end}]});
    }

    parser.state.exportedIdentifiers.set(name, parser.getLoc(node));
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(parser) {
    const specifiers = [];
    let first = true;

    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
    'export specifiers');

    while (true) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma);
        if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      const start = parser.getPosition();
      const local = ___R$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(parser, true);
      const exported = parser.eatContextual('as') ? ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true) : ___R$romejs$js$parser$parser$expression_ts$toIdentifier(parser.cloneNode(local));
      specifiers.push({
        loc: parser.finishLoc(start),
        type: 'ExportSpecifier',
        local: local,
        exported: exported});
    }

    return specifiers;
  }

  function ___R$romejs$js$parser$parser$modules_ts$parseImport(parser, start) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name) && parser.lookaheadState().tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.eq) {
      return ___R$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(parser, start);
    }

    let specifiers;
    let source;
    let importKind;

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
      specifiers = [];
      source = ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
    } else {
      ({specifiers: specifiers, importKind: importKind} = ___R$$priv$romejs$js$parser$parser$modules_ts$parseImportSpecifiers(parser, start));

      if (parser.expectContextual('from') && parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
        source = ___R$romejs$js$parser$parser$expression_ts$parseStringLiteral(parser);
      } else {
        parser.addDiagnostic({
          message: 'import missing a source'});

        source = {
          type: 'StringLiteral',
          value: '',
          loc: parser.finishLoc(start)};
      }
    }

    parser.semicolon();
    return {
      loc: parser.finishLoc(start),
      type: 'ImportDeclaration',
      specifiers: specifiers,
      source: source,
      importKind: importKind};
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$shouldParseDefaultImport(parser, kind) {
    if (___R$romejs$js$parser$parser$flow_ts$hasTypeImportKind(kind)) {
      return ___R$romejs$js$parser$parser$flow_ts$isMaybeDefaultImport(parser.state);
    } else {
      return parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name);
    }
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$parseImportSpecifierLocal(parser, importKind, contextDescription) {
    const start = parser.getPosition();

    const local = ___R$romejs$js$parser$parser$flow_ts$hasTypeImportKind(importKind) ? ___R$romejs$js$parser$parser$flow_ts$parseFlowRestrictedIdentifier(parser, true) : ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);

    ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, local, true, undefined, contextDescription);

    return {
      type: 'ImportSpecifierLocal',
      loc: parser.finishLoc(start),
      name: local,
      importKind: importKind};
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$parseImportSpecifiers(parser, start) {
    let importKind = undefined;

    const lh = parser.lookaheadState();
    if (lh.tokenType !== ___R$romejs$js$parser$tokenizer$types_ts$types.name ||
    lh.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.name && lh.tokenValue !== 'from') {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types._typeof)) {
        importKind = 'typeof';
      } else if (parser.isContextual('type')) {
        importKind = 'type';
      }
    }

    if (importKind) {
      if (importKind === 'type' && lh.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.star) {
        parser.addDiagnostic({
          start: lh.startPos,
          message: 'import * is not allowed'});
      }

      if (___R$romejs$js$parser$parser$flow_ts$isMaybeDefaultImport(lh) ||
      lh.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.braceL ||
      lh.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.star) {
        parser.next();
      }
    }

    const specifiers = [];

    let first = true;

    if (___R$$priv$romejs$js$parser$parser$modules_ts$shouldParseDefaultImport(parser, importKind)) {
      const start = parser.getPosition();

      const meta = ___R$$priv$romejs$js$parser$parser$modules_ts$parseImportSpecifierLocal(
      parser,
      importKind,
      'default import specifier');

      specifiers.push({
        loc: parser.finishLoc(start),
        type: 'ImportDefaultSpecifier',
        local: meta});

      if (!parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.comma)) {
        return {specifiers: specifiers, importKind: importKind};
      }
    }

    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.star)) {
      const start = parser.getPosition();
      parser.next();
      parser.expectContextual('as');

      const meta = ___R$$priv$romejs$js$parser$parser$modules_ts$parseImportSpecifierLocal(
      parser,
      importKind,
      'import namespace specifier');

      specifiers.push({
        loc: parser.finishLoc(start),
        type: 'ImportNamespaceSpecifier',
        local: meta});

      return {specifiers: specifiers, importKind: importKind};
    }

    const openContext = parser.expectOpening(
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceL,
    ___R$romejs$js$parser$tokenizer$types_ts$types.braceR,
    'import specifiers');

    while (true) {
      if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR) || parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
        parser.expectClosing(openContext);
        break;
      }

      if (first) {
        first = false;
      } else {
        if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.colon)) {
          parser.addDiagnostic({
            message: 'ES2015 named imports do not destructure. Use another statement for destructuring after the import.'});
        }

        parser.expect(___R$romejs$js$parser$tokenizer$types_ts$types.comma);

        if (parser.eat(___R$romejs$js$parser$tokenizer$types_ts$types.braceR)) {
          break;
        }
      }

      specifiers.push(___R$$priv$romejs$js$parser$parser$modules_ts$parseImportSpecifier(parser, importKind));
    }

    return {specifiers: specifiers, importKind: importKind};
  }

  function ___R$$priv$romejs$js$parser$parser$modules_ts$parseImportSpecifier(parser, nodeKind) {
    const start = parser.getPosition();
    const firstIdentPos = parser.state.startPos;
    const firstIdent = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);

    let imported;
    let local;
    let importKind = undefined;
    if (firstIdent.name === 'type') {
      importKind = 'type';
    } else if (firstIdent.name === 'typeof') {
      importKind = 'typeof';
    }

    let isBinding = false;
    if (parser.isContextual('as') && !parser.isLookaheadContextual('as')) {
      const as_ident = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
      if (importKind !== undefined &&
      !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name) &&
      parser.state.tokenType.keyword === undefined) {
        imported = as_ident;
        local = ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(parser.cloneNode(as_ident));
      } else {
        imported = firstIdent;
        importKind = undefined;
        local = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
      }
    } else if (importKind !== undefined &&
    (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.name) || parser.state.tokenType.keyword)) {
      imported = ___R$romejs$js$parser$parser$expression_ts$parseIdentifier(parser, true);
      if (parser.eatContextual('as')) {
        local = ___R$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(parser);
      } else {
        isBinding = true;
        local = ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(parser.cloneNode(imported));
      }
    } else {
      isBinding = true;
      imported = firstIdent;
      importKind = undefined;
      local = ___R$romejs$js$parser$parser$expression_ts$toBindingIdentifier(parser.cloneNode(imported));
    }

    const nodeIsTypeImport = ___R$romejs$js$parser$parser$flow_ts$hasTypeImportKind(nodeKind);
    const specifierIsTypeImport = ___R$romejs$js$parser$parser$flow_ts$hasTypeImportKind(importKind);

    if (nodeIsTypeImport && specifierIsTypeImport) {
      parser.addDiagnostic({
        start: firstIdentPos,
        message: 'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements'});
    }

    const loc = parser.finishLoc(start);

    if (nodeIsTypeImport || specifierIsTypeImport) {
      ___R$romejs$js$parser$parser$flow_ts$checkReservedType(parser, local.name, loc);
    }

    if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
      ___R$romejs$js$parser$parser$expression_ts$checkReservedWord(parser, local.name, loc, true, true);
    }

    ___R$romejs$js$parser$parser$lval_ts$checkLVal(parser, local, true, undefined, 'import specifier');

    return {
      type: 'ImportSpecifier',
      loc: loc,
      imported: imported,
      local: {
        type: 'ImportSpecifierLocal',
        loc: loc,
        name: local,
        importKind: importKind}};
  }

  // romejs/js-parser/parser/index.ts


  // romejs/js-parser/tokenizer/unicodeMistakes.ts

  const ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES = new Map();

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u07fa', ['Nko Lajanyalan', '_']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe4d', ['Dashed Low Line', '_']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe4e', ['Centreline Low Line', '_']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe4f', ['Wavy Low Line', '_']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff3f', ['Fullwidth Low Line', '_']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2010', ['Hyphen', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2011', ['Non-Breaking Hyphen', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2012', ['Figure Dash', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2013', ['En Dash', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2014', ['Em Dash', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe58', ['Small Em Dash', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u06d4', ['Arabic Full Stop', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2043', ['Hyphen Bullet', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02d7', ['Modifier Letter Minus Sign', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2212', ['Minus Sign', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2796', ['Heavy Minus Sign', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2cba', ['Coptic Letter Dialect-P Ni', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u30fc', ['Katakana-Hiragana Prolonged Sound Mark', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0d', ['Fullwidth Hyphen-Minus', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2015', ['Horizontal Bar', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2500', ['Box Drawings Light Horizontal', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2501', ['Box Drawings Heavy Horizontal', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u31d0', ['CJK Stroke H', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua7f7', ['Latin Epigraphic Letter Dideways', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1173', ['Hangul Jungseong Eu', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3161', ['Hangul Letter Eu', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u4e00', ['CJK Unified Ideograph-4E00', '-']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2f00', ['Kangxi Radical One', '-']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u060d', ['Arabic Date Separator', ',']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u066b', ['Arabic Decimal Separator', ',']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u201a', ['Single Low-9 Quotation Mark', ',']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\xb8', ['Cedilla', ',']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua4f9', ['Lisu Letter Tone Na Po', ',']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0c', ['Fullwidth Comma', ',']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u037e', ['Greek Question Mark', ';']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1b', ['Fullwidth Semicolon', ';']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe14', ['Presentation Form For Vertical Semicolon', ';']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0903', ['Devanagari Sign Visarga', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0a83', ['Gujarati Sign Visarga', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1a', ['Fullwidth Colon', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0589', ['Armenian Full Stop', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0703', ['Syriac Supralinear Colon', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0704', ['Syriac Sublinear Colon', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u16ec', ['Runic Multiple Punctuation', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe30', ['Presentation Form For Vertical Two Dot Leader', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1803', ['Mongolian Full Stop', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1809', ['Mongolian Manchu Full Stop', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u205a', ['Two Dot Punctuation', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u05c3', ['Hebrew Punctuation Sof Pasuq', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02f8', ['Modifier Letter Raised Colon', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua789', ['Modifier Letter Colon', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2236', ['Ratio', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02d0', ['Modifier Letter Triangular Colon', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua4fd', ['Lisu Letter Tone Mya Jeu', ':']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe13', ['Presentation Form For Vertical Colon', ':']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff01', ['Fullwidth Exclamation Mark', '!']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u01c3', ['Latin Letter Retroflex Click', '!']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2d51', ['Tifinagh Letter Tuareg Yang', '!']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe15', ['Presentation Form For Vertical Exclamation Mark', '!']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0294', ['Latin Letter Glottal Stop', '?']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0241', ['Latin Capital Letter Glottal Stop', '?']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u097d', ['Devanagari Letter Glottal Stop', '?']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u13ae', ['Cherokee Letter He', '?']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua6eb', ['Bamum Letter Ntuu', '?']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1f', ['Fullwidth Question Mark', '?']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe16', ['Presentation Form For Vertical Question Mark', '?']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1d16d}', ['Musical Symbol Combining Augmentation Dot', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2024', ['One Dot Leader', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0701', ['Syriac Supralinear Full Stop', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0702', ['Syriac Sublinear Full Stop', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua60e', ['Vai Full Stop', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{10a50}', ['Kharoshthi Punctuation Dot', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0660', ['Arabic-Indic Digit Zero', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u06f0', ['Extended Arabic-Indic Digit Zero', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua4f8', ['Lisu Letter Tone Mya Ti', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\xb7', ['Middle Dot', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u30fb', ['Katakana Middle Dot', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff65', ['Halfwidth Katakana Middle Dot', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u16eb', ['Runic Single Punctuation', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0387', ['Greek Ano Teleia', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2e31', ['Word Separator Middle Dot', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{10101}', ['Aegean Word Separator Dot', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2022', ['Bullet', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2027', ['Hyphenation Point', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2219', ['Bullet Operator', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u22c5', ['Dot Operator', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua78f', ['Latin Letter Sinological Dot', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1427', ['Canadian Syllabics Final Middle Dot', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1427', ['Canadian Syllabics Final Middle Dot', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0e', ['Fullwidth Full Stop', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3002', ['Ideographic Full Stop', '.']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe12', ['Presentation Form For Vertical Ideographic Full Stop', '.']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u055d', ['Armenian Comma', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff07', ['Fullwidth Apostrophe', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2018', ['Left Single Quotation Mark', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2019', ['Right Single Quotation Mark', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u201b', ['Single High-Reversed-9 Quotation Mark', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2032', ['Prime', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2035', ['Reversed Prime', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u055a', ['Armenian Apostrophe', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u05f3', ['Hebrew Punctuation Geresh', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('`', ['Grave Accent', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1fef', ['Greek Varia', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff40', ['Fullwidth Grave Accent', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\xb4', ['Acute Accent', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0384', ['Greek Tonos', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1ffd', ['Greek Oxia', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1fbd', ['Greek Koronis', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1fbf', ['Greek Psili', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1ffe', ['Greek Dasia', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02b9', ['Modifier Letter Prime', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u0374', ['Greek Numeral Sign', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02c8', ['Modifier Letter Vertical Line', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02ca', ['Modifier Letter Acute Accent', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02cb', ['Modifier Letter Grave Accent', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02f4', ['Modifier Letter Middle Grave Accent', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02bb', ['Modifier Letter Turned Comma', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02bd', ['Modifier Letter Reversed Comma', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02bc', ['Modifier Letter Apostrophe', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02be', ['Modifier Letter Right Half Ring', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua78c', ['Latin Small Letter Saltillo', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u05d9', ['Hebrew Letter Yod', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u07f4', ['Nko High Tone Apostrophe', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u07f5', ['Nko Low Tone Apostrophe', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u144a', ['Canadian Syllabics West-Cree P', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u16cc', ['Runic Letter Short-Twig-Sol S', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{16f51}', ['Miao Sign Aspiration', '\'']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{16f52}', ['Miao Sign Reformed Voicing', '\'']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1cd3', ['Vedic Sign Nihshvasa', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff02', ['Fullwidth Quotation Mark', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u201c', ['Left Double Quotation Mark', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u201d', ['Right Double Quotation Mark', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u201f', ['Double High-Reversed-9 Quotation Mark', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2033', ['Double Prime', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2036', ['Reversed Double Prime', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3003', ['Ditto Mark', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u05f4', ['Hebrew Punctuation Gershayim', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02dd', ['Double Acute Accent', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02ba', ['Modifier Letter Double Prime', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02f6', ['Modifier Letter Middle Double Acute Accent', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02f5', ['Modifier Letter Middle Double Grave Accent', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02ee', ['Modifier Letter Double Apostrophe', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u05f2', ['Hebrew Ligature Yiddish Double Yod', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u275e', ['Heavy Double Comma Quotation Mark Ornament', '"']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u275d', ['Heavy Double Turned Comma Quotation Mark Ornament', '"']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff08', ['Fullwidth Left Parenthesis', '(']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2768', ['Medium Left Parenthesis Ornament', '(']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufd3e', ['Ornate Left Parenthesis', '(']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff09', ['Fullwidth Right Parenthesis', ')']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2769', ['Medium Right Parenthesis Ornament', ')']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufd3f', ['Ornate Right Parenthesis', ')']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff3b', ['Fullwidth Left Square Bracket', '[']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2772', ['Light Left Tortoise Shell Bracket Ornament', '[']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300c', ['Left Corner Bracket', '[']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300e', ['Left White Corner Bracket', '[']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3010', ['Left Black Lenticular Bracket', '[']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3014', ['Left Tortoise Shell Bracket', '[']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3016', ['Left White Lenticular Bracket', '[']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3018', ['Left White Tortoise Shell Bracket', '[']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u301a', ['Left White Square Bracket', '[']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff3d', ['Fullwidth Right Square Bracket', ']']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2773', ['Light Right Tortoise Shell Bracket Ornament', ']']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300d', ['Right Corner Bracket', ']']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300f', ['Right White Corner Bracket', ']']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3011', ['Right Black Lenticular Bracket', ']']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3015', ['Right Tortoise Shell Bracket', ']']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3017', ['Right White Lenticular Bracket', ']']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3019', ['Right White Tortoise Shell Bracket', ']']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u301b', ['Right White Square Bracket', ']']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2774', ['Medium Left Curly Bracket Ornament', '{']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1d114}', ['Musical Symbol Brace', '{']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff5b', ['Fullwidth Left Curly Bracket', '{']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2775', ['Medium Right Curly Bracket Ornament', '}']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff5d', ['Fullwidth Right Curly Bracket', '}']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u204e', ['Low Asterisk', '*']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u066d', ['Arabic Five Pointed Star', '*']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2217', ['Asterisk Operator', '*']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1031f}', ['Old Italic Letter Ess', '*']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0a', ['Fullwidth Asterisk', '*']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1735', ['Philippine Single Punctuation', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2041', ['Caret Insertion Point', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2215', ['Division Slash', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2044', ['Fraction Slash', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2571', ['Box Drawings Light Diagonal Upper Right To Lower Left', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u27cb', ['Mathematical Rising Diagonal', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u29f8', ['Big Solidus', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1d23a}', ['Greek Instrumental Notation Symbol-47', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u31d3', ['CJK Stroke Sp', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3033', ['Vertical Kana Repeat Mark Upper Half', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2cc6', ['Coptic Capital Letter Old Coptic Esh', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u30ce', ['Katakana Letter No', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u4e3f', ['CJK Unified Ideograph-4E3F', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2f03', ['Kangxi Radical Slash', '/']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0f', ['Fullwidth Solidus', '/']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff3c', ['Fullwidth Reverse Solidus', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufe68', ['Small Reverse Solidus', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2216', ['Set Minus', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u27cd', ['Mathematical Falling Diagonal', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u29f5', ['Reverse Solidus Operator', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u29f9', ['Big Reverse Solidus', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u29f9', ['Greek Vocal Notation Symbol-16', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u29f9', ['Greek Instrumental Symbol-48', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u31d4', ['CJK Stroke D', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u4e36', ['CJK Unified Ideograph-4E36', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2f02', ['Kangxi Radical Dot', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3001', ['Ideographic Comma', '\\']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u30fd', ['Katakana Iteration Mark', '\\']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua778', ['Latin Small Letter Um', '&']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff06', ['Fullwidth Ampersand', '&']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u16ed', ['Runic Cross Punctuation', '+']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2795', ['Heavy Plus Sign', '+']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1029b}', ['Lycian Letter H', '+']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ufb29', ['Hebrew Letter Alternative Plus Sign', '+']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff0b', ['Fullwidth Plus Sign', '+']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2039', ['Single Left-Pointing Angle Quotation Mark', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u276e', ['Heavy Left-Pointing Angle Quotation Mark Ornament', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02c2', ['Modifier Letter Left Arrowhead', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1d236}', ['Greek Instrumental Symbol-40', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1438', ['Canadian Syllabics Pa', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u16b2', ['Runic Letter Kauna', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u276c', ['Medium Left-Pointing Angle Bracket Ornament', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u27e8', ['Mathematical Left Angle Bracket', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2329', ['Left-Pointing Angle Bracket', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3008', ['Left Angle Bracket', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u31db', ['CJK Stroke Pd', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u304f', ['Hiragana Letter Ku', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{21fe8}', ['CJK Unified Ideograph-21FE8', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300a', ['Left Double Angle Bracket', '<']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1c', ['Fullwidth Less-Than Sign', '<']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1400', ['Canadian Syllabics Hyphen', '=']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u2e40', ['Double Hyphen', '=']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u30a0', ['Katakana-Hiragana Double Hyphen', '=']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\ua4ff', ['Lisu Punctuation Full Stop', '=']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1d', ['Fullwidth Equals Sign', '=']);

  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u203a', ['Single Right-Pointing Angle Quotation Mark', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u276f', ['Heavy Right-Pointing Angle Quotation Mark Ornament', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u02c3', ['Modifier Letter Right Arrowhead', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{1d237}', ['Greek Instrumental Symbol-42', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u1433', ['Canadian Syllabics Po', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u{16f3f}', ['Miao Letter Archaic Zza', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u276d', ['Medium Right-Pointing Angle Bracket Ornament', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u27e9', ['Mathematical Right Angle Bracket', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u232a', ['Right-Pointing Angle Bracket', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u3009', ['Right Angle Bracket', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\u300b', ['Right Double Angle Bracket', '>']);
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set('\uff1e', ['Fullwidth Greater-Than Sign', '>']);

  const ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES = new Map();
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(' ', 'Space');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('_', 'Underscore');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('-', 'Minus/Hyphen');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(',', 'Comma');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(';', 'Semicolon');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(':', 'Colon');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('!', 'Exclamation Mark');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('?', 'Question Mark');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('.', 'Period');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('\'', 'Single Quote');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('"', 'Quotation Mark');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('(', 'Left Parenthesis');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(')', 'Right Parenthesis');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('[', 'Left Square Bracket');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(']', 'Right Square Bracket');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('{', 'Left Curly Brace');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('}', 'Right Curly Brace');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('*', 'Asterisk');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('/', 'Slash');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('\\', 'Backslash');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('&', 'Ampersand');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('+', 'Plus Sign');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('<', 'Less-Than Sign');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('=', 'Equals Sign');
  ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set('>', 'Greater-Than Sign');

  // romejs/js-parser/tokenizer/index.ts

  const ___R$$priv$romejs$js$parser$tokenizer$index_ts$HEX_NUMBER = /^[\da-fA-F]+$/;
  const ___R$$priv$romejs$js$parser$tokenizer$index_ts$DECIMAL_NUMBER = /^\d+$/;

  const ___R$$priv$romejs$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings = {
    decBinOct: [___R$romejs$string$charcodes$index_ts.dot, ___R$romejs$string$charcodes$index_ts.uppercaseB, ___R$romejs$string$charcodes$index_ts.uppercaseE, ___R$romejs$string$charcodes$index_ts.uppercaseO, ___R$romejs$string$charcodes$index_ts.underscore, ___R$romejs$string$charcodes$index_ts.lowercaseB, ___R$romejs$string$charcodes$index_ts.lowercaseE, ___R$romejs$string$charcodes$index_ts.lowercaseO],
    hex: [___R$romejs$string$charcodes$index_ts.dot, ___R$romejs$string$charcodes$index_ts.uppercaseX, ___R$romejs$string$charcodes$index_ts.underscore, ___R$romejs$string$charcodes$index_ts.lowercaseX]};

  const ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin = [___R$romejs$string$charcodes$index_ts.digit0, ___R$romejs$string$charcodes$index_ts.digit1];
  const ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct = [...___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin, ___R$romejs$string$charcodes$index_ts.digit2, ___R$romejs$string$charcodes$index_ts.digit3, ___R$romejs$string$charcodes$index_ts.digit4, ___R$romejs$string$charcodes$index_ts.digit5, ___R$romejs$string$charcodes$index_ts.digit6, ___R$romejs$string$charcodes$index_ts.digit7];
  const ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec = [...___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct, ___R$romejs$string$charcodes$index_ts.digit8, ___R$romejs$string$charcodes$index_ts.digit9];

  const ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsHex = [...___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec, ___R$romejs$string$charcodes$index_ts.uppercaseA, ___R$romejs$string$charcodes$index_ts.uppercaseB, ___R$romejs$string$charcodes$index_ts.uppercaseC, ___R$romejs$string$charcodes$index_ts.uppercaseD, ___R$romejs$string$charcodes$index_ts.uppercaseE, ___R$romejs$string$charcodes$index_ts.uppercaseF, ___R$romejs$string$charcodes$index_ts.lowercaseA, ___R$romejs$string$charcodes$index_ts.lowercaseB, ___R$romejs$string$charcodes$index_ts.lowercaseC, ___R$romejs$string$charcodes$index_ts.lowercaseD, ___R$romejs$string$charcodes$index_ts.lowercaseE, ___R$romejs$string$charcodes$index_ts.lowercaseF];
  const ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings = {
    bin: ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin,
    oct: ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct,
    dec: ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec,
    hex: ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsHex};

  class ___R$romejs$js$parser$tokenizer$index_ts$RegExpTokenValue {
    constructor(pattern, flags) {
      this.pattern = pattern;
      this.flags = flags;
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser) {
    const index = ___R$romejs$ob1$index_ts$inc(parser.state.index);
    parser.state.index = index;
    return index;
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) {
    return ___R$romejs$ob1$index_ts$get0(parser.state.index);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$codePointToString(code) {
    if (code <= 65535) {
      return String.fromCharCode(code);
    } else {
      return String.fromCharCode(
      (code - 65536 >> 10) + 55296,
      (code - 65536 & 1023) + 56320);
    }
  }

  function ___R$romejs$js$parser$tokenizer$index_ts$setStrict(parser, isStrict) {
    parser.pushScope('STRICT', isStrict);

    if (!parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.num) && !parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.string)) {
      return undefined;
    }

    parser.state.index = parser.state.startPos.index;
    while (parser.state.index < parser.state.lineStartIndex) {
      parser.state.lineStartIndex = ___R$romejs$ob1$index_ts$coerce0(
      parser.input.lastIndexOf('\n', ___R$romejs$ob1$index_ts$get0(parser.state.lineStartIndex) - 2) + 1);
      parser.state.curLine = ___R$romejs$ob1$index_ts$inc(parser.state.curLine);
    }
    ___R$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
  }

  function ___R$romejs$js$parser$tokenizer$index_ts$getCurContext(parser) {
    return parser.state.context[parser.state.context.length - 1];
  }

  function ___R$romejs$js$parser$tokenizer$index_ts$nextToken(parser) {
    const curContext = ___R$romejs$js$parser$tokenizer$index_ts$getCurContext(parser);

    if (!curContext || !curContext.preserveSpace) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$skipSpace(parser);
    }

    parser.state.containsOctal = false;
    parser.state.octalPosition = undefined;
    parser.state.startPos = parser.getPositionFromState();

    if (parser.state.index >= parser.length) {
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.eof);
      return undefined;
    }

    if (curContext.override) {
      curContext.override(parser);
    } else {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken(parser, ___R$$priv$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(parser));
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken(parser, code) {
    const matchedJSX = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readJSXToken(parser, code);
    if (matchedJSX) {
      return undefined;
    } else {
      return ___R$$priv$romejs$js$parser$tokenizer$index_ts$readNormalToken(parser, code);
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readJSXToken(parser, code) {
    if (parser.inScope('PROPERTY_NAME')) {
      return false;
    }

    if (parser.inScope('TYPE')) {
      return false;
    }

    if (!parser.shouldTokenizeJSX()) {
      return false;
    }

    const context = ___R$romejs$js$parser$tokenizer$index_ts$getCurContext(parser);

    if (context === ___R$romejs$js$parser$tokenizer$context_ts$types.jsxInner) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsx(parser);
      return true;
    }

    if (context === ___R$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag || context === ___R$romejs$js$parser$tokenizer$context_ts$types.jsxCloseTag) {
      if (___R$romejs$js$parser$utils$identifier_ts$isIdentifierStart(code)) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsxWord(parser);
        return true;
      }

      if (code === ___R$romejs$string$charcodes$index_ts.greaterThan) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd);
        return true;
      }

      if ((code === ___R$romejs$string$charcodes$index_ts.quotationMark || code === ___R$romejs$string$charcodes$index_ts.apostrophe) &&
      context === ___R$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsxString(parser, code);
        return true;
      }
    }

    if (code === ___R$romejs$string$charcodes$index_ts.lessThan &&
    parser.state.exprAllowed &&
    parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1) !== ___R$romejs$string$charcodes$index_ts.exclamationMark) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart);
      return true;
    }

    return false;
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readNormalToken(parser, code) {
    if (___R$romejs$js$parser$utils$identifier_ts$isIdentifierStart(code) || code === ___R$romejs$string$charcodes$index_ts.backslash) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$readWord(parser);
    } else {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(parser, code);
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(parser) {
    return ___R$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(parser.input, ___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$pushComment(parser, opts) {
    const loc = parser.finishLocAt(opts.startPos, opts.endPos);
    let comment;
    if (opts.block) {
      comment = {
        type: 'CommentBlock',
        value: opts.text,
        loc: loc};
    } else {
      comment = {
        type: 'CommentLine',
        value: opts.text,
        loc: loc};
    }

    if (opts.text.includes('@flow') || opts.text.includes('@noflow')) {
      if (parser.syntax.has('ts')) {
        parser.addDiagnostic({
          message: 'Cannot have a @flow annotation comment when TypeScript syntax has been enabled'});
      } else {
        parser.syntax.add('flow');

        parser.syntax.add('jsx');
      }
    }

    if (parser.isLookahead === false) {
      parser.state.comments.push(comment);
      ___R$romejs$js$parser$parser$comments_ts$addComment(parser, comment);
    }

    if (parser.shouldCreateToken()) {}

    return comment;
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$skipBlockComment(parser) {
    const startPos = parser.getPosition();
    const startIndex = parser.state.index;
    parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, 2);

    const endIndex = ___R$romejs$ob1$index_ts$coerce0(parser.input.indexOf('*/', ___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser)));

    if (endIndex === ___R$romejs$ob1$index_ts$number0Neg1) {
      parser.addDiagnostic({
        end: parser.getPositionFromIndex(___R$romejs$ob1$index_ts$sub(parser.state.index, 2)),
        message: 'Unterminated comment'});
      return undefined;
    }

    parser.state.index = ___R$romejs$ob1$index_ts$add(endIndex, 2);

    ___R$romejs$js$parser$utils$whitespace_ts$lineBreakG.lastIndex = ___R$romejs$ob1$index_ts$get0(startIndex);

    let match;
    while ((match = ___R$romejs$js$parser$utils$whitespace_ts$lineBreakG.exec(parser.input)) &&
    match.index < ___R$romejs$ob1$index_ts$get0(parser.state.index)) {
      parser.state.curLine = ___R$romejs$ob1$index_ts$inc(parser.state.curLine);
      parser.resetTokenizerLine();
      parser.state.lineStartIndex = ___R$romejs$ob1$index_ts$coerce0(match.index + match[0].length);
    }

    ___R$$priv$romejs$js$parser$tokenizer$index_ts$pushComment(parser, {
      block: true,
      text: parser.getRawInput(___R$romejs$ob1$index_ts$add(startIndex, 2), endIndex),
      startPos: startPos,
      endPos: parser.getPosition()});
  }

  function ___R$romejs$js$parser$tokenizer$index_ts$skipLineComment(parser, startSkip) {
    const startIndex = parser.state.index;
    const startPos = parser.getPosition();
    parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, startSkip);
    let ch = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    if (parser.state.index < parser.length) {
      while (ch !== ___R$romejs$string$charcodes$index_ts.lineFeed &&
      ch !== ___R$romejs$string$charcodes$index_ts.carriageReturn &&
      ch !== ___R$romejs$string$charcodes$index_ts.lineSeparator &&
      ch !== ___R$romejs$string$charcodes$index_ts.paragraphSeparator &&
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser) < parser.length) {
        ch = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      }
    }

    return ___R$$priv$romejs$js$parser$tokenizer$index_ts$pushComment(parser, {
      block: false,
      text: parser.getRawInput(___R$romejs$ob1$index_ts$add(startIndex, startSkip), parser.state.index),
      startPos: startPos,
      endPos: parser.getPosition()});
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$skipSpace(parser) {
    loop: while (parser.state.index < parser.length) {
      const ch = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));

      if (parser.state.lineStart) {
        if (ch === ___R$romejs$string$charcodes$index_ts.space || ch === ___R$romejs$string$charcodes$index_ts.tab) {
          parser.state.indentLevel = ___R$romejs$ob1$index_ts$inc(parser.state.indentLevel);
        } else {
          parser.state.lineStart = false;
        }
      }

      if (ch === ___R$romejs$string$charcodes$index_ts.carriageReturn &&
      parser.input.charCodeAt(___R$romejs$ob1$index_ts$get0(parser.state.index) + 1) ===
      ___R$romejs$string$charcodes$index_ts.lineFeed) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }

      switch (ch) {
        case ___R$romejs$string$charcodes$index_ts.space:
        case ___R$romejs$string$charcodes$index_ts.nonBreakingSpace:
          ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
          break;

        case ___R$romejs$string$charcodes$index_ts.carriageReturn:
        case ___R$romejs$string$charcodes$index_ts.lineFeed:
        case ___R$romejs$string$charcodes$index_ts.lineSeparator:
        case ___R$romejs$string$charcodes$index_ts.paragraphSeparator:
          ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
          parser.state.curLine = ___R$romejs$ob1$index_ts$inc(parser.state.curLine);
          parser.resetTokenizerLine();
          break;

        case ___R$romejs$string$charcodes$index_ts.slash:
          switch (parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1)) {
            case ___R$romejs$string$charcodes$index_ts.asterisk:
              if (parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2) ===
              ___R$romejs$string$charcodes$index_ts.colon &&
              parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 3) === ___R$romejs$string$charcodes$index_ts.colon) {
                break loop;
              }

              ___R$$priv$romejs$js$parser$tokenizer$index_ts$skipBlockComment(parser);
              break;

            case ___R$romejs$string$charcodes$index_ts.slash:
              ___R$romejs$js$parser$tokenizer$index_ts$skipLineComment(parser, 2);
              break;

            default:
              break loop;}
          break;

        default:
          if (ch > ___R$romejs$string$charcodes$index_ts.backSpace && ch < ___R$romejs$string$charcodes$index_ts.shiftOut ||
          ch >= ___R$romejs$string$charcodes$index_ts.oghamSpaceMark &&
          ___R$romejs$js$parser$utils$whitespace_ts$nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
          } else {
            break loop;
          }}
    }
  }

  function ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, type, val) {
    parser.state.endPos = parser.getPositionFromState();

    const prevType = parser.state.tokenType;
    parser.state.tokenType = type;
    parser.state.tokenValue = val;

    ___R$$priv$romejs$js$parser$tokenizer$index_ts$updateContext(parser, prevType);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_dot(parser) {
    const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
    if (next >= ___R$romejs$string$charcodes$index_ts.digit0 && next <= ___R$romejs$string$charcodes$index_ts.digit9) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$readNumber(parser, true);
      return undefined;
    }

    const next2 = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2);
    if (next === ___R$romejs$string$charcodes$index_ts.dot && next2 === ___R$romejs$string$charcodes$index_ts.dot) {
      parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, 3);
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.ellipsis);
    } else {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.dot);
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_slash(parser) {
    const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);

    if (next === ___R$romejs$string$charcodes$index_ts.asterisk &&
    parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2) === ___R$romejs$string$charcodes$index_ts.colon &&
    parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 3) === ___R$romejs$string$charcodes$index_ts.colon) {
      parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, 4);
      parser.pushScope('FLOW_COMMENT');
      ___R$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
      return;
    }

    if (parser.state.exprAllowed) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$romejs$js$parser$tokenizer$index_ts$readRegexp(parser);
      return;
    }

    if (next === ___R$romejs$string$charcodes$index_ts.equalsTo) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.assign, 2);
    } else {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.slash, 1);
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_mult_modulo(parser, code) {
    let next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);

    if (code === ___R$romejs$string$charcodes$index_ts.asterisk &&
    parser.inScope('FLOW_COMMENT') &&
    next === ___R$romejs$string$charcodes$index_ts.slash) {
      parser.popScope('FLOW_COMMENT');
      parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, 2);
      ___R$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
      return;
    }

    let type = code === ___R$romejs$string$charcodes$index_ts.asterisk ? ___R$romejs$js$parser$tokenizer$types_ts$types.star : ___R$romejs$js$parser$tokenizer$types_ts$types.modulo;
    let width = 1;
    const exprAllowed = parser.state.exprAllowed;

    if (code === ___R$romejs$string$charcodes$index_ts.asterisk && next === ___R$romejs$string$charcodes$index_ts.asterisk) {
      width++;
      next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2);
      type = ___R$romejs$js$parser$tokenizer$types_ts$types.exponent;
    }

    if (next === ___R$romejs$string$charcodes$index_ts.equalsTo && !exprAllowed) {
      width++;
      type = ___R$romejs$js$parser$tokenizer$types_ts$types.assign;
    }

    ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, type, width);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_pipe_amp(parser, code) {
    const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);

    if (next === code) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(
      parser,
      code === ___R$romejs$string$charcodes$index_ts.verticalBar ? ___R$romejs$js$parser$tokenizer$types_ts$types.logicalOR : ___R$romejs$js$parser$tokenizer$types_ts$types.logicalAND,
      2);
      return undefined;
    }

    if (code === ___R$romejs$string$charcodes$index_ts.verticalBar && next === ___R$romejs$string$charcodes$index_ts.rightCurlyBrace) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.braceBarR, 2);
      return undefined;
    }

    if (next === ___R$romejs$string$charcodes$index_ts.equalsTo) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.assign, 2);
      return undefined;
    }

    ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(
    parser,
    code === ___R$romejs$string$charcodes$index_ts.verticalBar ? ___R$romejs$js$parser$tokenizer$types_ts$types.bitwiseOR : ___R$romejs$js$parser$tokenizer$types_ts$types.bitwiseAND,
    1);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_caret(parser) {
    const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
    if (next === ___R$romejs$string$charcodes$index_ts.equalsTo) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.assign, 2);
    } else {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.bitwiseXOR, 1);
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_plus_min(parser, code) {
    const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);

    if (next === code) {
      if (next === ___R$romejs$string$charcodes$index_ts.dash &&
      !parser.inModule &&
      parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2) === ___R$romejs$string$charcodes$index_ts.greaterThan &&
      (parser.state.lastEndPos.index === ___R$romejs$ob1$index_ts$number0 ||
      ___R$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
      parser.getRawInput(parser.state.lastEndPos.index, parser.state.index)))) {
        ___R$romejs$js$parser$tokenizer$index_ts$skipLineComment(parser, 3);
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$skipSpace(parser);
        ___R$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
        return undefined;
      }
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.incDec, 2);
      return undefined;
    }

    if (next === ___R$romejs$string$charcodes$index_ts.equalsTo) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.assign, 2);
    } else {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.plusMin, 1);
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_lt_gt(parser, code) {
    const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
    let size = 1;

    if (next === code && !parser.inScope('TYPE')) {
      size =
      code === ___R$romejs$string$charcodes$index_ts.greaterThan &&
      parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2) === ___R$romejs$string$charcodes$index_ts.greaterThan ? 3 : 2;
      if (parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + size) === ___R$romejs$string$charcodes$index_ts.equalsTo) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.assign, size + 1);
        return undefined;
      }
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.bitShift, size);
      return undefined;
    }

    if (code === ___R$romejs$string$charcodes$index_ts.lessThan &&
    next === ___R$romejs$string$charcodes$index_ts.exclamationMark &&
    !parser.inModule &&
    parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2) === ___R$romejs$string$charcodes$index_ts.dash &&
    parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 3) === ___R$romejs$string$charcodes$index_ts.dash) {
      ___R$romejs$js$parser$tokenizer$index_ts$skipLineComment(parser, 4);
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$skipSpace(parser);
      ___R$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
      return undefined;
    }

    if (next === ___R$romejs$string$charcodes$index_ts.equalsTo) {
      size = 2;
    }

    ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.relational, size);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_eq_excl(parser, code) {
    const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
    if (next === ___R$romejs$string$charcodes$index_ts.equalsTo) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(
      parser,
      ___R$romejs$js$parser$tokenizer$types_ts$types.equality,
      parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2) === ___R$romejs$string$charcodes$index_ts.equalsTo ? 3 : 2);
      return undefined;
    }
    if (code === ___R$romejs$string$charcodes$index_ts.equalsTo && next === ___R$romejs$string$charcodes$index_ts.greaterThan) {
      parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, 2);
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.arrow);
      return undefined;
    }
    ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, code === ___R$romejs$string$charcodes$index_ts.equalsTo ? ___R$romejs$js$parser$tokenizer$types_ts$types.eq : ___R$romejs$js$parser$tokenizer$types_ts$types.bang, 1);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_question(parser) {
    const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
    const next2 = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 2);
    if (next === ___R$romejs$string$charcodes$index_ts.questionMark && !parser.inScope('TYPE')) {
      if (next2 === ___R$romejs$string$charcodes$index_ts.equalsTo) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.assign, 3);
      } else {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.nullishCoalescing, 2);
      }
    } else if (next === ___R$romejs$string$charcodes$index_ts.dot &&
    !(next2 >= ___R$romejs$string$charcodes$index_ts.digit0 && next2 <= ___R$romejs$string$charcodes$index_ts.digit9)) {
      parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, 2);
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.questionDot);
    } else {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.question);
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_numberSign(parser) {
    if (___R$romejs$ob1$index_ts$get0(parser.state.classLevel) > 0 || parser.state.index === ___R$romejs$ob1$index_ts$number0) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.hash);
      return undefined;
    }

    let advice;
    if (parser.input[___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1] === '!') {
      advice = [{
        type: 'log',
        category: 'info',
        message: 'Did you want to write a hashbang? A hashbang can only be the first thing in a file.'}];
    }

    parser.addDiagnostic({
      message: 'Unexpected character \'#\'',
      advice: advice});
    ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    ___R$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(parser, code) {
    if (code === ___R$romejs$string$charcodes$index_ts.digit0) {
      const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);

      if (next === ___R$romejs$string$charcodes$index_ts.lowercaseX || next === ___R$romejs$string$charcodes$index_ts.uppercaseX) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readRadixNumber(parser, 16);
        return undefined;
      }

      if (next === ___R$romejs$string$charcodes$index_ts.lowercaseO || next === ___R$romejs$string$charcodes$index_ts.uppercaseO) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readRadixNumber(parser, 8);
        return undefined;
      }

      if (next === ___R$romejs$string$charcodes$index_ts.lowercaseB || next === ___R$romejs$string$charcodes$index_ts.uppercaseB) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readRadixNumber(parser, 2);
        return undefined;
      }
    }

    switch (code) {
      case ___R$romejs$string$charcodes$index_ts.numberSign:
        return ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_numberSign(parser);

      case ___R$romejs$string$charcodes$index_ts.dot:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_dot(parser);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.leftParenthesis:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.parenL);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.rightParenthesis:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.parenR);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.semicolon:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.semi);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.comma:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.comma);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.leftSquareBracket:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.bracketL);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.rightSquareBracket:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.bracketR);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.leftCurlyBrace:
        if (parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1) === ___R$romejs$string$charcodes$index_ts.verticalBar) {
          ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.braceBarL, 2);
        } else {
          ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
          ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.braceL);
        }
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.rightCurlyBrace:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.braceR);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.colon:
        if (parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1) === ___R$romejs$string$charcodes$index_ts.colon) {
          ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.doubleColon, 2);
        } else {
          ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
          ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.colon);
        }
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.questionMark:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_question(parser);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.atSign:
        {
          const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
          if (next === ___R$romejs$string$charcodes$index_ts.atSign) {
            parser.state.isIterator = true;
            ___R$$priv$romejs$js$parser$tokenizer$index_ts$readWord(parser);
          } else {
            ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
            ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.at);
          }
          return undefined;
        }

      case ___R$romejs$string$charcodes$index_ts.graveAccent:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.backQuote);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.digit0:
      case ___R$romejs$string$charcodes$index_ts.digit1:
      case ___R$romejs$string$charcodes$index_ts.digit2:
      case ___R$romejs$string$charcodes$index_ts.digit3:
      case ___R$romejs$string$charcodes$index_ts.digit4:
      case ___R$romejs$string$charcodes$index_ts.digit5:
      case ___R$romejs$string$charcodes$index_ts.digit6:
      case ___R$romejs$string$charcodes$index_ts.digit7:
      case ___R$romejs$string$charcodes$index_ts.digit8:
      case ___R$romejs$string$charcodes$index_ts.digit9:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readNumber(parser, false);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.quotationMark:
      case ___R$romejs$string$charcodes$index_ts.apostrophe:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readString(parser, code);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.slash:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_slash(parser);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.percentSign:
      case ___R$romejs$string$charcodes$index_ts.asterisk:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_mult_modulo(parser, code);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.verticalBar:
      case ___R$romejs$string$charcodes$index_ts.ampersand:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_pipe_amp(parser, code);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.caret:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_caret(parser);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.plusSign:
      case ___R$romejs$string$charcodes$index_ts.dash:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_plus_min(parser, code);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.lessThan:
      case ___R$romejs$string$charcodes$index_ts.greaterThan:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_lt_gt(parser, code);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.equalsTo:
      case ___R$romejs$string$charcodes$index_ts.exclamationMark:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_eq_excl(parser, code);
        return undefined;

      case ___R$romejs$string$charcodes$index_ts.tilde:
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.tilde, 1);
        return undefined;}

    const char = parser.input[___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser)];
    const unicodeMistake = ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.get(char);
    if (unicodeMistake !== undefined) {
      const [unicodeName, equivalentChar] = unicodeMistake;
      const equivalentName = ___R$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.get(equivalentChar);
      if (equivalentName === undefined) {
        throw new Error('Expected ASCII name for ' + equivalentChar);
      }

      parser.addDiagnostic({
        message: 'Unexpected Unicode character \'<emphasis>' + char + '</emphasis>\' (<emphasis>' + unicodeName + '</emphasis>)',

        advice: [{
          type: 'log',
          category: 'info',
          message: 'Did you mean \'<emphasis>' + equivalentChar + '</emphasis>\' (<emphasis>' + equivalentName + '</emphasis>)? Both characters look the same, but are not.'}]});

      ___R$$priv$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(parser, equivalentChar.charCodeAt(0));
      return;
    }

    parser.addDiagnostic({
      message: 'Unexpected character \'' + ___R$$priv$romejs$js$parser$tokenizer$index_ts$codePointToString(code) + '\''});

    ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    ___R$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$finishOp(parser, type, size) {
    const str = parser.getRawInput(
    parser.state.index,
    ___R$romejs$ob1$index_ts$add(parser.state.index, size));
    parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, size);
    ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, type, str);
  }

  function ___R$romejs$js$parser$tokenizer$index_ts$readRegexp(parser) {
    const start = parser.state.index;
    let escaped, inClass;
    for (;;) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated regular expression'});
        break;
      }

      const ch = parser.input.charAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      if (___R$romejs$js$parser$utils$whitespace_ts$lineBreak.test(ch)) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated regular expression'});
        break;
      }

      if (escaped) {
        escaped = false;
      } else {
        if (ch === '[') {
          inClass = true;
        } else if (ch === ']' && inClass) {
          inClass = false;
        } else if (ch === '/' && !inClass) {
          break;
        }
        escaped = ch === '\\';
      }

      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    }

    const content = parser.getRawInput(start, parser.state.index);
    ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

    const rawMods = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readWord1(parser);

    if (parser.state.escapePosition !== undefined) {
      parser.addDiagnostic({
        index: parser.state.escapePosition,
        message: 'Regular expression flags can\'t contain unicode escapes'});
    }

    const mods = ___R$romejs$js$parser$utils$regex_ts$validateRegexFlags(rawMods, (msg, index) => {
      parser.addDiagnostic({
        index: ___R$romejs$ob1$index_ts$add(start, index),
        message: msg});
    });

    ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.regexp, new ___R$romejs$js$parser$tokenizer$index_ts$RegExpTokenValue(content, mods));
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readInt(parser, radix, len) {
    const start = parser.state.index;
    const forbiddenSiblings = radix === 16 ? ___R$$priv$romejs$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings.hex : ___R$$priv$romejs$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings.decBinOct;

    let allowedSiblings;
    if (radix === 16) {
      allowedSiblings = ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.hex;
    } else if (radix === 10) {
      allowedSiblings = ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.dec;
    } else if (radix === 8) {
      allowedSiblings = ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.oct;
    } else {
      allowedSiblings = ___R$$priv$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.bin;
    }

    let total = 0;

    for (let i = 0, e = len === undefined ? Infinity : len; i < e; ++i) {
      const code = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      let val;

      const prev = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) - 1);
      const next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1);
      if (code === ___R$romejs$string$charcodes$index_ts.underscore) {
        if (allowedSiblings.indexOf(next) === -1) {
          parser.addDiagnostic({
            message: 'Invalid or unexpected token'});
        }

        if (forbiddenSiblings.indexOf(prev) > -1 ||
        forbiddenSiblings.indexOf(next) > -1 ||
        Number.isNaN(next)) {
          parser.addDiagnostic({
            message: 'Invalid or unexpected token'});
        }

        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        continue;
      }

      if (code >= ___R$romejs$string$charcodes$index_ts.lowercaseA) {
        val = code - ___R$romejs$string$charcodes$index_ts.lowercaseA + ___R$romejs$string$charcodes$index_ts.lineFeed;
      } else if (code >= ___R$romejs$string$charcodes$index_ts.uppercaseA) {
        val = code - ___R$romejs$string$charcodes$index_ts.uppercaseA + ___R$romejs$string$charcodes$index_ts.lineFeed;
      } else if (___R$romejs$string$charcodes$index_ts.isDigit(code)) {
        val = code - ___R$romejs$string$charcodes$index_ts.digit0;
      } else {
        val = Infinity;
      }

      if (val >= radix) {
        break;
      }

      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      total = total * radix + val;
    }

    if (parser.state.index === start ||
    len !== undefined && ___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) - ___R$romejs$ob1$index_ts$get0(start) !== len) {
      return undefined;
    }

    return total;
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readRadixNumber(parser, radix) {
    const start = parser.state.index;
    let isBigInt = false;

    parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, 2);

    const val = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readInt(parser, radix);
    if (val === undefined) {
      parser.addDiagnostic({
        index: ___R$romejs$ob1$index_ts$add(start, 2),
        message: 'Expected number in radix ' + radix});
    }

    if (parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser)) === ___R$romejs$string$charcodes$index_ts.lowercaseN) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      isBigInt = true;
    }

    if (___R$romejs$js$parser$utils$identifier_ts$isIdentifierStart(___R$$priv$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(parser))) {
      parser.addDiagnostic({
        index: parser.state.index,
        message: 'Identifier directly after number'});
    }

    if (isBigInt) {
      const str = parser.getRawInput(start, parser.state.index).replace(/[_n]/g, '');
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.bigint, str);
      return undefined;
    }

    ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.num, val);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readNumber(parser, startsWithDot) {
    const start = parser.state.startPos;
    let isFloat = false;
    let isBigInt = false;

    if (!startsWithDot && ___R$$priv$romejs$js$parser$tokenizer$index_ts$readInt(parser, 10) === undefined) {
      parser.addDiagnostic({
        index: parser.state.index,
        message: 'Invalid number'});
    }

    let isOctal = ___R$romejs$ob1$index_ts$get0(parser.state.index) - ___R$romejs$ob1$index_ts$get0(start.index) >= 2 &&
    parser.input.charCodeAt(___R$romejs$ob1$index_ts$get0(start.index)) === ___R$romejs$string$charcodes$index_ts.digit0;
    if (isOctal) {
      if (parser.inScope('STRICT')) {
        parser.addDiagnostic({
          index: parser.state.index,
          message: 'Legacy octal literals are not allowed in strict mode'});
      }

      if (/[89]/.test(parser.getRawInput(start.index, parser.state.index))) {
        isOctal = false;
      }
    }

    let next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    if (next === ___R$romejs$string$charcodes$index_ts.dot && !isOctal) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$readInt(parser, 10);
      isFloat = true;
      next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    }

    if ((next === ___R$romejs$string$charcodes$index_ts.uppercaseE || next === ___R$romejs$string$charcodes$index_ts.lowercaseE) &&
    !isOctal) {
      next = parser.input.charCodeAt(___R$romejs$ob1$index_ts$get0(___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser)));

      if (next === ___R$romejs$string$charcodes$index_ts.plusSign || next === ___R$romejs$string$charcodes$index_ts.dash) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }

      if (___R$$priv$romejs$js$parser$tokenizer$index_ts$readInt(parser, 10) === undefined) {
        parser.addDiagnostic({
          index: parser.state.index,
          message: 'Invalid number'});
      }

      isFloat = true;
      next = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    }

    if (next === ___R$romejs$string$charcodes$index_ts.lowercaseN) {
      if (isFloat) {
        parser.addDiagnostic({
          index: parser.state.index,
          message: 'A bigint can\'t have a decimal'});
      }

      if (isOctal) {
        parser.addDiagnostic({
          index: parser.state.index,
          message: 'A bigint can\'t be an octal'});
      }

      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      isBigInt = true;
    }

    if (___R$romejs$js$parser$utils$identifier_ts$isIdentifierStart(parser.input.codePointAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser)))) {
      parser.addDiagnostic({
        index: parser.state.index,
        message: 'Identifier directly after number'});
    }

    const str = parser.getRawInput(start.index, parser.state.index).replace(/[_n]/g, '');

    if (isBigInt) {
      ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.bigint, str);
      return undefined;
    }

    const val = isOctal ? parseInt(str, 8) : parseFloat(str);
    ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.num, val);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readCodePoint(parser, throwOnInvalid) {
    const ch = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    let code;

    if (ch === ___R$romejs$string$charcodes$index_ts.leftCurlyBrace) {
      const codePos = parser.state.index;
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      code = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readHexChar(
      parser,
      parser.input.indexOf('}', ___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser)) - ___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser),
      throwOnInvalid);
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      if (code === undefined) {
        parser.state.invalidTemplateEscapePosition--;
      } else if (code > 1114111) {
        if (throwOnInvalid) {
          parser.addDiagnostic({
            index: codePos,
            message: 'Code point out of bounds'});
        } else {
          parser.state.invalidTemplateEscapePosition = ___R$romejs$ob1$index_ts$sub(codePos, 2);
          return undefined;
        }
      }
    } else {
      code = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readHexChar(parser, 4, throwOnInvalid);
    }
    return code;
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readString(parser, quote) {
    let out = '';
    let chunkStart = ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

    while (true) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated string constant'});
        break;
      }

      const ch = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      if (ch === quote) {
        break;
      }

      if (ch === ___R$romejs$string$charcodes$index_ts.backslash) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___R$$priv$romejs$js$parser$tokenizer$index_ts$readEscapedChar(parser, false);
        chunkStart = parser.state.index;
      } else if (ch === ___R$romejs$string$charcodes$index_ts.lineSeparator ||
      ch === ___R$romejs$string$charcodes$index_ts.paragraphSeparator) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        parser.state.curLine = ___R$romejs$ob1$index_ts$inc(parser.state.curLine);
      } else {
        if (___R$romejs$js$parser$utils$whitespace_ts$isNewLine(ch)) {
          parser.addDiagnostic({
            end: parser.getPositionFromIndex(parser.state.index),
            message: 'Unterminated string constant'});
        }
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }
    }

    out += parser.getRawInput(chunkStart, parser.state.index);
    ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.string, out);
  }

  function ___R$romejs$js$parser$tokenizer$index_ts$readTemplateToken(parser) {
    let out = '';
    let chunkStart = parser.state.index;
    let containsInvalid = false;

    while (true) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated template'});
        break;
      }

      const ch = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      if (ch === ___R$romejs$string$charcodes$index_ts.graveAccent ||
      ch === ___R$romejs$string$charcodes$index_ts.dollarSign &&
      parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) + 1) ===
      ___R$romejs$string$charcodes$index_ts.leftCurlyBrace) {
        if (parser.state.index === parser.state.startPos.index &&
        parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.template)) {
          if (ch === ___R$romejs$string$charcodes$index_ts.dollarSign) {
            parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, 2);
            ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.dollarBraceL);
            return undefined;
          } else {
            ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
            ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.backQuote);
            return undefined;
          }
        }
        out += parser.getRawInput(chunkStart, parser.state.index);
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.template, containsInvalid ? undefined : out);
        return undefined;
      }

      if (ch === ___R$romejs$string$charcodes$index_ts.backslash) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        const escaped = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readEscapedChar(parser, true);
        if (escaped === undefined) {
          containsInvalid = true;
        } else {
          out += escaped;
        }
        chunkStart = parser.state.index;
      } else if (___R$romejs$js$parser$utils$whitespace_ts$isNewLine(ch)) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

        if (ch === ___R$romejs$string$charcodes$index_ts.carriageReturn &&
        parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser)) === ___R$romejs$string$charcodes$index_ts.lineFeed) {
          ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
        }

        switch (ch) {
          case ___R$romejs$string$charcodes$index_ts.carriageReturn:
          case ___R$romejs$string$charcodes$index_ts.lineFeed:
            out += '\n';
            break;

          default:
            out += String.fromCharCode(ch);
            break;}

        parser.state.curLine = ___R$romejs$ob1$index_ts$inc(parser.state.curLine);
        parser.resetTokenizerLine();
        chunkStart = parser.state.index;
      } else {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readEscapedChar(parser, inTemplate) {
    const throwOnInvalid = !inTemplate;
    const ch = parser.input.charCodeAt(___R$romejs$ob1$index_ts$get0(___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser)));
    ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

    if (ch === ___R$romejs$string$charcodes$index_ts.carriageReturn &&
    parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser)) === ___R$romejs$string$charcodes$index_ts.lineFeed) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    }

    switch (ch) {
      case ___R$romejs$string$charcodes$index_ts.lowercaseN:
        return '\n';

      case ___R$romejs$string$charcodes$index_ts.lowercaseR:
        return '\r';

      case ___R$romejs$string$charcodes$index_ts.lowercaseX:
        {
          const code = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readHexChar(parser, 2, throwOnInvalid);
          return code === undefined ? undefined : String.fromCharCode(code);
        }

      case ___R$romejs$string$charcodes$index_ts.lowercaseU:
        {
          const code = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readCodePoint(parser, throwOnInvalid);
          return code === undefined ? undefined : ___R$$priv$romejs$js$parser$tokenizer$index_ts$codePointToString(code);
        }

      case ___R$romejs$string$charcodes$index_ts.lowercaseT:
        return '\t';

      case ___R$romejs$string$charcodes$index_ts.lowercaseB:
        return '\b';

      case ___R$romejs$string$charcodes$index_ts.lowercaseV:
        return '\x0b';

      case ___R$romejs$string$charcodes$index_ts.lowercaseF:
        return '\f';

      case ___R$romejs$string$charcodes$index_ts.carriageReturn:
      case ___R$romejs$string$charcodes$index_ts.lineFeed:
        parser.state.curLine = ___R$romejs$ob1$index_ts$inc(parser.state.curLine);
        parser.resetTokenizerLine();
        return '';

      default:
        if (ch >= ___R$romejs$string$charcodes$index_ts.digit0 && ch <= ___R$romejs$string$charcodes$index_ts.digit7) {
          const codePos = ___R$romejs$ob1$index_ts$dec(parser.state.index);
          const octalMatches = parser.input.substr(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser) - 1, 3).match(/^[0-7]+/);

          if (octalMatches == null) {
            throw new Error('No octals found, impossible since we checked it');
          }

          let octalStr = octalMatches[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }

          if (octal > 0) {
            if (inTemplate) {
              parser.state.invalidTemplateEscapePosition = codePos;
              return undefined;
            } else if (parser.inScope('STRICT')) {
              parser.addDiagnostic({
                index: codePos,
                message: 'Octal literal in strict mode'});
            } else if (!parser.state.containsOctal) {
              parser.state.containsOctal = true;
              parser.state.octalPosition = codePos;
            }
          }

          parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, octalStr.length - 1);
          return String.fromCharCode(octal);
        }

        return String.fromCharCode(ch);}
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readHexChar(parser, len, throwOnInvalid) {
    const start = parser.state.index;
    const n = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readInt(parser, 16, len);

    if (n === undefined) {
      if (throwOnInvalid) {
        parser.addDiagnostic({
          index: start,
          message: 'Bad character escape sequence'});
        return 0;
      }

      const codePos = parser.state.index;
      parser.state.index = ___R$romejs$ob1$index_ts$dec(codePos);
      parser.state.invalidTemplateEscapePosition = ___R$romejs$ob1$index_ts$dec(codePos);
    }

    return n;
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readWord1(parser) {
    parser.state.escapePosition = undefined;
    let word = '';
    let first = true;
    let chunkStart = parser.state.index;

    while (parser.state.index < parser.length) {
      const ch = ___R$$priv$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(parser);

      if (___R$romejs$js$parser$utils$identifier_ts$isIdentifierChar(ch)) {
        parser.state.index = ___R$romejs$ob1$index_ts$add(parser.state.index, ch <= 65535 ? 1 : 2);
      } else if (parser.state.isIterator && ch === ___R$romejs$string$charcodes$index_ts.atSign) {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      } else if (ch === ___R$romejs$string$charcodes$index_ts.backslash) {
        parser.state.escapePosition = parser.state.index;

        word += parser.getRawInput(chunkStart, parser.state.index);

        if (parser.input.charCodeAt(___R$romejs$ob1$index_ts$get0(___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser))) !==
        ___R$romejs$string$charcodes$index_ts.lowercaseU) {
          parser.addDiagnostic({
            index: parser.state.index,
            message: 'Expecting Unicode escape sequence \\uXXXX'});
        }

        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

        const esc = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readCodePoint(parser, true);
        if (esc === undefined) {
          throw new Error('readCodePoint() should have thrown an error');
        }

        const isValid = first ? ___R$romejs$js$parser$utils$identifier_ts$isIdentifierStart : ___R$romejs$js$parser$utils$identifier_ts$isIdentifierChar;
        if (isValid(esc) === false) {
          parser.addDiagnostic({
            index: parser.state.index,
            message: 'Invalid Unicode escape'});
        }

        word += ___R$$priv$romejs$js$parser$tokenizer$index_ts$codePointToString(esc);
        chunkStart = parser.state.index;
      } else {
        break;
      }

      first = false;
    }

    return word + parser.getRawInput(chunkStart, parser.state.index);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readWord(parser) {
    const word = ___R$$priv$romejs$js$parser$tokenizer$index_ts$readWord1(parser);

    let type = ___R$romejs$js$parser$tokenizer$types_ts$keywords.get(word) || ___R$romejs$js$parser$tokenizer$types_ts$types.name;

    if (type.keyword !== undefined && parser.state.escapePosition !== undefined) {
      parser.addDiagnostic({
        index: parser.state.escapePosition,
        message: 'Escape sequence in keyword ' + word});
    }

    if (parser.state.isIterator &&
    (!___R$$priv$romejs$js$parser$tokenizer$index_ts$isIterator(word) || !parser.inScope('TYPE'))) {
      parser.addDiagnostic({
        message: 'Invalid identifier ' + word});
    }

    ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, type, word);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$isIterator(word) {
    return word === '@@iterator' || word === '@@asyncIterator';
  }

  function ___R$romejs$js$parser$tokenizer$index_ts$isBraceBlock(parser, prevType) {
    const parent = ___R$romejs$js$parser$tokenizer$index_ts$getCurContext(parser);
    if (parent === ___R$romejs$js$parser$tokenizer$context_ts$types.functionExpression || parent === ___R$romejs$js$parser$tokenizer$context_ts$types.functionStatement) {
      return true;
    }
    if (prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.colon &&
    (parent === ___R$romejs$js$parser$tokenizer$context_ts$types.braceStatement || parent === ___R$romejs$js$parser$tokenizer$context_ts$types.braceExpression)) {
      return !parent.isExpr;
    }

    if (prevType === ___R$romejs$js$parser$tokenizer$types_ts$types._return ||
    prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.name && parser.state.exprAllowed) {
      return ___R$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
      parser.getRawInput(
      parser.state.lastEndPos.index,
      parser.state.startPos.index));
    }

    if (prevType === ___R$romejs$js$parser$tokenizer$types_ts$types._else ||
    prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.semi ||
    prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.eof ||
    prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.parenR ||
    prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.arrow) {
      return true;
    }

    if (prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.braceL) {
      return parent === ___R$romejs$js$parser$tokenizer$context_ts$types.braceStatement;
    }

    if (prevType === ___R$romejs$js$parser$tokenizer$types_ts$types._var || prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.name || prevType === ___R$romejs$js$parser$tokenizer$types_ts$types._const) {
      return false;
    }

    if (prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.relational) {
      return true;
    }

    return !parser.state.exprAllowed;
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$updateContext(parser, prevType) {
    if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceL)) {
      const curContext = ___R$romejs$js$parser$tokenizer$index_ts$getCurContext(parser);
      if (curContext === ___R$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag) {
        parser.state.context.push(___R$romejs$js$parser$tokenizer$context_ts$types.braceExpression);
      } else if (curContext === ___R$romejs$js$parser$tokenizer$context_ts$types.jsxInner) {
        parser.state.context.push(___R$romejs$js$parser$tokenizer$context_ts$types.templateQuasi);
      } else {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$_updateContext(parser, prevType);
      }
      parser.state.exprAllowed = true;
    } else if (parser.match(___R$romejs$js$parser$tokenizer$types_ts$types.slash) && prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart) {
      parser.state.context.length -= 2;
      parser.state.context.push(___R$romejs$js$parser$tokenizer$context_ts$types.jsxCloseTag);
      parser.state.exprAllowed = false;
    } else {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$_updateContext(parser, prevType);
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$_updateContext(parser, prevType) {
    const type = parser.state.tokenType;

    if (type.keyword !== undefined &&
    (prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.dot || prevType === ___R$romejs$js$parser$tokenizer$types_ts$types.questionDot)) {
      parser.state.exprAllowed = false;
    } else if (type.updateContext !== undefined) {
      type.updateContext(parser, prevType);
    } else {
      parser.state.exprAllowed = type.beforeExpr;
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsx(parser) {
    let out = '';
    let chunkStart = parser.state.index;
    while (true) {
      if (parser.state.index >= parser.length) {
        ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.eof);
        break;
      }

      const code = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));

      if (code === ___R$romejs$string$charcodes$index_ts.lessThan || code === ___R$romejs$string$charcodes$index_ts.leftCurlyBrace) {
        if (parser.state.index === parser.state.startPos.index) {
          if (code === ___R$romejs$string$charcodes$index_ts.lessThan && parser.state.exprAllowed) {
            ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
            return ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart);
          }

          return ___R$$priv$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(parser, code);
        }

        out += parser.getRawInput(chunkStart, parser.state.index);
        return ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.jsxText, out);
      }

      if (code === ___R$romejs$string$charcodes$index_ts.ampersand) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsxEntity(parser);
        chunkStart = parser.state.index;
        continue;
      }

      if (___R$romejs$js$parser$utils$whitespace_ts$isNewLine(code)) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsxNewLine(parser, true);
        chunkStart = parser.state.index;
      } else {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsxNewLine(parser, normalizeCRLF) {
    const ch = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
    let out;
    ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

    if (ch === ___R$romejs$string$charcodes$index_ts.carriageReturn &&
    parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser)) === ___R$romejs$string$charcodes$index_ts.lineFeed) {
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      out = normalizeCRLF ? '\n' : '\r\n';
    } else {
      out = String.fromCharCode(ch);
    }

    parser.state.curLine = ___R$romejs$ob1$index_ts$inc(parser.state.curLine);
    parser.resetTokenizerLine();
    return out;
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsxString(parser, quote) {
    let out = '';
    let chunkStart = ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    while (true) {
      if (parser.state.index >= parser.length) {
        parser.addDiagnostic({
          end: parser.getPositionFromIndex(parser.state.index),
          message: 'Unterminated string constant'});
        break;
      }

      const ch = parser.input.charCodeAt(___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser));
      if (ch === quote) {
        break;
      }

      if (ch === ___R$romejs$string$charcodes$index_ts.ampersand) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsxEntity(parser);
        chunkStart = parser.state.index;
      } else if (___R$romejs$js$parser$utils$whitespace_ts$isNewLine(ch)) {
        out += parser.getRawInput(chunkStart, parser.state.index);
        out += ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsxNewLine(parser, false);
        chunkStart = parser.state.index;
      } else {
        ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      }
    }

    out += parser.getRawInput(chunkStart, parser.state.index);
    ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
    return ___R$romejs$js$parser$tokenizer$index_ts$finishToken(parser, ___R$romejs$js$parser$tokenizer$types_ts$types.string, out);
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsxEntity(parser) {
    let str = '';
    let count = 0;
    let entity;
    let ch = parser.input[___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser)];

    const startIndex = ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);

    while (parser.state.index < parser.length && count++ < 10) {
      ch = parser.input[___R$$priv$romejs$js$parser$tokenizer$index_ts$getIndex(parser)];
      ___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser);
      if (ch === ';') {
        if (str[0] === '#') {
          if (str[1] === 'x') {
            str = str.substr(2);
            if (___R$$priv$romejs$js$parser$tokenizer$index_ts$HEX_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 16));
            }
          } else {
            str = str.substr(1);
            if (___R$$priv$romejs$js$parser$tokenizer$index_ts$DECIMAL_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 10));
            }
          }
        } else {
          entity = ___R$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar[str];
        }
        break;
      }
      str += ch;
    }

    if (entity === undefined) {
      parser.state.index = startIndex;
      return '&';
    } else {
      return entity;
    }
  }

  function ___R$$priv$romejs$js$parser$tokenizer$index_ts$readToken_jsxWord(parser) {
    let ch;
    const start = parser.state.index;
    do {
      ch = parser.input.charCodeAt(___R$romejs$ob1$index_ts$get0(___R$$priv$romejs$js$parser$tokenizer$index_ts$bumpIndex(parser)));
    } while (___R$romejs$js$parser$utils$identifier_ts$isIdentifierChar(ch) || ch === ___R$romejs$string$charcodes$index_ts.dash);
    return ___R$romejs$js$parser$tokenizer$index_ts$finishToken(
    parser,
    ___R$romejs$js$parser$tokenizer$types_ts$types.jsxName,
    parser.getRawInput(start, parser.state.index));
  }

  // romejs/js-parser/tokenizer/state.ts


  const ___R$$priv$romejs$js$parser$tokenizer$state_ts$EMPTY_POS = {
    line: ___R$romejs$ob1$index_ts$number1,
    column: ___R$romejs$ob1$index_ts$number0,
    index: ___R$romejs$ob1$index_ts$number0};

  function ___R$romejs$js$parser$tokenizer$state_ts$createInitialState(options) {
    return {
      scopes: {},
      diagnostics: [],
      diagnosticFilters: [],
      hasHoistedVars: false,
      tokens: [],
      potentialArrowAt: ___R$romejs$ob1$index_ts$number0Neg1,
      commaAfterSpreadAt: ___R$romejs$ob1$index_ts$number0Neg1,
      yieldPos: ___R$romejs$ob1$index_ts$number0,
      awaitPos: ___R$romejs$ob1$index_ts$number0,
      noArrowAt: [],
      noArrowParamsConversionAt: [],
      maybeInArrowParameters: false,
      isIterator: false,
      noAnonFunctionType: false,
      classLevel: ___R$romejs$ob1$index_ts$number0,
      labels: [],
      yieldInPossibleArrowParameters: undefined,
      comments: [],
      trailingComments: [],
      leadingComments: [],
      commentStack: [],
      commentPreviousNode: undefined,
      index: ___R$romejs$ob1$index_ts$number0,
      lineStartIndex: ___R$romejs$ob1$index_ts$number0,
      curLine: ___R$romejs$ob1$index_ts$number1,
      tokenType: ___R$romejs$js$parser$tokenizer$types_ts$types.eof,
      tokenValue: undefined,
      startPos: ___R$$priv$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
      endPos: ___R$$priv$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
      lastStartPos: ___R$$priv$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
      lastEndPos: ___R$$priv$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
      context: [___R$romejs$js$parser$tokenizer$context_ts$types.braceStatement],
      exprAllowed: true,
      containsOctal: false,
      escapePosition: undefined,
      octalPosition: undefined,
      invalidTemplateEscapePosition: undefined,
      exportedIdentifiers: new Map(),
      possibleIncorrectOpenParens: [],
      lineStart: true,
      indentLevel: ___R$romejs$ob1$index_ts$number0};
  }

  // romejs/js-parser/ParserBranchFinder.ts


  class ___R$romejs$js$parser$ParserBranchFinder_ts$default {
    constructor(parser) {
      this.parser = parser;
      this.branch = undefined;
      this.picked = false;
    }

    hasOptimalBranch() {
      return this.branch !== undefined && this.branch.optimal;
    }

    hasBranch() {
      return this.branch !== undefined;
    }

    add(callback, opts = {}) {
      const topBranch = this.branch;

      if (topBranch !== undefined && topBranch.optimal) {
        return this;
      }

      const {maxNewDiagnostics: maxNewDiagnostics, diagnosticsPriority: diagnosticsPriority} = opts;
      const {parser: parser} = this;
      const prevState = parser.cloneState();

      parser.pushScope('MAX_NEW_DIAGNOSTICS', maxNewDiagnostics);

      let result;
      try {
        result = callback(parser);
      } catch (err) {
        if (err instanceof ___R$romejs$js$parser$parser_ts$DiagnosticsFatalError) {
          parser.setState(prevState);
          return this;
        } else {
          throw err;
        }
      }

      if (result === undefined) {
        parser.setState(prevState);
        return this;
      }

      const newState = parser.state;
      parser.popScope('MAX_NEW_DIAGNOSTICS');
      parser.setState(prevState);

      const newDiagnosticCount = newState.diagnostics.length;
      const prevDiagnosticCount = prevState.diagnostics.length;
      if (maxNewDiagnostics !== undefined &&
      newDiagnosticCount - prevDiagnosticCount > maxNewDiagnostics) {
        throw new Error('Max diagnostics unexpectedly exceeded ' + maxNewDiagnostics + '. Prev: ' + prevDiagnosticCount + ' New: ' + newDiagnosticCount);
      }

      const branch = {
        diagnosticsPriority: diagnosticsPriority,
        result: result,
        state: newState,
        newDiagnosticCount: newDiagnosticCount - prevDiagnosticCount,
        diagnosticCount: newDiagnosticCount,
        optimal: newDiagnosticCount === prevDiagnosticCount};

      let shouldPromote = false;

      if (topBranch === undefined || branch.optimal) {
        shouldPromote = true;
      } else {
        if (branch.diagnosticCount < topBranch.diagnosticCount) {
          shouldPromote = true;
        }

        if (branch.diagnosticsPriority !== undefined &&
        topBranch.diagnosticsPriority === undefined) {
          shouldPromote = true;
        }

        if (branch.diagnosticsPriority !== undefined &&
        topBranch.diagnosticsPriority !== undefined &&
        branch.diagnosticsPriority > topBranch.diagnosticsPriority) {
          shouldPromote = true;
        }

        if (topBranch.diagnosticsPriority !== undefined &&
        branch.diagnosticsPriority === undefined) {
          shouldPromote = false;
        }
      }

      if (shouldPromote) {
        this.branch = branch;
      }

      return this;
    }

    getBranch() {
      if (this.branch === undefined) {
        throw new Error('No branch');
      } else {
        return this.branch;
      }
    }

    pickOptional() {
      if (this.hasBranch()) {
        return this.pick();
      } else {
        return undefined;
      }
    }

    pick() {
      if (this.picked) {
        throw new Error('Already been picked');
      }
      this.picked = true;

      const {parser: parser} = this;
      const branch = this.getBranch();

      const {result: result, state: state} = branch;
      parser.setState(state);
      return result;
    }
  }

  // romejs/js-parser/parser.ts

  const ___R$$priv$romejs$js$parser$parser_ts$TOKEN_MISTAKES = {
    ';': ':',
    ',': '.'};

  class ___R$romejs$js$parser$parser_ts$DiagnosticsFatalError extends Error {
    constructor() {
      super(
      'Diagnostics exceeded maxDiagnostics state cap, this error is expected to be handled by a try-catch in the call stack');
    }
  }

  const ___R$$priv$romejs$js$parser$parser_ts$SCOPE_TYPES = ['FUNCTION_LOC', 'NON_ARROW_FUNCTION', 'FUNCTION', 'GENERATOR', 'ASYNC', 'PROPERTY_NAME', 'CLASS_PROPERTY', 'PARAMETERS', 'METHOD', 'CLASS', 'TYPE', 'MAX_NEW_DIAGNOSTICS', 'STRICT', 'FLOW_COMMENT'];

  const ___R$$priv$romejs$js$parser$parser_ts$createJSParser = ___R$romejs$parser$core$index_ts$createParser(
  (ParserCore, ParserWithRequiredPath) => (() => {
    class JSParser extends ParserWithRequiredPath {
      constructor(options) {
        const state = ___R$romejs$js$parser$tokenizer$state_ts$createInitialState(options);

        const parserOpts = {
          path: options.path,
          mtime: options.mtime,
          input: options.input};
        super(parserOpts, '@romejs/js-parser', state);

        this.isTrackingTokens = options.tokens;

        this.isLookahead = false;

        this.sourceType = options.sourceType;
        this.options = options;
        this.inModule =
        this.options.sourceType === 'template' ||
        this.options.sourceType === 'module';
        this.parenthesized = new Set();

        this.syntax = new Set(options.syntax);
      }

      resetTokenizerLine() {
        this.state.lineStartIndex = this.state.index;
        this.state.lineStart = true;
        this.state.indentLevel = ___R$romejs$ob1$index_ts$number0;
      }

      getScope(type) {
        let scope = this.state.scopes[type];
        if (scope === undefined) {
          scope = [];
          this.state.scopes[type] = scope;
        }
        return scope;
      }

      getLastScope(type) {
        const scope = this.getScope(type);
        return scope[scope.length - 1];
      }

      pushScope(type, value) {
        this.getScope(type).push(value);
      }

      popScope(type) {
        this.getScope(type).pop();
      }

      inScope(type) {
        return this.hasScope(type) && this.getLastScope(type) !== false;
      }

      hasScope(type) {
        const scope = this.state.scopes[type];
        return scope !== undefined && scope.length > 0;
      }

      addParenthesized(node) {
        this.parenthesized.add(this.getLoc(node).start.index);
      }

      isParenthesized(node) {
        return this.parenthesized.has(this.getLoc(node).start.index);
      }

      setState(newState) {
        const maxDiagnostics = this.getLastScope('MAX_NEW_DIAGNOSTICS');
        if (typeof maxDiagnostics === 'number' && maxDiagnostics !== -1) {
          const diff = newState.diagnostics.length - this.state.diagnostics.length;
          if (diff > maxDiagnostics) {
            throw new ___R$romejs$js$parser$parser_ts$DiagnosticsFatalError();
          }
        }

        this.state = newState;
      }

      atEOF() {
        return this.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof);
      }

      createBranch() {
        return new ___R$romejs$js$parser$ParserBranchFinder_ts$default(this);
      }

      tryBranch(fn) {
        const branch = new ___R$romejs$js$parser$ParserBranchFinder_ts$default(this);
        branch.add(fn, {maxNewDiagnostics: 0});
        if (branch.hasBranch()) {
          return branch.pickOptional();
        }
      }

      createUnknownIdentifier(reason, start = this.getPosition(), end = this.getEndPosition()) {
        return {
          type: 'Identifier',
          name: 'INVALID_PLACHOLDER',
          loc: this.finishLocAt(start, end)};
      }

      createUnknownStringLiteral(reason, start = this.getPosition(), end = this.getEndPosition()) {
        return {
          type: 'StringLiteral',
          value: 'INVALID_PLACHOLDER',
          loc: this.finishLocAt(start, end)};
      }

      assertNoSpace(message = 'Unexpected space') {
        const {state: state} = this;

        if (state.startPos.index > state.lastEndPos.index) {
          this.addDiagnostic({
            start: state.lastEndPos,
            end: state.lastEndPos,
            message: message});
        }
      }

      getDiagnostics() {
        const collector = new ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default({
          origins: [{
            category: 'js-parser'}]});

        for (const filter of this.state.diagnosticFilters) {
          collector.addFilter(filter);
        }

        return collector.addDiagnostics(this.state.diagnostics).slice(0, 1);
      }

      addDiagnosticFilter(diag) {
        this.state.diagnosticFilters.push(diag);
      }

      addCompleteDiagnostic(diags) {
        this.state.diagnostics = [...this.state.diagnostics, ...diags];
      }

      shouldCreateToken() {
        return this.isTrackingTokens && this.isLookahead === false;
      }

      createToken(state) {
        const token = {
          type: state.tokenType,
          start: state.startPos.index,
          end: state.endPos.index,
          loc: {
            filename: this.filename,
            start: state.startPos,
            end: state.endPos}};
        this.pushToken(token);
        return token;
      }

      pushToken(token) {
        const lastToken = this.state.tokens[this.state.tokens.length - 1];
        if (lastToken !== undefined) {
          if (token.loc.start.index < lastToken.loc.end.index) {
            throw new Error('Trying to push a token that appears before the last pushed token');
          }
        }

        this.state.tokens.push(token);
      }

      addDiagnostic(diag) {
        if (this.isLookahead) {
          return undefined;
        }

        let maxDiagnostics = this.getLastScope('MAX_NEW_DIAGNOSTICS');
        if (typeof maxDiagnostics === 'number') {
          maxDiagnostics--;
          this.popScope('MAX_NEW_DIAGNOSTICS');
          this.pushScope('MAX_NEW_DIAGNOSTICS', maxDiagnostics);
          if (maxDiagnostics < 0) {
            throw new ___R$romejs$js$parser$parser_ts$DiagnosticsFatalError();
          }
        }

        if (this.state.diagnostics.length > 0) {}

        let {start: start, end: end} = diag;

        if (diag.index !== undefined) {
          start = this.getPositionFromIndex(diag.index);
          end = start;
        }

        if (diag.loc !== undefined) {
          start = diag.loc.start;
          end = diag.loc.end;
        }

        if (start === undefined && end === undefined) {
          start = this.getPosition();
          end = this.getEndPosition();
        }

        if (start === undefined && end !== undefined) {
          start = end;
        }

        if (start !== undefined && end === undefined) {
          end = start;
        }

        this.state.diagnostics.push({
          filename: this.filename,
          mtime: this.mtime,
          message: diag.message,
          advice: diag.advice,
          start: start,
          end: end,
          category: 'parse/js'});
      }

      shouldTokenizeJSX() {
        return !this.isSyntaxEnabled('ts') || this.isSyntaxEnabled('jsx');
      }

      isSyntaxEnabled(syntax) {
        return this.syntax.has(syntax);
      }

      expectSyntaxEnabled(syntax) {
        if (!this.isSyntaxEnabled(syntax)) {
          this.addDiagnostic({
            message: 'Expected ' + syntax + ' to be enabled'});
        }
      }

      isRelational(op) {
        return this.match(___R$romejs$js$parser$tokenizer$types_ts$types.relational) && this.state.tokenValue === op;
      }

      expectRelational(op) {
        if (this.eatRelational(op)) {
          return true;
        } else {
          this.addDiagnostic({
            message: 'Expected relational operator'});
          return false;
        }
      }

      isLookaheadRelational(op) {
        const l = this.lookaheadState();
        return l.tokenType == ___R$romejs$js$parser$tokenizer$types_ts$types.relational && l.tokenValue == op;
      }

      banUnicodeEscape(index, name) {
        if (index !== undefined) {
          this.addDiagnostic({
            index: index,
            message: name + ' can\'t contain a unicode escape'});
        }
      }

      eatRelational(op) {
        if (this.isRelational(op)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }

      isContextual(name) {
        return this.match(___R$romejs$js$parser$tokenizer$types_ts$types.name) &&
        this.state.tokenValue === name &&
        this.state.escapePosition === undefined;
      }

      isLookaheadContextual(name) {
        const l = this.lookaheadState();
        return l.tokenType === ___R$romejs$js$parser$tokenizer$types_ts$types.name &&
        l.tokenValue === name &&
        l.escapePosition === undefined;
      }

      eatContextual(name) {
        if (this.isContextual(name)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }

      expectContextual(name, message = 'Expected keyword ' + name) {
        if (this.eatContextual(name)) {
          return true;
        } else {
          this.addDiagnostic({
            message: message});
          return false;
        }
      }

      canInsertSemicolon() {
        return this.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof) ||
        this.match(___R$romejs$js$parser$tokenizer$types_ts$types.braceR) ||
        this.hasPrecedingLineBreak();
      }

      hasPrecedingLineBreak() {
        return ___R$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
        this.getRawInput(
        this.state.lastEndPos.index,
        this.state.startPos.index));
      }

      isLineTerminator() {
        return this.eat(___R$romejs$js$parser$tokenizer$types_ts$types.semi) || this.canInsertSemicolon();
      }

      semicolon() {
        if (!this.isLineTerminator()) {
          this.addDiagnostic({
            message: 'Expected a semicolon or a line terminator'});
        }
      }

      expect(type, pos) {
        if (this.eat(type)) {
          return true;
        } else {
          this.unexpectedToken(pos, type);
          return false;
        }
      }

      expectOpening(open, close, name) {
        const pos = this.getPosition();
        const indent = this.state.indentLevel;
        this.expect(open);
        return {
          indent: indent,
          start: pos,
          name: name,
          open: open,
          close: close};
      }

      expectClosing(context) {
        if (this.match(context.close)) {
          if (this.state.indentLevel !== context.indent) {
            this.state.possibleIncorrectOpenParens.push(context);
          }
          this.next();
          return true;
        } else {
          const currPos = this.getPosition();

          const advice = [{
            type: 'log',
            category: 'info',
            message: 'We expected to find the closing character <emphasis>' + context.close.label + '</emphasis> here'}, {
            type: 'frame',
            filename: this.filename,
            start: currPos,
            end: currPos}];

          const possibleThief = this.state.possibleIncorrectOpenParens.shift();
          if (possibleThief !== undefined) {
            advice.push({
              type: 'log',
              category: 'info',
              message: 'We found this ' + possibleThief.name + ' that looks suspicious. It could be the real culprit that\'s unclosed.'});

            advice.push({
              type: 'frame',
              filename: this.filename,
              start: possibleThief.start,
              end: possibleThief.start});
          }

          this.addDiagnostic({
            message: 'Unclosed ' + context.name,
            start: context.start,
            end: context.start,
            advice: advice});
          return false;
        }
      }

      unexpectedToken(pos, tokenType) {
        const advice = [];
        let message = 'Unexpected token';

        if (tokenType !== undefined) {
          message += ', expected "' + tokenType.label + '"';

          const possibleMistake = ___R$$priv$romejs$js$parser$parser_ts$TOKEN_MISTAKES[tokenType.label];
          if (possibleMistake !== undefined &&
          possibleMistake === this.state.tokenType.label) {
            advice.push({
              type: 'log',
              category: 'info',
              message: 'Did you accidently hold shift?'});
          }
        }

        this.addDiagnostic({
          message: message,
          start: pos === undefined ? this.state.startPos : pos,
          end: pos === undefined ? this.state.endPos : pos,
          advice: advice});
      }

      unexpected() {
        throw new Error('js-parser should never throw an exception, use addDiagnostic or unexpectedToken instead');
      }

      tokenize() {
        throw new Error('js-parser does not use the parser-core tokenizer');
      }

      cloneNode(node) {
        if (node.leadingComments === undefined &&
        node.trailingComments === undefined &&
        node.innerComments === undefined) {
          return Object.assign({}, node);
        } else {
          return Object.assign({}, node, {
            leadingComments: undefined,
            trailingComments: undefined,
            innerComments: undefined});
        }
      }

      resetStartLocationFromNode(node, locationNode) {
        node.loc = Object.assign({}, this.getLoc(node), {
          start: this.getLoc(locationNode).start});
      }

      next() {
        if (this.shouldCreateToken()) {
          this.createToken(this.state);
        }

        this.state.lastEndPos = this.state.endPos;
        this.state.lastStartPos = this.state.startPos;
        ___R$romejs$js$parser$tokenizer$index_ts$nextToken(this);
      }

      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        }

        return false;
      }

      match(type) {
        return this.state.tokenType === type;
      }

      lookaheadState() {
        const old = this.state;
        this.state = this.cloneState(true);

        this.isLookahead = true;
        this.next();
        this.isLookahead = false;

        const curr = this.state;
        this.state = old;
        return curr;
      }

      cloneState(skipArrays = false) {
        const state = Object.assign({}, this.state);

        for (const key in state) {
          let val = state[key];

          const shouldSlice = skipArrays === false || key === 'context';
          if (shouldSlice && Array.isArray(val)) {
            state[key] = val.slice();
          }
        }

        const scopes = Object.assign({}, state.scopes);
        state.scopes = scopes;
        for (const type of ___R$$priv$romejs$js$parser$parser_ts$SCOPE_TYPES) {
          const scope = scopes[type];
          if (scope !== undefined) {
            scopes[type] = scope.slice();
          }
        }

        return state;
      }

      getPosition() {
        return this.state.startPos;
      }

      getEndPosition() {
        return this.state.lastEndPos;
      }

      getPositionFromState() {
        const {state: state} = this;
        return {
          index: state.index,
          line: state.curLine,
          column: ___R$romejs$ob1$index_ts$sub(state.index, state.lineStartIndex)};
      }

      parse() {
        if (this.inModule) {
          this.pushScope('ASYNC', true);
          this.pushScope('STRICT', true);
        }

        const program = ___R$romejs$js$parser$parser$statement_ts$parseTopLevel(this);

        if (this.inModule) {
          this.popScope('ASYNC');
          this.popScope('STRICT');
        }

        for (const type of ___R$$priv$romejs$js$parser$parser_ts$SCOPE_TYPES) {
          if (this.hasScope(type)) {
            throw new Error('Finished parsing but there was still a ' + type + ' scope stack');
          }
        }

        if (!this.match(___R$romejs$js$parser$tokenizer$types_ts$types.eof)) {
          throw new Error('Finish parsing but we arent at the end of the file');
        }

        return program;
      }
    }
    return JSParser;
  })());

  const ___R$romejs$js$parser$parser_ts$default = ___R$$priv$romejs$js$parser$parser_ts$createJSParser;

  // romejs/js-parser/index.ts

  function ___R$romejs$js$parser$index_ts$parseJS(userOptions) {
    const options = ___R$romejs$js$parser$options_ts$normalizeOptions(userOptions);
    return ___R$romejs$js$parser$parser_ts$default(options).parse();
  }

  function ___R$romejs$js$parser$index_ts$tokenizeJS(input, userOptions) {
    const options = ___R$romejs$js$parser$options_ts$normalizeOptions(userOptions);
    const parser = ___R$romejs$js$parser$parser_ts$default(Object.assign({}, options, {
      tokens: true, input: input}));
    parser.parse();

    const diagnostics = parser.getDiagnostics();
    let tokens = parser.state.tokens;

    if (diagnostics.length > 0) {
      const firstDiag = diagnostics[0];
      const invalidStart = firstDiag.start;
      const invalidEnd = firstDiag.end;
      if (invalidStart === undefined || invalidEnd === undefined) {
        throw new Error('All parser diagnostics are expected to have a start/end');
      }

      const invalidStartIndex = invalidStart.index;

      const invalidToken = {
        type: ___R$romejs$js$parser$tokenizer$types_ts$types.invalid,
        start: invalidStart.index,
        end: invalidEnd.index,
        loc: {
          filename: parser.filename,
          start: invalidStart,
          end: invalidEnd}};

      tokens = tokens.filter(token => {
        return token.loc.start.index >= invalidStartIndex;
      });

      tokens.push(invalidToken);
    }

    return tokens;
  }

  // romejs/js-generator/generators/literals/StringLiteral.ts

  function ___R$romejs$js$generator$generators$literals$StringLiteral_ts$default(generator, node, parent) {
    node =
    node.type == 'StringLiteralTypeAnnotation' || node.type === 'Directive' ? node : ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.assert(node);

    const quotes = parent.type === 'JSXAttribute' ? '"' : '\'';
    const value = parent.type === 'JSXAttribute' ? ___R$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities(node.value) : node.value;

    generator.token(
    ___R$romejs$string$escape$escapeString_ts$default(value, {
      quote: quotes}));
  }

  // romejs/js-generator/generators/core/Directive.ts

  function ___R$romejs$js$generator$generators$core$Directive_ts$default(generator, node, parent) {
    ___R$romejs$js$generator$generators$literals$StringLiteral_ts$default(generator, node, parent);
    generator.semicolon();
  }

  // romejs/js-generator/generators/expressions/DoExpression.ts

  function ___R$romejs$js$generator$generators$expressions$DoExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$DoExpression_ts$doExpression.assert(node);
    ___R$romejs$js$ast$expressions$DoExpression_ts$doExpression.assert(node);
    generator.word('do');
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/generators/statements/DoWhileStatement.ts

  function ___R$romejs$js$generator$generators$statements$DoWhileStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement.assert(node);

    generator.word('do');
    generator.space();
    generator.print(node.body, node);
    generator.space();
    generator.word('while');
    generator.space();
    generator.token('(');
    generator.print(node.test, node);
    generator.token(')');
    generator.semicolon();
  }

  // romejs/js-generator/generators/types/EmptyKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$EmptyKeywordTypeAnnotation_ts$default(generator) {
    generator.word('empty');
  }

  // romejs/js-generator/generators/statements/EmptyStatement.ts

  function ___R$romejs$js$generator$generators$statements$EmptyStatement_ts$default(generator) {
    generator.semicolon(true);
  }

  // romejs/js-generator/generators/modules/ExportAllDeclaration.ts

  function ___R$romejs$js$generator$generators$modules$ExportAllDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration.assert(node);

    generator.word('export');
    generator.space();
    generator.token('*');
    generator.space();
    generator.word('from');
    generator.space();
    generator.print(node.source, node);
    generator.semicolon();
  }

  // romejs/js-generator/generators/modules/ExportNamedDeclaration.ts

  function ___R$romejs$js$generator$generators$modules$ExportNamedDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ExportNamedDeclaration_ts$exportNamedDeclaration.assert(node);

    if (node.exportKind === 'type' && !generator.options.typeAnnotations) {
      return;
    }
    generator.word('export');
    generator.space();
    ___R$romejs$js$generator$generators$modules$ExportNamedDeclaration_ts$_ExportDeclaration(generator, node);
  }

  function ___R$romejs$js$generator$generators$modules$ExportNamedDeclaration_ts$_ExportDeclaration(generator, node) {
    node =
    node.type === 'ExportDefaultDeclaration' ? node : ___R$romejs$js$ast$modules$ExportNamedDeclaration_ts$exportNamedDeclaration.assert(node);

    if (node.declaration) {
      const declar = node.declaration;
      generator.print(declar, node);
      if (!___R$romejs$js$ast$utils$isStatement_ts$default(declar)) {
        generator.semicolon();
      }
    } else {
      if (node.type !== 'ExportNamedDeclaration') {
        throw new Error('Expected ExportNamedDeclaration');
      }

      if (node.exportKind === 'type') {
        generator.word('type');
        generator.space();
      }

      if (node.specifiers === undefined) {
        throw new Error('Expected specifiers since there was no declaration');
      }

      const specifiers = node.specifiers.slice(0);

      let hasSpecial = false;
      while (true) {
        const first = specifiers[0];
        if (first !== undefined &&
        (first.type === 'ExportDefaultSpecifier' ||
        first.type === 'ExportNamespaceSpecifier')) {
          hasSpecial = true;
          generator.print(specifiers.shift(), node);
          if (specifiers.length) {
            generator.token(',');
            generator.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length || !specifiers.length && !hasSpecial) {
        generator.token('{');
        if (specifiers.length) {
          generator.printCommaList(specifiers, node);
        }
        generator.token('}');
      }

      if (node.source) {
        generator.space();
        generator.word('from');
        generator.space();
        generator.print(node.source, node);
      }

      generator.semicolon();
    }
  }

  // romejs/js-generator/generators/modules/ExportDefaultDeclaration.ts

  function ___R$romejs$js$generator$generators$modules$ExportDefaultDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration.assert(node);

    generator.word('export');
    generator.space();
    generator.word('default');
    generator.space();
    ___R$romejs$js$generator$generators$modules$ExportNamedDeclaration_ts$_ExportDeclaration(generator, node);
  }

  // romejs/js-generator/generators/modules/ExportDefaultSpecifier.ts

  function ___R$romejs$js$generator$generators$modules$ExportDefaultSpecifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier.assert(node);

    generator.print(node.exported, node);
  }

  // romejs/js-generator/generators/modules/ExportNamespaceSpecifier.ts

  function ___R$romejs$js$generator$generators$modules$ExportNamespaceSpecifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier.assert(node);

    generator.token('*');
    generator.space();
    generator.word('as');
    generator.space();
    generator.print(node.exported, node);
  }

  // romejs/js-generator/generators/modules/ExportSpecifier.ts

  function ___R$romejs$js$generator$generators$modules$ExportSpecifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ExportSpecifier_ts$exportSpecifier.assert(node);

    generator.print(node.local, node);
    if (node.exported && node.local.name !== node.exported.name) {
      generator.space();
      generator.word('as');
      generator.space();
      generator.print(node.exported, node);
    }
  }

  // romejs/js-generator/generators/statements/ExpressionStatement.ts

  function ___R$romejs$js$generator$generators$statements$ExpressionStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement.assert(node);

    generator.print(node.expression, node);
    generator.semicolon();
  }

  // romejs/js-generator/generators/flow/FlowArrayTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$flow$FlowArrayTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts$flowArrayTypeAnnotation.assert(node);

    generator.print(node.elementType, node);
    generator.token('[');
    generator.token(']');
  }

  // romejs/js-generator/generators/flow/FlowInterfaceExtends.ts

  function ___R$romejs$js$generator$generators$flow$FlowInterfaceExtends_ts$default(generator, node) {
    node =
    node.type === 'FlowGenericTypeAnnotation' ||
    node.type === 'FlowClassImplements' ? node : ___R$romejs$js$ast$flow$FlowInterfaceExtends_ts$flowInterfaceExtends.assert(node);

    generator.print(node.id, node);
    generator.print(node.typeParameters, node);
  }

  // romejs/js-generator/generators/flow/FlowClassImplements.ts

  function ___R$romejs$js$generator$generators$flow$FlowClassImplements_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$flow$FlowClassImplements_ts$flowClassImplements.assert(node);

    ___R$romejs$js$generator$generators$flow$FlowInterfaceExtends_ts$default(generator, node);
  }

  // romejs/js-generator/generators/flow/FlowInterfaceDeclaration.ts

  function ___R$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$default(generator, node, parent) {
    node =
    node.type === 'FlowDeclareInterface' ? node : ___R$romejs$js$ast$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration.assert(node);

    generator.word('interface');
    generator.space();
    ___R$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$_interfaceish(generator, node);
  }

  function ___R$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$_interfaceish(generator, node) {
    node =
    node.type === 'FlowDeclareInterface' || node.type === 'FlowDeclareClass' ? node : ___R$romejs$js$ast$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration.assert(node);

    generator.print(node.id, node);
    generator.print(node.typeParameters, node);

    if (node.extends.length > 0) {
      generator.space();
      generator.word('extends');
      generator.space();
      generator.printCommaList(node.extends, node);
    }

    if (node.mixins.length > 0) {
      generator.space();
      generator.word('mixins');
      generator.space();
      generator.printCommaList(node.mixins, node);
    }

    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/generators/flow/FlowDeclareClass.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclareClass_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$flow$FlowDeclareClass_ts$flowDeclareClass.assert(node);

    if (parent.type !== 'ExportNamedDeclaration') {
      generator.word('declare');
      generator.space();
    }
    generator.word('class');
    generator.space();
    ___R$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$_interfaceish(generator, node);
  }

  // romejs/js-generator/generators/flow/FlowDeclaredPredicate.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclaredPredicate_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowDeclaredPredicate_ts$flowDeclaredPredicate.assert(node);

    generator.token('%checks');
    generator.space();
    generator.print(node.value, node);
  }

  // romejs/js-generator/generators/flow/FlowDeclareExportAll.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclareExportAll_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowDeclareExportAll_ts$flowDeclareExportAll.assert(node);

    ___R$romejs$js$ast$flow$FlowDeclareExportAll_ts$flowDeclareExportAll.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/flow/FlowDeclareExportDefault.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclareExportDefault_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowDeclareExportDefault_ts$flowDeclareExportDefault.assert(node);

    ___R$romejs$js$ast$flow$FlowDeclareExportDefault_ts$flowDeclareExportDefault.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/flow/FlowDeclareExportNamed.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclareExportNamed_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowDeclareExportNamed_ts$flowDeclareExportNamed.assert(node);

    ___R$romejs$js$ast$flow$FlowDeclareExportNamed_ts$flowDeclareExportNamed.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/flow/FlowDeclareFunction.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclareFunction_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$flow$FlowDeclareFunction_ts$flowDeclareFunction.assert(node);

    if (parent.type !== 'ExportNamedDeclaration') {
      generator.word('declare');
      generator.space();
    }
    generator.word('function');
    generator.space();

    const {id: id} = node;
    generator.print(id, node);

    if (id.meta !== undefined && id.meta.typeAnnotation !== undefined) {
      generator.printTypeColon(id.meta.typeAnnotation, node);
    }

    generator.semicolon();
  }

  // romejs/js-generator/generators/flow/FlowDeclareInterface.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclareInterface_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$flow$FlowDeclareInterface_ts$flowDeclareInterface.assert(node);

    generator.word('declare');
    generator.space();
    ___R$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$default(generator, node, parent);
  }

  // romejs/js-generator/generators/flow/FlowDeclareModule.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclareModule_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowDeclareModule_ts$flowDeclareModule.assert(node);

    generator.word('declare');
    generator.space();
    generator.word('module');
    generator.space();
    generator.print(node.id, node);
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/generators/flow/FlowDeclareModuleExports.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclareModuleExports_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowDeclareModuleExports_ts$flowDeclareModuleExports.assert(node);

    generator.word('declare');
    generator.space();
    generator.word('module');
    generator.token('.');
    generator.word('exports');
    generator.printTypeColon(node.typeAnnotation, node);
  }

  // romejs/js-generator/generators/flow/FlowOpaqueType.ts

  function ___R$romejs$js$generator$generators$flow$FlowOpaqueType_ts$default(generator, node, parent) {
    node =
    node.type === 'FlowDeclareOpaqueType' ? node : ___R$romejs$js$ast$flow$FlowOpaqueType_ts$flowOpaqueType.assert(node);

    generator.word('opaque');
    generator.space();
    generator.word('type');
    generator.space();
    generator.print(node.id, node);
    generator.print(node.typeParameters, node);
    if (node.supertype) {
      generator.token(':');
      generator.space();
      generator.print(node.supertype, node);
    }
    if (node.impltype) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.impltype, node);
    }
    generator.semicolon();
  }

  // romejs/js-generator/generators/flow/FlowDeclareOpaqueType.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclareOpaqueType_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$flow$FlowDeclareOpaqueType_ts$flowDeclareOpaqueType.assert(node);

    if (parent.type !== 'ExportNamedDeclaration') {
      generator.word('declare');
      generator.space();
    }
    ___R$romejs$js$generator$generators$flow$FlowOpaqueType_ts$default(generator, node, parent);
  }

  // romejs/js-generator/generators/flow/FlowDeclareVariable.ts

  function ___R$romejs$js$generator$generators$flow$FlowDeclareVariable_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$flow$FlowDeclareVariable_ts$flowDeclareVariable.assert(node);

    if (parent.type !== 'ExportNamedDeclaration') {
      generator.word('declare');
      generator.space();
    }
    generator.word('var');
    generator.space();

    const {id: id} = node;
    generator.print(id, node);
    if (id.meta !== undefined) {
      generator.print(id.meta.typeAnnotation, node);
    }

    generator.semicolon();
  }

  // romejs/js-generator/generators/flow/FlowExistsTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$flow$FlowExistsTypeAnnotation_ts$default(generator) {
    generator.token('*');
  }

  // romejs/js-generator/generators/flow/FlowFunctionTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$flow$FlowFunctionTypeAnnotation_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts$flowFunctionTypeAnnotation.assert(node);

    generator.print(node.typeParameters, node);
    generator.token('(');
    generator.printCommaList(node.params, node);
    generator.token(')');

    if (parent.type === 'FlowObjectTypeCallProperty' ||
    parent.type === 'FlowDeclareFunction') {
      generator.token(':');
    } else {
      generator.space();
      generator.token('=>');
    }

    generator.space();
    generator.print(node.returnType, node);
  }

  // romejs/js-generator/generators/flow/FlowFunctionTypeParam.ts

  function ___R$romejs$js$generator$generators$flow$FlowFunctionTypeParam_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowFunctionTypeParam_ts$flowFunctionTypeParam.assert(node);

    if (node.name) {
      generator.print(node.name, node);
      if (node.meta.optional === true) {
        generator.token('?');
      }
      generator.token(':');
      generator.space();
    }
    generator.print(node.meta.typeAnnotation, node);
  }

  // romejs/js-generator/generators/flow/FlowGenericTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$flow$FlowGenericTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts$flowGenericTypeAnnotation.assert(node);

    ___R$romejs$js$generator$generators$flow$FlowInterfaceExtends_ts$default(generator, node);
  }

  // romejs/js-generator/generators/flow/FlowInferredPredicate.ts

  function ___R$romejs$js$generator$generators$flow$FlowInferredPredicate_ts$default(generator) {
    generator.token('%checks');
  }

  // romejs/js-generator/generators/flow/FlowInterface.ts

  function ___R$romejs$js$generator$generators$flow$FlowInterface_ts$default() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/flow/FlowInterfaceTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$flow$FlowInterfaceTypeAnnotation_ts$default() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/flow/FlowNullableTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$flow$FlowNullableTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts$flowNullableTypeAnnotation.assert(node);

    generator.token('?');
    generator.print(node.typeAnnotation, node);
  }

  // romejs/js-generator/generators/flow/FlowNumericLiteral.ts

  function ___R$romejs$js$generator$generators$flow$FlowNumericLiteral_ts$default() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/flow/FlowObjectTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$flow$FlowObjectTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts$flowObjectTypeAnnotation.assert(node);

    if (node.exact === true) {
      generator.token('{|');
    } else {
      generator.token('{');
    }

    const props = node.properties;
    if (props.length) {
      generator.space();

      generator.printJoin(props, node, {
        indent: true,
        iterator: () => {
          if (props.length !== 1) {
            generator.token(',');
            generator.space();
          }
        },
        statement: ___R$romejs$js$generator$node$index_ts$isMultiLine(node)});

      generator.space();
    }

    if (node.exact === true) {
      generator.token('|}');
    } else {
      generator.token('}');
    }
  }

  // romejs/js-generator/generators/flow/FlowObjectTypeCallProperty.ts

  function ___R$romejs$js$generator$generators$flow$FlowObjectTypeCallProperty_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts$flowObjectTypeCallProperty.assert(node);

    if (node.static === true) {
      generator.word('static');
      generator.space();
    }
    generator.print(node.value, node);
  }

  // romejs/js-generator/generators/flow/FlowObjectTypeIndexer.ts

  function ___R$romejs$js$generator$generators$flow$FlowObjectTypeIndexer_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowObjectTypeIndexer_ts$flowObjectTypeIndexer.assert(node);

    if (node.static === true) {
      generator.word('static');
      generator.space();
    }

    generator.print(node.variance, node);
    generator.token('[');

    if (node.id !== undefined) {
      generator.print(node.id, node);
      generator.token(':');
    }

    generator.space();
    generator.print(node.key, node);
    generator.token(']');
    generator.token(':');
    generator.space();
    generator.print(node.value, node);
  }

  // romejs/js-generator/generators/flow/FlowObjectTypeInternalSlot.ts

  function ___R$romejs$js$generator$generators$flow$FlowObjectTypeInternalSlot_ts$default() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/flow/FlowObjectTypeProperty.ts

  function ___R$romejs$js$generator$generators$flow$FlowObjectTypeProperty_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowObjectTypeProperty_ts$flowObjectTypeProperty.assert(node);

    if (node.static === true) {
      generator.word('static');
      generator.space();
    }
    generator.print(node.variance, node);
    generator.print(node.key, node);
    if (node.optional === true) {
      generator.token('?');
    }
    generator.token(':');
    generator.space();
    generator.print(node.value, node);
  }

  // romejs/js-generator/generators/flow/FlowObjectTypeSpreadProperty.ts

  function ___R$romejs$js$generator$generators$flow$FlowObjectTypeSpreadProperty_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts$flowObjectTypeSpreadProperty.assert(node);

    generator.token('...');
    generator.print(node.argument, node);
  }

  // romejs/js-generator/generators/flow/FlowQualifiedTypeIdentifier.ts

  function ___R$romejs$js$generator$generators$flow$FlowQualifiedTypeIdentifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts$flowQualifiedTypeIdentifier.assert(node);

    generator.print(node.qualification, node);
    generator.token('.');
    generator.print(node.id, node);
  }

  // romejs/js-generator/generators/flow/FlowThisTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$flow$FlowThisTypeAnnotation_ts$default(generator) {
    generator.word('this');
  }

  // romejs/js-generator/generators/flow/FlowTupleTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$flow$FlowTupleTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts$flowTupleTypeAnnotation.assert(node);

    generator.token('[');
    generator.printCommaList(node.types, node);
    generator.token(']');
  }

  // romejs/js-generator/generators/flow/FlowTypeCastExpression.ts

  function ___R$romejs$js$generator$generators$flow$FlowTypeCastExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowTypeCastExpression_ts$flowTypeCastExpression.assert(node);

    if (generator.options.typeAnnotations) {
      generator.token('(');
      generator.print(node.expression, node);
      generator.printTypeColon(node.typeAnnotation, node);
      generator.token(')');
    } else {
      generator.print(node.expression, node);
    }
  }

  // romejs/js-generator/generators/flow/FlowTypeofTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$flow$FlowTypeofTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts$flowTypeofTypeAnnotation.assert(node);

    generator.word('typeof');
    generator.space();
    generator.print(node.argument, node);
  }

  // romejs/js-generator/generators/flow/FlowTypeParameter.ts

  function ___R$romejs$js$generator$generators$flow$FlowTypeParameter_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowTypeParameter_ts$flowTypeParameter.assert(node);

    generator.print(node.variance, node);
    generator.word(node.name);

    if (node.bound) {
      generator.print(node.bound, node);
    }

    if (node.default) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.default, node);
    }
  }

  // romejs/js-generator/generators/flow/FlowTypeParameterInstantiation.ts

  function ___R$romejs$js$generator$generators$flow$FlowTypeParameterInstantiation_ts$default(generator, node) {
    node =
    node.type === 'FlowTypeParameterDeclaration' ? node : ___R$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts$flowTypeParameterInstantiation.assert(node);

    generator.token('<');
    generator.printCommaList(
    node.params,
    node);
    generator.token('>');
  }

  // romejs/js-generator/generators/flow/FlowTypeParameterDeclaration.ts

  function ___R$romejs$js$generator$generators$flow$FlowTypeParameterDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts$flowTypeParameterDeclaration.assert(node);

    ___R$romejs$js$generator$generators$flow$FlowTypeParameterInstantiation_ts$default(generator, node);
  }

  // romejs/js-generator/generators/flow/FlowVariance.ts

  function ___R$romejs$js$generator$generators$flow$FlowVariance_ts$default(generator, node) {
    node = ___R$romejs$js$ast$flow$FlowVariance_ts$flowVariance.assert(node);
    ___R$romejs$js$ast$flow$FlowVariance_ts$flowVariance.assert(node);
    if (node.kind === 'plus') {
      generator.token('+');
    } else if (node.kind === 'minus') {
      generator.token('-');
    }
  }

  // romejs/js-generator/generators/statements/ForInStatement.ts

  const ___R$romejs$js$generator$generators$statements$ForInStatement_ts$default = ___R$romejs$js$generator$generators$utils_ts$buildForXStatementGenerator('in');

  // romejs/js-generator/generators/statements/ForOfStatement.ts

  const ___R$romejs$js$generator$generators$statements$ForOfStatement_ts$default = ___R$romejs$js$generator$generators$utils_ts$buildForXStatementGenerator('of');

  // romejs/js-generator/generators/statements/ForStatement.ts

  function ___R$romejs$js$generator$generators$statements$ForStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$ForStatement_ts$forStatement.assert(node);
    ___R$romejs$js$ast$statements$ForStatement_ts$forStatement.assert(node);
    generator.word('for');
    generator.space();
    generator.token('(');

    generator.inForStatementInitCounter++;
    generator.print(node.init, node);
    generator.inForStatementInitCounter--;
    generator.token(';');

    if (node.test) {
      generator.space();
      generator.print(node.test, node);
    }
    generator.token(';');

    if (node.update) {
      generator.space();
      generator.print(node.update, node);
    }

    generator.token(')');
    generator.printBlock(node);
  }

  // romejs/js-generator/generators/expressions/FunctionExpression.ts

  function ___R$romejs$js$generator$generators$expressions$FunctionExpression_ts$default(generator, node) {
    node =
    node.type === 'FunctionDeclaration' ? node : ___R$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression.assert(node);

    if (node.head.async === true) {
      generator.word('async');
      generator.space();
    }

    generator.word('function');

    if (node.head.generator === true) {
      generator.token('*');
    }

    if (node.id) {
      generator.space();
      generator.print(node.id, node);
    }

    generator.print(node.head, node);
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/generators/statements/FunctionDeclaration.ts

  function ___R$romejs$js$generator$generators$statements$FunctionDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration.assert(node);

    ___R$romejs$js$generator$generators$expressions$FunctionExpression_ts$default(generator, node);
  }

  // romejs/js-generator/generators/auxiliary/FunctionHead.ts

  function ___R$romejs$js$generator$generators$auxiliary$FunctionHead_ts$default(generator, node) {
    node = ___R$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.assert(node);

    const {typeAnnotations: typeAnnotations} = generator.options;

    generator.print(node.typeParameters, node);
    generator.token('(');

    generator.printCommaList(node.params, node, {
      iterator: node => {
        if (typeAnnotations && node.meta !== undefined) {
          if (node.meta.optional) {
            generator.token('?');
          }
          generator.printTypeColon(node.meta.typeAnnotation, node);
        }
      }});

    if (node.rest !== undefined) {
      if (node.params.length > 0) {
        generator.token(',');
        generator.space();
      }

      generator.token('...');
      generator.print(node.rest, node);
    }

    generator.token(')');

    if (typeAnnotations) {
      if (node.returnType) {
        generator.printTypeColon(node.returnType, node);
      }

      if (node.predicate) {
        if (!node.returnType) {
          generator.token(':');
        }
        generator.space();
        generator.print(node.predicate, node);
      }
    }
  }

  // romejs/js-generator/generators/statements/IfStatement.ts

  function ___R$romejs$js$generator$generators$statements$IfStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$IfStatement_ts$ifStatement.assert(node);
    ___R$romejs$js$ast$statements$IfStatement_ts$ifStatement.assert(node);
    generator.word('if');
    generator.space();
    generator.token('(');
    generator.print(node.test, node);
    generator.token(')');
    generator.space();

    let needsBlock = false;
    if (node.alternate !== undefined) {
      needsBlock = ___R$$priv$romejs$js$generator$generators$statements$IfStatement_ts$getLastStatement(node.consequent).type === 'IfStatement';
    }
    if (needsBlock) {
      generator.token('{');
      generator.newline();
      generator.indent();
    }

    generator.print(node.consequent, node);

    if (needsBlock) {
      generator.dedent();
      generator.newline();
      generator.token('}');
    }

    if (node.alternate) {
      if (generator.endsWith('}')) {
        generator.space();
      }
      generator.word('else');
      generator.space();
      generator.print(node.alternate, node);
    }
  }

  function ___R$$priv$romejs$js$generator$generators$statements$IfStatement_ts$getLastStatement(statement) {
    if ((statement.type === 'WithStatement' ||
    statement.type === 'WhileStatement' ||
    statement.type === 'DoWhileStatement' ||
    statement.type === 'ForOfStatement' ||
    statement.type === 'ForInStatement' ||
    statement.type === 'ForStatement') &&
    ___R$romejs$js$ast$utils$isStatement_ts$default(statement.body)) {
      return ___R$$priv$romejs$js$generator$generators$statements$IfStatement_ts$getLastStatement(statement.body);
    } else {
      return statement;
    }
  }

  // romejs/js-generator/generators/modules/ImportCall.ts

  function ___R$romejs$js$generator$generators$modules$ImportCall_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ImportCall_ts$importCall.assert(node);
    ___R$romejs$js$ast$modules$ImportCall_ts$importCall.assert(node);
    generator.word('import');
    generator.token('(');
    generator.print(node.argument, node);
    generator.token(')');
  }

  // romejs/js-generator/generators/modules/ImportDeclaration.ts

  function ___R$romejs$js$generator$generators$modules$ImportDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration.assert(node);

    generator.word('import');
    generator.space();

    if (node.importKind === 'type' || node.importKind === 'typeof') {
      generator.word(node.importKind);
      generator.space();
    }

    let {specifiers: specifiers} = node;
    if (specifiers !== undefined && specifiers.length > 0) {
      specifiers = [...specifiers];

      while (specifiers.length > 0) {
        const first = specifiers[0];
        if (first.type === 'ImportDefaultSpecifier' ||
        first.type === 'ImportNamespaceSpecifier') {
          generator.print(specifiers.shift(), node);
          if (specifiers.length) {
            generator.token(',');
            generator.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length > 0) {
        generator.token('{');
        generator.printCommaList(specifiers, node);
        generator.token('}');
      }

      generator.space();
      generator.word('from');
      generator.space();
    }

    generator.print(node.source, node);
    generator.semicolon();
  }

  // romejs/js-generator/generators/modules/ImportDefaultSpecifier.ts

  function ___R$romejs$js$generator$generators$modules$ImportDefaultSpecifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier.assert(node);

    generator.print(node.local.name, node);
  }

  // romejs/js-generator/generators/modules/ImportNamespaceSpecifier.ts

  function ___R$romejs$js$generator$generators$modules$ImportNamespaceSpecifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier.assert(node);

    generator.token('*');
    generator.space();
    generator.word('as');
    generator.space();
    generator.print(node.local.name, node);
  }

  // romejs/js-generator/generators/modules/ImportSpecifier.ts

  function ___R$romejs$js$generator$generators$modules$ImportSpecifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier.assert(node);

    if (node.local.importKind === 'type' || node.local.importKind === 'typeof') {
      generator.word(node.local.importKind);
      generator.space();
    }

    generator.print(node.imported, node);

    if (node.local.name.name !== node.imported.name) {
      generator.space();
      generator.word('as');
      generator.space();
      generator.print(node.local.name, node);
    }
  }

  // romejs/js-generator/generators/modules/ImportSpecifierLocal.ts

  function ___R$romejs$js$generator$generators$modules$ImportSpecifierLocal_ts$default(generator, node) {
    node = ___R$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/core/InterpreterDirective.ts

  function ___R$romejs$js$generator$generators$core$InterpreterDirective_ts$default(generator, node) {
    node = ___R$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/types/IntersectionTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$IntersectionTypeAnnotation_ts$intersectionTypeAnnotation.assert(node);

    generator.printJoin(node.types, node, {separator: ___R$$priv$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$andSeparator});
  }

  function ___R$$priv$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$andSeparator(generator) {
    generator.space();
    generator.token('&');
    generator.space();
  }

  // romejs/js-generator/generators/jsx/JSXAttribute.ts

  function ___R$romejs$js$generator$generators$jsx$JSXAttribute_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute.assert(node);
    ___R$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute.assert(node);
    generator.print(node.name, node);
    if (node.value) {
      generator.token('=');
      generator.print(node.value, node);
    }
  }

  // romejs/js-generator/generators/jsx/JSXElement.ts

  function ___R$romejs$js$generator$generators$jsx$JSXElement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXElement_ts$jsxElement.assert(node);
    ___R$romejs$js$ast$jsx$JSXElement_ts$jsxElement.assert(node);
    generator.token('<');
    generator.print(node.name, node);
    generator.print(node.typeArguments, node);

    if (node.attributes.length > 0) {
      generator.space();
      generator.printJoin(node.attributes, node, {separator: ___R$$priv$romejs$js$generator$generators$jsx$JSXElement_ts$spaceSeparator});
    }

    if (node.selfClosing === true) {
      generator.space();
      generator.token('/>');
      return;
    } else {
      generator.token('>');
    }

    generator.indent();
    for (const child of node.children) {
      generator.print(child, node);
    }
    generator.dedent();

    generator.token('</');
    generator.print(node.name, node);
    generator.token('>');
  }

  function ___R$$priv$romejs$js$generator$generators$jsx$JSXElement_ts$spaceSeparator(generator) {
    generator.space();
  }

  // romejs/js-generator/generators/jsx/JSXEmptyExpression.ts

  function ___R$romejs$js$generator$generators$jsx$JSXEmptyExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression.assert(node);

    generator.printInnerComments(node);
  }

  // romejs/js-generator/generators/jsx/JSXExpressionContainer.ts

  function ___R$romejs$js$generator$generators$jsx$JSXExpressionContainer_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.assert(node);

    generator.token('{');
    generator.print(node.expression, node);
    generator.token('}');
  }

  // romejs/js-generator/generators/jsx/JSXFragment.ts

  function ___R$romejs$js$generator$generators$jsx$JSXFragment_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment.assert(node);
    ___R$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment.assert(node);
    generator.token('<>');
    generator.indent();

    for (const child of node.children) {
      generator.print(child, node);
    }

    generator.dedent();
    generator.token('</>');
  }

  // romejs/js-generator/generators/jsx/JSXIdentifier.ts

  function ___R$romejs$js$generator$generators$jsx$JSXIdentifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.assert(node);

    generator.word(node.name);
  }

  // romejs/js-generator/generators/jsx/JSXMemberExpression.ts

  function ___R$romejs$js$generator$generators$jsx$JSXMemberExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression.assert(node);

    generator.print(node.object, node);
    generator.token('.');
    generator.print(node.property, node);
  }

  // romejs/js-generator/generators/jsx/JSXNamespacedName.ts

  function ___R$romejs$js$generator$generators$jsx$JSXNamespacedName_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName.assert(node);

    generator.print(node.namespace, node);
    generator.token(':');
    generator.print(node.name, node);
  }

  // romejs/js-generator/generators/jsx/JSXReferenceIdentifier.ts

  function ___R$romejs$js$generator$generators$jsx$JSXReferenceIdentifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/jsx/JSXSpreadAttribute.ts

  function ___R$romejs$js$generator$generators$jsx$JSXSpreadAttribute_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute.assert(node);

    generator.token('{');
    generator.token('...');
    generator.print(node.argument, node);
    generator.token('}');
  }

  // romejs/js-generator/generators/jsx/JSXSpreadChild.ts

  function ___R$romejs$js$generator$generators$jsx$JSXSpreadChild_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild.assert(node);

    generator.token('{');
    generator.token('...');
    generator.print(node.expression, node);
    generator.token('}');
  }

  // romejs/js-generator/generators/jsx/JSXText.ts

  function ___R$romejs$js$generator$generators$jsx$JSXText_ts$default(generator, node) {
    node = ___R$romejs$js$ast$jsx$JSXText_ts$jsxText.assert(node);
    ___R$romejs$js$ast$jsx$JSXText_ts$jsxText.assert(node);
    generator.token(___R$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities(node.value));
  }

  // romejs/js-generator/generators/statements/LabeledStatement.ts

  function ___R$romejs$js$generator$generators$statements$LabeledStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement.assert(node);

    generator.print(node.label, node);
    generator.token(':');
    generator.space();
    generator.print(node.body, node);
  }

  // romejs/js-generator/generators/expressions/LogicalExpression.ts

  function ___R$romejs$js$generator$generators$expressions$LogicalExpression_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression.assert(node);

    ___R$romejs$js$generator$generators$expressions$AssignmentExpression_ts$default(generator, node, parent);
  }

  // romejs/js-generator/generators/expressions/MemberExpression.ts

  function ___R$romejs$js$generator$generators$expressions$MemberExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.assert(node);

    generator.print(node.object, node);
    generator.print(node.property, node);
  }

  // romejs/js-generator/generators/expressions/MetaProperty.ts

  function ___R$romejs$js$generator$generators$expressions$MetaProperty_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$MetaProperty_ts$metaProperty.assert(node);
    ___R$romejs$js$ast$expressions$MetaProperty_ts$metaProperty.assert(node);
    generator.print(node.meta, node);
    generator.token('.');
    generator.print(node.property, node);
  }

  // romejs/js-generator/generators/types/MixedKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$MixedKeywordTypeAnnotation_ts$default(generator) {
    generator.word('mixed');
  }

  // romejs/js-generator/generators/temp/MockParent.ts

  function ___R$romejs$js$generator$generators$temp$MockParent_ts$default(generator, node) {
    node = ___R$romejs$js$ast$temp$MockParent_ts$mockParent.assert(node);
    ___R$romejs$js$ast$temp$MockParent_ts$mockParent.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/types/NeverKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$NeverKeywordTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts$neverKeywordTypeAnnotation.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/expressions/NewExpression.ts

  function ___R$romejs$js$generator$generators$expressions$NewExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$NewExpression_ts$newExpression.assert(node);

    generator.word('new');
    generator.space();
    generator.print(node.callee, node);
    generator.print(node.typeArguments, node);
    generator.token('(');
    generator.printCommaList(node.arguments, node);
    generator.token(')');
  }

  // romejs/js-generator/generators/types/NullKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$NullKeywordTypeAnnotation_ts$default(generator) {
    generator.word('null');
  }

  // romejs/js-generator/generators/literals/NullLiteral.ts

  function ___R$romejs$js$generator$generators$literals$NullLiteral_ts$default(generator) {
    generator.word('null');
  }

  // romejs/js-generator/generators/types/NumberKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$NumberKeywordTypeAnnotation_ts$default(generator) {
    generator.word('number');
  }

  // romejs/js-generator/generators/literals/NumericLiteral.ts

  function ___R$romejs$js$generator$generators$literals$NumericLiteral_ts$default(generator, node) {
    node =
    node.type === 'NumericLiteralTypeAnnotation' ? node : ___R$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral.assert(node);

    const value = String(node.value);
    generator.number(value);
  }

  // romejs/js-generator/generators/types/NumericLiteralTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$NumericLiteralTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts$numericLiteralTypeAnnotation.assert(node);

    ___R$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts$numericLiteralTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/types/ObjectKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$ObjectKeywordTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts$objectKeywordTypeAnnotation.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/objects/ObjectMethod.ts

  function ___R$romejs$js$generator$generators$objects$ObjectMethod_ts$default(generator, node) {
    node = ___R$romejs$js$ast$objects$ObjectMethod_ts$objectMethod.assert(node);
    ___R$romejs$js$ast$objects$ObjectMethod_ts$objectMethod.assert(node);
    ___R$romejs$js$generator$generators$utils_ts$printMethod(generator, node);
  }

  // romejs/js-generator/generators/objects/ObjectProperty.ts

  function ___R$romejs$js$generator$generators$objects$ObjectProperty_ts$default(generator, node) {
    node = ___R$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.assert(node);

    generator.print(node.key, node);
    generator.token(':');
    generator.space();
    generator.print(node.value, node);
  }

  // romejs/js-generator/generators/expressions/OptionalCallExpression.ts

  function ___R$romejs$js$generator$generators$expressions$OptionalCallExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/patterns/PatternMeta.ts

  function ___R$romejs$js$generator$generators$patterns$PatternMeta_ts$default(generator, node) {
    node = ___R$romejs$js$ast$patterns$PatternMeta_ts$patternMeta.assert(node);
    ___R$romejs$js$ast$patterns$PatternMeta_ts$patternMeta.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/classes/PrivateName.ts

  function ___R$romejs$js$generator$generators$classes$PrivateName_ts$default() {
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/core/Program.ts

  function ___R$romejs$js$generator$generators$core$Program_ts$default(generator, node) {
    node = ___R$romejs$js$ast$core$Program_ts$program.assert(node);
    ___R$romejs$js$ast$core$Program_ts$program.assert(node);
    generator.printInnerComments(node, false);
    generator.printStatementList(node.directives, node);

    if (node.directives && node.directives.length) {
      generator.newline();
    }

    generator.printStatementList(node.body, node);
  }

  // romejs/js-generator/generators/expressions/ReferenceIdentifier.ts

  function ___R$romejs$js$generator$generators$expressions$ReferenceIdentifier_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.assert(node);
    ___R$romejs$js$generator$generators$auxiliary$Identifier_ts$default(generator, node);
  }

  // romejs/js-generator/generators/literals/RegExpLiteral.ts

  function ___R$romejs$js$generator$generators$literals$RegExpLiteral_ts$default(generator, node) {
    node = ___R$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral.assert(node);

    const flags = [];

    if (node.global === true) {
      flags.push('g');
    }

    if (node.multiline === true) {
      flags.push('m');
    }

    if (node.sticky === true) {
      flags.push('y');
    }

    if (node.insensitive === true) {
      flags.push('i');
    }

    if (node.noDotNewline === true) {
      flags.push('s');
    }

    if (node.unicode === true) {
      flags.push('u');
    }

    generator.word('/' + node.pattern + '/' + flags.join(''));
  }

  // romejs/js-generator/generators/statements/ReturnStatement.ts

  const ___R$romejs$js$generator$generators$statements$ReturnStatement_ts$default = ___R$romejs$js$generator$generators$utils_ts$buildLabelStatementGenerator('return');

  // romejs/js-generator/generators/expressions/SequenceExpression.ts

  function ___R$romejs$js$generator$generators$expressions$SequenceExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.assert(node);

    generator.printCommaList(node.expressions, node);
  }

  // romejs/js-generator/generators/auxiliary/SpreadElement.ts

  function ___R$romejs$js$generator$generators$auxiliary$SpreadElement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement.assert(node);

    generator.token('...');
    generator.print(node.argument, node);
  }

  // romejs/js-generator/generators/objects/SpreadProperty.ts

  function ___R$romejs$js$generator$generators$objects$SpreadProperty_ts$default(generator, node) {
    node = ___R$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty.assert(node);

    generator.token('...');
    generator.print(node.argument, node);
  }

  // romejs/js-generator/generators/auxiliary/StaticMemberProperty.ts

  function ___R$romejs$js$generator$generators$auxiliary$StaticMemberProperty_ts$default(generator, node) {
    node = ___R$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty.assert(node);

    generator.token('.');
    generator.print(node.value, node);
  }

  // romejs/js-generator/generators/objects/StaticPropertyKey.ts

  function ___R$romejs$js$generator$generators$objects$StaticPropertyKey_ts$default(generator, node) {
    node = ___R$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.assert(node);

    generator.print(node.value, node);
  }

  // romejs/js-generator/generators/types/StringKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$StringKeywordTypeAnnotation_ts$default(generator) {
    generator.word('string');
  }

  // romejs/js-generator/generators/types/StringLiteralTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$StringLiteralTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$StringLiteralTypeAnnotation_ts$stringLiteralTypeAnnotation.assert(node);

    ___R$romejs$js$ast$types$StringLiteralTypeAnnotation_ts$stringLiteralTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/expressions/Super.ts

  function ___R$romejs$js$generator$generators$expressions$Super_ts$default(generator) {
    generator.word('super');
  }

  // romejs/js-generator/generators/auxiliary/SwitchCase.ts

  function ___R$romejs$js$generator$generators$auxiliary$SwitchCase_ts$default(generator, node) {
    node = ___R$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase.assert(node);

    if (node.test) {
      generator.word('case');
      generator.space();
      generator.print(node.test, node);
      generator.token(':');
    } else {
      generator.word('default');
      generator.token(':');
    }

    generator.newline();

    if (node.consequent.length) {
      generator.printStatementList(node.consequent, node, {indent: true});
    }
  }

  // romejs/js-generator/generators/statements/SwitchStatement.ts

  function ___R$romejs$js$generator$generators$statements$SwitchStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$SwitchStatement_ts$switchStatement.assert(node);

    generator.word('switch');
    generator.space();
    generator.token('(');
    generator.print(node.discriminant, node);
    generator.token(')');
    generator.space();
    generator.token('{');

    generator.printStatementList(node.cases, node, {
      indent: true});

    generator.token('}');
  }

  // romejs/js-generator/generators/types/SymbolKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$SymbolKeywordTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts$symbolKeywordTypeAnnotation.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/expressions/TaggedTemplateExpression.ts

  function ___R$romejs$js$generator$generators$expressions$TaggedTemplateExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression.assert(node);

    generator.print(node.tag, node);
    generator.print(node.quasi, node);
  }

  // romejs/js-generator/generators/auxiliary/TemplateElement.ts

  function ___R$romejs$js$generator$generators$auxiliary$TemplateElement_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement.assert(node);
    parent = ___R$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral.assert(parent);

    const isFirst = parent.quasis[0] === node;
    const isLast = parent.quasis[parent.quasis.length - 1] === node;

    const value = (isFirst ? '`' : '}') + node.raw + (isLast ? '`' : '${');

    generator.token(value);
  }

  // romejs/js-generator/generators/literals/TemplateLiteral.ts

  function ___R$romejs$js$generator$generators$literals$TemplateLiteral_ts$default(generator, node) {
    node = ___R$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral.assert(node);

    const quasis = node.quasis;

    for (let i = 0; i < quasis.length; i++) {
      generator.print(quasis[i], node);

      if (i + 1 < quasis.length) {
        generator.print(node.expressions[i], node);
      }
    }
  }

  // romejs/js-generator/generators/types/TemplateLiteralTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$TemplateLiteralTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts$templateLiteralTypeAnnotation.assert(node);

    ___R$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts$templateLiteralTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/expressions/ThisExpression.ts

  function ___R$romejs$js$generator$generators$expressions$ThisExpression_ts$default(generator) {
    generator.word('this');
  }

  // romejs/js-generator/generators/statements/ThrowStatement.ts

  const ___R$romejs$js$generator$generators$statements$ThrowStatement_ts$default = ___R$romejs$js$generator$generators$utils_ts$buildLabelStatementGenerator('throw');

  // romejs/js-generator/generators/statements/TryStatement.ts

  function ___R$romejs$js$generator$generators$statements$TryStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$TryStatement_ts$tryStatement.assert(node);
    ___R$romejs$js$ast$statements$TryStatement_ts$tryStatement.assert(node);
    generator.word('try');
    generator.space();
    generator.print(node.block, node);
    generator.space();
    generator.print(node.handler, node);

    if (node.finalizer) {
      generator.space();
      generator.word('finally');
      generator.space();
      generator.print(node.finalizer, node);
    }
  }

  // romejs/js-generator/generators/typescript/TSArrayType.ts

  function ___R$romejs$js$generator$generators$typescript$TSArrayType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType.assert(node);
    ___R$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSAsExpression.ts

  function ___R$romejs$js$generator$generators$typescript$TSAsExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression.assert(node);

    generator.print(node.expression);
    if (generator.options.typeAnnotations) {
      generator.word('as');
      generator.print(node.typeAnnotation, node);
    }
  }

  // romejs/js-generator/generators/typescript/TSAssignmentAsExpression.ts

  function ___R$romejs$js$generator$generators$typescript$TSAssignmentAsExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSAssignmentNonNullExpression.ts

  function ___R$romejs$js$generator$generators$typescript$TSAssignmentNonNullExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSAssignmentTypeAssertion.ts

  function ___R$romejs$js$generator$generators$typescript$TSAssignmentTypeAssertion_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSCallSignatureDeclaration.ts

  function ___R$romejs$js$generator$generators$typescript$TSCallSignatureDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSConditionalType.ts

  function ___R$romejs$js$generator$generators$typescript$TSConditionalType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSConstructorType.ts

  function ___R$romejs$js$generator$generators$typescript$TSConstructorType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSConstructSignatureDeclaration.ts

  function ___R$romejs$js$generator$generators$typescript$TSConstructSignatureDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSDeclareFunction.ts

  function ___R$romejs$js$generator$generators$typescript$TSDeclareFunction_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSDeclareMethod.ts

  function ___R$romejs$js$generator$generators$typescript$TSDeclareMethod_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSEnumDeclaration.ts

  function ___R$romejs$js$generator$generators$typescript$TSEnumDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSEnumMember.ts

  function ___R$romejs$js$generator$generators$typescript$TSEnumMember_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember.assert(node);
    ___R$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSExportAssignment.ts

  function ___R$romejs$js$generator$generators$typescript$TSExportAssignment_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSExpressionWithTypeArguments.ts

  function ___R$romejs$js$generator$generators$typescript$TSExpressionWithTypeArguments_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSExternalModuleReference.ts

  function ___R$romejs$js$generator$generators$typescript$TSExternalModuleReference_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSFunctionType.ts

  function ___R$romejs$js$generator$generators$typescript$TSFunctionType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSImportEqualsDeclaration.ts

  function ___R$romejs$js$generator$generators$typescript$TSImportEqualsDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSImportType.ts

  function ___R$romejs$js$generator$generators$typescript$TSImportType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSImportType_ts$tsImportType.assert(node);
    ___R$romejs$js$ast$typescript$TSImportType_ts$tsImportType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSIndexedAccessType.ts

  function ___R$romejs$js$generator$generators$typescript$TSIndexedAccessType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSIndexSignature.ts

  function ___R$romejs$js$generator$generators$typescript$TSIndexSignature_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSInferType.ts

  function ___R$romejs$js$generator$generators$typescript$TSInferType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSInferType_ts$tsInferType.assert(node);
    ___R$romejs$js$ast$typescript$TSInferType_ts$tsInferType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSInterfaceBody.ts

  function ___R$romejs$js$generator$generators$typescript$TSInterfaceBody_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSInterfaceDeclaration.ts

  function ___R$romejs$js$generator$generators$typescript$TSInterfaceDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSMappedType.ts

  function ___R$romejs$js$generator$generators$typescript$TSMappedType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType.assert(node);
    ___R$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSMethodSignature.ts

  function ___R$romejs$js$generator$generators$typescript$TSMethodSignature_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSModuleBlock.ts

  function ___R$romejs$js$generator$generators$typescript$TSModuleBlock_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSModuleDeclaration.ts

  function ___R$romejs$js$generator$generators$typescript$TSModuleDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSNamespaceExportDeclaration.ts

  function ___R$romejs$js$generator$generators$typescript$TSNamespaceExportDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSNonNullExpression.ts

  function ___R$romejs$js$generator$generators$typescript$TSNonNullExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSOptionalType.ts

  function ___R$romejs$js$generator$generators$typescript$TSOptionalType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSParenthesizedType.ts

  function ___R$romejs$js$generator$generators$typescript$TSParenthesizedType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSPropertySignature.ts

  function ___R$romejs$js$generator$generators$typescript$TSPropertySignature_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSQualifiedName.ts

  function ___R$romejs$js$generator$generators$typescript$TSQualifiedName_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSSignatureDeclarationMeta.ts

  function ___R$romejs$js$generator$generators$typescript$TSSignatureDeclarationMeta_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta.assert(node);

    ___R$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSThisType.ts

  function ___R$romejs$js$generator$generators$typescript$TSThisType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSThisType_ts$tsThisType.assert(node);
    ___R$romejs$js$ast$typescript$TSThisType_ts$tsThisType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSTupleType.ts

  function ___R$romejs$js$generator$generators$typescript$TSTupleType_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType.assert(node);
    ___R$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSTypeAssertion.ts

  function ___R$romejs$js$generator$generators$typescript$TSTypeAssertion_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSTypeLiteral.ts

  function ___R$romejs$js$generator$generators$typescript$TSTypeLiteral_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSTypeOperator.ts

  function ___R$romejs$js$generator$generators$typescript$TSTypeOperator_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSTypeParameter.ts

  function ___R$romejs$js$generator$generators$typescript$TSTypeParameter_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSTypeParameterDeclaration.ts

  function ___R$romejs$js$generator$generators$typescript$TSTypeParameterDeclaration_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSTypeParameterInstantiation.ts

  function ___R$romejs$js$generator$generators$typescript$TSTypeParameterInstantiation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSTypePredicate.ts

  function ___R$romejs$js$generator$generators$typescript$TSTypePredicate_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSTypeQuery.ts

  function ___R$romejs$js$generator$generators$typescript$TSTypeQuery_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery.assert(node);
    ___R$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/typescript/TSTypeReference.ts

  function ___R$romejs$js$generator$generators$typescript$TSTypeReference_ts$default(generator, node) {
    node = ___R$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/types/TypeAliasTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$TypeAliasTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation.assert(node);

    generator.word('type');
    generator.space();
    generator.print(node.id, node);
    generator.print(node.typeParameters, node);
    generator.space();
    generator.token('=');
    generator.space();
    generator.print(node.right, node);
    generator.semicolon();
  }

  // romejs/js-generator/generators/expressions/UnaryExpression.ts

  function ___R$romejs$js$generator$generators$expressions$UnaryExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression.assert(node);

    if (node.operator === 'void' ||
    node.operator === 'delete' ||
    node.operator === 'typeof') {
      generator.word(node.operator);
      generator.space();
    } else {
      generator.token(node.operator);
    }

    generator.print(node.argument, node);
  }

  // romejs/js-generator/generators/types/UndefinedKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$UndefinedKeywordTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts$undefinedKeywordTypeAnnotation.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/types/UnionTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$UnionTypeAnnotation_ts$unionTypeAnnotation.assert(node);

    generator.printJoin(node.types, node, {separator: ___R$$priv$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$orSeparator});
  }

  function ___R$$priv$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$orSeparator(generator) {
    generator.space();
    generator.token('|');
    generator.space();
  }

  // romejs/js-generator/generators/types/UnknownKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$UnknownKeywordTypeAnnotation_ts$default(generator, node) {
    node = ___R$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts$unknownKeywordTypeAnnotation.assert(node);

    throw new Error('unimplemented');
  }

  // romejs/js-generator/generators/expressions/UpdateExpression.ts

  function ___R$romejs$js$generator$generators$expressions$UpdateExpression_ts$default(generator, node) {
    node = ___R$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression.assert(node);

    if (node.prefix === true) {
      generator.token(node.operator);
      generator.print(node.argument, node);
    } else {
      generator.print(node.argument, node);
      generator.token(node.operator);
    }
  }

  // romejs/js-generator/generators/auxiliary/VariableDeclaration.ts

  function ___R$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$default(generator, node, parent) {
    node = ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.assert(node);

    generator.word(node.kind);
    generator.space();

    let hasInits = false;

    if (!___R$romejs$js$ast$utils$isFor_ts$default(parent)) {
      for (const declar of node.declarations) {
        if (declar.init) {
          hasInits = true;
        }
      }
    }

    let separator = ___R$$priv$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$variableDeclarationNormal;
    if (hasInits) {
      separator =
      node.kind === 'const' ? ___R$$priv$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$constDeclarationIndent : ___R$$priv$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$variableDeclarationIndent;
    }

    generator.printJoin(node.declarations, node, {separator: separator});
  }

  function ___R$$priv$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$variableDeclarationNormal(generator) {
    generator.token(',');
    generator.space();
  }

  function ___R$$priv$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$variableDeclarationIndent(generator) {
    generator.token(',');
    generator.newline();
    if (generator.endsWith('\n')) {
      for (let i = 0; i < 4; i++) {
        generator.space();
      }
    }
  }

  function ___R$$priv$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$constDeclarationIndent(generator) {
    generator.token(',');
    generator.newline();
    if (generator.endsWith('\n')) {
      for (let i = 0; i < 6; i++) {
        generator.space();
      }
    }
  }

  // romejs/js-generator/generators/statements/VariableDeclarationStatement.ts

  function ___R$romejs$js$generator$generators$statements$VariableDeclarationStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.assert(node);

    if (node.declare === true && !generator.options.typeAnnotations) {
      return;
    }

    generator.print(node.declaration, node);
    generator.semicolon();
  }

  // romejs/js-generator/generators/auxiliary/VariableDeclarator.ts

  function ___R$romejs$js$generator$generators$auxiliary$VariableDeclarator_ts$default(generator, node) {
    node = ___R$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.assert(node);

    const {id: id} = node;
    generator.print(id, node);
    if (id.meta !== undefined) {
      generator.print(id.meta.typeAnnotation, id.meta);
    }

    if (node.init) {
      generator.space();
      generator.token('=');
      generator.space();
      generator.print(node.init, node);
    }
  }

  // romejs/js-generator/generators/types/VoidKeywordTypeAnnotation.ts

  function ___R$romejs$js$generator$generators$types$VoidKeywordTypeAnnotation_ts$default(generator) {
    generator.word('void');
  }

  // romejs/js-generator/generators/statements/WhileStatement.ts

  function ___R$romejs$js$generator$generators$statements$WhileStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$WhileStatement_ts$whileStatement.assert(node);

    generator.word('while');
    generator.space();
    generator.token('(');
    generator.print(node.test, node);
    generator.token(')');
    generator.printBlock(node);
  }

  // romejs/js-generator/generators/statements/WithStatement.ts

  function ___R$romejs$js$generator$generators$statements$WithStatement_ts$default(generator, node) {
    node = ___R$romejs$js$ast$statements$WithStatement_ts$withStatement.assert(node);

    generator.word('with');
    generator.space();
    generator.token('(');
    generator.print(node.object, node);
    generator.token(')');
    generator.printBlock(node);
  }

  // romejs/js-generator/generators/expressions/YieldExpression.ts

  const ___R$romejs$js$generator$generators$expressions$YieldExpression_ts$default = ___R$romejs$js$generator$generators$utils_ts$buildYieldAwaitGenerator('yield');

  // romejs/js-generator/generators/index.ts

  const ___R$$priv$romejs$js$generator$generators$index_ts$generators = new Map();
  const ___R$romejs$js$generator$generators$index_ts$default = ___R$$priv$romejs$js$generator$generators$index_ts$generators;
  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set(
  'AmbiguousFlowTypeCastExpression',
  ___R$romejs$js$generator$generators$temp$AmbiguousFlowTypeCastExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('AnyKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$AnyKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ArrayExpression', ___R$romejs$js$generator$generators$expressions$ArrayExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ArrowFunctionExpression', ___R$romejs$js$generator$generators$expressions$ArrowFunctionExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('AssignmentArrayPattern', ___R$romejs$js$generator$generators$patterns$AssignmentArrayPattern_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('AssignmentAssignmentPattern', ___R$romejs$js$generator$generators$patterns$AssignmentAssignmentPattern_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('AssignmentExpression', ___R$romejs$js$generator$generators$expressions$AssignmentExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('AssignmentIdentifier', ___R$romejs$js$generator$generators$patterns$AssignmentIdentifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('AssignmentObjectPattern', ___R$romejs$js$generator$generators$patterns$AssignmentObjectPattern_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set(
  'AssignmentObjectPatternProperty',
  ___R$romejs$js$generator$generators$patterns$AssignmentObjectPatternProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('AwaitExpression', ___R$romejs$js$generator$generators$expressions$AwaitExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BigIntKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$BigIntKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BigIntLiteral', ___R$romejs$js$generator$generators$literals$BigIntLiteral_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BinaryExpression', ___R$romejs$js$generator$generators$expressions$BinaryExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BindingArrayPattern', ___R$romejs$js$generator$generators$patterns$BindingArrayPattern_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BindingAssignmentPattern', ___R$romejs$js$generator$generators$patterns$BindingAssignmentPattern_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BindingIdentifier', ___R$romejs$js$generator$generators$patterns$BindingIdentifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BindingObjectPattern', ___R$romejs$js$generator$generators$patterns$BindingObjectPattern_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BindingObjectPatternProperty', ___R$romejs$js$generator$generators$patterns$BindingObjectPatternProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BlockStatement', ___R$romejs$js$generator$generators$statements$BlockStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BooleanKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$BooleanKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BooleanLiteral', ___R$romejs$js$generator$generators$literals$BooleanLiteral_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BooleanLiteralTypeAnnotation', ___R$romejs$js$generator$generators$types$BooleanLiteralTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('BreakStatement', ___R$romejs$js$generator$generators$statements$BreakStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('CallExpression', ___R$romejs$js$generator$generators$expressions$CallExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('CatchClause', ___R$romejs$js$generator$generators$auxiliary$CatchClause_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ClassDeclaration', ___R$romejs$js$generator$generators$classes$ClassDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ClassExpression', ___R$romejs$js$generator$generators$classes$ClassExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ClassHead', ___R$romejs$js$generator$generators$classes$ClassHead_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ClassMethod', ___R$romejs$js$generator$generators$classes$ClassMethod_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ClassPrivateMethod', ___R$romejs$js$generator$generators$classes$ClassPrivateMethod_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ClassPrivateProperty', ___R$romejs$js$generator$generators$classes$ClassPrivateProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ClassProperty', ___R$romejs$js$generator$generators$classes$ClassProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ClassPropertyMeta', ___R$romejs$js$generator$generators$classes$ClassPropertyMeta_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('CommentBlock', ___R$romejs$js$generator$generators$core$CommentBlock_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('CommentLine', ___R$romejs$js$generator$generators$core$CommentLine_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ComputedMemberProperty', ___R$romejs$js$generator$generators$auxiliary$ComputedMemberProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ComputedPropertyKey', ___R$romejs$js$generator$generators$objects$ComputedPropertyKey_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ConditionalExpression', ___R$romejs$js$generator$generators$expressions$ConditionalExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ContinueStatement', ___R$romejs$js$generator$generators$statements$ContinueStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('DebuggerStatement', ___R$romejs$js$generator$generators$statements$DebuggerStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('Directive', ___R$romejs$js$generator$generators$core$Directive_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('DoExpression', ___R$romejs$js$generator$generators$expressions$DoExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('DoWhileStatement', ___R$romejs$js$generator$generators$statements$DoWhileStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('EmptyKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$EmptyKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('EmptyStatement', ___R$romejs$js$generator$generators$statements$EmptyStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ExportAllDeclaration', ___R$romejs$js$generator$generators$modules$ExportAllDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ExportDefaultDeclaration', ___R$romejs$js$generator$generators$modules$ExportDefaultDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ExportDefaultSpecifier', ___R$romejs$js$generator$generators$modules$ExportDefaultSpecifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ExportNamedDeclaration', ___R$romejs$js$generator$generators$modules$ExportNamedDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ExportNamespaceSpecifier', ___R$romejs$js$generator$generators$modules$ExportNamespaceSpecifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ExportSpecifier', ___R$romejs$js$generator$generators$modules$ExportSpecifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ExpressionStatement', ___R$romejs$js$generator$generators$statements$ExpressionStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowArrayTypeAnnotation', ___R$romejs$js$generator$generators$flow$FlowArrayTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowClassImplements', ___R$romejs$js$generator$generators$flow$FlowClassImplements_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareClass', ___R$romejs$js$generator$generators$flow$FlowDeclareClass_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclaredPredicate', ___R$romejs$js$generator$generators$flow$FlowDeclaredPredicate_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareExportAll', ___R$romejs$js$generator$generators$flow$FlowDeclareExportAll_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareExportDefault', ___R$romejs$js$generator$generators$flow$FlowDeclareExportDefault_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareExportNamed', ___R$romejs$js$generator$generators$flow$FlowDeclareExportNamed_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareFunction', ___R$romejs$js$generator$generators$flow$FlowDeclareFunction_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareInterface', ___R$romejs$js$generator$generators$flow$FlowDeclareInterface_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareModule', ___R$romejs$js$generator$generators$flow$FlowDeclareModule_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareModuleExports', ___R$romejs$js$generator$generators$flow$FlowDeclareModuleExports_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareOpaqueType', ___R$romejs$js$generator$generators$flow$FlowDeclareOpaqueType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowDeclareVariable', ___R$romejs$js$generator$generators$flow$FlowDeclareVariable_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowExistsTypeAnnotation', ___R$romejs$js$generator$generators$flow$FlowExistsTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowFunctionTypeAnnotation', ___R$romejs$js$generator$generators$flow$FlowFunctionTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowFunctionTypeParam', ___R$romejs$js$generator$generators$flow$FlowFunctionTypeParam_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowGenericTypeAnnotation', ___R$romejs$js$generator$generators$flow$FlowGenericTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowInferredPredicate', ___R$romejs$js$generator$generators$flow$FlowInferredPredicate_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowInterface', ___R$romejs$js$generator$generators$flow$FlowInterface_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowInterfaceDeclaration', ___R$romejs$js$generator$generators$flow$FlowInterfaceDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowInterfaceExtends', ___R$romejs$js$generator$generators$flow$FlowInterfaceExtends_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowInterfaceTypeAnnotation', ___R$romejs$js$generator$generators$flow$FlowInterfaceTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowNullableTypeAnnotation', ___R$romejs$js$generator$generators$flow$FlowNullableTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowNumericLiteral', ___R$romejs$js$generator$generators$flow$FlowNumericLiteral_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeAnnotation', ___R$romejs$js$generator$generators$flow$FlowObjectTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeCallProperty', ___R$romejs$js$generator$generators$flow$FlowObjectTypeCallProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeIndexer', ___R$romejs$js$generator$generators$flow$FlowObjectTypeIndexer_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeInternalSlot', ___R$romejs$js$generator$generators$flow$FlowObjectTypeInternalSlot_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeProperty', ___R$romejs$js$generator$generators$flow$FlowObjectTypeProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowObjectTypeSpreadProperty', ___R$romejs$js$generator$generators$flow$FlowObjectTypeSpreadProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowOpaqueType', ___R$romejs$js$generator$generators$flow$FlowOpaqueType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowQualifiedTypeIdentifier', ___R$romejs$js$generator$generators$flow$FlowQualifiedTypeIdentifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowThisTypeAnnotation', ___R$romejs$js$generator$generators$flow$FlowThisTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowTupleTypeAnnotation', ___R$romejs$js$generator$generators$flow$FlowTupleTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowTypeCastExpression', ___R$romejs$js$generator$generators$flow$FlowTypeCastExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowTypeofTypeAnnotation', ___R$romejs$js$generator$generators$flow$FlowTypeofTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowTypeParameter', ___R$romejs$js$generator$generators$flow$FlowTypeParameter_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowTypeParameterDeclaration', ___R$romejs$js$generator$generators$flow$FlowTypeParameterDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set(
  'FlowTypeParameterInstantiation',
  ___R$romejs$js$generator$generators$flow$FlowTypeParameterInstantiation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FlowVariance', ___R$romejs$js$generator$generators$flow$FlowVariance_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ForInStatement', ___R$romejs$js$generator$generators$statements$ForInStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ForOfStatement', ___R$romejs$js$generator$generators$statements$ForOfStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ForStatement', ___R$romejs$js$generator$generators$statements$ForStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FunctionDeclaration', ___R$romejs$js$generator$generators$statements$FunctionDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FunctionExpression', ___R$romejs$js$generator$generators$expressions$FunctionExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('FunctionHead', ___R$romejs$js$generator$generators$auxiliary$FunctionHead_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('Identifier', ___R$romejs$js$generator$generators$auxiliary$Identifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('IfStatement', ___R$romejs$js$generator$generators$statements$IfStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ImportCall', ___R$romejs$js$generator$generators$modules$ImportCall_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ImportDeclaration', ___R$romejs$js$generator$generators$modules$ImportDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ImportDefaultSpecifier', ___R$romejs$js$generator$generators$modules$ImportDefaultSpecifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ImportNamespaceSpecifier', ___R$romejs$js$generator$generators$modules$ImportNamespaceSpecifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ImportSpecifier', ___R$romejs$js$generator$generators$modules$ImportSpecifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ImportSpecifierLocal', ___R$romejs$js$generator$generators$modules$ImportSpecifierLocal_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('InterpreterDirective', ___R$romejs$js$generator$generators$core$InterpreterDirective_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('IntersectionTypeAnnotation', ___R$romejs$js$generator$generators$types$IntersectionTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXAttribute', ___R$romejs$js$generator$generators$jsx$JSXAttribute_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXElement', ___R$romejs$js$generator$generators$jsx$JSXElement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXEmptyExpression', ___R$romejs$js$generator$generators$jsx$JSXEmptyExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXExpressionContainer', ___R$romejs$js$generator$generators$jsx$JSXExpressionContainer_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXFragment', ___R$romejs$js$generator$generators$jsx$JSXFragment_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXIdentifier', ___R$romejs$js$generator$generators$jsx$JSXIdentifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXMemberExpression', ___R$romejs$js$generator$generators$jsx$JSXMemberExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXNamespacedName', ___R$romejs$js$generator$generators$jsx$JSXNamespacedName_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXReferenceIdentifier', ___R$romejs$js$generator$generators$jsx$JSXReferenceIdentifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXSpreadAttribute', ___R$romejs$js$generator$generators$jsx$JSXSpreadAttribute_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXSpreadChild', ___R$romejs$js$generator$generators$jsx$JSXSpreadChild_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('JSXText', ___R$romejs$js$generator$generators$jsx$JSXText_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('LabeledStatement', ___R$romejs$js$generator$generators$statements$LabeledStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('LogicalExpression', ___R$romejs$js$generator$generators$expressions$LogicalExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('MemberExpression', ___R$romejs$js$generator$generators$expressions$MemberExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('MetaProperty', ___R$romejs$js$generator$generators$expressions$MetaProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('MixedKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$MixedKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('MockParent', ___R$romejs$js$generator$generators$temp$MockParent_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('NeverKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$NeverKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('NewExpression', ___R$romejs$js$generator$generators$expressions$NewExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('NullKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$NullKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('NullLiteral', ___R$romejs$js$generator$generators$literals$NullLiteral_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('NumberKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$NumberKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('NumericLiteral', ___R$romejs$js$generator$generators$literals$NumericLiteral_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('NumericLiteralTypeAnnotation', ___R$romejs$js$generator$generators$types$NumericLiteralTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ObjectExpression', ___R$romejs$js$generator$generators$objects$ObjectExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ObjectKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$ObjectKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ObjectMethod', ___R$romejs$js$generator$generators$objects$ObjectMethod_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ObjectProperty', ___R$romejs$js$generator$generators$objects$ObjectProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('OptionalCallExpression', ___R$romejs$js$generator$generators$expressions$OptionalCallExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('PatternMeta', ___R$romejs$js$generator$generators$patterns$PatternMeta_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('PrivateName', ___R$romejs$js$generator$generators$classes$PrivateName_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('Program', ___R$romejs$js$generator$generators$core$Program_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ReferenceIdentifier', ___R$romejs$js$generator$generators$expressions$ReferenceIdentifier_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('RegExpLiteral', ___R$romejs$js$generator$generators$literals$RegExpLiteral_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ReturnStatement', ___R$romejs$js$generator$generators$statements$ReturnStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('SequenceExpression', ___R$romejs$js$generator$generators$expressions$SequenceExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('SpreadElement', ___R$romejs$js$generator$generators$auxiliary$SpreadElement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('SpreadProperty', ___R$romejs$js$generator$generators$objects$SpreadProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('StaticMemberProperty', ___R$romejs$js$generator$generators$auxiliary$StaticMemberProperty_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('StaticPropertyKey', ___R$romejs$js$generator$generators$objects$StaticPropertyKey_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('StringKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$StringKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('StringLiteral', ___R$romejs$js$generator$generators$literals$StringLiteral_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('StringLiteralTypeAnnotation', ___R$romejs$js$generator$generators$types$StringLiteralTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('Super', ___R$romejs$js$generator$generators$expressions$Super_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('SwitchCase', ___R$romejs$js$generator$generators$auxiliary$SwitchCase_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('SwitchStatement', ___R$romejs$js$generator$generators$statements$SwitchStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('SymbolKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$SymbolKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TaggedTemplateExpression', ___R$romejs$js$generator$generators$expressions$TaggedTemplateExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TemplateElement', ___R$romejs$js$generator$generators$auxiliary$TemplateElement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TemplateLiteral', ___R$romejs$js$generator$generators$literals$TemplateLiteral_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TemplateLiteralTypeAnnotation', ___R$romejs$js$generator$generators$types$TemplateLiteralTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ThisExpression', ___R$romejs$js$generator$generators$expressions$ThisExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('ThrowStatement', ___R$romejs$js$generator$generators$statements$ThrowStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TryStatement', ___R$romejs$js$generator$generators$statements$TryStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSArrayType', ___R$romejs$js$generator$generators$typescript$TSArrayType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSAsExpression', ___R$romejs$js$generator$generators$typescript$TSAsExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSAssignmentAsExpression', ___R$romejs$js$generator$generators$typescript$TSAssignmentAsExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSAssignmentNonNullExpression', ___R$romejs$js$generator$generators$typescript$TSAssignmentNonNullExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSAssignmentTypeAssertion', ___R$romejs$js$generator$generators$typescript$TSAssignmentTypeAssertion_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSCallSignatureDeclaration', ___R$romejs$js$generator$generators$typescript$TSCallSignatureDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSConditionalType', ___R$romejs$js$generator$generators$typescript$TSConditionalType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSConstructorType', ___R$romejs$js$generator$generators$typescript$TSConstructorType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set(
  'TSConstructSignatureDeclaration',
  ___R$romejs$js$generator$generators$typescript$TSConstructSignatureDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSDeclareFunction', ___R$romejs$js$generator$generators$typescript$TSDeclareFunction_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSDeclareMethod', ___R$romejs$js$generator$generators$typescript$TSDeclareMethod_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSEnumDeclaration', ___R$romejs$js$generator$generators$typescript$TSEnumDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSEnumMember', ___R$romejs$js$generator$generators$typescript$TSEnumMember_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSExportAssignment', ___R$romejs$js$generator$generators$typescript$TSExportAssignment_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSExpressionWithTypeArguments', ___R$romejs$js$generator$generators$typescript$TSExpressionWithTypeArguments_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSExternalModuleReference', ___R$romejs$js$generator$generators$typescript$TSExternalModuleReference_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSFunctionType', ___R$romejs$js$generator$generators$typescript$TSFunctionType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSImportEqualsDeclaration', ___R$romejs$js$generator$generators$typescript$TSImportEqualsDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSImportType', ___R$romejs$js$generator$generators$typescript$TSImportType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSIndexedAccessType', ___R$romejs$js$generator$generators$typescript$TSIndexedAccessType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSIndexSignature', ___R$romejs$js$generator$generators$typescript$TSIndexSignature_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSInferType', ___R$romejs$js$generator$generators$typescript$TSInferType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSInterfaceBody', ___R$romejs$js$generator$generators$typescript$TSInterfaceBody_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSInterfaceDeclaration', ___R$romejs$js$generator$generators$typescript$TSInterfaceDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSMappedType', ___R$romejs$js$generator$generators$typescript$TSMappedType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSMethodSignature', ___R$romejs$js$generator$generators$typescript$TSMethodSignature_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSModuleBlock', ___R$romejs$js$generator$generators$typescript$TSModuleBlock_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSModuleDeclaration', ___R$romejs$js$generator$generators$typescript$TSModuleDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSNamespaceExportDeclaration', ___R$romejs$js$generator$generators$typescript$TSNamespaceExportDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSNonNullExpression', ___R$romejs$js$generator$generators$typescript$TSNonNullExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSOptionalType', ___R$romejs$js$generator$generators$typescript$TSOptionalType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSParenthesizedType', ___R$romejs$js$generator$generators$typescript$TSParenthesizedType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSPropertySignature', ___R$romejs$js$generator$generators$typescript$TSPropertySignature_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSQualifiedName', ___R$romejs$js$generator$generators$typescript$TSQualifiedName_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSSignatureDeclarationMeta', ___R$romejs$js$generator$generators$typescript$TSSignatureDeclarationMeta_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSThisType', ___R$romejs$js$generator$generators$typescript$TSThisType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSTupleType', ___R$romejs$js$generator$generators$typescript$TSTupleType_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSTypeAssertion', ___R$romejs$js$generator$generators$typescript$TSTypeAssertion_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSTypeLiteral', ___R$romejs$js$generator$generators$typescript$TSTypeLiteral_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSTypeOperator', ___R$romejs$js$generator$generators$typescript$TSTypeOperator_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSTypeParameter', ___R$romejs$js$generator$generators$typescript$TSTypeParameter_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSTypeParameterDeclaration', ___R$romejs$js$generator$generators$typescript$TSTypeParameterDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSTypeParameterInstantiation', ___R$romejs$js$generator$generators$typescript$TSTypeParameterInstantiation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSTypePredicate', ___R$romejs$js$generator$generators$typescript$TSTypePredicate_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSTypeQuery', ___R$romejs$js$generator$generators$typescript$TSTypeQuery_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TSTypeReference', ___R$romejs$js$generator$generators$typescript$TSTypeReference_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('TypeAliasTypeAnnotation', ___R$romejs$js$generator$generators$types$TypeAliasTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('UnaryExpression', ___R$romejs$js$generator$generators$expressions$UnaryExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set(
  'UndefinedKeywordTypeAnnotation',
  ___R$romejs$js$generator$generators$types$UndefinedKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('UnionTypeAnnotation', ___R$romejs$js$generator$generators$types$UnionTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('UnknownKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$UnknownKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('UpdateExpression', ___R$romejs$js$generator$generators$expressions$UpdateExpression_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('VariableDeclaration', ___R$romejs$js$generator$generators$auxiliary$VariableDeclaration_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('VariableDeclarationStatement', ___R$romejs$js$generator$generators$statements$VariableDeclarationStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('VariableDeclarator', ___R$romejs$js$generator$generators$auxiliary$VariableDeclarator_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('VoidKeywordTypeAnnotation', ___R$romejs$js$generator$generators$types$VoidKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('WhileStatement', ___R$romejs$js$generator$generators$statements$WhileStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('WithStatement', ___R$romejs$js$generator$generators$statements$WithStatement_ts$default);

  ___R$$priv$romejs$js$generator$generators$index_ts$generators.set('YieldExpression', ___R$romejs$js$generator$generators$expressions$YieldExpression_ts$default);

  // romejs/js-generator/Buffer.ts

  const ___R$$priv$romejs$js$generator$Buffer_ts$SPACES_RE = /^[ \t]+$/;

  class ___R$romejs$js$generator$Buffer_ts$default {
    constructor(opts, code) {
      this.originalCode = code;
      this.opts = opts;
      this.mappings = [];
      this.inputSourceMap =
      opts.inputSourceMap === undefined ? undefined : new ___R$romejs$codec$source$map$SourceMapConsumer_ts$default(opts.inputSourceMap);

      this.buf = [];
      this.last = '';
      this._queue = [];

      this.position = {
        index: ___R$romejs$ob1$index_ts$number0Neg1,
        column: ___R$romejs$ob1$index_ts$number0,
        line: ___R$romejs$ob1$index_ts$number1};

      this.sourcePosition = {
        column: undefined,
        filename: undefined,
        identifierName: undefined,
        line: undefined};
    }

    getSourceMap() {
      const {opts: opts} = this;

      const map = new ___R$romejs$codec$source$map$SourceMapGenerator_ts$default({
        file: opts.sourceMapTarget,
        sourceRoot: opts.sourceRoot});

      if (opts.sourceFileName !== undefined) {
        map.setSourceContent(opts.sourceFileName, this.originalCode);
      }

      for (const mapping of this.mappings) {
        map.addMapping(mapping);
      }

      return map.toJSON();
    }

    getMappings() {
      return this.mappings.slice();
    }

    mark(generatedLine, generatedColumn, originalLine, originalColumn, identifierName, filename = this.opts.sourceFileName) {
      if (originalLine === undefined || originalColumn === undefined) {
        return undefined;
      }

      if (this.lastGenLine === generatedLine &&
      this.lastSourceLine === originalLine &&
      this.lastSourceColumn === originalColumn) {
        return undefined;
      }

      this.lastGenLine = generatedLine;
      this.lastSourceLine = originalLine;
      this.lastSourceColumn = originalColumn;

      const name = identifierName === undefined ? undefined : identifierName;
      const source = filename;

      const {inputSourceMap: inputSourceMap} = this;
      if (inputSourceMap !== undefined) {
        const actual = inputSourceMap.exactOriginalPositionFor(
        originalLine,
        originalColumn);
        if (actual === undefined) {
          return;
        } else {
          originalLine = actual.line;
          originalColumn = actual.column;
        }
      }

      this.mappings.push({
        generated: {line: generatedLine, column: generatedColumn},
        original: {line: originalLine, column: originalColumn},
        name: name,
        source: source});
    }

    getCode() {
      this.flush();
      return this.buf.join('').trimRight();
    }

    append(str) {
      this.flush();
      const {column: column, filename: filename, identifierName: identifierName, line: line} = this.sourcePosition;
      this._append(str, line, column, identifierName, filename);
    }

    queue(str) {
      if (str === '\n') {
        while (this._queue.length > 0 && ___R$$priv$romejs$js$generator$Buffer_ts$SPACES_RE.test(this._queue[0][0])) {
          this._queue.shift();
        }
      }

      const {column: column, filename: filename, identifierName: identifierName, line: line} = this.sourcePosition;
      this._queue.unshift([str, line, column, identifierName, filename]);
    }

    flush() {
      let item;
      while (item = this._queue.pop()) {
        var ___R$;
        ___R$ = this, ___R$._append.apply(___R$, [...item]);
      }
    }

    _append(str, line, column, identifierName, filename) {
      if (str[0] !== '\n') {
        this.mark(
        this.position.line,
        this.position.column,
        line,
        column,
        identifierName,
        filename);
      }

      this.buf.push(str);
      this.last = str[str.length - 1];

      for (let i = 0; i < str.length; i++) {
        this.position.index = ___R$romejs$ob1$index_ts$inc(this.position.index);

        if (str[i] === '\n') {
          this.position.line = ___R$romejs$ob1$index_ts$inc(this.position.line);
          this.position.column = ___R$romejs$ob1$index_ts$number0;
        } else {
          this.position.column = ___R$romejs$ob1$index_ts$inc(this.position.column);
        }
      }
    }

    removeTrailingNewline() {
      if (this._queue.length > 0 && this._queue[0][0] === '\n') {
        this._queue.shift();
      }
    }

    removeLastSemicolon() {
      if (this._queue.length > 0 && this._queue[0][0] === ';') {
        this._queue.shift();
      }
    }

    endsWith(suffix) {
      if (suffix.length === 1) {
        let last;
        if (this._queue.length > 0) {
          const str = this._queue[0][0];
          last = str[str.length - 1];
        } else {
          last = this.last;
        }

        return last === suffix;
      }

      const end = this.last + this._queue.reduce((acc, item) => item[0] + acc, '');
      if (suffix.length <= end.length) {
        return end.slice(-suffix.length) === suffix;
      }

      return false;
    }

    hasContent() {
      return this._queue.length > 0 || Boolean(this.last);
    }

    source(prop, loc) {
      if (prop && !loc) {
        return undefined;
      }

      const pos = loc ? loc[prop] : undefined;

      this.sourcePosition.identifierName =
      loc && loc.identifierName || undefined;
      this.sourcePosition.line = pos ? pos.line : undefined;
      this.sourcePosition.column = pos ? pos.column : undefined;
      this.sourcePosition.filename = loc && loc.filename || undefined;
    }

    withSource(prop, loc, cb) {
      const originalLine = this.sourcePosition.line;
      const originalColumn = this.sourcePosition.column;
      const originalFilename = this.sourcePosition.filename;
      const originalIdentifierName = this.sourcePosition.identifierName;

      this.source(prop, loc);

      cb();

      this.sourcePosition.line = originalLine;
      this.sourcePosition.column = originalColumn;
      this.sourcePosition.filename = originalFilename;
      this.sourcePosition.identifierName = originalIdentifierName;
    }

    getCurrentColumn() {
      const extra = this._queue.reduce((acc, item) => item[0] + acc, '');
      const lastIndex = extra.lastIndexOf('\n');

      if (lastIndex === -1) {
        return ___R$romejs$ob1$index_ts$add(this.position.column, extra.length);
      } else {
        return ___R$romejs$ob1$index_ts$coerce0(extra.length - 1 - lastIndex);
      }
    }

    getCurrentLine() {
      const extra = this._queue.reduce((acc, item) => item[0] + acc, '');

      let count = 0;
      for (let i = 0; i < extra.length; i++) {
        if (extra[i] === '\n') {
          count++;
        }
      }

      return ___R$romejs$ob1$index_ts$add(this.position.line, count);
    }
  }

  // romejs/js-generator/Generator.ts

  ___R$romejs$js$ast$utils_ts$assertNodeTypeSet(___R$romejs$js$generator$generators$index_ts$default, 'generators');

  const ___R$$priv$romejs$js$generator$Generator_ts$SCIENTIFIC_NOTATION = /e/i;
  const ___R$$priv$romejs$js$generator$Generator_ts$ZERO_DECIMAL_INTEGER = /\.0+$/;
  const ___R$$priv$romejs$js$generator$Generator_ts$NON_DECIMAL_LITERAL = /^0[box]/;

  class ___R$romejs$js$generator$Generator_ts$default {
    constructor(opts, code) {
      this.buf = new ___R$romejs$js$generator$Buffer_ts$default(opts, code);
      this.currentIndentLevel = opts.indent === undefined ? 0 : opts.indent;

      this.options = opts;
      this.inForStatementInitCounter = 0;
      this.printedCommentStarts = new Set();
      this.printedComments = new Set();
      this.printStack = [];
      this.parenPushNewlineState = undefined;
      this.endsWithInteger = false;
      this.endsWithWord = false;
    }

    indent() {
      this.currentIndentLevel++;
    }

    dedent() {
      this.currentIndentLevel--;
    }

    semicolon(force = false) {
      this.append(';', !force);
    }

    rightBrace() {
      this.token('}');
    }

    space(force = false) {
      if (this.buf.hasContent() && !this.endsWith(' ') && !this.endsWith('\n') ||
      force) {
        this._space();
      }
    }

    word(str) {
      if (this.endsWithWord) {
        this.space();
      }

      this.append(str);

      this.endsWithWord = true;
    }

    number(str) {
      this.word(str);

      this.endsWithInteger =
      Number.isInteger(Number(str)) &&
      !___R$$priv$romejs$js$generator$Generator_ts$NON_DECIMAL_LITERAL.test(str) &&
      !___R$$priv$romejs$js$generator$Generator_ts$SCIENTIFIC_NOTATION.test(str) &&
      !___R$$priv$romejs$js$generator$Generator_ts$ZERO_DECIMAL_INTEGER.test(str) &&
      str[str.length - 1] !== '.';
    }

    token(str) {
      if (str === '--' && this.endsWith('!') ||
      str[0] === '+' && this.endsWith('+') ||
      str[0] === '-' && this.endsWith('-') ||
      str[0] === '.' && this.endsWithInteger) {
        this.space();
      }

      this.append(str);
    }

    endsWith(str) {
      return this.buf.endsWith(str);
    }

    removeTrailingNewline() {
      this.buf.removeTrailingNewline();
    }

    source(prop, loc) {
      this.buf.source(prop, loc);
    }

    _space() {
      this.append(' ', true);
    }

    newline() {
      if (this.endsWith('\n\n')) {
        return undefined;
      }

      if (this.endsWith('{\n') || this.endsWith(':\n')) {
        return undefined;
      }

      this.append('\n', true);
    }

    newlineX(num) {
      for (let i = 0; i < num && i < 2; i++) {
        this.newline();
      }
    }

    append(str, queue = false) {
      this.maybeAddParen(str);
      this.maybeIndent(str);

      if (queue) {
        this.buf.queue(str);
      } else {
        this.buf.append(str);
      }

      this.endsWithWord = false;
      this.endsWithInteger = false;
    }

    maybeIndent(str) {
      if (this.currentIndentLevel > 0 && this.endsWith('\n') && str[0] !== '\n') {
        this.buf.queue(this.getIndent());
      }
    }

    maybeAddParen(str) {
      const parenPushNewlineState = this.parenPushNewlineState;
      if (!parenPushNewlineState) {
        return undefined;
      }
      this.parenPushNewlineState = undefined;

      let i;
      for (i = 0; i < str.length && str[i] === ' '; i++) {
        continue;
      }
      if (i === str.length) {
        return undefined;
      }

      const cha = str[i];
      if (cha === '\n' || cha === '/') {
        this.token('(');
        this.indent();
        parenPushNewlineState.printed = true;
      }
    }

    getIndent() {
      return '  '.repeat(this.currentIndentLevel);
    }

    startTerminatorless() {
      return this.parenPushNewlineState = {
        printed: false};
    }

    endTerminatorless(state) {
      if (state.printed) {
        this.dedent();
        this.newline();
        this.token(')');
      }
    }

    printTypeColon(node, parent) {
      if (node !== undefined) {
        this.token(':');
        this.space();
        this.print(node, parent);
      }
    }

    print(node, parent = ___R$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT) {
      if (node === undefined) {
        return;
      }

      if (this.options.typeAnnotations === false &&
      ___R$romejs$js$ast$utils$isTypeNode_ts$default(node) &&
      !___R$romejs$js$ast$utils$isTypeExpressionWrapperNode_ts$default(node)) {
        return;
      }

      const printMethod = ___R$romejs$js$generator$generators$index_ts$default.get(
      node.type);
      if (printMethod === undefined) {
        throw new Error('No known generator for node ' + node.type + ' with parent ' + parent.type);
      }

      this.printStack.push(node);

      const needsParens = ___R$romejs$js$generator$node$index_ts.needsParens(node, parent, this.printStack);

      if (needsParens === true) {
        this.token('(');
      }

      const loc = node.type === 'Program' ? undefined : node.loc;

      const leadingComments = this.getComments(true, node);
      this.printComments(leadingComments);

      const lastComment = leadingComments && leadingComments[leadingComments.length - 1];
      this.newlineX(___R$romejs$js$generator$node$index_ts.getLinesBetween(lastComment, node) - 1);

      this.buf.withSource('start', loc, () => {
        printMethod(this, node, parent);
      });

      const trailingComments = this.getComments(false, node);
      this.newlineX(
      ___R$romejs$js$generator$node$index_ts.getLinesBetween(trailingComments && trailingComments[0], node));
      this.printComments(trailingComments);

      if (needsParens === true) {
        this.token(')');
      }

      this.printStack.pop();
    }

    getStatementList(nodes) {
      const allNodes = new Set();

      for (const node of nodes) {
        this.getStatementList_addComments(allNodes, this.getComments(true, node));

        allNodes.add(node);

        this.getStatementList_addComments(
        allNodes,
        this.getComments(false, node));
      }

      return Array.from(allNodes);
    }

    getStatementList_addComments(allNodes, comments) {
      if (!comments) {
        return;
      }

      for (const comment of comments) {
        this.printedComments.add(comment);
        allNodes.add(comment);
      }
    }

    printJoin(nodes, parent, opts = {}) {
      if (!nodes || !nodes.length) {
        return undefined;
      }

      if (opts.indent === true) {
        this.indent();
      }

      if (opts.statement === true) {
        this.newline();
      }

      let interleavedNodes = nodes;
      if (opts.statement === true) {
        interleavedNodes = this.getStatementList(nodes);
      }

      for (let i = 0; i < interleavedNodes.length; i++) {
        const node = interleavedNodes[i];
        if (!node) {
          continue;
        }

        if (node.type === 'CommentBlock' || node.type === 'CommentLine') {
          this.printComment(node);
        } else {
          this.print(node, parent);

          if (opts.iterator) {
            opts.iterator(node, i);
          }

          const isLastNode = i === nodes.length - 1;
          if (opts.separator && !isLastNode) {
            opts.separator(this);
          }
        }

        if (opts.statement === true) {
          const nextNode = interleavedNodes[i + 1];
          if (nextNode) {
            if (node.loc && nextNode.loc) {
              let linesBetween = ___R$romejs$js$generator$node$index_ts.getLinesBetween(node, nextNode);
              if (node.type === 'CommentLine') {
                linesBetween--;
              }
              this.newlineX(linesBetween);
            } else {
              this.newline();
            }
          }
        }
      }

      if (opts.indent === true) {
        this.dedent();
      }
    }

    printBlock(parent) {
      const node = parent.body;

      if (node.type !== 'EmptyStatement') {
        this.space();
      }

      this.print(node, parent);
    }

    printStatementList(nodes, parent, opts = {}) {
      return this.printJoin(nodes, parent, Object.assign({}, opts, {
        statement: true}));
    }

    printCommaList(items, parent, opts = {}) {
      if (!items || !items.length) {
        return undefined;
      }

      this.printJoin(items, parent, Object.assign({}, opts, {
        separator: opts.separator || ___R$$priv$romejs$js$generator$Generator_ts$commaSeparator}));
    }

    printInnerComments(node, indent = true) {
      if (!node.innerComments) {
        return undefined;
      }

      if (indent) {
        this.indent();
      }

      this.printComments(node.innerComments);

      if (indent) {
        this.dedent();
      }
    }

    printComments(comments) {
      if (!comments || !comments.length) {
        return undefined;
      }

      for (let i = 0; i < comments.length; i++) {
        const comment = comments[i];
        this.printComment(comment);

        const nextComment = comments[i + 1];
        if (nextComment) {
          if (comment.type === 'CommentBlock' &&
          ___R$romejs$js$generator$node$index_ts.getLinesBetween(comment, nextComment) > 0) {
            this.newline();
          }

          if (___R$romejs$js$generator$node$index_ts.hasExtraLineBetween(comment, nextComment)) {
            this.newline();
          }
        }
      }
    }

    getComments(leading, node) {
      if (!node) {
        return undefined;
      }

      const comments = leading ? node.leadingComments : node.trailingComments;
      if (!comments) {
        return undefined;
      }

      return comments.filter(comment => {
        return !this.hasPrintedComment(comment);
      });
    }

    hasPrintedComment(comment) {
      if (!comment) {
        return true;
      }

      if (this.printedComments.has(comment)) {
        return true;
      }

      if (comment.loc !== undefined &&
      this.printedCommentStarts.has(comment.loc.start.index)) {
        return true;
      }

      return false;
    }

    printComment(comment) {
      this.printedComments.add(comment);

      if (comment.loc !== undefined) {
        this.printedCommentStarts.add(comment.loc.start.index);
      }

      const isBlockComment = comment.type === 'CommentBlock';
      const val = isBlockComment ? '/*' + comment.value + '*/' : '//' + comment.value + '\n';

      if (!this.endsWith('[') && !this.endsWith('{')) {
        this.space();
      }

      if (this.endsWith('/')) {
        this.space();
      }

      this.buf.withSource('start', comment.loc, () => {
        this.append(val);
      });
    }
  }

  function ___R$$priv$romejs$js$generator$Generator_ts$commaSeparator(generator) {
    generator.token(',');
    generator.space();
  }

  // romejs/js-generator/index.ts

  class ___R$$priv$romejs$js$generator$index_ts$GeneratorPublic {
    constructor(ast, opts, code = '') {
      const generator = new ___R$romejs$js$generator$Generator_ts$default(opts, code);
      generator.print(ast);
      this.generator = generator;
    }

    getCode() {
      return this.generator.buf.getCode();
    }

    getSourceMap() {
      return this.generator.buf.getSourceMap();
    }

    getMappings() {
      return this.generator.buf.getMappings();
    }
  }

  function ___R$romejs$js$generator$index_ts$default(ast, opts, code = '') {
    return new ___R$$priv$romejs$js$generator$index_ts$GeneratorPublic(ast, opts, code);
  }

  // romejs/js-compiler/api/lint.ts


  const ___R$$priv$romejs$js$compiler$api$lint_ts$lintCache = new ___R$romejs$js$compiler$lib$Cache_ts$default();

  async function ___R$romejs$js$compiler$api$lint_ts$default(req) {
    const {ast: ast, sourceText: src, project: project} = req;

    if (!project.config.lint.enabled) {
      return {
        diagnostics: [],
        src: src,
        ast: ast};
    }

    const query = ___R$romejs$js$compiler$lib$Cache_ts$default.buildQuery(req);
    const cached = ___R$$priv$romejs$js$compiler$api$lint_ts$lintCache.get(query);
    if (cached) {
      return cached;
    }

    const context = new ___R$romejs$js$compiler$lib$Context_ts$default({
      ast: ast,
      project: project,
      origin: {
        category: 'lint'}});
    const newAst = ___R$romejs$js$ast$core$Program_ts$program.assert(context.reduce(ast, ___R$romejs$js$compiler$plugins$lint$index_ts$lintTransforms));

    let formattedCode = src;
    if (project.config.format.enabled) {
      const generated = ___R$romejs$js$generator$index_ts$default(
      newAst,
      {
        typeAnnotations: true},
      src);
      formattedCode = generated.getCode() + '\n';
    }

    const result = {
      ast: newAst,
      diagnostics: [...ast.diagnostics, ...context.diagnostics],
      src: formattedCode};
    ___R$$priv$romejs$js$compiler$api$lint_ts$lintCache.set(query, result);
    return result;
  }

  // romejs/js-compiler/plugins/compile/transpile/classProperties.ts

  function ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$hasClassProps(node) {
    for (const bodyNode of node.meta.body) {
      if (bodyNode.type === 'ClassProperty') {
        return true;
      }
    }

    return false;
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$createConstructor(rest, body) {
    return ___R$romejs$js$ast$classes$ClassMethod_ts$classMethod.create({
      kind: 'constructor',
      key: ___R$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick('constructor')),
      meta: ___R$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta.create({}),
      head: ___R$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.create({params: [], rest: rest}),
      body: ___R$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({body: body})});
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$toExpressionStatements(expressions) {
    return expressions.map(expr => {
      return ___R$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement.create({expression: expr});
    });
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$isSuperCall(node) {
    return node.type === 'CallExpression' && node.callee.type === 'Super';
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$transformClass(node, scope, context) {
    const bodyReplacements = [];
    const constructorAssignments = [];
    const className = node.id === undefined ? scope.generateUid('class') : node.id.name;

    let constructor = undefined;
    const filteredClassBody = [];
    for (const bodyNode of node.meta.body) {
      if (bodyNode.type === 'ClassMethod' && bodyNode.kind === 'constructor') {
        constructor = bodyNode;
        continue;
      }

      if (bodyNode.type === 'ClassProperty') {
        if (bodyNode.value === undefined) {
          continue;
        }

        if (bodyNode.key.type === 'ComputedPropertyKey') {
          if (bodyNode.meta.static === true) {
            bodyReplacements.push(
            ___R$romejs$js$ast$utils$template_ts$default.statement`${className}[${bodyNode.key.value}] = ${bodyNode.value};`);
          } else {
            constructorAssignments.push(
            ___R$romejs$js$ast$utils$template_ts$default.expression`this[${bodyNode.key.value}] = ${bodyNode.value};`);
          }
        } else {
          if (bodyNode.meta.static === true) {
            bodyReplacements.push(
            ___R$romejs$js$ast$utils$template_ts$default.statement`${className}.${bodyNode.key.value} = ${bodyNode.value};`);
          } else {
            constructorAssignments.push(
            ___R$romejs$js$ast$utils$template_ts$default.expression`this.${bodyNode.key.value} = ${bodyNode.value};`);
          }
        }
      } else {
        filteredClassBody.push(bodyNode);
      }
    }

    if (constructorAssignments.length) {
      if (node.meta.superClass !== undefined) {
        if (constructor) {
          const visited = new Set();

          const reducedConstructor = context.reduce(constructor, [{
            name: 'classPropertiesInjector',
            enter(path) {
              const {node: node} = path;

              if (visited.has(node)) {
                return node;
              }

              if (___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$isSuperCall(node) &&
              path.parent.type !== 'ExpressionStatement') {
                visited.add(node);

                return ___R$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.create({
                  expressions: [node, ...constructorAssignments]});
              }

              if (node.type === 'ExpressionStatement' &&
              ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$isSuperCall(node.expression)) {
                visited.add(node);

                return [node, ...___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments)];
              }

              return node;
            }}]);
          constructor = ___R$romejs$js$ast$classes$ClassMethod_ts$classMethod.assert(reducedConstructor);
        } else {
          constructor = ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$createConstructor(___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick('args'), [___R$romejs$js$ast$utils$template_ts$default.statement`super(...args);`, ...___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments)]);
        }
      } else {
        if (constructor) {
          constructor = Object.assign({}, constructor, {
            body: Object.assign({}, constructor.body, {
              body: [...___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments), ...constructor.body.body]})});
        } else {
          constructor = ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$createConstructor(
          undefined,
          ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$toExpressionStatements(constructorAssignments));
        }
      }
    }

    if (constructor !== undefined) {
      filteredClassBody.unshift(constructor);
    }

    const newClass = Object.assign({}, node, {
      id: node.id !== undefined && node.id.name === className ? node.id : ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
        name: className}),
      meta: Object.assign({}, node.meta, {
        body: filteredClassBody})});

    return {
      newClass: newClass,
      className: className,
      declarations: bodyReplacements};
  }
  const ___R$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$default = {
    name: 'classProperties',
    enter(path) {
      const {node: node, scope: scope, context: context} = path;

      if ((node.type === 'ExportNamedDeclaration' ||
      node.type === 'ExportDefaultDeclaration') &&
      node.declaration !== undefined &&
      node.declaration.type === 'ClassDeclaration' &&
      ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$hasClassProps(node.declaration)) {
        const {newClass: newClass, declarations: declarations} = ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$transformClass(
        node.declaration,
        scope,
        context);
        return [Object.assign({}, node, {
          declaration: newClass}), ...declarations];
      }

      if (node.type === 'ClassExpression' && ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$hasClassProps(node)) {
        const className = node.id === undefined ? scope.generateUid('class') : node.id.name;

        return ___R$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
          callee: ___R$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression.create({
            head: ___R$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.quick([]),
            body: ___R$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({
              body: [Object.assign({}, node, {
                type: 'ClassDeclaration',
                id: ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(className)}), ___R$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.create({
                argument: ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(className)})]})}),
          arguments: []});
      }

      if (node.type === 'ClassDeclaration' && ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$hasClassProps(node)) {
        const {newClass: newClass, declarations: declarations} = ___R$$priv$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$transformClass(node, scope, context);
        return [newClass, ...declarations];
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compile/transpile/paramlessCatch.ts

  const ___R$romejs$js$compiler$plugins$compile$transpile$paramlessCatch_ts$default = {
    name: 'paramlessCatch',

    enter(path) {
      const {node: node} = path;

      if (node.type === 'CatchClause' && node.param === undefined) {
        return Object.assign({}, node, {
          param: ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
            name: path.scope.generateUid()})});
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compile/transpile/optionalChaining.ts

  const ___R$romejs$js$compiler$plugins$compile$transpile$optionalChaining_ts$default = {
    name: 'optionalChaining',

    enter(path) {
      const {node: node} = path;

      if (node.type === 'MemberExpression' && node.property.optional) {
        if (node.property.type === 'ComputedMemberProperty') {
          return ___R$romejs$js$ast$utils$template_ts$default.expression`${node.object} == null ? undefined : ${node.object}[${node.property.value}]`;
        } else {
          return ___R$romejs$js$ast$utils$template_ts$default.expression`${node.object} == null ? undefined : ${node.object}.${node.property.value}`;
        }
      }

      if (node.type === 'OptionalCallExpression') {
        return ___R$romejs$js$ast$utils$template_ts$default.expression`${node.callee} == null ? undefined : ${___R$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
          callee: node.callee,
          arguments: node.arguments})}`;
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compile/transpile/nullishCoalescing.ts

  const ___R$romejs$js$compiler$plugins$compile$transpile$nullishCoalescing_ts$default = {
    name: 'nullishCoalescing',

    enter(path) {
      const {node: node} = path;

      if (node.type === 'LogicalExpression' && node.operator === '??') {
        return ___R$romejs$js$ast$utils$template_ts$default.expression`${node.left} == null ? ${node.right} : ${node.left}`;
      }

      return node;
    }};

  // romejs/js-compiler/plugins/defaultHooks/index.ts


  const ___R$romejs$js$compiler$plugins$defaultHooks$index_ts$bindingInjector = ___R$romejs$js$compiler$api$createHook_ts$default(
  {
    name: 'bindingInjectorHook',

    initialState: {
      bindings: []},

    call(path, state, opts = {}) {
      const name = opts.name === undefined ? path.scope.generateUid() : opts.name;

      const ref = ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(name);

      const ass = ___R$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.quick(name);

      return {
        value: [ref, ass],
        state: {
          bindings: [...state.bindings, [name, opts.init]]}};
    },

    exit(path, state) {
      const {node: node} = path;

      if (node.type !== 'BlockStatement' && node.type !== 'Program') {
        throw new Error('Never should have been used as a provider');
      }

      const {bindings: bindings} = state;
      if (bindings.length === 0) {
        return node;
      }

      return Object.assign({}, node, {
        body: [___R$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
        ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
          kind: 'var',
          declarations: bindings.map(([name, init]) => {
            return ___R$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
              id: ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(name),
              init: init});
          })})), ...node.body]});
    }});

  const ___R$romejs$js$compiler$plugins$defaultHooks$index_ts$variableInjectorVisitor = {
    name: 'variableInjector',
    enter(path) {
      const {node: node} = path;

      if (node.type === 'BlockStatement' || node.type === 'Program') {
        path.provideHook(___R$romejs$js$compiler$plugins$defaultHooks$index_ts$bindingInjector);
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compile/transpile/callSpread.ts

  const ___R$romejs$js$compiler$plugins$compile$transpile$callSpread_ts$default = {
    name: 'callSpread',

    enter(path) {
      const {node: node} = path;

      if (node.type === 'CallExpression') {
        let func = node.callee;

        if (func.type === 'Super') {
          return node;
        }

        let hasSpread = false;
        for (const arg of node.arguments) {
          if (arg.type === 'SpreadElement') {
            hasSpread = true;
            break;
          }
        }
        if (hasSpread) {
          let prepend;

          let object;
          if (func.type === 'MemberExpression') {
            const injection = path.callHook(___R$romejs$js$compiler$plugins$defaultHooks$index_ts$bindingInjector, {});
            object = injection[0];

            prepend = ___R$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.create({
              operator: '=',
              left: injection[1],
              right: func.object});

            func = ___R$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.create({
              object: object,
              property: func.property});
          } else {
            object = ___R$romejs$js$ast$literals$NullLiteral_ts$nullLiteral.create({});
          }

          let call = {
            type: 'CallExpression',
            loc: node.loc,
            callee: ___R$romejs$js$ast$utils$template_ts$default.expression`${func}.apply`,
            arguments: [object, ___R$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression.create({elements: node.arguments})]};

          if (prepend === undefined) {
            return call;
          } else {
            return ___R$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.create({
              expressions: [prepend, call]});
          }
        }
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compile/transpile/templateLiterals.ts

  const ___R$romejs$js$compiler$plugins$compile$transpile$templateLiterals_ts$default = {
    name: 'templateLiterals',
    enter(path) {
      const {node: node, parent: parent} = path;

      if (node.type === 'TaggedTemplateExpression') {}

      if (node.type === 'TemplateLiteral' &&
      parent.type !== 'TaggedTemplateExpression') {
        const nodes = [];
        const {expressions: expressions, quasis: quasis} = node;

        let index = 0;
        for (const elem of quasis) {
          if (elem.cooked) {
            nodes.push(
            ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
              value: elem.cooked}));
          }

          if (index < expressions.length) {
            const expr = expressions[index++];
            if (expr.type !== 'StringLiteral' || expr.value !== '') {
              nodes.push(expr);
            }
          }
        }

        if (nodes.length === 1) {
          return nodes[0];
        }

        if (nodes[0].type !== 'StringLiteral' &&
        nodes[1].type !== 'StringLiteral') {
          nodes.unshift(___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(''));
        }

        let root = nodes[0];
        for (let i = 1; i < nodes.length; i++) {
          root = ___R$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression.create({
            operator: '+',
            left: root,
            right: nodes[i]});
        }
        return root;
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compile/transpile/objectSpread.ts

  function ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$hasSpreadProperty(props) {
    for (const prop of props) {
      if (prop.type === 'SpreadProperty') {
        return true;
      }
    }
    return false;
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$getRestProperty(node) {
    if (node === undefined) {
      return undefined;
    }

    switch (node.type) {
      case 'VariableDeclarator':
        return ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$getRestProperty(node.id);

      case 'VariableDeclarationStatement':
        return ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$getRestProperty(node.declaration);

      case 'VariableDeclaration':
        for (const declarator of node.declarations) {
          const rest = ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$getRestProperty(declarator);
          if (rest !== undefined) {
            return rest;
          }
        }
        return undefined;

      case 'BindingObjectPattern':
        return node.rest;}
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$transformSpreadProperty(path, node) {
    let props = [];
    const assignArgs = [];

    function pushProps() {
      if (props.length === 0 && assignArgs.length > 0) {
        return undefined;
      }

      assignArgs.push(___R$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({properties: props}));

      props = [];
    }

    for (const prop of node.properties) {
      if (prop.type === 'SpreadProperty') {
        pushProps();
        assignArgs.push(prop.argument);
      } else {
        props.push(prop);
      }
    }

    pushProps();

    return ___R$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
      callee: ___R$romejs$js$ast$utils$template_ts$default.expression`Object.assign`,
      arguments: assignArgs});
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$transformRestProperty(path, node) {
    const nodes = [];

    for (const declarator of node.declarations) {
      const restElem = ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$getRestProperty(declarator);

      if (restElem === undefined ||
      declarator.id.type !== 'BindingObjectPattern') {
        nodes.push(
        ___R$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
        ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
          kind: node.kind,
          declarations: [declarator]})));
        continue;
      }

      const uid = path.scope.generateUid();

      nodes.push(
      ___R$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
      ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
        kind: node.kind,
        declarations: [___R$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
          id: ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
            name: uid}),
          init: declarator.init})]})));

      const removeProps = [];
      for (const prop of declarator.id.properties) {
        if (prop.type === 'BindingObjectPatternProperty') {
          if (prop.key.type === 'ComputedPropertyKey' ||
          prop.key.value.type !== 'Identifier') {
            throw new Error('unimplemented');
          } else {
            removeProps.push(prop.key.value.name);
          }
        }
      }

      const restName = restElem.name;
      nodes.push(
      ___R$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
      ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
        kind: node.kind,
        declarations: [___R$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
          id: ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(restName),
          init: ___R$romejs$js$ast$utils$template_ts$default.expression`Object.assign({}, ${uid})`})]})));

      for (const name of removeProps) {
        nodes.push(___R$romejs$js$ast$utils$template_ts$default.statement`delete ${restName}.${name};`);
      }

      nodes.push(
      ___R$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
      ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
        kind: node.kind,
        declarations: [___R$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
          id: ___R$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern.create({
            properties: declarator.id.properties,
            rest: undefined}),
          init: ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(uid)})]})));
    }

    return nodes;
  }
  const ___R$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$default = {
    name: 'objectSpread',
    enter(path) {
      const {node: node} = path;

      if (node.type === 'VariableDeclarationStatement' &&
      ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$getRestProperty(node) !== undefined) {
        return ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$transformRestProperty(path, node.declaration);
      }

      if (node.type === 'ObjectExpression' &&
      ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$hasSpreadProperty(node.properties)) {
        return ___R$$priv$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$transformSpreadProperty(path, node);
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compile/validation/optimizeImports.ts

  const ___R$$priv$romejs$js$compiler$plugins$compile$validation$optimizeImports_ts$BLACKLIST = ['React', 'react'];

  function ___R$$priv$romejs$js$compiler$plugins$compile$validation$optimizeImports_ts$getName(node) {
    if (node.type !== 'MemberExpression' && node.type !== 'JSXMemberExpression') {
      return;
    }

    const {property: property} = node;

    if (property.type === 'ComputedMemberProperty') {
      if (property.value.type === 'StringLiteral') {
        return property.value.value;
      }
    } else {
      if (___R$romejs$js$ast$utils$isIdentifierish_ts$default(property)) {
        return property.name;
      }
    }
  }
  const ___R$romejs$js$compiler$plugins$compile$validation$optimizeImports_ts$default = {
    name: 'optimizeImports',
    enter(path) {
      const {node: node} = path;

      if (node.type !== 'Program') {
        return node;
      }

      const wildcardImports = new Map();
      const wildcardImportNodeToLocal = new Map();
      for (const child of node.body) {
        if (child.type === 'ImportDeclaration' &&
        !___R$$priv$romejs$js$compiler$plugins$compile$validation$optimizeImports_ts$BLACKLIST.includes(child.source.value) &&
        child.specifiers !== undefined) {
          for (const specifier of child.specifiers) {
            if (specifier.type === 'ImportNamespaceSpecifier') {
              wildcardImports.set(specifier.local.name.name, {
                binding: path.scope.getBindingAssert(specifier.local.name.name),
                names: new Set(),
                mappings: new Map(),
                references: new Set()});
              wildcardImportNodeToLocal.set(child, specifier.local.name.name);
            }
          }
        }
      }
      if (wildcardImports.size === 0) {
        return node;
      }

      path.traverse('optimizeImportsWildcardCollector', path => {
        const {node: node, parent: parent} = path;
        if (node.type !== 'ReferenceIdentifier') {
          return;
        }

        const wildcardInfo = wildcardImports.get(node.name);
        if (wildcardInfo === undefined) {
          return;
        }

        if (path.scope.getBinding(node.name) !== wildcardInfo.binding) {
          return;
        }

        const isComputed = parent.type === 'MemberExpression' &&
        parent.object === node &&
        ___R$$priv$romejs$js$compiler$plugins$compile$validation$optimizeImports_ts$getName(parent) === undefined;
        const isUnboxed = parent.type !== 'MemberExpression' &&
        parent.type !== 'JSXMemberExpression';

        if (isComputed || isUnboxed) {
          wildcardImports.delete(node.name);
        } else {
          const name = ___R$$priv$romejs$js$compiler$plugins$compile$validation$optimizeImports_ts$getName(parent);
          if (name === undefined) {
            throw new Error('Expected name');
          }
          wildcardInfo.names.add(name);
          wildcardInfo.references.add(parent);
        }
      });
      if (wildcardImports.size === 0) {
        return node;
      }

      for (const info of wildcardImports.values()) {
        for (const name of info.names) {
          info.mappings.set(name, path.scope.generateUid(name));
        }
      }

      return path.reduce({
        name: 'optimizeImportWilcards',
        enter(path) {
          const {node: node} = path;

          if ((node.type === 'MemberExpression' ||
          node.type === 'JSXMemberExpression') &&
          ___R$romejs$js$ast$utils$isIdentifierish_ts$default(node.object)) {
            const wildcardInfo = wildcardImports.get(node.object.name);
            if (wildcardInfo !== undefined && wildcardInfo.references.has(node)) {
              const name = ___R$$priv$romejs$js$compiler$plugins$compile$validation$optimizeImports_ts$getName(node);
              if (name === undefined) {
                throw new Error('Expected name');
              }

              const newName = wildcardInfo.mappings.get(name);
              if (newName === undefined) {
                throw new Error('Expected newName');
              }

              if (node.type === 'JSXMemberExpression') {
                return ___R$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.quick(newName);
              } else {
                return ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(newName);
              }
            }
          }

          if (node.type === 'ImportDeclaration' &&
          wildcardImportNodeToLocal.has(node)) {
            const local = wildcardImportNodeToLocal.get(node);
            if (local === undefined) {
              throw new Error('Expected local');
            }

            const wildcardInfo = wildcardImports.get(local);
            if (wildcardInfo === undefined) {
              return node;
            }

            let specifiers = [];
            if (node.specifiers !== undefined) {
              specifiers = node.specifiers.filter(
              specifier => {
                if (specifier.type === 'ImportNamespaceSpecifier' &&
                specifier.local.name.name === local) {
                  return false;
                } else {
                  return true;
                }
              });
            }

            for (const [imported, local] of wildcardInfo.mappings) {
              specifiers.push(
              ___R$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier.create({
                imported: ___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(imported),
                local: ___R$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal.quick(
                ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(local))}));
            }

            return ___R$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration.create({specifiers: specifiers, source: node.source});
          }

          return node;
        }});
    }};

  // romejs/js-compiler/plugins/compile/validation/optimizeExports.ts

  const ___R$romejs$js$compiler$plugins$compile$validation$optimizeExports_ts$default = {
    name: 'optimizeExports',
    enter(path) {
      const {node: node} = path;

      if (node.type === 'ExportNamedDeclaration' &&
      node.exportKind === 'value' &&
      node.source === undefined &&
      node.declaration === undefined &&
      node.specifiers !== undefined) {
        const nodes = [];
        const specifiers = [];

        for (const specifier of node.specifiers) {
          if (specifier.type === 'ExportSpecifier') {
            const binding = path.scope.getBinding(specifier.local.name);
            if (binding !== undefined &&
            binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$ImportBinding &&
            binding.meta.type === 'name') {
              nodes.push(
              ___R$romejs$js$ast$modules$ExportNamedDeclaration_ts$exportNamedDeclaration.create({
                specifiers: [___R$romejs$js$ast$modules$ExportSpecifier_ts$exportSpecifier.create({
                  local: ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(binding.meta.imported),
                  exported: specifier.exported,
                  loc: specifier.loc})],
                source: ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(binding.meta.source)}));
            } else {
              specifiers.push(specifier);
            }
          } else {
            specifiers.push(specifier);
          }
        }

        if (specifiers.length === node.specifiers.length && nodes.length === 0) {
          return node;
        }

        if (specifiers.length !== 0) {
          nodes.push(___R$romejs$js$ast$modules$ExportNamedDeclaration_ts$exportNamedDeclaration.create({specifiers: specifiers}));
        }

        return nodes;
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compile/jsx.ts

  function ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$isCompatTag(tagName) {
    return tagName !== undefined ? /^[a-z]|-/.test(tagName) : false;
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$convertJSXIdentifier(path) {
    const {node: node} = path;

    if (node.type === 'JSXReferenceIdentifier') {
      if (node.name === 'this') {
        return ___R$romejs$js$ast$expressions$ThisExpression_ts$thisExpression.create({});
      } else if (___R$romejs$js$ast$utils$isValidIdentifierName_ts$default(node.name)) {
        return ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create(
        {
          name: node.name},
        node);
      } else {
        return ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(node.name);
      }
    } else if (node.type === 'JSXMemberExpression') {
      let prop = ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$convertJSXIdentifier(path.getChildPath('property'));

      if (prop.type === 'ReferenceIdentifier') {
        return ___R$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.create({
          object: ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$convertJSXIdentifier(path.getChildPath('object')),
          property: ___R$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty.quick(___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(prop.name))});
      } else {
        return ___R$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.create({
          object: ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$convertJSXIdentifier(path.getChildPath('object')),
          property: ___R$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty.quick(prop)});
      }
    } else {
      throw new Error('Received a node of type ' + node.type + ', the only node types that should be in this position are JSXIdentifier and JSXMemberExpression');
    }
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$convertAttributeValue(node) {
    if (node.type === 'JSXExpressionContainer') {
      return node.expression;
    } else {
      return node;
    }
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$extractName(node) {
    if (node.type === 'JSXNamespacedName') {
      throw new Error('JSX is not XML blah blah blah');
    } else {
      return ___R$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.assert(node).name;
    }
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$convertAttribute(node) {
    let valueNode = ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$convertAttributeValue(
    node.value || ___R$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral.create({value: true}));
    if (valueNode.type === 'StringLiteral' &&
    (!node.value || node.value.type !== 'JSXExpressionContainer')) {
      valueNode = ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
        value: valueNode.value.replace(/\n\s+/g, ' ')});
    }

    const name = ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$extractName(node.name);

    if (___R$romejs$js$ast$utils$isValidIdentifierName_ts$default(name)) {
      const nameNode = ___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.create({
        name: name,
        loc: ___R$romejs$js$ast$utils$inheritLoc_ts$default(node)});

      return ___R$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.create({
        key: ___R$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(nameNode),
        value: valueNode});
    } else {
      return ___R$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.create({
        key: ___R$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey.quick(___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(name)),
        value: valueNode});
    }
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$pushProps(_props, objs) {
    if (!_props.length) {
      return _props;
    }

    objs.push(___R$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({properties: _props}));
    return [];
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$buildOpeningElementAttributes(attribs) {
    let _props = [];
    const objs = [];

    while (attribs.length > 0) {
      const prop = attribs.shift();
      if (prop === undefined) {
        throw new Error('Already validated length');
      }

      if (prop.type === 'JSXSpreadAttribute') {
        _props = ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$pushProps(_props, objs);
        objs.push(prop.argument);
      } else {
        _props.push(___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$convertAttribute(prop));
      }
    }

    ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$pushProps(_props, objs);

    let ret;
    if (objs.length === 1) {
      ret = objs[0];
    } else {
      if (objs[0].type !== 'ObjectExpression') {
        objs.unshift(___R$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({properties: []}));
      }

      ret = ___R$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
        callee: ___R$romejs$js$ast$utils$template_ts$default.expression`Object.assign`,
        arguments: objs});
    }

    return ret;
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$cleanJSXElementLiteralChild(value) {
    const lines = value.split(/\r\n|\n|\r/);

    let lastNonEmptyLine = 0;

    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }

    let str = '';

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;

      let trimmedLine = line.replace(/\t/g, ' ');

      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, '');
      }

      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, '');
      }

      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += ' ';
        }

        str += trimmedLine;
      }
    }

    if (str != '') {
      return ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(str);
    }
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$buildChildren(children) {
    const elems = [];

    for (let child of children) {
      if (child.type === 'JSXText') {
        const node = ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$cleanJSXElementLiteralChild(child.value);
        if (node !== undefined) {
          elems.push(node);
        }
        continue;
      }

      if (child.type === 'JSXExpressionContainer') {
        const {expression: expression} = child;
        if (expression.type !== 'JSXEmptyExpression') {
          elems.push(child.expression);
        }
        continue;
      }

      if (child.type === 'JSXSpreadChild') {
        elems.push(___R$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement.quick(child.expression));
        continue;
      }

      elems.push(child);
    }

    return elems;
  }

  function ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$shouldIgnoreFbt(path, node) {
    const {name: name} = node;
    if (name.type === 'JSXNamespacedName' && name.namespace.name === 'fbt') {
      return true;
    }

    if (name.type === 'JSXReferenceIdentifier' && name.name === 'fbt') {
      return true;
    }

    const fbtAncestor = path.findAncestry(path => {
      const {node: node} = path;
      return ___R$romejs$js$ast$jsx$JSXElement_ts$jsxElement.is(node) && ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$shouldIgnoreFbt(path, node);
    });
    return fbtAncestor !== undefined;
  }
  const ___R$romejs$js$compiler$plugins$compile$jsx_ts$default = {
    name: 'jsx',
    enter(path) {
      const {node: node, context: context, parent: parent, scope: scope} = path;

      if (___R$romejs$js$ast$jsx$JSXElement_ts$jsxElement.is(node) &&
      ___R$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName.is(node.name) &&
      !scope.hasBinding('React')) {
        path.callHook(___R$romejs$js$compiler$plugins$defaultHooks$index_ts$bindingInjector, {
          name: 'React',
          init: ___R$romejs$js$ast$utils$template_ts$default.expression`require('React')`});
      }

      if (___R$romejs$js$ast$jsx$JSXElement_ts$jsxElement.is(node) && !___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$shouldIgnoreFbt(path, node)) {
        let type = ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$convertJSXIdentifier(path.getChildPath('name'));

        if (___R$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName.is(node.name)) {
          context.addNodeDiagnostic(type, {
            category: 'compile/jsx',
            message: 'JSX is not XML'});
        }

        if (type.type === 'ReferenceIdentifier' && ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$isCompatTag(type.name)) {
          type = ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(type.name);
        }

        let attribs;
        if (node.attributes.length > 0) {
          attribs = ___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$buildOpeningElementAttributes(node.attributes);
        } else {
          attribs = ___R$romejs$js$ast$literals$NullLiteral_ts$nullLiteral.create({});
        }

        const call = ___R$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
          callee: ___R$romejs$js$ast$utils$template_ts$default.expression`React.createElement`,
          arguments: [type, attribs, ...___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$buildChildren(node.children)]});

        if (___R$romejs$js$ast$jsx$JSXElement_ts$jsxElement.is(parent)) {
          return ___R$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.create({
            expression: call});
        } else {
          return call;
        }
      }

      if (node.type === 'JSXFragment') {
        const type = ___R$romejs$js$ast$utils$template_ts$default.expression`React.Fragment`;
        const attribs = ___R$romejs$js$ast$utils$template_ts$default.expression`null`;
        return ___R$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
          callee: ___R$romejs$js$ast$utils$template_ts$default.expression`React.createElement`,
          arguments: [type, attribs, ...___R$$priv$romejs$js$compiler$plugins$compile$jsx_ts$buildChildren(node.children)]});
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compileForBundle/_utils.ts

  function ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getOptions(context) {
    const opts = context.options.bundle;
    if (opts === undefined) {
      throw new Error('No bundle options found');
    }
    return opts;
  }

  function ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrivateName(name, moduleId) {
    return ___R$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX + '$priv$' + ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$normalizeModuleId(moduleId) + '$' + name;
  }

  function ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$normalizeModuleId(id) {
    return id.replace(/[\\\/\@\-]/g, '$').replace(/[-\.]/g, '_');
  }

  function ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName(name, moduleId, opts) {
    const forwarded = opts.resolvedImports[moduleId + ':' + name];
    if (forwarded !== undefined) {
      moduleId = forwarded.id;
      name = forwarded.name;
    }

    return ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$normalizeModuleId(moduleId)) + '$' + name;
  }

  function ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId) {
    return '' + ___R$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX + ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$normalizeModuleId(moduleId);
  }

  function ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getModuleId(source, opts) {
    return opts.relativeSourcesToModuleId[source];
  }

  // romejs/js-analysis/Graph.ts


  class ___R$romejs$js$analysis$Graph_ts$default {
    constructor() {
      this.nodes = [];
      this.nodesByValue = new Map();
    }

    addNode(value) {
      if (this.find(value)) {
        return undefined;
      }

      const node = {lines: [], value: value};
      this.nodesByValue.set(value, node);
      this.nodes.push(node);
    }

    find(value) {
      return this.nodesByValue.get(value);
    }

    hasConnections(value) {
      const node = this.nodesByValue.get(value);
      return node !== undefined && node.lines.length > 0;
    }

    addLine(startValue, endValue) {
      const startNode = this.find(startValue);
      const endNode = this.find(endValue);

      if (!startNode || !endNode) {
        throw new Error('Both nodes need to exist');
      }

      startNode.lines.push(endNode);
    }
  }

  // romejs/js-analysis/types/T.ts

  let ___R$$priv$romejs$js$analysis$types$T_ts$counter = 0;

  class ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode) {
      this.human = undefined;
      this.scope = scope;

      const {hub: hub} = scope;
      this.hub = hub;
      this.utils = hub.utils;
      this.evaluator = hub.evaluator;
      this.originEvaluator = scope.evaluator.evaluatingType;

      this.graph = scope.evaluator.graph;
      this.graph.addNode(this);

      this.originNode = originNode;
      this.originLoc = originNode === undefined ? undefined : originNode.loc;
      this.id = String(process.pid) + ':' + String(___R$$priv$romejs$js$analysis$types$T_ts$counter++);

      this.compatibilityCache = new Map();
    }

    getConstructor() {
      return this.constructor;
    }

    setHuman(human) {
      this.human = human;
    }

    shouldMatch(type) {
      this.hub.assertOpen();
      this.graph.addLine(this, type);
    }

    hasConnections() {
      return this.graph.hasConnections(this);
    }

    explodeUnion() {
      return [this];
    }

    compatibleWith(otherType) {
      return otherType instanceof this.constructor;
    }

    clone() {
      const idsToType = new Map();

      const addType = type => {
        const reduced = this.utils.reduce(type);
        idsToType.set(type.id, type);
        return reduced.id;
      };

      const data = this.serialize(addType);

      const getType = id => {
        if (typeof id !== 'string') {
          throw new Error('Expected id to be a string');
        }

        const type = idsToType.get(id);
        if (type === undefined) {
          throw new Error('Expected type');
        }
        return type;
      };

      return this.getConstructor().hydrate(
      this.scope,
      this.originNode,
      data,
      getType);
    }

    static hydrate(scope, originNode, data, getType) {
      throw new Error('Unimplemented ' + this.type + '.hydrate');
    }

    serialize(addType) {
      throw new Error('Unimplemented ' + this.getConstructor().type + '.prototype.serialize');
    }

    reduce() {
      return this;
    }

    humanize(builder) {
      const reduced = this.utils.reduce(this);
      if (reduced === this) {
        throw new Error('unimplemented');
      } else {
        return builder.humanize(reduced);
      }
    }

    inspect() {
      return this.utils.inspect(this);
    }
  }
  ___R$romejs$js$analysis$types$T_ts$default.type = 'T';

  // romejs/js-analysis/types/UnknownT.ts

  class ___R$romejs$js$analysis$types$UnknownT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$romejs$js$analysis$types$UnknownT_ts$default(scope, originNode);
    }

    humanize() {
      return 'unknown';
    }

    compatibleWith() {
      return false;
    }
  }
  ___R$romejs$js$analysis$types$UnknownT_ts$default.type = 'UnknownT';

  // romejs/js-analysis/types/OpenT.ts

  class ___R$romejs$js$analysis$types$OpenT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    humanize(builder) {
      const type = this.utils.reduce(this);
      if (type === this) {
        return 'open';
      } else {
        return builder.humanize(type);
      }
    }

    reduce() {
      const node = this.graph.find(this);
      if (node === undefined) {
        return new ___R$romejs$js$analysis$types$UnknownT_ts$default(this.scope, this.originNode);
      }

      const values = node.lines.map(line => this.utils.reduce(line.value));
      return this.scope.createUnion(values, this.originNode);
    }
  }
  ___R$romejs$js$analysis$types$OpenT_ts$default.type = 'OpenT';

  // romejs/js-analysis/types/OpenIntrinsicT.ts

  class ___R$romejs$js$analysis$types$OpenIntrinsicT_ts$default extends ___R$romejs$js$analysis$types$OpenT_ts$default {
    constructor(scope, originNode, name) {
      super(scope, originNode);
      this.name = name;
    }

    serialize() {
      return {
        name: this.name};
    }

    static hydrate(scope, originNode, data) {
      return scope.intrinsics.get(String(data.name));
    }

    humanize() {
      return 'open intrinsic';
    }
  }
  ___R$romejs$js$analysis$types$OpenIntrinsicT_ts$default.type = 'OpenIntrinsicT';

  // romejs/js-analysis/Intrinsics.ts

  class ___R$romejs$js$analysis$Intrinsics_ts$default {
    constructor(scope) {
      this.scope = scope;

      this.intrinsicByName = new Map();

      this.NumberPrototype = this.createOpenT('NumberPrototype');
      this.Number = this.createOpenT('Number');

      this.StringPrototype = this.createOpenT('StringPrototype');
      this.String = this.createOpenT('String');

      this.ObjectPrototype = this.createOpenT('ObjectPrototype');
      this.Object = this.createOpenT('Object');

      this.ArrayPrototype = this.createOpenT('ArrayPrototype');
      this.Array = this.createOpenT('Array');

      this.RegExpPrototype = this.createOpenT('RegExpPrototype');
      this.RegExp = this.createOpenT('RegExp');
    }

    get(name) {
      const t = this.intrinsicByName.get(name);
      if (t === undefined) {
        throw new Error('No intrinsic found for ' + name);
      }
      return t;
    }

    createOpenT(name) {
      const t = new ___R$romejs$js$analysis$types$OpenIntrinsicT_ts$default(this.scope, undefined, name);
      this.intrinsicByName.set(name, t);
      return t;
    }

    link() {
      this.String.shouldMatch(this.scope.query(['String']));
      this.StringPrototype.shouldMatch(this.scope.query(['String', 'prototype']));

      this.Object.shouldMatch(this.scope.query(['Object']));
      this.ObjectPrototype.shouldMatch(this.scope.query(['Object', 'prototype']));

      this.Array.shouldMatch(this.scope.query(['Array']));
      this.ArrayPrototype.shouldMatch(this.scope.query(['Array', 'prototype']));

      this.RegExp.shouldMatch(this.scope.query(['RegExp']));
      this.RegExpPrototype.shouldMatch(this.scope.query(['RegExp', 'prototype']));

      this.Number.shouldMatch(this.scope.query(['Number']));
      this.NumberPrototype.shouldMatch(this.scope.query(['Number', 'prototype']));
    }
  }

  // romejs/js-analysis/types/ObjPropT.ts

  class ___R$romejs$js$analysis$types$ObjPropT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, key, value) {
      super(scope, originNode);
      this.key = key;
      this.value = value;
    }

    serialize(addType) {
      return {
        key: this.key,
        value: addType(this.value)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$ObjPropT_ts$default(scope, originNode, String(data.key), getType(data.value));
    }

    compatibleWith(otherType) {
      if (otherType instanceof ___R$romejs$js$analysis$types$ObjPropT_ts$default && otherType.key === this.key) {
        return this.utils.checkCompability(this.value, otherType.value);
      } else {
        return false;
      }
    }

    humanize(builder) {
      return this.key + ': ' + builder.humanize(this.value);
    }
  }
  ___R$romejs$js$analysis$types$ObjPropT_ts$default.type = 'ObjPropT';

  // romejs/js-analysis/types/ObjT.ts

  class ___R$romejs$js$analysis$types$ObjT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.calls = opts.calls === undefined ? [] : opts.calls;
      this.props = opts.props === undefined ? [] : opts.props;
      this.proto = opts.proto;
    }

    serialize(addType) {
      if (this.constructor !== ___R$romejs$js$analysis$types$ObjT_ts$default) {
        throw new Error('Expected ObjT to be constructor, youve likely forgot to define this method in the type subclass');
      }

      return {
        calls: this.calls.map(type => addType(type)),
        proto: this.proto === undefined ? undefined : addType(this.proto),
        props: this.props.map(type => addType(type))};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$ObjT_ts$default(scope, originNode, {
        props: Array(data.props).map(id => getType(id)),
        proto: data.proto === undefined ? undefined : getType(data.proto),
        calls: Array(data.calls).map(id => getType(id))});
    }

    compatibleWith(otherType) {
      if (!(otherType instanceof ___R$romejs$js$analysis$types$ObjT_ts$default)) {
        return false;
      }

      const ourProps = this.props;
      const theirProps = otherType.props;

      for (const ourPropRaw of ourProps) {
        const ourProp = this.utils.reduce(ourPropRaw);
        let key;
        if (ourProp instanceof ___R$romejs$js$analysis$types$ObjPropT_ts$default) {
          key = ourProp.key;
        } else {
          continue;
        }

        let theirProp;
        for (const theirPropRaw of theirProps) {
          const maybeTheirProp = this.utils.reduce(theirPropRaw);
          if (maybeTheirProp instanceof ___R$romejs$js$analysis$types$ObjPropT_ts$default && maybeTheirProp.key === key) {
            theirProp = maybeTheirProp;
            break;
          }
        }

        if (!ourProp || !theirProp) {
          return false;
        }

        const compatibility = this.utils.checkCompability(ourProp, theirProp);
        if (compatibility.type === 'incompatible') {
          return compatibility;
        }
      }

      return true;
    }

    humanize(builder) {
      if (this.props.length === 0) {
        return '{}';
      } else {
        return ['{', ...this.props.map(prop => {
          const val = builder.humanize(prop);
          let lines = val.split('\n');
          lines = lines.map(line => '  ' + line);
          return lines.join('\n') + ',';
        }), '}'].join('\n');
      }
    }
  }
  ___R$romejs$js$analysis$types$ObjT_ts$default.type = 'ObjT';

  // romejs/js-analysis/types/StringLiteralT.ts

  class ___R$romejs$js$analysis$types$StringLiteralT_ts$default extends ___R$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode, value) {
      super(scope, originNode, {
        props: [],
        proto: scope.intrinsics.StringPrototype,
        calls: []});
      this.value = value;
    }

    serialize() {
      return {value: this.value};
    }

    static hydrate(scope, originNode, data) {
      return new ___R$romejs$js$analysis$types$StringLiteralT_ts$default(scope, originNode, String(data.value));
    }

    humanize() {
      let str = JSON.stringify(this.value);
      if (this.value.includes('\'')) {
        return str;
      } else {
        return '\'' + str.slice(1, -1) + '\'';
      }
    }

    compatibleWith(type) {
      return type instanceof ___R$romejs$js$analysis$types$StringLiteralT_ts$default && type.value === this.value;
    }
  }
  ___R$romejs$js$analysis$types$StringLiteralT_ts$default.type = 'StringLiteralT';

  // romejs/js-analysis/types/AnyT.ts

  class ___R$romejs$js$analysis$types$AnyT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$romejs$js$analysis$types$AnyT_ts$default(scope, originNode);
    }

    compatibleWith() {
      return true;
    }

    humanize() {
      return 'any';
    }
  }
  ___R$romejs$js$analysis$types$AnyT_ts$default.type = 'AnyT';

  // romejs/js-analysis/types/errors/E.ts

  class ___R$romejs$js$analysis$types$errors$E_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    static hydrate(scope, originNode) {
      return new ___R$romejs$js$analysis$types$AnyT_ts$default(scope, originNode);
    }

    humanize() {
      return this.getError().message;
    }

    getError() {
      throw new Error('unimplemented');
    }

    compatibleWith() {
      return false;
    }
  }
  ___R$romejs$js$analysis$types$errors$E_ts$default.type = 'E';

  // romejs/js-analysis/types/errors/UnknownPropE.ts

  class ___R$romejs$js$analysis$types$errors$UnknownPropE_ts$default extends ___R$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.thisKeys = opts.thisKeys;
      this.protoKeys = opts.protoKeys;
      this.allProps = [...this.thisKeys, ...this.protoKeys];
      this.key = opts.key;
      this.object = opts.object;
      this.property = opts.property;
    }

    sortProps(props) {
      if (props.length === 0) {
        return props;
      }

      const ratings = ___R$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(this.key, props);
      const sortedProps = ratings.map(prop => prop.target);
      return sortedProps;
    }

    getError() {
      let message = 'Property \'' + this.key + '\' not found in';

      return {
        message: message,
        advice: ___R$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(this.key, this.allProps),
        lowerTarget: this.property,
        upperTarget: this.object};
    }
  }
  ___R$romejs$js$analysis$types$errors$UnknownPropE_ts$default.type = 'UnknownPropE';

  // romejs/js-analysis/types/ObjIndexPropT.ts

  class ___R$romejs$js$analysis$types$ObjIndexPropT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, key, value) {
      super(scope, originNode);
      this.key = key;
      this.value = value;
    }

    serialize(addType) {
      return {
        key: addType(this.key),
        value: addType(this.value)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$ObjIndexPropT_ts$default(scope, originNode, getType(data.key), getType(data.value));
    }

    humanize(builder) {
      return '[' + builder.humanize(this.key) + ']: ' + builder.humanize(this.value);
    }
  }
  ___R$romejs$js$analysis$types$ObjIndexPropT_ts$default.type = 'ObjIndexPropT';

  // romejs/js-analysis/types/GetPropT.ts

  class ___R$romejs$js$analysis$types$GetPropT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, object, property) {
      super(scope, originNode);
      this.object = object;
      this.property = property;
    }

    serialize(addType) {
      return {
        object: addType(this.object),
        property: addType(this.property)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$GetPropT_ts$default(scope, originNode, getType(data.object), getType(data.property));
    }

    lookup(object, property, opts = {}) {
      object = this.utils.reduce(object);
      property = this.utils.reduce(property);

      const thisKeys = new Set();

      const protoKeys = opts.protoKeys === undefined ? [] : opts.protoKeys;
      const topObject = opts.topObject === undefined ? object : opts.topObject;

      let key;
      if (property instanceof ___R$romejs$js$analysis$types$StringLiteralT_ts$default) {
        key = property.value;
      }

      if (key !== undefined && object instanceof ___R$romejs$js$analysis$types$ObjT_ts$default) {
        const indexers = [];
        for (const maybePropRaw of object.props) {
          const maybeProp = this.utils.reduce(maybePropRaw);
          if (maybeProp instanceof ___R$romejs$js$analysis$types$ObjPropT_ts$default) {
            if (maybeProp.key === key) {
              return this.utils.reduce(maybeProp.value);
            } else {
              thisKeys.add(maybeProp.key);
            }
          } else if (maybeProp instanceof ___R$romejs$js$analysis$types$ObjIndexPropT_ts$default) {
            indexers.push(maybeProp);
          }
        }

        for (const indexer of indexers) {
          if (this.utils.isCompatibleWith(indexer.key, property)) {
            return this.utils.reduce(indexer.value);
          }
        }

        if (object.proto) {
          return this.lookup(object.proto, property, {
            topObject: topObject,
            protoKeys: [...protoKeys, ...thisKeys]});
        }
      }

      if (object instanceof ___R$romejs$js$analysis$types$AnyT_ts$default || object instanceof ___R$romejs$js$analysis$types$errors$E_ts$default) {
        return new ___R$romejs$js$analysis$types$AnyT_ts$default(this.scope, this.originNode);
      }

      if (typeof key === 'string') {
        return new ___R$romejs$js$analysis$types$errors$UnknownPropE_ts$default(this.scope, this.originNode, {
          object: topObject,
          property: property,
          key: key,
          thisKeys: Array.from(thisKeys),
          protoKeys: protoKeys});
      } else {
        return new ___R$romejs$js$analysis$types$UnknownT_ts$default(this.scope, this.originNode);
      }
    }

    reduce() {
      return this.lookup(this.object, this.property);
    }
  }
  ___R$romejs$js$analysis$types$GetPropT_ts$default.type = 'GetPropT';

  // romejs/js-analysis/types/UnionT.ts

  class ___R$romejs$js$analysis$types$UnionT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, types) {
      super(scope, originNode);
      this.types = [...new Set(types)];
    }

    serialize(addType) {
      return {
        types: this.types.map(type => addType(type))};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$UnionT_ts$default(scope, originNode, Array(data.types).map(id => getType(id)));
    }

    reduce() {
      const uniqTypes = [];
      const types = this.explodeUnion();

      for (const type of types) {
        let foundMatch = false;
        for (const compareType of uniqTypes) {
          const isCompatible = this.utils.isCompatibleWith(compareType, type);
          if (isCompatible) {
            foundMatch = true;
            break;
          }
        }
        if (foundMatch === false) {
          uniqTypes.push(type);
        }
      }

      if (uniqTypes.length === types.length) {
        return this;
      } else if (uniqTypes.length === 1) {
        return uniqTypes[0];
      } else {
        return new ___R$romejs$js$analysis$types$UnionT_ts$default(this.scope, this.originNode, uniqTypes);
      }
    }

    explodeUnion() {
      let types = [];
      const visited = new Set([this]);

      for (const type of this.types) {
        const reduced = this.utils.reduce(type);
        if (visited.has(reduced)) {
          continue;
        } else {
          visited.add(reduced);
        }

        types = types.concat(this.utils.explodeUnion(type));
      }

      return types;
    }

    compatibleWith(otherType) {
      const ourTypes = this.utils.explodeUnion(this);

      if (ourTypes.includes(otherType)) {
        return true;
      }

      const otherTypes = this.utils.explodeUnion(otherType);
      const missing = [];

      for (const type of ourTypes) {
        let compatible = false;

        for (const otherType of otherTypes) {
          if (this.utils.isCompatibleWith(type, otherType)) {
            compatible = true;
          }
        }

        if (compatible === false) {
          missing.push(type);
        }
      }

      if (missing.length === 0) {
        return true;
      } else {
        return false;
      }
    }

    humanize(builder) {
      return this.types.map(type => builder.humanize(type)).join(' | ');
    }
  }
  ___R$romejs$js$analysis$types$UnionT_ts$default.type = 'UnionT';

  // romejs/js-analysis/scopes.ts


  class ___R$romejs$js$analysis$scopes_ts$Scope {
    constructor(opts) {
      let {evaluator: evaluator, parentScope: parentScope} = opts;
      if (evaluator === undefined && parentScope !== undefined) {
        evaluator = parentScope.evaluator;
      }

      if (evaluator === undefined) {
        throw new Error('No evaluator was passed or inferred');
      }

      this.intrinsics = evaluator.intrinsics;
      this.evaluator = evaluator;
      this.hub = evaluator.hub;
      this.parentScope = parentScope;

      this.bindings = new Map();
    }

    getBinding(name) {
      let scope = this;
      while (scope) {
        const binding = scope.bindings.get(name);
        if (binding) {
          return binding.type;
        }
        scope = scope.parentScope;
      }
    }

    getBindingAssert(name) {
      const binding = this.getBinding(name);
      if (binding === undefined) {
        throw new Error('Expected binding ' + name);
      }
      return binding;
    }

    query(paths) {
      let initial = this.getBinding(paths[0]);
      if (initial === undefined) {
        throw new Error('Expected "' + paths[0] + '" binding, found ' + JSON.stringify(
        this.getBindingNames()) + ' ' + this.evaluator.filename);
      }

      for (let i = 1; i < paths.length; i++) {
        initial = new ___R$romejs$js$analysis$types$GetPropT_ts$default(this, undefined, initial, new ___R$romejs$js$analysis$types$StringLiteralT_ts$default(this, undefined, paths[i]));
      }

      return initial;
    }

    declareBinding(name, originNode) {
      if (name === undefined) {
        throw new Error('Expected name');
      }
      this.bindings.set(name, {
        type: new ___R$romejs$js$analysis$types$OpenT_ts$default(this, originNode),
        status: 'declared'});
    }

    addBinding(name, type) {
      if (name === undefined) {
        throw new Error('Expected name');
      }

      const existingBinding = this.bindings.get(name);
      if (existingBinding !== undefined &&
      existingBinding.status === 'declared') {
        if (!(existingBinding.type instanceof ___R$romejs$js$analysis$types$OpenT_ts$default)) {
          throw new Error('expected OpenT');
        }

        existingBinding.type.shouldMatch(type);
      }

      this.bindings.set(name, {
        type: type,
        status: 'initialized'});
    }

    getBindingNames() {
      const names = new Set(this.parentScope ? this.parentScope.getBindingNames() : []);

      for (const [name] of this.bindings) {
        names.add(name);
      }

      return Array.from(names);
    }

    getOwnBindingNames() {
      return Array.from(this.bindings.keys());
    }

    createUnion(types, originNode) {
      if (types.length === 0) {
        return new ___R$romejs$js$analysis$types$UnknownT_ts$default(this, originNode);
      } else if (types.length === 1) {
        return types[0];
      } else {
        return new ___R$romejs$js$analysis$types$UnionT_ts$default(this, originNode, types);
      }
    }

    fork() {
      return new ___R$romejs$js$analysis$scopes_ts$Scope({evaluator: this.evaluator, parentScope: this});
    }

    find(klass) {
      const scope = this.findOptional(klass);
      if (scope === undefined) {
        throw new Error('Failed to find class');
      } else {
        return scope;
      }
    }

    findOptional(klass) {
      let scope = this;

      do {
        if (scope instanceof klass) {
          return scope;
        }

        scope = scope.parentScope;
      } while (scope !== undefined);
    }

    refine() {
      return new ___R$romejs$js$analysis$scopes_ts$RefineScope({evaluator: this.evaluator, parentScope: this});
    }

    evaluate(node) {
      return this.evaluator.evaluate(node, this);
    }
  }

  class ___R$romejs$js$analysis$scopes_ts$RefineScope extends ___R$romejs$js$analysis$scopes_ts$Scope {}

  class ___R$romejs$js$analysis$scopes_ts$ClassScope extends ___R$romejs$js$analysis$scopes_ts$Scope {
    constructor(opts, meta) {
      super(opts);
      this.meta = meta;
    }
  }

  class ___R$romejs$js$analysis$scopes_ts$ThisScope extends ___R$romejs$js$analysis$scopes_ts$Scope {
    constructor(opts, context) {
      super(opts);
      this.context = context;
    }
  }

  class ___R$romejs$js$analysis$scopes_ts$FunctionScope extends ___R$romejs$js$analysis$scopes_ts$ThisScope {
    constructor(opts, meta) {
      super(opts, meta.thisContext);
      this.meta = meta;
    }
  }

  // romejs/js-analysis/types/errors/UnknownImportE.ts

  class ___R$romejs$js$analysis$types$errors$UnknownImportE_ts$default extends ___R$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.possibleNames = opts.possibleNames;
      this.importedName = opts.importedName;
      this.source = opts.source;
    }

    getError() {
      const {possibleNames: possibleNames} = this;
      const suggestion = ___R$romejs$string$utils$findClosestStringMatch_ts$findClosestStringMatch(this.importedName, possibleNames);

      let infoMessage = undefined;
      let infoList = undefined;

      if (possibleNames.length === 0) {
        infoMessage = 'This file contains no exports.';
      } else {
        if (suggestion === undefined) {
          infoList = this.possibleNames;
          infoMessage = 'Did you mean one of these?';
        } else {
          infoMessage = 'Did you mean <emphasis>' + suggestion + '</emphasis>?';
        }
      }

      const advice = [{
        type: 'log',
        category: 'info',
        message: infoMessage}];
      if (infoList !== undefined) {
        advice.push({
          type: 'list',
          list: infoList});
      }

      return {
        message: 'Unknown import \'' + this.importedName + '\' in \'' + this.source + '\'',
        advice: advice,
        lowerTarget: this};
    }
  }
  ___R$romejs$js$analysis$types$errors$UnknownImportE_ts$default.type = 'UnknownImportE';

  // romejs/js-analysis/types/VoidT.ts

  class ___R$romejs$js$analysis$types$VoidT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$romejs$js$analysis$types$VoidT_ts$default(scope, originNode);
    }

    humanize() {
      return 'void';
    }
  }
  ___R$romejs$js$analysis$types$VoidT_ts$default.type = 'VoidT';

  // romejs/js-analysis/types/EmptyT.ts

  class ___R$romejs$js$analysis$types$EmptyT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$romejs$js$analysis$types$EmptyT_ts$default(scope, originNode);
    }

    humanize() {
      return 'empty';
    }

    compatibleWith(otherType) {
      return otherType instanceof ___R$romejs$js$analysis$types$EmptyT_ts$default || otherType instanceof ___R$romejs$js$analysis$types$VoidT_ts$default;
    }
  }
  ___R$romejs$js$analysis$types$EmptyT_ts$default.type = 'EmptyT';

  // romejs/js-analysis/types/BooleanLiteralT.ts

  class ___R$romejs$js$analysis$types$BooleanLiteralT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, value) {
      super(scope, originNode);
      this.value = value;
    }

    serialize() {
      return {value: this.value};
    }

    static hydrate(scope, originNode, data) {
      return new ___R$romejs$js$analysis$types$BooleanLiteralT_ts$default(scope, originNode, Boolean(data.value));
    }

    humanize() {
      if (this.value === true) {
        return 'true';
      } else {
        return 'false';
      }
    }

    compatibleWith(type) {
      return type instanceof ___R$romejs$js$analysis$types$BooleanLiteralT_ts$default && type.value === this.value;
    }
  }
  ___R$romejs$js$analysis$types$BooleanLiteralT_ts$default.type = 'BooleanLiteralT';

  // romejs/js-analysis/types/BooleanT.ts

  class ___R$romejs$js$analysis$types$BooleanT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$romejs$js$analysis$types$BooleanT_ts$default(scope, originNode);
    }

    humanize() {
      return 'boolean';
    }

    compatibleWith(type) {
      return type instanceof ___R$romejs$js$analysis$types$BooleanT_ts$default || type instanceof ___R$romejs$js$analysis$types$BooleanLiteralT_ts$default;
    }
  }
  ___R$romejs$js$analysis$types$BooleanT_ts$default.type = 'BooleanT';

  // romejs/js-analysis/types/errors/NotCallableE.ts

  class ___R$romejs$js$analysis$types$errors$NotCallableE_ts$default extends ___R$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, callee) {
      super(scope, originNode);
      this.callee = callee;
    }

    getError() {
      return {
        message: 'This type isn\'t callable',
        lowerTarget: this.callee};
    }
  }
  ___R$romejs$js$analysis$types$errors$NotCallableE_ts$default.type = 'NotCallableE';

  // romejs/js-analysis/types/FunctionT.ts

  class ___R$romejs$js$analysis$types$FunctionT_ts$default extends ___R$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode, {
        props: opts.props,
        proto: opts.proto,
        calls: []});
      this.params = opts.params;
      this.rest = opts.rest;
      this.returns = opts.returns;
      this.body = opts.body;
    }

    serialize(addType) {
      return {
        params: this.params.map(type => addType(type)),
        rest: this.rest ? addType(this.rest) : undefined,
        returns: addType(this.returns),
        proto: this.proto === undefined ? undefined : addType(this.proto),
        body: this.body === undefined ? undefined : addType(this.body),
        props: this.props.map(type => addType(type))};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$FunctionT_ts$default(scope, originNode, {
        params: Array(data.params).map(id => getType(id)),
        rest: data.rest === undefined ? undefined : getType(data.rest),
        returns: getType(data.returns),
        props: Array(data.props).map(id => getType(id)),
        proto: data.proto === undefined ? undefined : getType(data.proto),
        body: data.body === undefined ? undefined : getType(data.body)});
    }

    humanize(builder) {
      return '(' + this.params.map(param => builder.humanize(param)).join(', ') + ') => ' + builder.humanize(this.returns);
    }

    reduce() {
      const {body: body} = this;
      if (body === undefined) {
        return this;
      }

      const reducedBody = this.utils.reduce(body);
      if (reducedBody !== body) {
        return new ___R$romejs$js$analysis$types$FunctionT_ts$default(this.scope, this.originNode, {
          params: this.params,
          rest: this.rest,
          returns: this.returns,
          props: this.props,
          proto: this.proto,
          body: reducedBody});
      }

      return this;
    }
  }
  ___R$romejs$js$analysis$types$FunctionT_ts$default.type = 'FunctionT';

  // romejs/js-analysis/types/CallT.ts

  class ___R$romejs$js$analysis$types$CallT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, callee, args) {
      super(scope, originNode);
      this.callee = callee;
      this.args = args;
    }

    reduce() {
      let callee = this.utils.reduce(this.callee);
      if (callee instanceof ___R$romejs$js$analysis$types$ObjT_ts$default && callee.calls.length) {
        callee = this.utils.reduce(callee.calls[0]);
      }

      if (callee instanceof ___R$romejs$js$analysis$types$AnyT_ts$default || callee instanceof ___R$romejs$js$analysis$types$errors$E_ts$default) {
        return new ___R$romejs$js$analysis$types$AnyT_ts$default(this.scope, this.originNode);
      } else if (callee instanceof ___R$romejs$js$analysis$types$FunctionT_ts$default) {
        return this.utils.reduce(callee.returns);
      } else {
        return new ___R$romejs$js$analysis$types$errors$NotCallableE_ts$default(this.scope, this.originNode, this.callee);
      }
    }
  }
  ___R$romejs$js$analysis$types$CallT_ts$default.type = 'CallT';

  // romejs/js-analysis/types/ClassT.ts

  class ___R$romejs$js$analysis$types$ClassT_ts$default extends ___R$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode, opts) {
      let protoProp = undefined;
      if (opts.extends) {
        const originNode = opts.extends.originNode;
        protoProp = new ___R$romejs$js$analysis$types$GetPropT_ts$default(scope, originNode, opts.extends, new ___R$romejs$js$analysis$types$StringLiteralT_ts$default(scope, originNode, 'prototype'));
      }

      const constructorOpen = new ___R$romejs$js$analysis$types$OpenT_ts$default(scope, undefined);
      const constructorProp = new ___R$romejs$js$analysis$types$ObjPropT_ts$default(scope, undefined, 'constructor', constructorOpen);
      const instances = [...opts.instances, constructorProp];

      const protoObj = new ___R$romejs$js$analysis$types$ObjT_ts$default(scope, originNode, {
        props: instances,
        proto: protoProp,
        calls: []});

      super(scope, originNode, {
        props: [...opts.statics, new ___R$romejs$js$analysis$types$ObjPropT_ts$default(scope, originNode, 'prototype', protoObj)],
        proto: opts.extends,
        calls: opts.calls === undefined ? [] : opts.calls});

      constructorOpen.shouldMatch(this);

      this._constructor = opts.constructor;
      this._statics = opts.statics;
      this._instances = opts.instances;
      this._extends = opts.extends;
    }

    serialize(addType) {
      return {
        constructor: this._constructor === undefined ? undefined : addType(this._constructor),
        statics: this._statics.map(type => addType(type)),
        instances: this._instances.map(type => addType(type)),
        extends: this._extends === undefined ? undefined : addType(this._extends)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$ClassT_ts$default(scope, originNode, {
        constructor: data.constructor === undefined ? undefined : getType(data.constructor),
        statics: Array(data.statics).map(id => getType(id)),
        instances: Array(data.instances).map(id => getType(id)),
        extends: data.extends === undefined ? undefined : getType(data.extends)});
    }
  }
  ___R$romejs$js$analysis$types$ClassT_ts$default.type = 'ClassT';

  // romejs/js-analysis/types/IntersectionT.ts

  class ___R$romejs$js$analysis$types$IntersectionT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, types) {
      super(scope, originNode);
      this.types = types;
    }

    serialize(addType) {
      return {
        types: this.types.map(type => addType(type))};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$IntersectionT_ts$default(scope, originNode, Array(data.types).map(id => getType(id)));
    }

    compatibleWith(otherType) {
      for (const type of this.types) {
        const compatibility = this.utils.checkCompability(type, otherType);
        if (compatibility.type === 'incompatible') {
          return compatibility;
        }
      }
      return true;
    }

    humanize(builder) {
      return this.types.map(type => builder.humanize(type)).join(' & ');
    }
  }
  ___R$romejs$js$analysis$types$IntersectionT_ts$default.type = 'IntersectionT';

  // romejs/js-analysis/types/NullT.ts

  class ___R$romejs$js$analysis$types$NullT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$romejs$js$analysis$types$NullT_ts$default(scope, originNode);
    }

    humanize() {
      return 'null';
    }
  }
  ___R$romejs$js$analysis$types$NullT_ts$default.type = 'NullT';

  // romejs/js-analysis/types/MaybeT.ts

  class ___R$romejs$js$analysis$types$MaybeT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, parent) {
      super(scope, originNode);
      this.parent = parent;
    }

    serialize(addType) {
      return {
        parent: addType(this.parent)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$MaybeT_ts$default(scope, originNode, getType(data.parent));
    }

    humanize(builder) {
      return '?' + builder.humanize(this.parent);
    }

    explodeUnion() {
      return [new ___R$romejs$js$analysis$types$VoidT_ts$default(this.scope, this.originNode), new ___R$romejs$js$analysis$types$NullT_ts$default(this.scope, this.originNode), ...this.utils.explodeUnion(this.parent)];
    }

    compatibleWith(otherType) {
      if (otherType instanceof ___R$romejs$js$analysis$types$MaybeT_ts$default) {
        return this.utils.checkCompability(this.parent, otherType.parent);
      } else {
        return otherType instanceof ___R$romejs$js$analysis$types$VoidT_ts$default ||
        otherType instanceof ___R$romejs$js$analysis$types$NullT_ts$default ||
        this.utils.checkCompability(this.parent, otherType);
      }
    }
  }
  ___R$romejs$js$analysis$types$MaybeT_ts$default.type = 'MaybeT';

  // romejs/js-analysis/types/MixedT.ts

  class ___R$romejs$js$analysis$types$MixedT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$romejs$js$analysis$types$MixedT_ts$default(scope, originNode);
    }

    compatibleWith() {
      return false;
    }

    humanize() {
      return 'mixed';
    }
  }
  ___R$romejs$js$analysis$types$MixedT_ts$default.type = 'MixedT';

  // romejs/js-analysis/types/NumericT.ts

  class ___R$romejs$js$analysis$types$NumericT_ts$default extends ___R$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode) {
      super(scope, originNode, {
        props: [],
        proto: scope.intrinsics.NumberPrototype,
        calls: []});
    }

    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$romejs$js$analysis$types$NumericT_ts$default(scope, originNode);
    }

    humanize() {
      return 'number';
    }

    compatibleWith(type) {
      return type instanceof ___R$romejs$js$analysis$types$NumericT_ts$default || type instanceof ___R$romejs$js$analysis$types$NumericLiteralT_ts$default;
    }
  }
  ___R$romejs$js$analysis$types$NumericT_ts$default.type = 'NumericT';

  // romejs/js-analysis/types/NumericLiteralT.ts

  class ___R$romejs$js$analysis$types$NumericLiteralT_ts$default extends ___R$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode, value) {
      super(scope, originNode, {
        props: [],
        proto: scope.intrinsics.NumberPrototype,
        calls: []});
      this.value = value;
    }

    serialize() {
      return {value: this.value};
    }

    static hydrate(scope, originNode, data) {
      return new ___R$romejs$js$analysis$types$NumericLiteralT_ts$default(scope, originNode, Number(data.value));
    }

    humanize() {
      return String(this.value);
    }

    compatibleWith(type) {
      return type instanceof ___R$romejs$js$analysis$types$NumericT_ts$default ||
      type instanceof ___R$romejs$js$analysis$types$NumericLiteralT_ts$default && type.value === this.value;
    }
  }
  ___R$romejs$js$analysis$types$NumericLiteralT_ts$default.type = 'NumericLiteralT';

  // romejs/js-analysis/types/ImportT.ts

  class ___R$romejs$js$analysis$types$ImportT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, opts) {
      super(scope, originNode);
      this.importedName = opts.importedName;
      this.relative =
      opts.relative === undefined ? scope.evaluator.filename : opts.relative;
      this.source = opts.source;
      this.absolute = undefined;
      this.resolvedType = undefined;
      scope.evaluator.addImport(this, {
        importedName: this.importedName,
        relative: this.relative,
        source: this.source});
    }

    setAbsolute(absolute) {
      this.absolute = absolute;
    }

    setResolvedType(resolvedType) {
      this.resolvedType = resolvedType;
    }

    serialize() {
      return {
        importedName: this.importedName,
        relative: this.relative,
        source: this.source};
    }

    static hydrate(scope, originNode, data) {
      return new ___R$romejs$js$analysis$types$ImportT_ts$default(scope, originNode, {
        importedName: String(data.importedName),
        source: String(data.source),
        relative: String(data.relative)});
    }

    humanize(builder) {
      let object;
      if (this.resolvedType !== undefined) {
        object = builder.humanize(this.resolvedType);
      } else if (this.absolute === undefined) {
        object = '$Exports<"' + this.source + '", "' + this.relative + '">';
      } else {
        object = '$Exports<"' + this.absolute + '">';
      }

      if (this.importedName === undefined) {
        return object;
      } else {
        return object + '.' + this.importedName;
      }
    }

    reduce() {
      if (this.resolvedType === undefined) {
        return this;
      } else {
        return this.resolvedType;
      }
    }
  }
  ___R$romejs$js$analysis$types$ImportT_ts$default.type = 'ImportT';

  // romejs/js-analysis/types/StringT.ts

  class ___R$romejs$js$analysis$types$StringT_ts$default extends ___R$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode) {
      super(scope, originNode, {
        props: [],
        proto: scope.intrinsics.StringPrototype,
        calls: []});
    }

    serialize() {
      return {};
    }

    static hydrate(scope, originNode) {
      return new ___R$romejs$js$analysis$types$StringT_ts$default(scope, originNode);
    }

    humanize() {
      return 'string';
    }

    compatibleWith(type) {
      return type instanceof ___R$romejs$js$analysis$types$StringT_ts$default || type instanceof ___R$romejs$js$analysis$types$StringLiteralT_ts$default;
    }
  }
  ___R$romejs$js$analysis$types$StringT_ts$default.type = 'StringT';

  // romejs/js-analysis/types/ExhaustiveT.ts

  class ___R$$priv$romejs$js$analysis$types$ExhaustiveT_ts$ENotExhaustive extends ___R$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, target, only, extraenous) {
      super(scope, originNode);
      this.target = target;
      this.only = only;
      this.extraenous = extraenous;
    }

    getError() {
      let message = 'Expected only a ' + this.utils.humanize(
      this.only) + ' but got ' + this.utils.humanize(this.target);

      return {
        message: message,
        lowerTarget: this.target};
    }
  }
  ___R$$priv$romejs$js$analysis$types$ExhaustiveT_ts$ENotExhaustive.type = 'ENotExhaustive';
  class ___R$romejs$js$analysis$types$ExhaustiveT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, target, only) {
      super(scope, originNode);
      this.target = target;
      this.only = only;
    }

    serialize(addType) {
      return {
        target: addType(this.target),
        only: addType(this.only)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, originNode, getType(data.target), getType(data.only));
    }

    reduce() {
      const target = this.utils.reduce(this.target);
      const only = this.utils.reduce(this.only);
      if (target instanceof ___R$romejs$js$analysis$types$AnyT_ts$default || only instanceof ___R$romejs$js$analysis$types$AnyT_ts$default) {
        return this.only;
      }

      const targetCandidates = this.utils.explodeUnion(target);
      const onlyCandidates = this.utils.explodeUnion(only);

      const extraneous = [];
      for (const possible of targetCandidates) {
        let compatible = false;

        for (const otherType of onlyCandidates) {
          if (this.utils.isCompatibleWith(possible, otherType)) {
            compatible = true;
          }
        }

        if (compatible === false) {
          extraneous.push(possible);
        }
      }

      if (extraneous.length === 0) {
        return target;
      } else {
        return new ___R$$priv$romejs$js$analysis$types$ExhaustiveT_ts$ENotExhaustive(this.scope, this.originNode, this.target, this.only, extraneous);
      }
    }

    humanize(builder) {
      return 'exhaustive ' + builder.humanize(
      this.target) + ' should only match ' + builder.humanize(this.target);
    }
  }
  ___R$romejs$js$analysis$types$ExhaustiveT_ts$default.type = 'ExhaustiveT';

  // romejs/js-analysis/types/InstanceT.ts

  class ___R$romejs$js$analysis$types$InstanceT_ts$default extends ___R$romejs$js$analysis$types$ObjT_ts$default {
    constructor(scope, originNode, target, typeParameters) {
      const prototype = new ___R$romejs$js$analysis$types$GetPropT_ts$default(scope, originNode, target, new ___R$romejs$js$analysis$types$StringLiteralT_ts$default(scope, originNode, 'prototype'));
      super(scope, originNode, {
        props: [],
        proto: prototype,
        calls: []});

      this.typeParameters = typeParameters;
      this.target = target;
    }

    serialize(addType) {
      return {
        target: addType(this.target),
        params: this.typeParameters.map(type => addType(type))};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$InstanceT_ts$default(scope, originNode, getType(data.target), Array(data.params).map(id => getType(id)));
    }

    humanize(builder) {
      const name = builder.humanize(this.target);
      const typeParams = this.typeParameters;
      if (typeParams.length === 0) {
        return name;
      } else {
        return name + '<' + typeParams.map(param => builder.humanize(param)).join(', ') + '>';
      }
    }

    compatibleWith(otherType) {
      return otherType instanceof ___R$romejs$js$analysis$types$InstanceT_ts$default &&
      this.utils.checkCompability(this.target, otherType.target);
    }
  }
  ___R$romejs$js$analysis$types$InstanceT_ts$default.type = 'InstanceT';

  // romejs/js-analysis/types/GenericT.ts

  class ___R$romejs$js$analysis$types$GenericT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, name, type) {
      super(scope, originNode);
      this.name = name;
      this.type = type;
    }

    serialize(addType) {
      return {
        name: this.name,
        type: addType(this.type)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$GenericT_ts$default(scope, originNode, String(data.name), getType(data.type));
    }

    humanize() {
      return this.name;
    }

    reduce() {
      const type = this.utils.reduce(this.type);
      if (type instanceof ___R$romejs$js$analysis$types$ClassT_ts$default) {
        return new ___R$romejs$js$analysis$types$InstanceT_ts$default(this.scope, this.originNode, this.type, []);
      } else {
        return type;
      }
    }
  }
  ___R$romejs$js$analysis$types$GenericT_ts$default.type = 'GenericT';

  // romejs/js-analysis/types/BinaryOpT.ts

  function ___R$$priv$romejs$js$analysis$types$BinaryOpT_ts$isNumber(t) {
    return t instanceof ___R$romejs$js$analysis$types$NumericT_ts$default || t instanceof ___R$romejs$js$analysis$types$NumericLiteralT_ts$default;
  }

  class ___R$romejs$js$analysis$types$BinaryOpT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, left, operator, right) {
      super(scope, originNode);
      this.operator = operator;
      this.left = left;
      this.right = right;
    }

    serialize(addType) {
      return {
        left: addType(this.left),
        right: addType(this.right)};
    }

    static hydrate(scope, originNode, data, getType) {
      return new ___R$romejs$js$analysis$types$BinaryOpT_ts$default(scope, originNode, getType(data.left), String(data.operator), getType(data.right));
    }

    reduce() {
      const left = this.utils.reduce(this.left);
      const right = this.utils.reduce(this.right);
      const {scope: scope, originNode: originNode, operator: operator} = this;

      switch (operator) {
        case '===':
        case '==':
        case '!=':
        case '!==':
        case '<':
        case '<=':
        case '>':
        case '>=':
        case 'in':
        case 'instanceof':
          return new ___R$romejs$js$analysis$types$BooleanT_ts$default(scope, originNode);

        case '+':
          if (left instanceof ___R$romejs$js$analysis$types$AnyT_ts$default || right instanceof ___R$romejs$js$analysis$types$AnyT_ts$default) {
            return new ___R$romejs$js$analysis$types$AnyT_ts$default(scope, originNode);
          } else if (left instanceof ___R$romejs$js$analysis$types$NumericLiteralT_ts$default &&
          right instanceof ___R$romejs$js$analysis$types$NumericLiteralT_ts$default) {
            return new ___R$romejs$js$analysis$types$NumericLiteralT_ts$default(scope, originNode, left.value + right.value);
          } else if (___R$$priv$romejs$js$analysis$types$BinaryOpT_ts$isNumber(left) && ___R$$priv$romejs$js$analysis$types$BinaryOpT_ts$isNumber(right)) {
            return new ___R$romejs$js$analysis$types$NumericT_ts$default(scope, originNode);
          } else if (left instanceof ___R$romejs$js$analysis$types$StringLiteralT_ts$default &&
          right instanceof ___R$romejs$js$analysis$types$StringLiteralT_ts$default) {
            return new ___R$romejs$js$analysis$types$StringLiteralT_ts$default(scope, originNode, left.value + right.value);
          } else {
            return new ___R$romejs$js$analysis$types$StringT_ts$default(scope, originNode);
          }

        case '<<':
        case '>>':
        case '>>>':
        case '-':
        case '*':
        case '/':
        case '%':
        case '**':
        case '|':
        case '^':
        case '&':
          return new ___R$romejs$js$analysis$types$NumericT_ts$default(scope, originNode);

        default:
          throw new Error('Unknown operator');}
    }
  }
  ___R$romejs$js$analysis$types$BinaryOpT_ts$default.type = 'BinaryOpT';

  // romejs/js-analysis/types/errors/MissingUnionE.ts

  class ___R$romejs$js$analysis$types$errors$MissingUnionE_ts$default extends ___R$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, target, union, missing) {
      super(scope, originNode);
      this.target = target;
      this.union = union;
      this.missing = missing;
    }

    getError() {
      return {
        message: 'Missing the conditions ' + this.missing.map(type => this.utils.humanize(type)).join(', '),
        lowerTarget: this.target};
    }
  }
  ___R$romejs$js$analysis$types$errors$MissingUnionE_ts$default.type = 'MissingUnionE';

  // romejs/js-analysis/types/RefinedT.ts

  class ___R$romejs$js$analysis$types$RefinedT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, root, remove) {
      super(scope, originNode);
      this.root = root;
      this.remove = remove;
    }

    reduce() {
      const {root: root} = this;

      const exploded = this.utils.explodeUnion(root);
      const removeTypes = this.utils.explodeUnion(this.remove);

      const clean = [];
      const removed = [];

      for (const type of exploded) {
        let compatible = false;

        for (const remove of removeTypes) {
          if (this.utils.isCompatibleWith(type, remove)) {
            compatible = true;
          }
        }

        if (compatible === false) {
          clean.push(type);
        } else {
          removed.push(type);
        }
      }

      if (removed.length === 0) {
        return new ___R$romejs$js$analysis$types$errors$MissingUnionE_ts$default(root.scope, root.originNode, root, this.remove, removed);
      } else {
        return root.scope.createUnion(clean, root.originNode);
      }
    }
  }
  ___R$romejs$js$analysis$types$RefinedT_ts$default.type = 'RefinedT';

  // romejs/js-analysis/types/RefineTypeofT.ts

  class ___R$romejs$js$analysis$types$RefineTypeofT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, node, str, fallback) {
      super(scope, node);
      this.str = str;
      this.fallback = fallback;
    }

    reduce() {
      const {fallback: fallback, utils: utils} = this;
      const str = utils.reduce(this.str);

      if (str instanceof ___R$romejs$js$analysis$types$StringLiteralT_ts$default) {
        let val;

        switch (str.value) {
          case 'string':
            val = new ___R$romejs$js$analysis$types$StringT_ts$default(this.scope, undefined);
            break;

          case 'number':
            val = new ___R$romejs$js$analysis$types$NumericT_ts$default(this.scope, undefined);
            break;

          case 'undefined':
            val = new ___R$romejs$js$analysis$types$VoidT_ts$default(this.scope, undefined);
            break;

          case 'boolean':
            val = new ___R$romejs$js$analysis$types$BooleanT_ts$default(this.scope, undefined);
            break;

          case 'symbol':
          case 'function':
          case 'object':
            return utils.reduce(fallback);

          default:
            return utils.reduce(fallback);}

        const types = utils.explodeUnion(fallback);
        for (const type of types) {
          if (utils.isCompatibleWith(type, val)) {
            return utils.reduce(type);
          }
        }

        return utils.reduce(fallback);
      }

      return utils.reduce(fallback);
    }
  }
  ___R$romejs$js$analysis$types$RefineTypeofT_ts$default.type = 'RefineTypeofT';

  // romejs/js-analysis/types/TypeofT.ts

  class ___R$romejs$js$analysis$types$TypeofT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, node, obj) {
      super(scope, node);
      this.obj = obj;
    }

    reduce() {
      const types = this.utils.explodeUnion(this.obj);

      const possibleTypes = [];
      for (const rawType of types) {
        const type = this.utils.reduce(rawType);
        let typeStr;

        if (type instanceof ___R$romejs$js$analysis$types$StringT_ts$default || type instanceof ___R$romejs$js$analysis$types$StringLiteralT_ts$default) {
          typeStr = 'string';
        }

        if (type instanceof ___R$romejs$js$analysis$types$NumericT_ts$default || type instanceof ___R$romejs$js$analysis$types$NumericLiteralT_ts$default) {
          typeStr = 'number';
        }

        if (type instanceof ___R$romejs$js$analysis$types$BooleanT_ts$default || type instanceof ___R$romejs$js$analysis$types$BooleanLiteralT_ts$default) {
          typeStr = 'boolean';
        }

        if (type instanceof ___R$romejs$js$analysis$types$VoidT_ts$default) {
          typeStr = 'undefined';
        }

        if (type instanceof ___R$romejs$js$analysis$types$ObjT_ts$default) {
          if (type.calls.length === 0) {
            typeStr = 'object';
          } else {
            typeStr = 'function';
          }
        }

        if (type instanceof ___R$romejs$js$analysis$types$NullT_ts$default) {
          typeStr = 'object';
        }

        if (typeStr !== undefined) {
          possibleTypes.push(
          new ___R$romejs$js$analysis$types$StringLiteralT_ts$default(this.scope, this.originNode, typeStr));
        }
      }

      if (possibleTypes.length === 0) {
        return new ___R$romejs$js$analysis$types$StringT_ts$default(this.scope, this.originNode);
      } else {
        return this.scope.createUnion(possibleTypes, this.originNode);
      }
    }
  }
  ___R$romejs$js$analysis$types$TypeofT_ts$default.type = 'TypeofT';

  // romejs/js-analysis/types/SideEffectT.ts

  class ___R$romejs$js$analysis$types$SideEffectT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, actualType) {
      super(scope, originNode);
      this.actualType = actualType;
    }

    reduce() {
      return this.utils.reduce(this.actualType);
    }
  }
  ___R$romejs$js$analysis$types$SideEffectT_ts$default.type = 'SideEffectT';

  // romejs/js-analysis/types/BlockT.ts

  class ___R$romejs$js$analysis$types$BlockT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, body) {
      super(scope, originNode);
      this.body = body;
    }

    reduce() {
      const body = [];
      let changed = false;

      for (const type of this.body) {
        const reduced = this.utils.reduce(type);
        body.push(reduced);
        if (reduced !== type) {
          changed = true;
        }
      }

      if (changed) {
        return new ___R$romejs$js$analysis$types$BlockT_ts$default(this.scope, this.originNode, body);
      } else {
        return this;
      }
    }

    humanize() {
      return '{}';
    }
  }
  ___R$romejs$js$analysis$types$BlockT_ts$default.type = 'BlockT';

  // romejs/js-analysis/types/errors/UndeclaredVarE.ts

  class ___R$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default extends ___R$romejs$js$analysis$types$errors$E_ts$default {
    constructor(scope, originNode, name) {
      super(scope, originNode);
      this.name = name;
    }

    getError() {
      const possibleNames = this.scope.getBindingNames();
      return {
        message: 'Undeclared variable \'' + this.name + '\'',
        advice: ___R$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(this.name, possibleNames),
        lowerTarget: this};
    }
  }
  ___R$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default.type = 'UndeclaredVarE';

  // romejs/js-analysis/types/index.ts

  const ___R$romejs$js$analysis$types$index_ts = {
    get default() {
      return ___R$romejs$js$analysis$types$index_ts$default;
    }};
  const ___R$$priv$romejs$js$analysis$types$index_ts$types = new Map();
  const ___R$romejs$js$analysis$types$index_ts$default = ___R$$priv$romejs$js$analysis$types$index_ts$types;
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('AnyT', ___R$romejs$js$analysis$types$AnyT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('BooleanLiteralT', ___R$romejs$js$analysis$types$BooleanLiteralT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('BooleanT', ___R$romejs$js$analysis$types$BooleanT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('CallT', ___R$romejs$js$analysis$types$CallT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('ClassT', ___R$romejs$js$analysis$types$ClassT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('EmptyT', ___R$romejs$js$analysis$types$EmptyT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('FunctionT', ___R$romejs$js$analysis$types$FunctionT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('GetPropT', ___R$romejs$js$analysis$types$GetPropT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('IntersectionT', ___R$romejs$js$analysis$types$IntersectionT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('MaybeT', ___R$romejs$js$analysis$types$MaybeT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('MixedT', ___R$romejs$js$analysis$types$MixedT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('NullT', ___R$romejs$js$analysis$types$NullT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('NumericLiteralT', ___R$romejs$js$analysis$types$NumericLiteralT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('NumericT', ___R$romejs$js$analysis$types$NumericT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('ObjPropT', ___R$romejs$js$analysis$types$ObjPropT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('ObjT', ___R$romejs$js$analysis$types$ObjT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('OpenIntrinsicT', ___R$romejs$js$analysis$types$OpenIntrinsicT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('ImportT', ___R$romejs$js$analysis$types$ImportT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('OpenT', ___R$romejs$js$analysis$types$OpenT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('StringLiteralT', ___R$romejs$js$analysis$types$StringLiteralT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('StringT', ___R$romejs$js$analysis$types$StringT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('UnionT', ___R$romejs$js$analysis$types$UnionT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('UnknownT', ___R$romejs$js$analysis$types$UnknownT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('VoidT', ___R$romejs$js$analysis$types$VoidT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('ExhaustiveT', ___R$romejs$js$analysis$types$ExhaustiveT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('InstanceT', ___R$romejs$js$analysis$types$InstanceT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('GenericT', ___R$romejs$js$analysis$types$GenericT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('ObjIndexPropT', ___R$romejs$js$analysis$types$ObjIndexPropT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('BinaryOpT', ___R$romejs$js$analysis$types$BinaryOpT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('RefinedT', ___R$romejs$js$analysis$types$RefinedT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('RefineTypeofT', ___R$romejs$js$analysis$types$RefineTypeofT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('TypeofT', ___R$romejs$js$analysis$types$TypeofT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('SideEffectT', ___R$romejs$js$analysis$types$SideEffectT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('BlockT', ___R$romejs$js$analysis$types$BlockT_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('E', ___R$romejs$js$analysis$types$errors$E_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('NotCallableE', ___R$romejs$js$analysis$types$errors$NotCallableE_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('UndeclaredVarE', ___R$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('UnknownPropE', ___R$romejs$js$analysis$types$errors$UnknownPropE_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('UnknownImportE', ___R$romejs$js$analysis$types$errors$UnknownImportE_ts$default);
  ___R$$priv$romejs$js$analysis$types$index_ts$types.set('MissingUnionE', ___R$romejs$js$analysis$types$errors$MissingUnionE_ts$default);

  // romejs/js-analysis/evaluators/temp/AmbiguousFlowTypeCastExpression.ts

  function ___R$romejs$js$analysis$evaluators$temp$AmbiguousFlowTypeCastExpression_ts$default(node) {
    node = ___R$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/AnyKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$AnyKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$AnyKeywordTypeAnnotation_ts$anyKeywordTypeAnnotation.assert(node);
    return new ___R$romejs$js$analysis$types$AnyT_ts$default(scope, node);
  }

  // romejs/js-analysis/evaluators/expressions/ArrayExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$ArrayExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression.assert(node);
    const elems = [];

    for (const expr of node.elements) {
      if (expr === undefined) {} else {
        elems.push(scope.evaluate(expr));
      }
    }

    let value;
    if (elems.length === 0) {
      value = new ___R$romejs$js$analysis$types$OpenT_ts$default(scope, node);
    } else {
      value = scope.createUnion(elems, node);
    }
    return new ___R$romejs$js$analysis$types$InstanceT_ts$default(scope, node, scope.intrinsics.Array, [value]);
  }

  // romejs/js-analysis/utils/executeAtom.ts

  function ___R$romejs$js$analysis$utils$executeAtom_ts$default(leftNode, rightType, scope) {
    switch (leftNode.type) {
      case 'BindingIdentifier':
        scope.addBinding(leftNode.name, rightType);
        break;

      case 'BindingObjectPattern':
        for (const prop of leftNode.properties) {
          ___R$romejs$js$analysis$utils$executeAtom_ts$default(prop, rightType, scope);
        }
        break;

      case 'BindingObjectPatternProperty':
        {
          const {key: key} = leftNode;
          if (key.type === 'ComputedPropertyKey' ||
          key.value.type !== 'Identifier') {
            throw new Error('unimplemented');
          }

          const propKey = new ___R$romejs$js$analysis$types$StringLiteralT_ts$default(scope, key, key.value.name);
          const getProp = new ___R$romejs$js$analysis$types$GetPropT_ts$default(scope, leftNode, rightType, propKey);
          ___R$romejs$js$analysis$utils$executeAtom_ts$default(leftNode.value, getProp, scope);
          break;
        }

      case 'BindingArrayPattern':
        for (let i = 0; i < leftNode.elements.length; i++) {
          const elem = leftNode.elements[i];
          if (elem === undefined) {
            continue;
          }

          const propKey = new ___R$romejs$js$analysis$types$NumericLiteralT_ts$default(scope, elem, i);
          const getProp = new ___R$romejs$js$analysis$types$GetPropT_ts$default(scope, leftNode, rightType, propKey);
          ___R$romejs$js$analysis$utils$executeAtom_ts$default(elem, getProp, scope);
        }
        break;

      case 'BindingAssignmentPattern':
        ___R$romejs$js$analysis$utils$executeAtom_ts$default(leftNode.left, rightType, scope);
        break;}
  }

  // romejs/js-analysis/utils/executeFunction.ts

  function ___R$romejs$js$analysis$utils$executeFunction_ts$default(node, scope, bindId, thisContext) {
    const {head: head} = node;

    const returns = new ___R$romejs$js$analysis$types$OpenT_ts$default(scope, head.returnType ? head.returnType : node);

    const bodyScope = new ___R$romejs$js$analysis$scopes_ts$FunctionScope({
      parentScope: scope}, {
      thisContext: thisContext ? thisContext : new ___R$romejs$js$analysis$types$VoidT_ts$default(scope, undefined),
      returnType: returns});
    if (head.typeParameters) {
      bodyScope.evaluate(head.typeParameters);
    }

    const params = [];
    let rest;
    for (let paramNode of head.params) {
      let optional = paramNode.meta !== undefined && paramNode.meta.optional === true;
      if (paramNode.type === 'BindingAssignmentPattern') {
        optional = false;
        paramNode = paramNode.left;
      }

      let paramType;
      if (paramNode.meta !== undefined &&
      paramNode.meta.typeAnnotation !== undefined) {
        paramType = scope.evaluate(paramNode.meta.typeAnnotation);
      } else {
        paramType = new ___R$romejs$js$analysis$types$OpenT_ts$default(scope, paramNode);
      }

      if (optional) {
        paramType = new ___R$romejs$js$analysis$types$MaybeT_ts$default(scope, paramNode, paramType);
      }

      params.push(paramType);
    }

    for (let i = 0; i < head.params.length; i++) {
      ___R$romejs$js$analysis$utils$executeAtom_ts$default(head.params[i], params[i], scope);
    }
    const block = bodyScope.evaluate(node.body);

    if (returns.hasConnections() === false) {}

    if (head.returnType) {
      returns.shouldMatch(scope.evaluate(head.returnType));
    }

    const func = new ___R$romejs$js$analysis$types$FunctionT_ts$default(scope, node, {params: params, rest: rest, returns: returns, body: block});
    return func;
  }

  // romejs/js-analysis/evaluators/expressions/ArrowFunctionExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$ArrowFunctionExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression.assert(node);

    let thisContext;
    const funcScope = scope.findOptional(___R$romejs$js$analysis$scopes_ts$FunctionScope);
    if (funcScope !== undefined) {
      thisContext = funcScope.meta.thisContext;
    }

    return ___R$romejs$js$analysis$utils$executeFunction_ts$default(node, scope, true, thisContext);
  }

  // romejs/js-analysis/evaluators/patterns/AssignmentArrayPattern.ts

  function ___R$romejs$js$analysis$evaluators$patterns$AssignmentArrayPattern_ts$default(node, scope) {
    node = ___R$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/patterns/AssignmentAssignmentPattern.ts

  function ___R$romejs$js$analysis$evaluators$patterns$AssignmentAssignmentPattern_ts$default(node) {
    node = ___R$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/AssignmentExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$AssignmentExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.assert(node);

    const {left: left, right: right, operator: operator} = node;

    if (operator === '=') {
      const rightType = scope.evaluate(right);
      const leftType = scope.evaluate(left);
      leftType.shouldMatch(rightType);
      return new ___R$romejs$js$analysis$types$SideEffectT_ts$default(scope, node, rightType);
    } else {}
  }

  // romejs/js-analysis/evaluators/patterns/AssignmentIdentifier.ts

  function ___R$romejs$js$analysis$evaluators$patterns$AssignmentIdentifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/patterns/AssignmentObjectPattern.ts

  function ___R$romejs$js$analysis$evaluators$patterns$AssignmentObjectPattern_ts$default(node, scope) {
    node = ___R$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/patterns/AssignmentObjectPatternProperty.ts

  function ___R$romejs$js$analysis$evaluators$patterns$AssignmentObjectPatternProperty_ts$default(node) {
    node = ___R$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/AwaitExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$AwaitExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/BigIntKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$BigIntKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$BigIntKeywordTypeAnnotation_ts$bigIntKeywordTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/literals/BigIntLiteral.ts

  function ___R$romejs$js$analysis$evaluators$literals$BigIntLiteral_ts$default(node, scope) {
    node = ___R$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/BinaryExpression.ts

  function ___R$$priv$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$maybeRefine(node, left, right, scope) {
    const evaluator = scope.evaluator;

    if (left.type === 'Identifier') {
      scope.addBinding(left.name, evaluator.getTypeFromEvaluatedNode(right));
      return true;
    }

    if (left.type === 'UnaryExpression' &&
    left.operator === 'typeof' &&
    left.argument.type === 'ReferenceIdentifier') {
      const name = left.argument.name;
      const binding = scope.getBinding(name);
      if (binding !== undefined) {
        const type = new ___R$romejs$js$analysis$types$RefineTypeofT_ts$default(scope, node, evaluator.getTypeFromEvaluatedNode(right), binding);
        scope.addBinding(name, type);
        return true;
      }
    }

    return false;
  }

  function ___R$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression.assert(node);

    const left = scope.evaluate(node.left);
    const right = scope.evaluate(node.right);

    switch (node.operator) {
      case '<<':
      case '>>':
      case '>>>':
      case '-':
      case '*':
      case '/':
      case '%':
      case '**':
      case '|':
      case '^':
      case '&':
      case '<':
      case '<=':
      case '>':
      case '>=':
        const num = new ___R$romejs$js$analysis$types$NumericT_ts$default(scope, undefined);
        new ___R$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, node, left, num);
        new ___R$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, node, right, num);
        break;}

    let refinedScope = scope;
    if (node.operator === '===') {
      refinedScope = scope.refine();
      ___R$$priv$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$maybeRefine(node, node.left, node.right, refinedScope) ||
      ___R$$priv$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$maybeRefine(node, node.right, node.left, refinedScope);
    }

    return new ___R$romejs$js$analysis$types$BinaryOpT_ts$default(refinedScope, node, left, node.operator, right);
  }

  // romejs/js-analysis/evaluators/patterns/BindingArrayPattern.ts

  function ___R$romejs$js$analysis$evaluators$patterns$BindingArrayPattern_ts$default(node, scope) {
    node = ___R$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/patterns/BindingAssignmentPattern.ts

  function ___R$romejs$js$analysis$evaluators$patterns$BindingAssignmentPattern_ts$default(node, scope) {
    node = ___R$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/patterns/BindingIdentifier.ts

  function ___R$romejs$js$analysis$evaluators$patterns$BindingIdentifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/patterns/BindingObjectPattern.ts

  function ___R$romejs$js$analysis$evaluators$patterns$BindingObjectPattern_ts$default(node, scope) {
    node = ___R$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/patterns/BindingObjectPatternProperty.ts

  function ___R$romejs$js$analysis$evaluators$patterns$BindingObjectPatternProperty_ts$default(node) {
    node = ___R$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/BlockStatement.ts

  function ___R$$priv$romejs$js$analysis$evaluators$statements$BlockStatement_ts$shouldHoistExecute(node) {
    if (node === undefined) {
      return false;
    }

    if (node.type === 'FunctionDeclaration' || ___R$romejs$js$ast$utils$isTypeNode_ts$default(node)) {
      return true;
    }

    if (node.type === 'ExportNamedDeclaration' ||
    node.type === 'ExportDefaultDeclaration') {
      return ___R$$priv$romejs$js$analysis$evaluators$statements$BlockStatement_ts$shouldHoistExecute(node.declaration);
    }

    return false;
  }

  function ___R$romejs$js$analysis$evaluators$statements$BlockStatement_ts$default(node, scope) {
    node = node.type === 'Program' ? node : ___R$romejs$js$ast$statements$BlockStatement_ts$blockStatement.assert(node);

    for (const child of node.body) {
      if (child.type === 'ImportDeclaration') {
        scope.evaluate(child);
      }

      const declarations = ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(child);
      for (const id of declarations) {
        scope.declareBinding(id.name, id);
      }
    }

    const types = [];

    const body = [];
    for (const child of node.body) {
      if (child.type === 'ImportDeclaration') {} else if (___R$$priv$romejs$js$analysis$evaluators$statements$BlockStatement_ts$shouldHoistExecute(child)) {
        types.push(scope.evaluate(child));
      } else {
        body.push(child);
      }
    }

    for (const child of body) {
      types.push(scope.evaluate(child));
    }

    return new ___R$romejs$js$analysis$types$BlockT_ts$default(scope, node, types);
  }

  // romejs/js-analysis/evaluators/types/BooleanKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$BooleanKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$BooleanKeywordTypeAnnotation_ts$booleanKeywordTypeAnnotation.assert(node);
    return new ___R$romejs$js$analysis$types$BooleanT_ts$default(scope, node);
  }

  // romejs/js-analysis/evaluators/literals/BooleanLiteral.ts

  function ___R$romejs$js$analysis$evaluators$literals$BooleanLiteral_ts$default(node, scope) {
    node = ___R$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral.assert(node);
    return new ___R$romejs$js$analysis$types$BooleanLiteralT_ts$default(scope, node, node.value);
  }

  // romejs/js-analysis/evaluators/types/BooleanLiteralTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$BooleanLiteralTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$BooleanLiteralTypeAnnotation_ts$booleanLiteralTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/BreakStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$BreakStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$BreakStatement_ts$breakStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/CallExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$CallExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$CallExpression_ts$callExpression.assert(node);

    return new ___R$romejs$js$analysis$types$CallT_ts$default(scope, node, scope.evaluate(node.callee), node.arguments.map(arg => {
      return scope.evaluate(arg);
    }));
  }

  // romejs/js-analysis/evaluators/auxiliary/CatchClause.ts

  function ___R$romejs$js$analysis$evaluators$auxiliary$CatchClause_ts$default(node, scope) {
    node = ___R$romejs$js$ast$auxiliary$CatchClause_ts$catchClause.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/classes/ClassExpression.ts

  function ___R$romejs$js$analysis$evaluators$classes$ClassExpression_ts$default(node, scope) {
    node = node.type === 'ClassDeclaration' ? node : ___R$romejs$js$ast$classes$ClassExpression_ts$classExpression.assert(node);

    const instances = [];
    const statics = [];

    const classInstance = new ___R$romejs$js$analysis$types$OpenT_ts$default(scope, node);
    const classId = new ___R$romejs$js$analysis$types$OpenT_ts$default(scope, node);

    const bodyScope = new ___R$romejs$js$analysis$scopes_ts$ClassScope({parentScope: scope}, {
      instance: classInstance,
      static: classId});

    if (node.id !== undefined) {
      bodyScope.addBinding(node.id.name, classId);
    }

    if (node.meta.typeParameters !== undefined) {
      bodyScope.evaluate(node.meta.typeParameters);
    }

    let constructor = undefined;

    for (const bodyNode of node.meta.body) {
      const type = bodyScope.evaluate(bodyNode);

      if (bodyNode.type === 'ClassMethod' && bodyNode.kind === 'constructor') {
        constructor = type;
      } else {
        if (bodyNode.type !== 'TSIndexSignature' &&
        bodyNode.meta.static === true) {
          statics.push(type);
        } else {
          instances.push(type);
        }
      }
    }

    const classOrigin = node.id ? node.id : node;
    let type = new ___R$romejs$js$analysis$types$ClassT_ts$default(scope, classOrigin, {
      constructor: constructor,
      instances: instances,
      statics: statics,
      extends: node.meta.superClass ? scope.evaluate(node.meta.superClass) : undefined});
    if (node.id) {
      type.setHuman(node.id.name);
    }

    classId.shouldMatch(type);

    const instance = new ___R$romejs$js$analysis$types$InstanceT_ts$default(scope, classOrigin, type, []);
    classInstance.shouldMatch(instance);

    return type;
  }

  // romejs/js-analysis/evaluators/classes/ClassDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$classes$ClassDeclaration_ts$default(node, scope) {
    node = ___R$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration.assert(node);
    const type = ___R$romejs$js$analysis$evaluators$classes$ClassExpression_ts$default(node, scope);
    if (node.id) {
      scope.addBinding(node.id.name, type);
    }
    return type;
  }

  // romejs/js-analysis/evaluators/classes/ClassHead.ts

  function ___R$romejs$js$analysis$evaluators$classes$ClassHead_ts$default(node, scope) {
    node = ___R$romejs$js$ast$classes$ClassHead_ts$classHead.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/classes/ClassMethod.ts

  function ___R$romejs$js$analysis$evaluators$classes$ClassMethod_ts$default(node, scope) {
    node = ___R$romejs$js$ast$classes$ClassMethod_ts$classMethod.assert(node);
    if (node.key.type === 'ComputedPropertyKey' === true) {
      return undefined;
    }

    const classScope = scope.find(___R$romejs$js$analysis$scopes_ts$ClassScope);
    const thisContext = node.meta.static === true ? classScope.meta.static : classScope.meta.instance;
    const func = ___R$romejs$js$analysis$utils$executeFunction_ts$default(node, scope, false, thisContext);

    if (node.key.value.type !== 'Identifier') {
      throw new Error('Expected only an identifier key');
    }
    return new ___R$romejs$js$analysis$types$ObjPropT_ts$default(scope, node, node.key.value.name, func);
  }

  // romejs/js-analysis/evaluators/classes/ClassPrivateMethod.ts

  function ___R$romejs$js$analysis$evaluators$classes$ClassPrivateMethod_ts$default(node, scope) {
    node = ___R$romejs$js$ast$classes$ClassPrivateMethod_ts$classPrivateMethod.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/classes/ClassPrivateProperty.ts

  function ___R$romejs$js$analysis$evaluators$classes$ClassPrivateProperty_ts$default(node, scope) {
    node = ___R$romejs$js$ast$classes$ClassPrivateProperty_ts$classPrivateProperty.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/classes/ClassProperty.ts

  function ___R$romejs$js$analysis$evaluators$classes$ClassProperty_ts$default(node, scope) {
    node = ___R$romejs$js$ast$classes$ClassProperty_ts$classProperty.assert(node);

    if (node.key.type === 'ComputedPropertyKey') {
      return undefined;
    }

    const classScope = scope.find(___R$romejs$js$analysis$scopes_ts$ClassScope);
    const funcScope = new ___R$romejs$js$analysis$scopes_ts$ThisScope({parentScope: scope}, classScope.meta.instance);

    let annotatedType;
    let inferredType;

    if (node.typeAnnotation) {
      annotatedType = funcScope.evaluate(node.typeAnnotation);
    }

    if (node.value) {
      inferredType = funcScope.evaluate(node.value);

      if (annotatedType !== undefined) {
        inferredType.shouldMatch(annotatedType);
      }
    }

    if (annotatedType === undefined && inferredType === undefined) {
      inferredType = new ___R$romejs$js$analysis$types$AnyT_ts$default(scope, node);
    }

    const actualValue = annotatedType === undefined ? inferredType : annotatedType;
    if (actualValue === undefined) {
      throw new Error('Expected actual value');
    }

    if (node.key.value.type !== 'Identifier') {
      throw new Error('Expected only an identifier key');
    }

    return new ___R$romejs$js$analysis$types$ObjPropT_ts$default(scope, node, node.key.value.name, actualValue);
  }

  // romejs/js-analysis/evaluators/classes/ClassPropertyMeta.ts

  function ___R$romejs$js$analysis$evaluators$classes$ClassPropertyMeta_ts$default(node, scope) {
    node = ___R$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/core/CommentBlock.ts

  function ___R$romejs$js$analysis$evaluators$core$CommentBlock_ts$default(node, scope) {
    node = ___R$romejs$js$ast$core$CommentBlock_ts$commentBlock.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/core/CommentLine.ts

  function ___R$romejs$js$analysis$evaluators$core$CommentLine_ts$default(node, scope) {
    node = ___R$romejs$js$ast$core$CommentLine_ts$commentLine.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/auxiliary/ComputedMemberProperty.ts

  function ___R$romejs$js$analysis$evaluators$auxiliary$ComputedMemberProperty_ts$default(node, scope) {
    node = ___R$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/objects/ComputedPropertyKey.ts

  function ___R$romejs$js$analysis$evaluators$objects$ComputedPropertyKey_ts$default(node, scope) {
    node = ___R$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/IfStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$IfStatement_ts$default(node, scope) {
    node =
    node.type === 'ConditionalExpression' ? node : ___R$romejs$js$ast$statements$IfStatement_ts$ifStatement.assert(node);

    const test = scope.evaluate(node.test);
    new ___R$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, node, test, new ___R$romejs$js$analysis$types$BooleanT_ts$default(scope, undefined));

    const hasRefinedTest = test.scope instanceof ___R$romejs$js$analysis$scopes_ts$RefineScope;

    const consequentScope = hasRefinedTest ? test.scope : scope;
    const consequent = consequentScope.evaluate(node.consequent);

    if (node.alternate === undefined) {
      return consequent;
    } else {
      const alternateScope = scope.fork();

      return new ___R$romejs$js$analysis$types$UnionT_ts$default(scope, undefined, [consequent, alternateScope.evaluate(node.alternate)]);
    }
  }

  // romejs/js-analysis/evaluators/expressions/ConditionalExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$ConditionalExpression_ts$default(node, scope) {
    return ___R$romejs$js$analysis$evaluators$statements$IfStatement_ts$default(node, scope);
  }

  // romejs/js-analysis/evaluators/statements/ContinueStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$ContinueStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$ContinueStatement_ts$continueStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/DebuggerStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$DebuggerStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$DebuggerStatement_ts$debuggerStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/core/Directive.ts

  function ___R$romejs$js$analysis$evaluators$core$Directive_ts$default(node, scope) {
    node = ___R$romejs$js$ast$core$Directive_ts$directive.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/DoExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$DoExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$DoExpression_ts$doExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/DoWhileStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$DoWhileStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/EmptyKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$EmptyKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$EmptyKeywordTypeAnnotation_ts$emptyKeywordTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/EmptyStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$EmptyStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$EmptyStatement_ts$emptyStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/modules/ExportAllDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$modules$ExportAllDeclaration_ts$default(node, scope, {evaluator: evaluator}) {
    node = ___R$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration.assert(node);
    evaluator.addExportAll(node.source.value);
  }

  // romejs/js-analysis/evaluators/modules/ExportDefaultDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$modules$ExportDefaultDeclaration_ts$default(node, scope, {evaluator: evaluator}) {
    node = ___R$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration.assert(node);

    const decl = node.declaration;
    const declType = scope.evaluate(decl);
    evaluator.addExport('default', declType);
    return declType;
  }

  // romejs/js-analysis/evaluators/modules/ExportDefaultSpecifier.ts

  function ___R$romejs$js$analysis$evaluators$modules$ExportDefaultSpecifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/modules/ExportNamedDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$modules$ExportNamedDeclaration_ts$default(node, scope, {evaluator: evaluator}) {
    node = ___R$romejs$js$ast$modules$ExportNamedDeclaration_ts$exportNamedDeclaration.assert(node);

    const decl = node.declaration;
    if (decl !== undefined) {
      const declType = scope.evaluate(decl);

      switch (decl.type) {
        case 'FunctionDeclaration':
        case 'ClassDeclaration':
          const id = decl.id;
          if (id === undefined) {
            throw new Error('Expected id');
          }
          evaluator.addExport(id.name, declType);
          break;

        case 'VariableDeclarationStatement':
          for (const id of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(decl)) {
            const type = scope.getBinding(id.name);
            if (type === undefined) {
              throw new Error('Couldn\'t find binding type for ' + id.name);
            }
            evaluator.addExport(id.name, type);
          }
          break;

        case 'TypeAliasTypeAnnotation':
        case 'TypeAliasTypeAnnotation':
          const type = scope.getBinding(decl.id.name);
          if (type === undefined) {
            throw new Error('Couldn\'t find binding type for ' + decl.id.name);
          }
          evaluator.addExport(decl.id.name, type);
          break;}

      return declType;
    }

    const source = node.source === undefined ? undefined : node.source.value;
    const {specifiers: specifiers} = node;
    if (specifiers !== undefined) {
      for (const specifier of specifiers) {
        if (specifier.type === 'ExportSpecifier') {
          let type;
          if (source === undefined) {
            type = scope.evaluate(specifier.local);
          } else {
            type = new ___R$romejs$js$analysis$types$ImportT_ts$default(scope, node, {
              importedName: specifier.local.name,
              source: source});
          }
          evaluator.addExport(specifier.exported.name, type);
        }
      }
    }
  }

  // romejs/js-analysis/evaluators/modules/ExportNamespaceSpecifier.ts

  function ___R$romejs$js$analysis$evaluators$modules$ExportNamespaceSpecifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/modules/ExportSpecifier.ts

  function ___R$romejs$js$analysis$evaluators$modules$ExportSpecifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$modules$ExportSpecifier_ts$exportSpecifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/ExpressionStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$ExpressionStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement.assert(node);

    return scope.evaluate(node.expression);
  }

  // romejs/js-analysis/evaluators/flow/FlowArrayTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowArrayTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowArrayTypeAnnotation_ts$flowArrayTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowClassImplements.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowClassImplements_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowClassImplements_ts$flowClassImplements.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowDeclareClass.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclareClass_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclareClass_ts$flowDeclareClass.assert(node);
    const bodyScope = scope.fork();
    if (node.typeParameters) {
      bodyScope.evaluate(node.typeParameters);
    }

    const calls = [];
    const instances = [];
    const statics = [];

    for (const propNode of node.body.properties) {
      const prop = bodyScope.evaluate(propNode);
      if (propNode.type !== 'FlowObjectTypeSpreadProperty' &&
      propNode.static === true) {
        statics.push(prop);
      } else if (propNode.type === 'FlowObjectTypeCallProperty') {
        calls.push(scope.evaluate(propNode));
      } else {
        instances.push(prop);
      }
    }

    let xtends = undefined;
    if (node.extends.length > 0) {
      xtends = scope.evaluate(node.extends[0]);
    }

    const type = new ___R$romejs$js$analysis$types$ClassT_ts$default(bodyScope, node.id, {
      constructor: undefined,
      instances: instances,
      statics: statics,
      extends: xtends,
      calls: calls});
    scope.addBinding(node.id.name, type);
    type.setHuman(node.id.name);
    return type;
  }

  // romejs/js-analysis/evaluators/flow/FlowDeclaredPredicate.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclaredPredicate_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclaredPredicate_ts$flowDeclaredPredicate.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowDeclareExportAll.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclareExportAll_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclareExportAll_ts$flowDeclareExportAll.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowDeclareExportDefault.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclareExportDefault_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclareExportDefault_ts$flowDeclareExportDefault.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowDeclareExportNamed.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclareExportNamed_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclareExportNamed_ts$flowDeclareExportNamed.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowDeclareFunction.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclareFunction_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclareFunction_ts$flowDeclareFunction.assert(node);

    return scope.addBinding(
    node.id.name,
    scope.evaluate(node.id.meta.typeAnnotation));
  }

  // romejs/js-analysis/evaluators/flow/FlowInterfaceDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowInterfaceDeclaration_ts$default(node, scope) {
    node =
    node.type === 'FlowDeclareInterface' ? node : ___R$romejs$js$ast$flow$FlowInterfaceDeclaration_ts$flowInterfaceDeclaration.assert(node);

    const typeScope = scope.fork();
    if (node.typeParameters) {
      typeScope.evaluate(node.typeParameters);
    }

    const body = typeScope.evaluate(node.body);
    scope.addBinding(node.id.name, body);
    return body;
  }

  // romejs/js-analysis/evaluators/flow/FlowDeclareInterface.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclareInterface_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclareInterface_ts$flowDeclareInterface.assert(node);
    return ___R$romejs$js$analysis$evaluators$flow$FlowInterfaceDeclaration_ts$default(node, scope);
  }

  // romejs/js-analysis/evaluators/flow/FlowDeclareModule.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclareModule_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclareModule_ts$flowDeclareModule.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowDeclareModuleExports.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclareModuleExports_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclareModuleExports_ts$flowDeclareModuleExports.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/types/OpaqueT.ts

  class ___R$romejs$js$analysis$types$OpaqueT_ts$default extends ___R$romejs$js$analysis$types$T_ts$default {
    constructor(scope, originNode, name) {
      super(scope, originNode);
      this.name = name;
    }

    serialize() {
      return {name: this.name};
    }

    static hydrate(scope, originNode, data) {
      return new ___R$romejs$js$analysis$types$OpaqueT_ts$default(scope, originNode, String(data.name));
    }

    humanize() {
      return 'opaque ' + this.name;
    }

    compatibleWith(otherType) {
      return otherType === this;
    }
  }
  ___R$romejs$js$analysis$types$OpaqueT_ts$default.type = 'OpaqueT';

  // romejs/js-analysis/evaluators/flow/FlowDeclareOpaqueType.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclareOpaqueType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclareOpaqueType_ts$flowDeclareOpaqueType.assert(node);

    return new ___R$romejs$js$analysis$types$OpaqueT_ts$default(scope, node.id, node.id.name);
  }

  // romejs/js-analysis/evaluators/flow/FlowDeclareVariable.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowDeclareVariable_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowDeclareVariable_ts$flowDeclareVariable.assert(node);

    const {id: id} = node;
    if (id.meta === undefined) {
      throw new Error('TODO');
    }

    const type = scope.evaluate(id.meta.typeAnnotation);
    scope.addBinding(id.name, type);
    return type;
  }

  // romejs/js-analysis/evaluators/flow/FlowExistsTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowExistsTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowExistsTypeAnnotation_ts$flowExistsTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowFunctionTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowFunctionTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowFunctionTypeAnnotation_ts$flowFunctionTypeAnnotation.assert(node);

    const bodyScope = scope.fork();
    if (node.typeParameters) {
      bodyScope.evaluate(node.typeParameters);
    }

    const params = [];
    let rest;
    for (const paramNode of node.params) {
      let paramType = bodyScope.evaluate(paramNode.meta.typeAnnotation);
      if (paramNode.meta.optional === true) {
        paramType = new ___R$romejs$js$analysis$types$MaybeT_ts$default(scope, paramNode, paramType);
      }
      params.push(paramType);
    }
    if (node.rest !== undefined) {
      rest = bodyScope.evaluate(node.rest.meta.typeAnnotation);
    }

    const returns = bodyScope.evaluate(node.returnType);

    return new ___R$romejs$js$analysis$types$FunctionT_ts$default(scope, node, {params: params, rest: rest, returns: returns, body: undefined});
  }

  // romejs/js-analysis/evaluators/flow/FlowFunctionTypeParam.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowFunctionTypeParam_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowFunctionTypeParam_ts$flowFunctionTypeParam.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowGenericTypeAnnotation.ts

  function ___R$$priv$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node) {
    if (node.type === 'Identifier') {
      return node.name;
    } else {
      return ___R$$priv$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node.id) + '.' + ___R$$priv$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node.qualification);
    }
  }

  function ___R$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowGenericTypeAnnotation_ts$flowGenericTypeAnnotation.assert(node);

    return new ___R$romejs$js$analysis$types$GenericT_ts$default(scope, node, ___R$$priv$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$getName(node.id), scope.evaluate(node.id));
  }

  // romejs/js-analysis/evaluators/flow/FlowInferredPredicate.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowInferredPredicate_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowInferredPredicate_ts$flowInferredPredicate.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowInterface.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowInterface_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowInterface_ts$flowInterface.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowInterfaceExtends.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowInterfaceExtends_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowInterfaceExtends_ts$flowInterfaceExtends.assert(node);

    return scope.evaluate(node.id);
  }

  // romejs/js-analysis/evaluators/flow/FlowInterfaceTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowInterfaceTypeAnnotation_ts$default() {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowNullableTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowNullableTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowNullableTypeAnnotation_ts$flowNullableTypeAnnotation.assert(node);
    return new ___R$romejs$js$analysis$types$MaybeT_ts$default(scope, node, scope.evaluate(node.typeAnnotation));
  }

  // romejs/js-analysis/evaluators/flow/FlowNumericLiteral.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowNumericLiteral_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowNumericLiteral_ts$flowNumericLiteral.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowObjectTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowObjectTypeAnnotation_ts$flowObjectTypeAnnotation.assert(node);

    const props = [];
    const calls = [];

    for (const prop of node.properties) {
      props.push(scope.evaluate(prop));
    }

    return new ___R$romejs$js$analysis$types$ObjT_ts$default(scope, node, {
      props: props,
      proto: scope.intrinsics.ObjectPrototype,
      calls: calls});
  }

  // romejs/js-analysis/evaluators/flow/FlowObjectTypeCallProperty.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeCallProperty_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowObjectTypeCallProperty_ts$flowObjectTypeCallProperty.assert(node);

    return scope.evaluate(node.value);
  }

  // romejs/js-analysis/evaluators/flow/FlowObjectTypeIndexer.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeIndexer_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowObjectTypeIndexer_ts$flowObjectTypeIndexer.assert(node);

    return new ___R$romejs$js$analysis$types$ObjIndexPropT_ts$default(scope, node, scope.evaluate(node.key), scope.evaluate(node.value));
  }

  // romejs/js-analysis/evaluators/flow/FlowObjectTypeInternalSlot.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeInternalSlot_ts$default() {
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowObjectTypeProperty.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeProperty_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowObjectTypeProperty_ts$flowObjectTypeProperty.assert(node);

    const {key: key, value: value} = node;

    let keyStr;
    if (key.type === 'Identifier') {
      keyStr = key.name;
    } else if (key.type === 'StringLiteral') {
      keyStr = key.value;
    } else {
      throw new Error('Unknown property key');
    }

    return new ___R$romejs$js$analysis$types$ObjPropT_ts$default(scope, node, keyStr, scope.evaluate(value));
  }

  // romejs/js-analysis/evaluators/flow/FlowObjectTypeSpreadProperty.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeSpreadProperty_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowObjectTypeSpreadProperty_ts$flowObjectTypeSpreadProperty.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowOpaqueType.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowOpaqueType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowOpaqueType_ts$flowOpaqueType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowQualifiedTypeIdentifier.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowQualifiedTypeIdentifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowQualifiedTypeIdentifier_ts$flowQualifiedTypeIdentifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowThisTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowThisTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowThisTypeAnnotation_ts$flowThisTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowTupleTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowTupleTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowTupleTypeAnnotation_ts$flowTupleTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowTypeCastExpression.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowTypeCastExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowTypeCastExpression_ts$flowTypeCastExpression.assert(node);
    const expressionType = scope.evaluate(node.expression);
    const assertedType = scope.evaluate(node.typeAnnotation);
    new ___R$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, node, expressionType, assertedType);
    return assertedType;
  }

  // romejs/js-analysis/evaluators/flow/FlowTypeofTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowTypeofTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowTypeofTypeAnnotation_ts$flowTypeofTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowTypeParameter.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowTypeParameter_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowTypeParameter_ts$flowTypeParameter.assert(node);
    const type = new ___R$romejs$js$analysis$types$AnyT_ts$default(scope, node);
    scope.addBinding(node.name, type);
    return type;
  }

  // romejs/js-analysis/evaluators/flow/FlowTypeParameterDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowTypeParameterDeclaration_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowTypeParameterDeclaration_ts$flowTypeParameterDeclaration.assert(node);

    for (const param of node.params) {
      scope.evaluate(param);
    }
  }

  // romejs/js-analysis/evaluators/flow/FlowTypeParameterInstantiation.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowTypeParameterInstantiation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowTypeParameterInstantiation_ts$flowTypeParameterInstantiation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/flow/FlowVariance.ts

  function ___R$romejs$js$analysis$evaluators$flow$FlowVariance_ts$default(node, scope) {
    node = ___R$romejs$js$ast$flow$FlowVariance_ts$flowVariance.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/ForInStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$ForInStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$ForInStatement_ts$forInStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/ForOfStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$ForOfStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/ForStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$ForStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$ForStatement_ts$forStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/FunctionDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$statements$FunctionDeclaration_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration.assert(node);

    const func = ___R$romejs$js$analysis$utils$executeFunction_ts$default(node, scope, false);
    if (node.id !== undefined) {
      scope.addBinding(node.id.name, func);
    }
    return func;
  }

  // romejs/js-analysis/evaluators/expressions/FunctionExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$FunctionExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression.assert(node);
    return ___R$romejs$js$analysis$utils$executeFunction_ts$default(node, scope, true);
  }

  // romejs/js-analysis/evaluators/auxiliary/FunctionHead.ts

  function ___R$romejs$js$analysis$evaluators$auxiliary$FunctionHead_ts$default(node, scope) {
    node = ___R$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/auxiliary/Identifier.ts

  function ___R$romejs$js$analysis$evaluators$auxiliary$Identifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.assert(node);

    const binding = scope.getBinding(node.name);
    if (binding) {
      const type = new ___R$romejs$js$analysis$types$OpenT_ts$default(scope, node);
      type.shouldMatch(binding);
      return type;
    } else {
      switch (node.name) {
        case 'React$PropType$Primitive':
        case 'React$PropType$ArrayOf':
        case 'React$PropType$InstanceOf':
        case 'React$PropType$ObjectOf':
        case 'React$PropType$OneOf':
        case 'React$PropType$OneOfType':
        case 'React$PropTypePartial':
        case 'React$ElementProps':
        case 'React$ElementRef':
        case '$Exact':
        case 'Partial':
        case '$Keys':
        case 'Object$Assign':
        case 'Object$GetPrototypeOf':
        case 'Object$SetPrototypeOf':
        case '$CharSet':
        case 'Class':
        case '$Compose':
        case '$ComposeReverse':
        case '$Subtype':
        case 'Function$Prototype$Apply':
        case 'Function$Prototype$Bind':
        case 'Function$Prototype$Call':
        case '$Exports':
          return new ___R$romejs$js$analysis$types$AnyT_ts$default(scope, node);

        default:
          return new ___R$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default(scope, node, node.name);}
    }
  }

  // romejs/js-analysis/evaluators/modules/ImportCall.ts

  function ___R$romejs$js$analysis$evaluators$modules$ImportCall_ts$default(node, scope) {
    node = ___R$romejs$js$ast$modules$ImportCall_ts$importCall.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/modules/ImportDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$modules$ImportDeclaration_ts$default(node, scope) {
    node = ___R$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration.assert(node);

    const source = node.source.value;

    const {specifiers: specifiers} = node;
    if (specifiers !== undefined) {
      for (const specifier of specifiers) {
        if (specifier.type === 'ImportSpecifier') {
          const localName = specifier.local.name.name;
          const importedName = specifier.imported.name;

          const open = new ___R$romejs$js$analysis$types$ImportT_ts$default(scope, specifier, {
            importedName: importedName,
            source: source});
          scope.addBinding(localName, open);
        } else if (specifier.type === 'ImportDefaultSpecifier') {
          const localName = specifier.local.name.name;
          const open = new ___R$romejs$js$analysis$types$ImportT_ts$default(scope, specifier, {
            importedName: 'default',
            source: source});
          scope.addBinding(localName, open);
        } else if (specifier.type === 'ImportNamespaceSpecifier') {
          const localName = specifier.local.name.name;
          const open = new ___R$romejs$js$analysis$types$ImportT_ts$default(scope, specifier, {
            importedName: undefined,
            source: source});
          scope.addBinding(localName, open);
        } else {}
      }
    }
  }

  // romejs/js-analysis/evaluators/modules/ImportDefaultSpecifier.ts

  function ___R$romejs$js$analysis$evaluators$modules$ImportDefaultSpecifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/modules/ImportNamespaceSpecifier.ts

  function ___R$romejs$js$analysis$evaluators$modules$ImportNamespaceSpecifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/modules/ImportSpecifier.ts

  function ___R$romejs$js$analysis$evaluators$modules$ImportSpecifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/modules/ImportSpecifierLocal.ts

  function ___R$romejs$js$analysis$evaluators$modules$ImportSpecifierLocal_ts$default(node, scope) {
    node = ___R$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/core/InterpreterDirective.ts

  function ___R$romejs$js$analysis$evaluators$core$InterpreterDirective_ts$default(node, scope) {
    node = ___R$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/IntersectionTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$IntersectionTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$IntersectionTypeAnnotation_ts$intersectionTypeAnnotation.assert(node);

    return new ___R$romejs$js$analysis$types$IntersectionT_ts$default(scope, node, node.types.map(type => {
      return scope.evaluate(type);
    }));
  }

  // romejs/js-analysis/evaluators/jsx/JSXAttribute.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXAttribute_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXElement.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXElement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXElement_ts$jsxElement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXEmptyExpression.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXEmptyExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXExpressionContainer.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXExpressionContainer_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXFragment.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXFragment_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXIdentifier.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXIdentifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXMemberExpression.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXMemberExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXNamespacedName.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXNamespacedName_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXReferenceIdentifier.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXReferenceIdentifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXSpreadAttribute.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXSpreadAttribute_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXSpreadChild.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXSpreadChild_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/jsx/JSXText.ts

  function ___R$romejs$js$analysis$evaluators$jsx$JSXText_ts$default(node, scope) {
    node = ___R$romejs$js$ast$jsx$JSXText_ts$jsxText.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/LabeledStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$LabeledStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/LogicalExpression.ts

  function ___R$$priv$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$uniq(args) {
    return [...new Set(args)];
  }

  function ___R$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression.assert(node);

    switch (node.operator) {
      case '||':
        {
          const left = scope.refine().evaluate(node.left);
          const right = scope.refine().evaluate(node.right);

          const refinedScope = scope.refine();
          const refinedNames = ___R$$priv$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$uniq([...left.scope.getOwnBindingNames(), ...right.scope.getOwnBindingNames()]);
          const mergeScopes = [left.scope, right.scope];
          for (const name of refinedNames) {
            const rawTypes = new Set();
            for (const scope of mergeScopes) {
              const binding = scope.getBinding(name);
              if (binding !== undefined) {
                rawTypes.add(binding);
              }
            }

            const types = Array.from(rawTypes);
            refinedScope.addBinding(name, refinedScope.createUnion(types));
          }

          return new ___R$romejs$js$analysis$types$UnionT_ts$default(refinedScope, node, [left, right]);
        }

      case '&&':
        {
          const left = scope.evaluate(node.left);
          const right = left.scope.evaluate(node.right);
          return new ___R$romejs$js$analysis$types$UnionT_ts$default(right.scope, node, [left, right]);
        }

      default:
        throw new Error('Unknown operator');}
  }

  // romejs/js-analysis/evaluators/expressions/MemberExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$MemberExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.assert(node);
    if (node.property.type === 'ComputedMemberProperty') {
      throw new Error('Computed properties not supportd yet');
    }

    if (node.property.value.type === 'PrivateName') {
      throw new Error('PrivateName in static member not supported yet');
    }

    const prop = new ___R$romejs$js$analysis$types$StringLiteralT_ts$default(scope, node.property.value, node.property.value.name);
    return new ___R$romejs$js$analysis$types$GetPropT_ts$default(scope, node, scope.evaluate(node.object), prop);
  }

  // romejs/js-analysis/evaluators/expressions/MetaProperty.ts

  function ___R$romejs$js$analysis$evaluators$expressions$MetaProperty_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$MetaProperty_ts$metaProperty.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/MixedKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$MixedKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$MixedKeywordTypeAnnotation_ts$mixedKeywordTypeAnnotation.assert(node);
    return new ___R$romejs$js$analysis$types$MixedT_ts$default(scope, node);
  }

  // romejs/js-analysis/evaluators/temp/MockParent.ts

  function ___R$romejs$js$analysis$evaluators$temp$MockParent_ts$default(node, scope) {
    node = ___R$romejs$js$ast$temp$MockParent_ts$mockParent.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/NeverKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$NeverKeywordTypeAnnotation_ts$default(node) {
    node = ___R$romejs$js$ast$types$NeverKeywordTypeAnnotation_ts$neverKeywordTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/NewExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$NewExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$NewExpression_ts$newExpression.assert(node);
    return new ___R$romejs$js$analysis$types$InstanceT_ts$default(scope, node, scope.evaluate(node.callee), []);
  }

  // romejs/js-analysis/evaluators/types/NullKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$NullKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$NullKeywordTypeAnnotation_ts$nullKeywordTypeAnnotation.assert(node);
    return new ___R$romejs$js$analysis$types$NullT_ts$default(scope, node);
  }

  // romejs/js-analysis/evaluators/literals/NullLiteral.ts

  function ___R$romejs$js$analysis$evaluators$literals$NullLiteral_ts$default(node, scope) {
    node = node = ___R$romejs$js$ast$literals$NullLiteral_ts$nullLiteral.assert(node);
    return new ___R$romejs$js$analysis$types$NullT_ts$default(scope, node);
  }

  // romejs/js-analysis/evaluators/types/NumberKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$NumberKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$NumberKeywordTypeAnnotation_ts$numberKeywordTypeAnnotation.assert(node);
    return new ___R$romejs$js$analysis$types$NumericT_ts$default(scope, node);
  }

  // romejs/js-analysis/evaluators/literals/NumericLiteral.ts

  function ___R$romejs$js$analysis$evaluators$literals$NumericLiteral_ts$default(node, scope) {
    node = ___R$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral.assert(node);
    return new ___R$romejs$js$analysis$types$NumericLiteralT_ts$default(scope, node, node.value);
  }

  // romejs/js-analysis/evaluators/types/NumericLiteralTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$NumericLiteralTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$NumericLiteralTypeAnnotation_ts$numericLiteralTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/objects/ObjectExpression.ts

  function ___R$romejs$js$analysis$evaluators$objects$ObjectExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.assert(node);
    const props = [];

    for (const prop of node.properties) {
      if (prop.type === 'SpreadProperty') {} else if (prop.type === 'ObjectProperty') {
        if (prop.key.type === 'ComputedPropertyKey') {} else {
          const {
            key: {value: key},
            value: value} = prop;

          let keyStr;
          if (key.type === 'Identifier') {
            keyStr = key.name;
          } else {
            continue;
          }

          if (keyStr === undefined) {
            throw new Error('Expected keyStr');
          }

          props.push(new ___R$romejs$js$analysis$types$ObjPropT_ts$default(scope, prop, keyStr, scope.evaluate(value)));
        }
      } else {}
    }

    return new ___R$romejs$js$analysis$types$ObjT_ts$default(scope, node, {
      calls: [],
      props: props,
      proto: scope.intrinsics.ObjectPrototype});
  }

  // romejs/js-analysis/evaluators/types/ObjectKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$ObjectKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$ObjectKeywordTypeAnnotation_ts$objectKeywordTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/objects/ObjectMethod.ts

  function ___R$romejs$js$analysis$evaluators$objects$ObjectMethod_ts$default(node, scope) {
    node = ___R$romejs$js$ast$objects$ObjectMethod_ts$objectMethod.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/objects/ObjectProperty.ts

  function ___R$romejs$js$analysis$evaluators$objects$ObjectProperty_ts$default(node, scope) {
    node = ___R$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/OptionalCallExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$OptionalCallExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/patterns/PatternMeta.ts

  function ___R$romejs$js$analysis$evaluators$patterns$PatternMeta_ts$default(node, scope) {
    node = ___R$romejs$js$ast$patterns$PatternMeta_ts$patternMeta.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/classes/PrivateName.ts

  function ___R$romejs$js$analysis$evaluators$classes$PrivateName_ts$default(node, scope) {
    node = ___R$romejs$js$ast$classes$PrivateName_ts$privateName.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/core/Program.ts

  function ___R$romejs$js$analysis$evaluators$core$Program_ts$default(node, scope) {
    node = ___R$romejs$js$ast$core$Program_ts$program.assert(node);
    ___R$romejs$js$analysis$evaluators$statements$BlockStatement_ts$default(node, scope);
  }

  // romejs/js-analysis/evaluators/expressions/ReferenceIdentifier.ts

  function ___R$romejs$js$analysis$evaluators$expressions$ReferenceIdentifier_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/literals/RegExpLiteral.ts

  function ___R$romejs$js$analysis$evaluators$literals$RegExpLiteral_ts$default(node, scope) {
    node = ___R$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/ReturnStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$ReturnStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.assert(node);
    const funcScope = scope.find(___R$romejs$js$analysis$scopes_ts$FunctionScope);
    if (node.argument === undefined) {} else {
      const type = scope.evaluate(node.argument);
      funcScope.meta.returnType.shouldMatch(type);
    }
  }

  // romejs/js-analysis/evaluators/expressions/SequenceExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$SequenceExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/auxiliary/SpreadElement.ts

  function ___R$romejs$js$analysis$evaluators$auxiliary$SpreadElement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/objects/SpreadProperty.ts

  function ___R$romejs$js$analysis$evaluators$objects$SpreadProperty_ts$default(node, scope) {
    node = ___R$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/auxiliary/StaticMemberProperty.ts

  function ___R$romejs$js$analysis$evaluators$auxiliary$StaticMemberProperty_ts$default(node, scope) {
    node = ___R$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/objects/StaticPropertyKey.ts

  function ___R$romejs$js$analysis$evaluators$objects$StaticPropertyKey_ts$default(node, scope) {
    node = ___R$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/StringKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$StringKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$StringKeywordTypeAnnotation_ts$stringKeywordTypeAnnotation.assert(node);
    return new ___R$romejs$js$analysis$types$StringT_ts$default(scope, node);
  }

  // romejs/js-analysis/evaluators/literals/StringLiteral.ts

  function ___R$romejs$js$analysis$evaluators$literals$StringLiteral_ts$default(node, scope) {
    node = ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.assert(node);
    return new ___R$romejs$js$analysis$types$StringLiteralT_ts$default(scope, node, node.value);
  }

  // romejs/js-analysis/evaluators/types/StringLiteralTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$StringLiteralTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$StringLiteralTypeAnnotation_ts$stringLiteralTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/Super.ts

  function ___R$romejs$js$analysis$evaluators$expressions$Super_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$Super_ts$_super.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/auxiliary/SwitchCase.ts

  function ___R$romejs$js$analysis$evaluators$auxiliary$SwitchCase_ts$default(node, scope) {
    node = ___R$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/SwitchStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$SwitchStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$SwitchStatement_ts$switchStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/SymbolKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$SymbolKeywordTypeAnnotation_ts$default(node) {
    node = ___R$romejs$js$ast$types$SymbolKeywordTypeAnnotation_ts$symbolKeywordTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/TaggedTemplateExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$TaggedTemplateExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/auxiliary/TemplateElement.ts

  function ___R$romejs$js$analysis$evaluators$auxiliary$TemplateElement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/literals/TemplateLiteral.ts

  function ___R$romejs$js$analysis$evaluators$literals$TemplateLiteral_ts$default(node, scope) {
    node = ___R$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral.assert(node);
    for (const expr of node.expressions) {
      new ___R$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, expr, scope.evaluate(expr), new ___R$romejs$js$analysis$types$StringT_ts$default(scope, undefined));
    }
    return new ___R$romejs$js$analysis$types$StringT_ts$default(scope, node);
  }

  // romejs/js-analysis/evaluators/types/TemplateLiteralTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$TemplateLiteralTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$TemplateLiteralTypeAnnotation_ts$templateLiteralTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/ThisExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$ThisExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$ThisExpression_ts$thisExpression.assert(node);
    const thisScope = scope.find(___R$romejs$js$analysis$scopes_ts$ThisScope);
    if (thisScope === undefined) {} else {
      const type = new ___R$romejs$js$analysis$types$OpenT_ts$default(scope, node);
      type.shouldMatch(thisScope.context);
      return type;
    }
  }

  // romejs/js-analysis/evaluators/statements/ThrowStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$ThrowStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$ThrowStatement_ts$throwStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/TryStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$TryStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$TryStatement_ts$tryStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSArrayType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSArrayType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSAsExpression.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSAsExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSAssignmentAsExpression.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSAssignmentAsExpression_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSAssignmentNonNullExpression.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSAssignmentNonNullExpression_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSAssignmentTypeAssertion.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSAssignmentTypeAssertion_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSCallSignatureDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSCallSignatureDeclaration_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSConditionalType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSConditionalType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSConstructorType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSConstructorType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSConstructSignatureDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSConstructSignatureDeclaration_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSDeclareFunction.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSDeclareFunction_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSDeclareMethod.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSDeclareMethod_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSEnumDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSEnumDeclaration_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSEnumMember.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSEnumMember_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSExportAssignment.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSExportAssignment_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSExpressionWithTypeArguments.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSExpressionWithTypeArguments_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSExternalModuleReference.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSExternalModuleReference_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSFunctionType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSFunctionType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSImportEqualsDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSImportEqualsDeclaration_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSImportType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSImportType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSImportType_ts$tsImportType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSIndexedAccessType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSIndexedAccessType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSIndexSignature.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSIndexSignature_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSInferType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSInferType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSInferType_ts$tsInferType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSInterfaceBody.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSInterfaceBody_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSInterfaceDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSInterfaceDeclaration_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSMappedType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSMappedType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSMethodSignature.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSMethodSignature_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSModuleBlock.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSModuleBlock_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSModuleDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSModuleDeclaration_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSNamespaceExportDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSNamespaceExportDeclaration_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSNonNullExpression.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSNonNullExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSOptionalType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSOptionalType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSParenthesizedType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSParenthesizedType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSPropertySignature.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSPropertySignature_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSQualifiedName.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSQualifiedName_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSSignatureDeclarationMeta.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSSignatureDeclarationMeta_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSThisType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSThisType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSThisType_ts$tsThisType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSTupleType.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSTupleType_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSTypeAssertion.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSTypeAssertion_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSTypeLiteral.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSTypeLiteral_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSTypeOperator.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSTypeOperator_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSTypeParameter.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSTypeParameter_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSTypeParameterDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSTypeParameterDeclaration_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSTypeParameterInstantiation.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSTypeParameterInstantiation_ts$default(node) {
    node = ___R$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSTypePredicate.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSTypePredicate_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSTypeQuery.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSTypeQuery_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/typescript/TSTypeReference.ts

  function ___R$romejs$js$analysis$evaluators$typescript$TSTypeReference_ts$default(node, scope) {
    node = ___R$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/TypeAliasTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$TypeAliasTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation.assert(node);

    const typeScope = scope.fork();
    if (node.typeParameters) {
      typeScope.evaluate(node.typeParameters);
    }

    const right = typeScope.evaluate(node.right);
    scope.addBinding(node.id.name, right);
    return right;
  }

  // romejs/js-analysis/evaluators/expressions/UnaryExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$UnaryExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression.assert(node);
    const argType = scope.evaluate(node.argument);

    switch (node.operator) {
      case 'delete':
      case '!':
        return new ___R$romejs$js$analysis$types$BooleanT_ts$default(scope, node);

      case '+':
      case '-':
      case '~':
        return new ___R$romejs$js$analysis$types$NumericT_ts$default(scope, node);

      case 'typeof':
        return new ___R$romejs$js$analysis$types$TypeofT_ts$default(scope, node, argType);

      case 'void':
        return new ___R$romejs$js$analysis$types$VoidT_ts$default(scope, node);

      case 'throw':
        break;}
  }

  // romejs/js-analysis/evaluators/types/UndefinedKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$UndefinedKeywordTypeAnnotation_ts$default(node) {
    node = ___R$romejs$js$ast$types$UndefinedKeywordTypeAnnotation_ts$undefinedKeywordTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/UnionTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$UnionTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$UnionTypeAnnotation_ts$unionTypeAnnotation.assert(node);

    return new ___R$romejs$js$analysis$types$UnionT_ts$default(scope, node, node.types.map(type => {
      return scope.evaluate(type);
    }));
  }

  // romejs/js-analysis/evaluators/types/UnknownKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$UnknownKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$UnknownKeywordTypeAnnotation_ts$unknownKeywordTypeAnnotation.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/UpdateExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$UpdateExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression.assert(node);
    const type = new ___R$romejs$js$analysis$types$NumericT_ts$default(scope, node);
    new ___R$romejs$js$analysis$types$ExhaustiveT_ts$default(scope, node.argument, scope.evaluate(node.argument), type);
    return type;
  }

  // romejs/js-analysis/evaluators/auxiliary/VariableDeclaration.ts

  function ___R$romejs$js$analysis$evaluators$auxiliary$VariableDeclaration_ts$default(node, scope) {
    node = ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.assert(node);

    for (const declarator of node.declarations) {
      const {id: id, init: init} = declarator;
      let inferredType;

      if (init === undefined) {
        inferredType = new ___R$romejs$js$analysis$types$OpenT_ts$default(scope, declarator);
        inferredType.shouldMatch(new ___R$romejs$js$analysis$types$VoidT_ts$default(scope, declarator));
      } else {
        inferredType = scope.evaluate(init);
      }

      let actualType = inferredType;

      if (id.meta !== undefined && id.meta.typeAnnotation !== undefined) {
        const annotatedType = scope.evaluate(id.meta.typeAnnotation);
        inferredType.shouldMatch(annotatedType);
        actualType = annotatedType;
      }

      ___R$romejs$js$analysis$utils$executeAtom_ts$default(id, actualType, scope);
    }
  }

  // romejs/js-analysis/evaluators/statements/VariableDeclarationStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$VariableDeclarationStatement_ts$default(node) {
    node = ___R$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/auxiliary/VariableDeclarator.ts

  function ___R$romejs$js$analysis$evaluators$auxiliary$VariableDeclarator_ts$default(node, scope) {
    node = ___R$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/types/VoidKeywordTypeAnnotation.ts

  function ___R$romejs$js$analysis$evaluators$types$VoidKeywordTypeAnnotation_ts$default(node, scope) {
    node = ___R$romejs$js$ast$types$VoidKeywordTypeAnnotation_ts$voidKeywordTypeAnnotation.assert(node);
    return new ___R$romejs$js$analysis$types$VoidT_ts$default(scope, node);
  }

  // romejs/js-analysis/evaluators/statements/WhileStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$WhileStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$WhileStatement_ts$whileStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/statements/WithStatement.ts

  function ___R$romejs$js$analysis$evaluators$statements$WithStatement_ts$default(node, scope) {
    node = ___R$romejs$js$ast$statements$WithStatement_ts$withStatement.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/expressions/YieldExpression.ts

  function ___R$romejs$js$analysis$evaluators$expressions$YieldExpression_ts$default(node, scope) {
    node = ___R$romejs$js$ast$expressions$YieldExpression_ts$yieldExpression.assert(node);
    throw new Error('unimplemented');
  }

  // romejs/js-analysis/evaluators/index.ts

  const ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators = new Map();
  const ___R$romejs$js$analysis$evaluators$index_ts$default = ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators;
  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set(
  'AmbiguousFlowTypeCastExpression',
  ___R$romejs$js$analysis$evaluators$temp$AmbiguousFlowTypeCastExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('AnyKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$AnyKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ArrayExpression', ___R$romejs$js$analysis$evaluators$expressions$ArrayExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ArrowFunctionExpression', ___R$romejs$js$analysis$evaluators$expressions$ArrowFunctionExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('AssignmentArrayPattern', ___R$romejs$js$analysis$evaluators$patterns$AssignmentArrayPattern_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('AssignmentAssignmentPattern', ___R$romejs$js$analysis$evaluators$patterns$AssignmentAssignmentPattern_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('AssignmentExpression', ___R$romejs$js$analysis$evaluators$expressions$AssignmentExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('AssignmentIdentifier', ___R$romejs$js$analysis$evaluators$patterns$AssignmentIdentifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('AssignmentObjectPattern', ___R$romejs$js$analysis$evaluators$patterns$AssignmentObjectPattern_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set(
  'AssignmentObjectPatternProperty',
  ___R$romejs$js$analysis$evaluators$patterns$AssignmentObjectPatternProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('AwaitExpression', ___R$romejs$js$analysis$evaluators$expressions$AwaitExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BigIntKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$BigIntKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BigIntLiteral', ___R$romejs$js$analysis$evaluators$literals$BigIntLiteral_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BinaryExpression', ___R$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BindingArrayPattern', ___R$romejs$js$analysis$evaluators$patterns$BindingArrayPattern_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BindingAssignmentPattern', ___R$romejs$js$analysis$evaluators$patterns$BindingAssignmentPattern_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BindingIdentifier', ___R$romejs$js$analysis$evaluators$patterns$BindingIdentifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BindingObjectPattern', ___R$romejs$js$analysis$evaluators$patterns$BindingObjectPattern_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BindingObjectPatternProperty', ___R$romejs$js$analysis$evaluators$patterns$BindingObjectPatternProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BlockStatement', ___R$romejs$js$analysis$evaluators$statements$BlockStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BooleanKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$BooleanKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BooleanLiteral', ___R$romejs$js$analysis$evaluators$literals$BooleanLiteral_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BooleanLiteralTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$BooleanLiteralTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('BreakStatement', ___R$romejs$js$analysis$evaluators$statements$BreakStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('CallExpression', ___R$romejs$js$analysis$evaluators$expressions$CallExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('CatchClause', ___R$romejs$js$analysis$evaluators$auxiliary$CatchClause_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassDeclaration', ___R$romejs$js$analysis$evaluators$classes$ClassDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassExpression', ___R$romejs$js$analysis$evaluators$classes$ClassExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassHead', ___R$romejs$js$analysis$evaluators$classes$ClassHead_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassMethod', ___R$romejs$js$analysis$evaluators$classes$ClassMethod_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassPrivateMethod', ___R$romejs$js$analysis$evaluators$classes$ClassPrivateMethod_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassPrivateProperty', ___R$romejs$js$analysis$evaluators$classes$ClassPrivateProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassProperty', ___R$romejs$js$analysis$evaluators$classes$ClassProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ClassPropertyMeta', ___R$romejs$js$analysis$evaluators$classes$ClassPropertyMeta_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('CommentBlock', ___R$romejs$js$analysis$evaluators$core$CommentBlock_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('CommentLine', ___R$romejs$js$analysis$evaluators$core$CommentLine_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ComputedMemberProperty', ___R$romejs$js$analysis$evaluators$auxiliary$ComputedMemberProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ComputedPropertyKey', ___R$romejs$js$analysis$evaluators$objects$ComputedPropertyKey_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ConditionalExpression', ___R$romejs$js$analysis$evaluators$expressions$ConditionalExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ContinueStatement', ___R$romejs$js$analysis$evaluators$statements$ContinueStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('DebuggerStatement', ___R$romejs$js$analysis$evaluators$statements$DebuggerStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('Directive', ___R$romejs$js$analysis$evaluators$core$Directive_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('DoExpression', ___R$romejs$js$analysis$evaluators$expressions$DoExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('DoWhileStatement', ___R$romejs$js$analysis$evaluators$statements$DoWhileStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('EmptyKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$EmptyKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('EmptyStatement', ___R$romejs$js$analysis$evaluators$statements$EmptyStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportAllDeclaration', ___R$romejs$js$analysis$evaluators$modules$ExportAllDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportDefaultDeclaration', ___R$romejs$js$analysis$evaluators$modules$ExportDefaultDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportDefaultSpecifier', ___R$romejs$js$analysis$evaluators$modules$ExportDefaultSpecifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportNamedDeclaration', ___R$romejs$js$analysis$evaluators$modules$ExportNamedDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportNamespaceSpecifier', ___R$romejs$js$analysis$evaluators$modules$ExportNamespaceSpecifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExportSpecifier', ___R$romejs$js$analysis$evaluators$modules$ExportSpecifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ExpressionStatement', ___R$romejs$js$analysis$evaluators$statements$ExpressionStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowArrayTypeAnnotation', ___R$romejs$js$analysis$evaluators$flow$FlowArrayTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowClassImplements', ___R$romejs$js$analysis$evaluators$flow$FlowClassImplements_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareClass', ___R$romejs$js$analysis$evaluators$flow$FlowDeclareClass_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclaredPredicate', ___R$romejs$js$analysis$evaluators$flow$FlowDeclaredPredicate_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareExportAll', ___R$romejs$js$analysis$evaluators$flow$FlowDeclareExportAll_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareExportDefault', ___R$romejs$js$analysis$evaluators$flow$FlowDeclareExportDefault_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareExportNamed', ___R$romejs$js$analysis$evaluators$flow$FlowDeclareExportNamed_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareFunction', ___R$romejs$js$analysis$evaluators$flow$FlowDeclareFunction_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareInterface', ___R$romejs$js$analysis$evaluators$flow$FlowDeclareInterface_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareModule', ___R$romejs$js$analysis$evaluators$flow$FlowDeclareModule_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareModuleExports', ___R$romejs$js$analysis$evaluators$flow$FlowDeclareModuleExports_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareOpaqueType', ___R$romejs$js$analysis$evaluators$flow$FlowDeclareOpaqueType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowDeclareVariable', ___R$romejs$js$analysis$evaluators$flow$FlowDeclareVariable_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowExistsTypeAnnotation', ___R$romejs$js$analysis$evaluators$flow$FlowExistsTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowFunctionTypeAnnotation', ___R$romejs$js$analysis$evaluators$flow$FlowFunctionTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowFunctionTypeParam', ___R$romejs$js$analysis$evaluators$flow$FlowFunctionTypeParam_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowGenericTypeAnnotation', ___R$romejs$js$analysis$evaluators$flow$FlowGenericTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowInferredPredicate', ___R$romejs$js$analysis$evaluators$flow$FlowInferredPredicate_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowInterface', ___R$romejs$js$analysis$evaluators$flow$FlowInterface_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowInterfaceDeclaration', ___R$romejs$js$analysis$evaluators$flow$FlowInterfaceDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowInterfaceExtends', ___R$romejs$js$analysis$evaluators$flow$FlowInterfaceExtends_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowInterfaceTypeAnnotation', ___R$romejs$js$analysis$evaluators$flow$FlowInterfaceTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowNullableTypeAnnotation', ___R$romejs$js$analysis$evaluators$flow$FlowNullableTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowNumericLiteral', ___R$romejs$js$analysis$evaluators$flow$FlowNumericLiteral_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeAnnotation', ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeCallProperty', ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeCallProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeIndexer', ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeIndexer_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeInternalSlot', ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeInternalSlot_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeProperty', ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowObjectTypeSpreadProperty', ___R$romejs$js$analysis$evaluators$flow$FlowObjectTypeSpreadProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowOpaqueType', ___R$romejs$js$analysis$evaluators$flow$FlowOpaqueType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowQualifiedTypeIdentifier', ___R$romejs$js$analysis$evaluators$flow$FlowQualifiedTypeIdentifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowThisTypeAnnotation', ___R$romejs$js$analysis$evaluators$flow$FlowThisTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTupleTypeAnnotation', ___R$romejs$js$analysis$evaluators$flow$FlowTupleTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTypeCastExpression', ___R$romejs$js$analysis$evaluators$flow$FlowTypeCastExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTypeofTypeAnnotation', ___R$romejs$js$analysis$evaluators$flow$FlowTypeofTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTypeParameter', ___R$romejs$js$analysis$evaluators$flow$FlowTypeParameter_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowTypeParameterDeclaration', ___R$romejs$js$analysis$evaluators$flow$FlowTypeParameterDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set(
  'FlowTypeParameterInstantiation',
  ___R$romejs$js$analysis$evaluators$flow$FlowTypeParameterInstantiation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FlowVariance', ___R$romejs$js$analysis$evaluators$flow$FlowVariance_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ForInStatement', ___R$romejs$js$analysis$evaluators$statements$ForInStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ForOfStatement', ___R$romejs$js$analysis$evaluators$statements$ForOfStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ForStatement', ___R$romejs$js$analysis$evaluators$statements$ForStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FunctionDeclaration', ___R$romejs$js$analysis$evaluators$statements$FunctionDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FunctionExpression', ___R$romejs$js$analysis$evaluators$expressions$FunctionExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('FunctionHead', ___R$romejs$js$analysis$evaluators$auxiliary$FunctionHead_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('Identifier', ___R$romejs$js$analysis$evaluators$auxiliary$Identifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('IfStatement', ___R$romejs$js$analysis$evaluators$statements$IfStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportCall', ___R$romejs$js$analysis$evaluators$modules$ImportCall_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportDeclaration', ___R$romejs$js$analysis$evaluators$modules$ImportDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportDefaultSpecifier', ___R$romejs$js$analysis$evaluators$modules$ImportDefaultSpecifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportNamespaceSpecifier', ___R$romejs$js$analysis$evaluators$modules$ImportNamespaceSpecifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportSpecifier', ___R$romejs$js$analysis$evaluators$modules$ImportSpecifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ImportSpecifierLocal', ___R$romejs$js$analysis$evaluators$modules$ImportSpecifierLocal_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('InterpreterDirective', ___R$romejs$js$analysis$evaluators$core$InterpreterDirective_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('IntersectionTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$IntersectionTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXAttribute', ___R$romejs$js$analysis$evaluators$jsx$JSXAttribute_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXElement', ___R$romejs$js$analysis$evaluators$jsx$JSXElement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXEmptyExpression', ___R$romejs$js$analysis$evaluators$jsx$JSXEmptyExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXExpressionContainer', ___R$romejs$js$analysis$evaluators$jsx$JSXExpressionContainer_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXFragment', ___R$romejs$js$analysis$evaluators$jsx$JSXFragment_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXIdentifier', ___R$romejs$js$analysis$evaluators$jsx$JSXIdentifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXMemberExpression', ___R$romejs$js$analysis$evaluators$jsx$JSXMemberExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXNamespacedName', ___R$romejs$js$analysis$evaluators$jsx$JSXNamespacedName_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXReferenceIdentifier', ___R$romejs$js$analysis$evaluators$jsx$JSXReferenceIdentifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXSpreadAttribute', ___R$romejs$js$analysis$evaluators$jsx$JSXSpreadAttribute_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXSpreadChild', ___R$romejs$js$analysis$evaluators$jsx$JSXSpreadChild_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('JSXText', ___R$romejs$js$analysis$evaluators$jsx$JSXText_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('LabeledStatement', ___R$romejs$js$analysis$evaluators$statements$LabeledStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('LogicalExpression', ___R$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('MemberExpression', ___R$romejs$js$analysis$evaluators$expressions$MemberExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('MetaProperty', ___R$romejs$js$analysis$evaluators$expressions$MetaProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('MixedKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$MixedKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('MockParent', ___R$romejs$js$analysis$evaluators$temp$MockParent_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('NeverKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$NeverKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('NewExpression', ___R$romejs$js$analysis$evaluators$expressions$NewExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('NullKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$NullKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('NullLiteral', ___R$romejs$js$analysis$evaluators$literals$NullLiteral_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('NumberKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$NumberKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('NumericLiteral', ___R$romejs$js$analysis$evaluators$literals$NumericLiteral_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('NumericLiteralTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$NumericLiteralTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ObjectExpression', ___R$romejs$js$analysis$evaluators$objects$ObjectExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ObjectKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$ObjectKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ObjectMethod', ___R$romejs$js$analysis$evaluators$objects$ObjectMethod_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ObjectProperty', ___R$romejs$js$analysis$evaluators$objects$ObjectProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('OptionalCallExpression', ___R$romejs$js$analysis$evaluators$expressions$OptionalCallExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('PatternMeta', ___R$romejs$js$analysis$evaluators$patterns$PatternMeta_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('PrivateName', ___R$romejs$js$analysis$evaluators$classes$PrivateName_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('Program', ___R$romejs$js$analysis$evaluators$core$Program_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ReferenceIdentifier', ___R$romejs$js$analysis$evaluators$expressions$ReferenceIdentifier_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('RegExpLiteral', ___R$romejs$js$analysis$evaluators$literals$RegExpLiteral_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ReturnStatement', ___R$romejs$js$analysis$evaluators$statements$ReturnStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('SequenceExpression', ___R$romejs$js$analysis$evaluators$expressions$SequenceExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('SpreadElement', ___R$romejs$js$analysis$evaluators$auxiliary$SpreadElement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('SpreadProperty', ___R$romejs$js$analysis$evaluators$objects$SpreadProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('StaticMemberProperty', ___R$romejs$js$analysis$evaluators$auxiliary$StaticMemberProperty_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('StaticPropertyKey', ___R$romejs$js$analysis$evaluators$objects$StaticPropertyKey_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('StringKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$StringKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('StringLiteral', ___R$romejs$js$analysis$evaluators$literals$StringLiteral_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('StringLiteralTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$StringLiteralTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('Super', ___R$romejs$js$analysis$evaluators$expressions$Super_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('SwitchCase', ___R$romejs$js$analysis$evaluators$auxiliary$SwitchCase_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('SwitchStatement', ___R$romejs$js$analysis$evaluators$statements$SwitchStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('SymbolKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$SymbolKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TaggedTemplateExpression', ___R$romejs$js$analysis$evaluators$expressions$TaggedTemplateExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TemplateElement', ___R$romejs$js$analysis$evaluators$auxiliary$TemplateElement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TemplateLiteral', ___R$romejs$js$analysis$evaluators$literals$TemplateLiteral_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TemplateLiteralTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$TemplateLiteralTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ThisExpression', ___R$romejs$js$analysis$evaluators$expressions$ThisExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('ThrowStatement', ___R$romejs$js$analysis$evaluators$statements$ThrowStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TryStatement', ___R$romejs$js$analysis$evaluators$statements$TryStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSArrayType', ___R$romejs$js$analysis$evaluators$typescript$TSArrayType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSAsExpression', ___R$romejs$js$analysis$evaluators$typescript$TSAsExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSAssignmentAsExpression', ___R$romejs$js$analysis$evaluators$typescript$TSAssignmentAsExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSAssignmentNonNullExpression', ___R$romejs$js$analysis$evaluators$typescript$TSAssignmentNonNullExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSAssignmentTypeAssertion', ___R$romejs$js$analysis$evaluators$typescript$TSAssignmentTypeAssertion_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSCallSignatureDeclaration', ___R$romejs$js$analysis$evaluators$typescript$TSCallSignatureDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSConditionalType', ___R$romejs$js$analysis$evaluators$typescript$TSConditionalType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSConstructorType', ___R$romejs$js$analysis$evaluators$typescript$TSConstructorType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set(
  'TSConstructSignatureDeclaration',
  ___R$romejs$js$analysis$evaluators$typescript$TSConstructSignatureDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSDeclareFunction', ___R$romejs$js$analysis$evaluators$typescript$TSDeclareFunction_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSDeclareMethod', ___R$romejs$js$analysis$evaluators$typescript$TSDeclareMethod_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSEnumDeclaration', ___R$romejs$js$analysis$evaluators$typescript$TSEnumDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSEnumMember', ___R$romejs$js$analysis$evaluators$typescript$TSEnumMember_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSExportAssignment', ___R$romejs$js$analysis$evaluators$typescript$TSExportAssignment_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSExpressionWithTypeArguments', ___R$romejs$js$analysis$evaluators$typescript$TSExpressionWithTypeArguments_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSExternalModuleReference', ___R$romejs$js$analysis$evaluators$typescript$TSExternalModuleReference_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSFunctionType', ___R$romejs$js$analysis$evaluators$typescript$TSFunctionType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSImportEqualsDeclaration', ___R$romejs$js$analysis$evaluators$typescript$TSImportEqualsDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSImportType', ___R$romejs$js$analysis$evaluators$typescript$TSImportType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSIndexedAccessType', ___R$romejs$js$analysis$evaluators$typescript$TSIndexedAccessType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSIndexSignature', ___R$romejs$js$analysis$evaluators$typescript$TSIndexSignature_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSInferType', ___R$romejs$js$analysis$evaluators$typescript$TSInferType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSInterfaceBody', ___R$romejs$js$analysis$evaluators$typescript$TSInterfaceBody_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSInterfaceDeclaration', ___R$romejs$js$analysis$evaluators$typescript$TSInterfaceDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSMappedType', ___R$romejs$js$analysis$evaluators$typescript$TSMappedType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSMethodSignature', ___R$romejs$js$analysis$evaluators$typescript$TSMethodSignature_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSModuleBlock', ___R$romejs$js$analysis$evaluators$typescript$TSModuleBlock_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSModuleDeclaration', ___R$romejs$js$analysis$evaluators$typescript$TSModuleDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSNamespaceExportDeclaration', ___R$romejs$js$analysis$evaluators$typescript$TSNamespaceExportDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSNonNullExpression', ___R$romejs$js$analysis$evaluators$typescript$TSNonNullExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSOptionalType', ___R$romejs$js$analysis$evaluators$typescript$TSOptionalType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSParenthesizedType', ___R$romejs$js$analysis$evaluators$typescript$TSParenthesizedType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSPropertySignature', ___R$romejs$js$analysis$evaluators$typescript$TSPropertySignature_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSQualifiedName', ___R$romejs$js$analysis$evaluators$typescript$TSQualifiedName_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSSignatureDeclarationMeta', ___R$romejs$js$analysis$evaluators$typescript$TSSignatureDeclarationMeta_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSThisType', ___R$romejs$js$analysis$evaluators$typescript$TSThisType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTupleType', ___R$romejs$js$analysis$evaluators$typescript$TSTupleType_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeAssertion', ___R$romejs$js$analysis$evaluators$typescript$TSTypeAssertion_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeLiteral', ___R$romejs$js$analysis$evaluators$typescript$TSTypeLiteral_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeOperator', ___R$romejs$js$analysis$evaluators$typescript$TSTypeOperator_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeParameter', ___R$romejs$js$analysis$evaluators$typescript$TSTypeParameter_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeParameterDeclaration', ___R$romejs$js$analysis$evaluators$typescript$TSTypeParameterDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeParameterInstantiation', ___R$romejs$js$analysis$evaluators$typescript$TSTypeParameterInstantiation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypePredicate', ___R$romejs$js$analysis$evaluators$typescript$TSTypePredicate_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeQuery', ___R$romejs$js$analysis$evaluators$typescript$TSTypeQuery_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TSTypeReference', ___R$romejs$js$analysis$evaluators$typescript$TSTypeReference_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('TypeAliasTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$TypeAliasTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('UnaryExpression', ___R$romejs$js$analysis$evaluators$expressions$UnaryExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set(
  'UndefinedKeywordTypeAnnotation',
  ___R$romejs$js$analysis$evaluators$types$UndefinedKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('UnionTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$UnionTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('UnknownKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$UnknownKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('UpdateExpression', ___R$romejs$js$analysis$evaluators$expressions$UpdateExpression_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('VariableDeclaration', ___R$romejs$js$analysis$evaluators$auxiliary$VariableDeclaration_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('VariableDeclarationStatement', ___R$romejs$js$analysis$evaluators$statements$VariableDeclarationStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('VariableDeclarator', ___R$romejs$js$analysis$evaluators$auxiliary$VariableDeclarator_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('VoidKeywordTypeAnnotation', ___R$romejs$js$analysis$evaluators$types$VoidKeywordTypeAnnotation_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('WhileStatement', ___R$romejs$js$analysis$evaluators$statements$WhileStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('WithStatement', ___R$romejs$js$analysis$evaluators$statements$WithStatement_ts$default);

  ___R$$priv$romejs$js$analysis$evaluators$index_ts$evaluators.set('YieldExpression', ___R$romejs$js$analysis$evaluators$expressions$YieldExpression_ts$default);

  // romejs/js-analysis/Evaluator.ts

  ___R$romejs$js$ast$utils_ts$assertNodeTypeSet(___R$romejs$js$analysis$evaluators$index_ts$default, 'evaluators');

  class ___R$romejs$js$analysis$Evaluator_ts$ModuleSignatureManager {
    constructor(graph, getModuleSignature, topScope) {
      this.topScope = topScope;
      this.getModuleSignature = getModuleSignature;
      this.graph = graph;
      this.openTypes = new Map();
      this.filename = graph.filename;

      this.exportNamesToTypeId = new Map();
    }

    addAll(manager) {
      for (const [name, id] of manager.exportNamesToTypeId) {
        if (name === 'default') {
          continue;
        }

        this.exportNamesToTypeId.set(name, id);

        const openType = manager.openTypes.get(id);
        if (openType === undefined) {
          throw new Error('Expected an open type');
        }
        this.openTypes.set(id, openType);
      }
    }

    async init() {
      const {graph: graph, openTypes: openTypes} = this;

      for (const id in graph.types) {
        const open = new ___R$romejs$js$analysis$types$OpenT_ts$default(this.topScope, undefined);
        openTypes.set(id, open);
      }

      let currGetType;

      const getType = id => {
        if (id === undefined) {
          throw new Error('expected id');
        }

        if (typeof id !== 'string') {
          throw new Error('expected string id');
        }

        const type = openTypes.get(id);

        if (type === undefined) {
          throw new Error(graph.filename + ': Expected type of id ' + id + ' but it doesn\'t exist, serialized data: ' + String(
          JSON.stringify(currGetType)));
        }

        return type;
      };

      await Promise.all(
      graph.exports.map(def => {
        if (def.type === 'all') {
          return this.getModuleSignature(def.source, graph.filename);
        } else {
          return undefined;
        }
      }));

      for (const def of graph.exports) {
        if (def.type === 'all') {
          const manager = await this.getModuleSignature(
          def.source,
          graph.filename);
          if (manager !== undefined) {
            this.addAll(manager);
          }
        } else {
          this.exportNamesToTypeId.set(def.name, def.value);
        }
      }

      for (const id in graph.types) {
        const node = graph.types[id];
        const {origin: origin, type: type, data: data, human: human} = node;
        currGetType = node;

        const openT = openTypes.get(id);
        if (openT === undefined) {
          throw new Error('Expected an open type');
        }

        const TConstructor = ___R$romejs$js$analysis$types$index_ts$default.get(type);
        if (TConstructor === undefined) {
          throw new Error('Expected a valid internal type constructor name');
        }

        const realT = TConstructor.hydrate(
        this.topScope,
        {loc: origin},
        data,
        getType);

        realT.setHuman(human);

        openT.shouldMatch(realT);
      }
    }

    link(importedName, type) {
      const graph = this.graph;

      const maybeExportId = this.exportNamesToTypeId.get(importedName);
      if (maybeExportId === undefined) {
        const error = new ___R$romejs$js$analysis$types$errors$UnknownImportE_ts$default(this.topScope, type.originNode, {
          possibleNames: Array.from(this.exportNamesToTypeId.keys()),
          importedName: importedName,
          source: graph.filename});
        error.shouldMatch(type);
        return undefined;
      }

      const openT = this.openTypes.get(maybeExportId);
      if (openT === undefined) {
        throw new Error('Expected an open type');
      }

      type.setResolvedType(openT);
    }
  }

  class ___R$romejs$js$analysis$Evaluator_ts$default {
    constructor(hub, filename) {
      this.filename = filename;
      this.nodeToType = new Map();
      this.exports = [];
      this.imports = [];
      this.hub = hub;
      this.graph = hub.graph;

      this.topScope = new ___R$romejs$js$analysis$scopes_ts$Scope({evaluator: this});
      this.intrinsics = this.topScope.intrinsics = new ___R$romejs$js$analysis$Intrinsics_ts$default(this.topScope);
      this.evaluatingType = undefined;
    }

    initModuleSignature(graph, getModuleSignature) {
      return new ___R$romejs$js$analysis$Evaluator_ts$ModuleSignatureManager(graph, getModuleSignature, this.topScope);
    }

    seed(ast) {
      return this.evaluate(ast, this.topScope);
    }

    evaluate(node, scope) {
      if (node === undefined) {
        throw new Error('Expected node but received undefined');
      }

      const evaluator = ___R$romejs$js$analysis$evaluators$index_ts$default.get(node.type);
      if (evaluator === undefined) {
        throw new Error('what is this? ' + node.type);
      } else {
        const oldEvaluatingType = this.evaluatingType;
        this.evaluatingType = node.type;
        let type = evaluator(node, scope, this.hub);
        if (type === undefined) {
          type = new ___R$romejs$js$analysis$types$EmptyT_ts$default(scope, node);
        }
        this.evaluatingType = oldEvaluatingType;
        this.nodeToType.set(node, type);
        return type;
      }
    }

    getTypeFromEvaluatedNode(node) {
      const type = this.nodeToType.get(node);
      if (type === undefined) {
        throw new Error('getTypeFromEvaluatedNode() called on a node that has not been validated yet');
      } else {
        return type;
      }
    }

    addExport(name, type) {
      this.exports.push({
        type: 'local',
        name: name,
        value: type});
    }

    addExportAll(source) {
      this.exports.push({
        type: 'all',
        source: source});
    }

    addImport(t, opts) {
      this.imports.push({
        relative: opts.relative,
        importedName: opts.importedName,
        source: opts.source,
        type: t});
    }
  }

  // romejs/js-analysis/Utils.ts

  class ___R$$priv$romejs$js$analysis$Utils_ts$ReduceRecursionError extends Error {}

  const ___R$$priv$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE = {type: 'compatible'};

  const ___R$$priv$romejs$js$analysis$Utils_ts$MAX_DEPTH = 100;

  class ___R$romejs$js$analysis$Utils_ts$HumanBuilder {
    constructor() {
      this.stack = new Set();
      this.usedAliases = new Set();
      this.aliases = new Map();
    }

    isRecursive(t) {
      if (t.human !== undefined) {
        return false;
      }

      if (this.aliases.has(t)) {
        return true;
      }

      if (this.stack.has(t)) {
        return true;
      }

      return false;
    }

    humanize(type) {
      if (type.human !== undefined) {
        return type.human;
      }

      if (this.aliases.has(type)) {
        const alias = this.aliases.get(type);
        if (alias === undefined) {
          throw new Error('Expected alias');
        }
        return alias;
      }

      if (this.isRecursive(type)) {
        const alias = 'Alias' + type.id;
        this.aliases.set(type, alias);
        return alias;
      }

      this.stack.add(type);
      try {
        let humanized = type.humanize(this);

        const alias = this.aliases.get(type);
        if (alias !== undefined) {
          humanized = alias + ' = ' + humanized;
        }
        return humanized;
      } finally {
        this.stack.delete(type);
      }
    }
  }

  class ___R$romejs$js$analysis$Utils_ts$default {
    constructor(hub) {
      this.reduceCatchers = new Set();
      this.reduceCache = new Map();
      this.reduceStack = new Set();
      this.compatibilityDepth = 0;
      this.hub = hub;
      this.debug = false;
    }

    inspect(t, safe = false) {
      const prevDebug = this.debug;
      this.debug = true;

      const data = new Map();
      data.set('id', String(t.id));

      const {originLoc: originLoc, originEvaluator: originEvaluator} = t;
      if (originLoc === undefined) {
        data.set('origin', 'unknown');
      } else {
        data.set(
        'origin',
        String(originLoc.filename) + ':' + String(originLoc.start.line) + ':' + String(
        originLoc.start.column));
      }
      if (originEvaluator !== undefined) {
        data.set('evaluator', originEvaluator);
      }

      const dataStr = Array.from(data.keys()).map(key => key + ': ' + String(data.get(key))).join(', ');

      let info = t.getConstructor().type + '<';
      if (safe === false) {
        info += this.humanize(t) + ', ';
      }
      info += dataStr + '>';

      this.debug = prevDebug;
      return info;
    }

    assertClosed() {
      if (this.debug === false) {
        this.hub.assertClosed();
      }
    }

    explodeUnion(type) {
      return Array.from(new Set(this.reduce(type).explodeUnion()));
    }

    isCompatibleWith(a, b) {
      return this.checkCompability(a, b).type === 'compatible';
    }

    checkCompability(a, b) {
      this.assertClosed();

      const lower = this.reduce(a);
      const upper = this.reduce(b);

      if (lower === upper) {
        return ___R$$priv$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
      }

      if (lower instanceof ___R$romejs$js$analysis$types$AnyT_ts$default || upper instanceof ___R$romejs$js$analysis$types$AnyT_ts$default) {
        return ___R$$priv$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
      }

      if (this.compatibilityDepth > ___R$$priv$romejs$js$analysis$Utils_ts$MAX_DEPTH) {
        throw new Error('Max depth exceeded when checking compatibility of ' + lower.inspect() + ' to ' + upper.inspect());
      }

      const cached = lower.compatibilityCache.get(upper);
      if (cached === undefined) {
        lower.compatibilityCache.set(upper, {
          type: 'incompatible',
          lower: lower,
          upper: upper});
      } else {
        return cached;
      }

      this.compatibilityDepth++;
      let ret;
      try {
        ret = lower.compatibleWith(upper);
      } catch (err) {
        if (err instanceof ___R$$priv$romejs$js$analysis$Utils_ts$ReduceRecursionError) {
          ret = ___R$$priv$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
        } else {
          throw err;
        }
      } finally {
        this.compatibilityDepth--;
      }
      let res;
      if (ret === true) {
        res = ___R$$priv$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
      } else if (ret === false) {
        res = {type: 'incompatible', lower: a, upper: b};
      } else if (ret instanceof ___R$romejs$js$analysis$types$errors$E_ts$default) {
        res = {type: 'incompatible', lower: a, upper: ret};
      } else {
        res = ret;
      }
      lower.compatibilityCache.set(upper, res);

      return res;
    }

    humanize(type) {
      this.assertClosed();

      return new ___R$romejs$js$analysis$Utils_ts$HumanBuilder().humanize(type);
    }

    reduce(type) {
      this.assertClosed();

      const cached = this.reduceCache.get(type);
      if (cached !== undefined) {
        return cached;
      }

      if (this.reduceStack.has(type)) {
        return new ___R$romejs$js$analysis$types$UnknownT_ts$default(type.scope, type.originNode);
      }

      if (this.reduceStack.size > ___R$$priv$romejs$js$analysis$Utils_ts$MAX_DEPTH) {
        throw new Error('Max depth exceeded when reducing');
      }

      this.reduceStack.add(type);

      if (this.reduceCatchers.size) {
        for (const set of this.reduceCatchers) {
          set.add(type);
        }
      }

      try {
        const reduced = type.reduce();

        if (reduced === undefined) {
          throw new Error('The reduce() method for ' + this.inspect(type, true) + ' returned null');
        }

        if (reduced.getConstructor().type === 'OpenT') {
          throw new Error('The reduce() method for ' + this.inspect(
          type,
          true) + ' returned an OpenT. This should never be possible. It likely forgot to return utils.reduce() on it.');
        }

        if (this.debug === false) {
          this.reduceCache.set(type, reduced);
        }

        return reduced;
      } finally {
        this.reduceStack.delete(type);
      }
    }

    reduceCatch(type) {
      const involved = new Set();
      this.reduceCatchers.add(involved);

      const final = this.reduce(type);
      this.reduceCatchers.delete(involved);

      return {final: final, involved: involved};
    }
  }

  // romejs/js-analysis/Hub.ts

  const ___R$$priv$romejs$js$analysis$Hub_ts$statuses = {
    OPEN: 0,
    CLOSING: 1,
    CLOSED: 2};

  class ___R$romejs$js$analysis$Hub_ts$default {
    constructor(ast, project) {
      this.context = new ___R$romejs$js$compiler$lib$Context_ts$default({
        ast: ast,
        project: project,
        origin: {
          category: 'typeChecking'}});
      this.utils = new ___R$romejs$js$analysis$Utils_ts$default(this);
      this.graph = new ___R$romejs$js$analysis$Graph_ts$default();
      this.evaluator = new ___R$romejs$js$analysis$Evaluator_ts$default(this, ast.filename);
      this.status = ___R$$priv$romejs$js$analysis$Hub_ts$statuses.OPEN;
    }

    close() {
      this.status = ___R$$priv$romejs$js$analysis$Hub_ts$statuses.CLOSING;

      for (const [node] of this.graph.nodesByValue) {
        this.utils.reduce(node);
      }

      this.status = ___R$$priv$romejs$js$analysis$Hub_ts$statuses.CLOSED;
    }

    isClosing() {
      return this.status === ___R$$priv$romejs$js$analysis$Hub_ts$statuses.CLOSING;
    }

    isOpen() {
      return this.isClosing() || this.status === ___R$$priv$romejs$js$analysis$Hub_ts$statuses.OPEN;
    }

    isClosed() {
      return this.isClosing() || this.status === ___R$$priv$romejs$js$analysis$Hub_ts$statuses.CLOSED;
    }

    assertOpen() {
      if (this.isClosed() && this.isClosing() === false) {
        throw new Error('This method can only be called when the graph has been open');
      }
    }

    assertClosed() {
      if (this.isOpen() && this.isClosing() === false) {
        throw new Error('This method can only be called when the graph has been closed');
      }
    }
  }

  // romejs/js-analysis/api/buildGraph.ts

  async function ___R$romejs$js$analysis$api$buildGraph_ts$default(opts) {
    const {ast: ast, connected: connected, project: project, provider: provider} = opts;

    const hub = new ___R$romejs$js$analysis$Hub_ts$default(ast, project);
    const {evaluator: evaluator} = hub;
    if (provider.libs !== undefined) {
      let body = [];
      for (const ast of provider.libs) {
        body = [...body, ...ast.body];
      }
      evaluator.seed(Object.assign({}, ast, {
        body: body}));
    }
    evaluator.seed(ast);

    if (connected) {
      const graphs = new Map();
      async function getModuleSignature(source, relative) {
        const graphKey = relative + ':' + source;
        if (graphs.has(graphKey)) {
          return graphs.get(graphKey);
        }

        const graph = await provider.getExportTypes(relative, source);

        if (graph === undefined) {
          graphs.set(graphKey, undefined);
          return undefined;
        }

        if (graphs.has(graph.filename)) {
          const manager = graphs.get(graph.filename);
          graphs.set(graphKey, manager);
          return manager;
        }

        const manager = evaluator.initModuleSignature(graph, getModuleSignature);
        graphs.set(graphKey, manager);
        graphs.set(graph.filename, manager);
        await manager.init();
        return manager;
      }

      const seedCache = new Set();
      await Promise.all(
      evaluator.imports.map(({source: source, relative: relative}) => {
        const cacheKey = source + ':' + relative;
        if (seedCache.has(cacheKey)) {
          return undefined;
        }

        seedCache.add(cacheKey);
        return getModuleSignature(source, relative);
      }));

      for (const {source: source, importedName: importedName, relative: relative, type: type} of evaluator.imports) {
        const graphKey = relative + ':' + source;
        const graph = graphs.get(graphKey);
        if (graph === undefined) {
          continue;
        }

        if (importedName === undefined) {
          continue;
        }

        type.setAbsolute(graph.filename);
        graph.link(importedName, type);
      }
    }

    evaluator.intrinsics.link();
    hub.close();
    return hub;
  }

  // romejs/js-analysis/api/getModuleSignature.ts

  const ___R$$priv$romejs$js$analysis$api$getModuleSignature_ts$exportsCache = new WeakMap();

  async function ___R$romejs$js$analysis$api$getModuleSignature_ts$default(opts) {
    const {ast: ast, provider: provider} = opts;
    const {filename: filename} = ast;

    if (filename.includes('node_modules')) {
      return {
        filename: filename,
        exports: [],
        types: {}};
    }

    const cached = ___R$$priv$romejs$js$analysis$api$getModuleSignature_ts$exportsCache.get(ast);
    if (cached !== undefined) {
      return cached;
    }

    const {
      evaluator: {exports: exports},
      utils: utils} = await ___R$romejs$js$analysis$api$buildGraph_ts$default({
      ast: ast,
      project: opts.project,
      connected: false,
      provider: provider});
    const types = {};
    const exportMap = [];

    const added = new Set();

    function addType(type) {
      const reducedType = utils.reduce(type);
      if (added.has(reducedType)) {
        return reducedType.id;
      } else {
        added.add(reducedType);
      }

      if (reducedType instanceof ___R$romejs$js$analysis$types$errors$E_ts$default) {
        types[reducedType.id] = {
          human: undefined,
          origin: reducedType.originLoc,
          type: 'AnyT',
          data: {}};
        return reducedType.id;
      }

      const data = reducedType.serialize(addType);

      types[reducedType.id] = {
        human: reducedType.human,
        origin: reducedType.originLoc,
        type: reducedType.getConstructor().type,
        data: data};
      return reducedType.id;
    }

    for (const def of exports) {
      if (def.type === 'all') {
        exportMap.push({
          type: 'all',
          source: def.source});
      } else if (def.type === 'local') {
        exportMap.push({
          type: 'local',
          name: def.name,
          value: addType(def.value)});
      } else {
        throw new Error('unknown export def type');
      }
    }

    const result = {
      filename: filename,
      exports: exportMap,
      types: types};
    ___R$$priv$romejs$js$analysis$api$getModuleSignature_ts$exportsCache.set(ast, result);
    return result;
  }

  // romejs/js-analysis/api/check.ts

  async function ___R$romejs$js$analysis$api$check_ts$default(opts) {
    const hub = await ___R$romejs$js$analysis$api$buildGraph_ts$default({
      ast: opts.ast,
      connected: true,
      provider: opts.provider,
      project: opts.project});
    ___R$$priv$romejs$js$analysis$api$check_ts$resolveGraph(hub);
    return hub.context.diagnostics;
  }

  function ___R$$priv$romejs$js$analysis$api$check_ts$isError(t) {
    return t !== undefined && t instanceof ___R$romejs$js$analysis$types$errors$E_ts$default;
  }

  function ___R$$priv$romejs$js$analysis$api$check_ts$resolveGraph(hub) {
    const {graph: graph, utils: utils, context: context} = hub;

    const caughtErrors = new Set();

    for (const node of graph.nodes) {
      const lower = node.value;

      if (lower instanceof ___R$romejs$js$analysis$types$OpenT_ts$default) {
        continue;
      }

      const reduced = utils.reduce(lower);
      if (reduced instanceof ___R$romejs$js$analysis$types$errors$E_ts$default) {
        if (caughtErrors.has(reduced)) {
          continue;
        } else {
          caughtErrors.add(reduced);
        }

        const {
          lowerTarget: lowerTarget,
          upperTarget: upperTarget,
          advice: rawAdvice,
          message: message} = reduced.getError();

        if (___R$$priv$romejs$js$analysis$api$check_ts$isError(lowerTarget) || ___R$$priv$romejs$js$analysis$api$check_ts$isError(upperTarget)) {
          continue;
        }

        let advice = [];

        if (upperTarget !== undefined) {
          const marker = upperTarget && !(upperTarget instanceof reduced.constructor) ? utils.humanize(upperTarget) : undefined;
          const {originLoc: originLoc} = upperTarget;

          if (originLoc !== undefined && marker !== undefined) {
            advice.push({
              type: 'log',
              category: 'info',
              message: marker});
          } else if (originLoc !== undefined) {
            advice.push({
              type: 'frame',
              filename: originLoc.filename,
              start: originLoc.start,
              end: originLoc.end,
              marker: marker});
          }
        }

        if (rawAdvice !== undefined) {
          advice = advice.concat(rawAdvice);
        }

        context.addNodeDiagnostic(lowerTarget.originNode, {
          category: 'typeError',
          message: message,
          advice: advice,
          marker: lowerTarget && !(lowerTarget instanceof reduced.constructor) ? utils.humanize(lowerTarget) : undefined});
        continue;
      }

      if (node.lines.length === 0) {
        continue;
      }

      for (const line of node.lines) {
        const upper = line.value;
        const compatibility = utils.checkCompability(upper, lower);

        if (compatibility.type === 'incompatible') {
          if (___R$$priv$romejs$js$analysis$api$check_ts$isError(compatibility.lower) || ___R$$priv$romejs$js$analysis$api$check_ts$isError(compatibility.upper)) {
            continue;
          }

          const advice = [{
            type: 'log',
            category: 'error',
            message: 'This type is incompatible with expected type of'}];

          const {originLoc: originLoc} = upper;
          if (originLoc === undefined) {
            advice.push({
              type: 'log',
              category: 'info',
              message: utils.humanize(upper)});
          } else {
            advice.push({
              type: 'frame',
              filename: originLoc.filename,
              start: originLoc.start,
              end: originLoc.end,
              marker: utils.humanize(upper)});
          }

          context.addNodeDiagnostic(compatibility.lower.originNode, {
            category: 'typeError',
            message: 'Type incompatibility found',
            marker: utils.humanize(compatibility.lower),
            advice: advice});
        }
      }
    }

    return context.diagnostics;
  }

  // romejs/js-analysis/types.ts

  const ___R$romejs$js$analysis$types_ts = {};

  // romejs/js-analysis/index.ts

  const ___R$romejs$js$analysis$index_ts = {
    get getModuleSignature() {
      return ___R$romejs$js$analysis$api$getModuleSignature_ts$default;
    },
    get buildGraph() {
      return ___R$romejs$js$analysis$api$buildGraph_ts$default;
    },
    get check() {
      return ___R$romejs$js$analysis$api$check_ts$default;
    }};
  Object.keys(___R$romejs$js$analysis$types$index_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$analysis$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$analysis$types$index_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$analysis$types_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$analysis$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$analysis$types_ts[key];
      }});
  });

  // romejs/core/common/types/analyzeDependencies.ts

  const ___R$romejs$core$common$types$analyzeDependencies_ts = {
    get UNKNOWN_ANALYZE_DEPENDENCIES_RESULT() {
      return ___R$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT;
    }};

  const ___R$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT = {
    moduleType: 'unknown',
    syntax: [],
    diagnostics: [],
    firstTopAwaitLocation: undefined,
    importFirstUsage: [],
    exports: [],
    dependencies: []};

  // romejs/fs/index.ts

  const ___R$$priv$romejs$fs$index_ts$fs = require('fs');

  function ___R$$priv$romejs$fs$index_ts$promisifyData(path, factory) {
    return new Promise((resolve, reject) => {
      factory(path.join(), (err, data) => {
        if (err === null) {
          resolve(data);
        } else {
          reject(err);
        }
      });
    });
  }

  function ___R$$priv$romejs$fs$index_ts$promisifyVoid(path, factory) {
    return new Promise((resolve, reject) => {
      factory(path.join(), err => {
        if (err === null) {
          resolve();
        } else {
          reject(err);
        }
      });
    });
  }

  function ___R$romejs$fs$index_ts$watch(path, options, listener) {
    return ___R$$priv$romejs$fs$index_ts$fs.watch(path.join(), options, listener);
  }

  function ___R$romejs$fs$index_ts$readFile(path) {
    return ___R$$priv$romejs$fs$index_ts$promisifyData(path, (filename, callback) => ___R$$priv$romejs$fs$index_ts$fs.readFile(filename, callback));
  }

  function ___R$romejs$fs$index_ts$readFileSync(path) {
    return ___R$$priv$romejs$fs$index_ts$fs.readFileSync(path.join());
  }

  async function ___R$romejs$fs$index_ts$readFileText(path) {
    return (await ___R$romejs$fs$index_ts$readFile(path)).toString();
  }

  function ___R$romejs$fs$index_ts$readFileTextSync(path) {
    return ___R$$priv$romejs$fs$index_ts$fs.readFileSync(path.join(), 'utf8');
  }

  function ___R$romejs$fs$index_ts$writeFile(path, content) {
    return ___R$$priv$romejs$fs$index_ts$promisifyVoid(path, (filename, callback) => ___R$$priv$romejs$fs$index_ts$fs.writeFile(filename, content, callback));
  }

  function ___R$romejs$fs$index_ts$writeFileSync(path, content) {
    return ___R$$priv$romejs$fs$index_ts$fs.writeFileSync(path.join(), content);
  }

  function ___R$$priv$romejs$fs$index_ts$createReaddirReturn(folder, files) {
    return new ___R$romejs$path$collections_ts$AbsoluteFilePathSet(files.map(basename => {
      return folder.append(basename);
    }));
  }

  function ___R$romejs$fs$index_ts$readdir(path) {
    return new Promise((resolve, reject) => {
      ___R$$priv$romejs$fs$index_ts$fs.readdir(path.join(), (err, files) => {
        if (err === null) {
          resolve(___R$$priv$romejs$fs$index_ts$createReaddirReturn(path, files));
        } else {
          reject(err);
        }
      });
    });
  }
  function ___R$romejs$fs$index_ts$readdirSync(path) {
    return ___R$$priv$romejs$fs$index_ts$createReaddirReturn(path, ___R$$priv$romejs$fs$index_ts$fs.readdirSync(path.join()));
  }

  function ___R$romejs$fs$index_ts$lstat(path) {
    return ___R$$priv$romejs$fs$index_ts$promisifyData(path, (filename, callback) => ___R$$priv$romejs$fs$index_ts$fs.lstat(filename, callback));
  }

  function ___R$romejs$fs$index_ts$lstatSync(path) {
    return ___R$$priv$romejs$fs$index_ts$fs.lstatSync(path.join());
  }

  function ___R$romejs$fs$index_ts$exists(path) {
    return new Promise((resolve, reject) => {
      ___R$$priv$romejs$fs$index_ts$fs.exists(path.join(), exists => {
        resolve(exists);
      });
    });
  }

  function ___R$romejs$fs$index_ts$existsSync(path) {
    return ___R$$priv$romejs$fs$index_ts$fs.existsSync(path.join());
  }

  function ___R$romejs$fs$index_ts$unlink(path) {
    return ___R$$priv$romejs$fs$index_ts$promisifyVoid(path, (filename, callback) => ___R$$priv$romejs$fs$index_ts$fs.unlink(filename, callback));
  }

  function ___R$romejs$fs$index_ts$unlinkSync(path) {
    ___R$$priv$romejs$fs$index_ts$fs.unlinkSync(path.join());
  }

  function ___R$romejs$fs$index_ts$createDirectory(path, opts = {}) {
    return ___R$$priv$romejs$fs$index_ts$promisifyVoid(path, (filename, callback) => ___R$$priv$romejs$fs$index_ts$fs.mkdir(filename, {recursive: opts.recursive}, callback));
  }

  function ___R$romejs$fs$index_ts$createDirectorySync(path, opts = {}) {
    ___R$$priv$romejs$fs$index_ts$fs.mkdirSync(path.join(), {recursive: opts.recursive});
  }

  // romejs/core/common/fileHandlers.ts


  function ___R$romejs$core$common$fileHandlers_ts$getFileHandlerExtensions(projectConfig) {
    return [...___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.keys(), ...projectConfig.files.assetExtensions];
  }

  function ___R$romejs$core$common$fileHandlers_ts$getFileHandler(path, projectConfig) {
    const basename = path.getBasename();

    const match = basename.match(/\.([a-zA-Z]+)$/);
    if (match == null) {
      return {ext: '', handler: undefined};
    }

    const ext = match[1];
    let handler = ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.get(ext);

    if (handler === undefined &&
    projectConfig.files.assetExtensions.includes(ext)) {
      handler = ___R$$priv$romejs$core$common$fileHandlers_ts$assetHandler;
    }

    return {ext: ext, handler: handler};
  }

  function ___R$romejs$core$common$fileHandlers_ts$getFileHandlerAssert(path, projectConfig) {
    const {handler: handler, ext: ext} = ___R$romejs$core$common$fileHandlers_ts$getFileHandler(path, projectConfig);

    if (handler === undefined) {
      throw new Error('No file handler found for \'' + path.join() + '\'');
    } else {
      return {handler: handler, ext: ext};
    }
  }

  const ___R$$priv$romejs$core$common$fileHandlers_ts$textHandler = {
    sourceType: 'module',

    async analyzeDependencies() {
      return Object.assign({}, ___R$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT, {
        moduleType: 'es',
        exports: [{
          type: 'local',
          loc: undefined,
          kind: 'value',
          valueType: 'other',
          name: 'default'}]});
    },

    async toJavaScript({file: file, worker: worker}) {
      const src = await ___R$romejs$fs$index_ts$readFileText(file.real);
      const serial = JSON.stringify(src);
      return {
        sourceText: 'export default ' + serial + ';',
        generated: true};
    }};

  const ___R$romejs$core$common$fileHandlers_ts$ASSET_EXPORT_TEMPORARY_VALUE = 'VALUE_INJECTED_BY_BUNDLER';

  const ___R$$priv$romejs$core$common$fileHandlers_ts$assetHandler = Object.assign({}, ___R$$priv$romejs$core$common$fileHandlers_ts$textHandler, {
    canHaveScale: true,
    isAsset: true,

    async toJavaScript({file: file, worker: worker}) {
      return {
        generated: true,
        sourceText: 'export default \'' + ___R$romejs$core$common$fileHandlers_ts$ASSET_EXPORT_TEMPORARY_VALUE + '\';'};
    }});

  const ___R$$priv$romejs$core$common$fileHandlers_ts$jsonHandler = Object.assign({}, ___R$$priv$romejs$core$common$fileHandlers_ts$textHandler, {
    hasteMode: 'noext',

    async lint(info) {
      const {file: ref, project: project} = info;
      const {uid: uid} = ref;

      const real = ___R$romejs$path$index_ts$createAbsoluteFilePath(ref.real);
      const src = await ___R$romejs$fs$index_ts$readFileText(real);

      const path = ___R$romejs$path$index_ts$createUnknownFilePath(uid);

      let formatted = src;

      if (project.config.format.enabled) {
        if (src.length > 50000) {
          ___R$romejs$codec$json$index_ts$parseJSON({
            path: path,
            input: src});
        } else {
          const {consumer: consumer, comments: comments, hasExtensions: hasExtensions} = ___R$romejs$codec$json$index_ts$consumeJSONExtra({
            input: src,
            path: path});

          if (hasExtensions) {
            formatted = ___R$romejs$codec$json$index_ts$stringifyJSON({consumer: consumer, comments: comments});
          } else {
            formatted = String(
            JSON.stringify(consumer.asUnknown(), undefined, '  '));
          }
        }
      }

      return {
        diagnostics: [],
        sourceText: src,
        formatted: formatted};
    },

    async toJavaScript({file: file}) {
      const src = await ___R$romejs$fs$index_ts$readFileText(file.real);

      const obj = ___R$romejs$codec$json$index_ts$parseJSON({
        path: ___R$romejs$path$index_ts$createUnknownFilePath(file.uid),
        input: src});

      const rawJson = JSON.stringify(obj);
      const json = rawJson === undefined ? 'undefined' : rawJson;

      return {
        sourceText: 'export default ' + json + ';',
        generated: true};
    }});

  const ___R$romejs$core$common$fileHandlers_ts$JS_EXTENSIONS = [];

  function ___R$$priv$romejs$core$common$fileHandlers_ts$buildJSHandler(ext, syntax, sourceType) {
    ___R$romejs$core$common$fileHandlers_ts$JS_EXTENSIONS.push(ext);

    return {
      hasteMode: 'ext',
      syntax: syntax,
      sourceType: sourceType,

      async analyzeDependencies({file: file, worker: worker}) {
        const {ast: ast, sourceText: sourceText, project: project, generated: generated} = await worker.parseJS(file);
        worker.logger.info('Analyzing:', file.real);

        return worker.api.interceptAndAddGeneratedToDiagnostics(
        (await ___R$romejs$js$compiler$index_ts.analyzeDependencies({
          ast: ast,
          sourceText: sourceText,
          project: project,
          options: {}})),
        generated);
      },

      async toJavaScript({file: file}) {
        return {
          sourceText: await ___R$romejs$fs$index_ts$readFileText(file.real),
          generated: false};
      },

      async lint(info) {
        const {file: ref, project: project, prefetchedModuleSignatures: prefetchedModuleSignatures, worker: worker} = info;

        const {ast: ast, sourceText: sourceText, generated: generated} = await worker.parseJS(
        ref);

        worker.logger.info('Linting: ', ref.real);

        const res = await ___R$romejs$js$compiler$index_ts.lint({
          options: {},
          ast: ast,
          project: project,
          sourceText: sourceText});

        let {diagnostics: diagnostics} = res;

        let typeCheckingEnabled = project.config.typeCheck.enabled === true;
        if (project.config.typeCheck.libs.has(ref.real)) {
          typeCheckingEnabled = false;
        }

        if (typeCheckingEnabled) {
          const typeCheckProvider = await worker.getTypeCheckProvider(
          ref.project,
          prefetchedModuleSignatures);
          const typeDiagnostics = await ___R$romejs$js$analysis$api$check_ts$default({
            ast: ast,
            provider: typeCheckProvider,
            project: project});
          diagnostics = [...diagnostics, ...typeDiagnostics];
        }

        return worker.api.interceptAndAddGeneratedToDiagnostics(
        {
          diagnostics: diagnostics,
          sourceText: sourceText,
          formatted: res.src},
        generated);
      }};
  }

  const ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS = new Map();

  const ___R$$priv$romejs$core$common$fileHandlers_ts$DEFUALT_ASSET_EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webm', 'mp4', 'm4v', 'avi', 'mkv', 'mp3', 'woff', 'woff2', 'eot', 'ttf', 'otf'];
  for (const ext of ___R$$priv$romejs$core$common$fileHandlers_ts$DEFUALT_ASSET_EXTENSIONS) {
    ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set(ext, ___R$$priv$romejs$core$common$fileHandlers_ts$assetHandler);
  }

  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('html', ___R$$priv$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('htm', ___R$$priv$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('css', ___R$$priv$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('txt', ___R$$priv$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('md', ___R$$priv$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('csv', ___R$$priv$romejs$core$common$fileHandlers_ts$textHandler);
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('tsv', ___R$$priv$romejs$core$common$fileHandlers_ts$textHandler);

  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('js', ___R$$priv$romejs$core$common$fileHandlers_ts$buildJSHandler('js', ['jsx', 'flow']));
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('jsx', ___R$$priv$romejs$core$common$fileHandlers_ts$buildJSHandler('jsx', ['jsx']));
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('cjs', ___R$$priv$romejs$core$common$fileHandlers_ts$buildJSHandler('cjs', [], 'script'));
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('mjs', ___R$$priv$romejs$core$common$fileHandlers_ts$buildJSHandler('mjs', [], 'module'));
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('ts', ___R$$priv$romejs$core$common$fileHandlers_ts$buildJSHandler('ts', ['ts'], 'module'));
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('tsx', ___R$$priv$romejs$core$common$fileHandlers_ts$buildJSHandler('tsx', ['ts', 'jsx'], 'module'));
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('json', ___R$$priv$romejs$core$common$fileHandlers_ts$jsonHandler);
  ___R$$priv$romejs$core$common$fileHandlers_ts$DEFAULT_HANDLERS.set('rjson', ___R$$priv$romejs$core$common$fileHandlers_ts$jsonHandler);

  const ___R$romejs$core$common$fileHandlers_ts$IMPLICIT_JS_EXTENSIONS = ['js', 'json', 'ts', 'tsx'];

  // romejs/js-compiler/plugins/compileForBundle/assetTransform.ts

  const ___R$romejs$js$compiler$plugins$compileForBundle$assetTransform_ts$default = {
    name: 'asset',

    enter(path) {
      const {node: node} = path;
      const options = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getOptions(path.context);

      if (node.type === 'ExportDefaultDeclaration' &&
      node.declaration.type === 'StringLiteral' &&
      node.declaration.value === ___R$romejs$core$common$fileHandlers_ts$ASSET_EXPORT_TEMPORARY_VALUE &&
      options.assetPath !== undefined) {
        return Object.assign({}, node, {
          declaration: Object.assign({}, node.declaration, {
            value: options.moduleId})});
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compileForBundle/modern/cjsRootTransform.ts

  const ___R$romejs$js$compiler$plugins$compileForBundle$modern$cjsRootTransform_ts$default = {
    name: 'cjsRootTransform',
    enter(path) {
      const {node: node, scope: scope, context: context} = path;

      const {moduleId: moduleId} = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getOptions(context);

      if (node.type === 'Program') {
        const mappings = new Map();

        for (const [name] of path.scope.bindings) {
          mappings.set(name, ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrivateName(name, moduleId));
        }

        if (scope.hasBinding('exports') === false) {
          mappings.set('exports', ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId));
        }

        const newProgram = ___R$romejs$js$ast$utils$renameBindings_ts$default(path, mappings);
        return newProgram;
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compileForBundle/modern/esToRefTransform.ts

  const ___R$romejs$js$compiler$plugins$compileForBundle$modern$esToRefTransform_ts$default = {
    name: 'esToRefTransform',
    enter(path) {
      const {node: node, scope: scope, context: context} = path;

      const opts = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getOptions(context);

      if (___R$romejs$js$ast$core$Program_ts$program.is(node)) {
        const mappings = new Map();

        for (const [name] of path.scope.bindings) {
          mappings.set(name, ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrivateName(name, opts.moduleId));
        }

        for (const child of node.body) {
          if (child.type === 'ImportDeclaration' &&
          child.importKind !== 'type' &&
          child.importKind !== 'typeof' &&
          child.specifiers !== undefined) {
            const moduleId = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getModuleId(child.source.value, opts);
            if (moduleId === undefined) {
              continue;
            }

            for (const specifier of child.specifiers) {
              if (specifier.type === 'ImportSpecifier') {
                mappings.set(
                specifier.local.name.name,
                ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName(specifier.imported.name, moduleId, opts));
              } else if (specifier.type === 'ImportNamespaceSpecifier') {
                mappings.set(
                specifier.local.name.name,
                ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId));
              } else if (specifier.type === 'ImportDefaultSpecifier') {
                mappings.set(
                specifier.local.name.name,
                ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName('default', moduleId, opts));
              } else {
                throw new Error('unexpected');
              }
            }
          }

          if (child.type === 'ExportNamedDeclaration' &&
          child.source === undefined) {
            for (const {name: name} of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(child)) {
              mappings.set(name, ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName(name, opts.moduleId, opts));
            }

            if (child.specifiers !== undefined) {
              for (const specifier of child.specifiers) {
                if (specifier.type !== 'ExportSpecifier') {
                  continue;
                }

                const local = specifier.local.name;
                if (scope.getBindingAssert(local) instanceof ___R$romejs$js$compiler$scope$bindings_ts$ImportBinding) {
                  continue;
                }

                mappings.set(
                local,
                ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName(specifier.exported.name, opts.moduleId, opts));
              }
            }
          }

          if (child.type === 'ExportDefaultDeclaration') {
            const {declaration: decl} = child;
            if ((decl.type === 'FunctionDeclaration' ||
            decl.type === 'ClassDeclaration') &&
            decl.id !== undefined) {
              mappings.set(
              decl.id.name,
              ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName('default', opts.moduleId, opts));
            }
          }
        }

        const newProgram = ___R$romejs$js$ast$core$Program_ts$program.assert(___R$romejs$js$ast$utils$renameBindings_ts$default(path, mappings));

        const newScope = scope.getRootScope().evaluate(newProgram, undefined, true);

        if (opts.moduleAll === true) {
          const exportNames = new Map();
          for (const child of newProgram.body) {
            if (child.type === 'ExportDefaultDeclaration') {
              exportNames.set(
              'default',
              ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName('default', opts.moduleId, opts));
            }

            if (child.type === 'ExportNamedDeclaration') {
              const {declaration: declaration, specifiers: specifiers} = child;

              if (declaration !== undefined) {
                throw new Error('No export declarations should be here as they have been removed by renameBindings');
              }

              if (specifiers !== undefined) {
                for (const specifier of specifiers) {
                  if (specifier.type === 'ExportSpecifier') {
                    let local = specifier.local.name;

                    if (child.source !== undefined) {
                      const moduleId = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getModuleId(child.source.value, opts);
                      if (moduleId === undefined) {
                        continue;
                      }

                      local = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName(local, moduleId, opts);
                    }

                    exportNames.set(specifier.exported.name, local);
                  } else {}
                }
              }
            }
          }

          const exportObjProps = [];

          for (const [exported, local] of exportNames) {
            const binding = newScope.getBinding(local);
            if (binding !== undefined) {
              if (binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding) {
                continue;
              }

              if (binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$FunctionBinding) {
                exportObjProps.push(
                ___R$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.create({
                  key: ___R$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(exported)),
                  value: ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(local)}));
                continue;
              }
            }

            exportObjProps.push(
            ___R$romejs$js$ast$objects$ObjectMethod_ts$objectMethod.create({
              kind: 'get',
              key: ___R$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(exported)),
              head: ___R$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.quick([]),
              body: ___R$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({
                body: [___R$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.create({
                  argument: ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create({
                    name: local})})]})}));
          }

          const exportObj = ___R$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({properties: exportObjProps});

          return Object.assign({}, newProgram, {
            type: 'Program',
            body: [___R$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
            ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
              kind: 'const',
              declarations: [___R$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
                id: ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
                  name: ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(opts.moduleId)}),
                init: exportObj})]})), ...newProgram.body]});
        } else {
          return newProgram;
        }
      }

      if (node.type === 'ImportDeclaration') {
        return ___R$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
      }

      if (node.type === 'ExportDefaultDeclaration') {
        const {declaration: declaration} = node;
        if (declaration.type === 'FunctionDeclaration' ||
        declaration.type === 'ClassDeclaration') {
          if (declaration.id === undefined) {
            return Object.assign({}, node, {
              declaration: Object.assign({}, declaration, {
                id: ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
                  name: ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName('default', opts.moduleId, opts)})})});
          } else {
            return declaration;
          }
        } else {
          return ___R$romejs$js$ast$utils$template_ts$default.statement`const ${___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName(
          'default',
          opts.moduleId,
          opts)} = ${declaration};`;
        }
      }

      if (node.type === 'ExportNamedDeclaration') {
        if (node.source !== undefined) {
          return ___R$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
        }

        const {declaration: declaration, specifiers: specifiers} = node;

        if (specifiers === undefined) {
          if (declaration === undefined) {
            throw new Error('No specifiers or declaration existed, if there\'s no specifiers then there should be a declaration');
          }
          return declaration;
        } else {
          const nodes = [];

          for (const specifier of specifiers) {
            if (specifier.type === 'ExportSpecifier') {
              const binding = path.scope.getBinding(specifier.local.name);

              if (binding === undefined || binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$ImportBinding) {
                nodes.push(
                ___R$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
                  kind: 'const',
                  declarations: [___R$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
                    id: ___R$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
                      name: ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedName(
                      specifier.exported.name,
                      opts.moduleId,
                      opts)}),
                    init: ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(specifier.local.name)})]}));
              }
            } else {}
          }

          if (nodes.length === 0) {
            return ___R$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
          } else {
            return nodes;
          }
        }
      }

      if (node.type === 'ExportAllDeclaration' && opts.moduleAll === true) {
        const moduleId = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getModuleId(node.source.value, opts);
        if (moduleId === undefined) {
          return node;
        }

        const theirNamespace = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId);
        const ourNamespace = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(opts.moduleId);
        return ___R$romejs$js$ast$utils$template_ts$default.statement`
        Object.keys(${theirNamespace}).forEach(function (key) {
          if (key === 'default') return undefined;
          Object.defineProperty(${ourNamespace}, key, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return ${theirNamespace}[key];
            }
          });
        });
      `;
      }

      if (node.type === 'ExportAllDeclaration' && opts.moduleAll !== true) {
        return ___R$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compileForBundle/modern/requireRewriteTransform.ts

  const ___R$romejs$js$compiler$plugins$compileForBundle$modern$requireRewriteTransform_ts$default = {
    name: 'requireRewriteTransform',
    enter(path) {
      const {node: node, context: context} = path;

      const {relativeSourcesToModuleId: relativeSourcesToModuleId, moduleId: moduleId} = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getOptions(context);

      if (node.type === 'MemberExpression' &&
      ___R$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(node, 'module.exports')) {
        return ___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.create({
          name: ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId),
          loc: ___R$romejs$js$ast$utils$inheritLoc_ts$default(node, 'module.exports')});
      }

      if (node.type === 'AssignmentExpression' &&
      ___R$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(node.left, 'module.exports')) {
        return ___R$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.create({
          operator: node.operator,
          left: ___R$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.create({
            name: ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(moduleId),
            loc: ___R$romejs$js$ast$utils$inheritLoc_ts$default(node, 'module.exports')}),
          right: node.right});
      }

      if (node.type === 'TSImportEqualsDeclaration' &&
      node.moduleReference.type === 'TSExternalModuleReference') {
        return ___R$romejs$js$ast$utils$template_ts$default.statement`const ${node.id} = require(${node.moduleReference.expression});`;
      }

      if (node.type !== 'CallExpression') {
        return node;
      }

      const {callee: callee} = node;
      if (callee.type !== 'ReferenceIdentifier' || callee.name !== 'require') {
        return node;
      }

      const sourceArg = node.arguments[0];
      if (sourceArg.type !== 'StringLiteral') {
        return node;
      }

      if (path.scope.hasBinding('require')) {
        return node;
      }

      const replacement = relativeSourcesToModuleId[sourceArg.value];
      if (typeof replacement === 'string') {
        return ___R$romejs$js$ast$auxiliary$Identifier_ts$identifier.create({
          name: ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(replacement)});
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compileForBundle/legacy/magicCJSTransform.ts

  const ___R$romejs$js$compiler$plugins$compileForBundle$legacy$magicCJSTransform_ts$default = {
    name: 'magicCJSTransform',
    enter(path) {
      const {node: node, scope: scope, context: context} = path;
      const options = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getOptions(context);

      if (node.type === 'CallExpression' &&
      node.callee.type === 'ReferenceIdentifier' &&
      node.callee.name === 'require' &&
      scope.getBinding('require') === undefined) {
        const args = node.arguments;
        const arg = args[0];

        if (args.length !== 1 || arg.type !== 'StringLiteral') {
          return node;
        }

        const source = arg.value;

        if (Object.prototype.hasOwnProperty.call(
        options.relativeSourcesToModuleId,
        source)) {
          const resolved = options.relativeSourcesToModuleId[source];
          const sourceNode = ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
            value: resolved});
          return ___R$romejs$js$ast$utils$template_ts$default.expression`Rome.requireNamespace(${sourceNode})`;
        }
      }

      if (node.type === 'ReferenceIdentifier' &&
      node.name === 'require' &&
      scope.getBinding('require') === undefined) {
        return ___R$romejs$js$ast$utils$template_ts$default.expression`Rome.requireNamespace`;
      }

      return node;
    },

    exit(path) {
      const {node: node, context: context} = path;
      const options = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getOptions(context);

      if (node.type === 'Program') {
        const source = ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
          value: options.moduleId});

        const factoryBody = ___R$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({
          directives: node.directives,
          body: node.body});

        const factory = Object.assign({}, ___R$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression.assert(
        ___R$romejs$js$ast$utils$template_ts$default.expression`(function(module, exports) {})`), {
          body: factoryBody});

        const declare = options.analyze.moduleType === 'es' ? ___R$romejs$js$ast$utils$template_ts$default.expression`Rome.declareES` : ___R$romejs$js$ast$utils$template_ts$default.expression`Rome.declareCJS`;
        const wrapper = ___R$romejs$js$ast$utils$template_ts$default.statement`${declare}(${source}, ${factory})`;

        return Object.assign({}, node, {
          directives: [],
          body: [wrapper]});
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compileForBundle/legacy/inlineRequiresTransform.ts

  const ___R$$priv$romejs$js$compiler$plugins$compileForBundle$legacy$inlineRequiresTransform_ts$NON_INLINED_REQUIRES = [];
  const ___R$romejs$js$compiler$plugins$compileForBundle$legacy$inlineRequiresTransform_ts$default = {
    name: 'inlineRequiresTransform',
    enter(path) {
      const {node: node} = path;

      if (node.type === 'ReferenceIdentifier') {
        const binding = path.scope.getBinding(node.name);

        if (binding !== undefined && binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$ConstBinding) {
          const source = ___R$romejs$js$ast$utils$getRequireSource_ts$default(binding.value, path.scope, true);
          if (source !== undefined &&
          !___R$$priv$romejs$js$compiler$plugins$compileForBundle$legacy$inlineRequiresTransform_ts$NON_INLINED_REQUIRES.includes(source) &&
          !___R$romejs$js$ast$utils$isInTypeAnnotation_ts$default(path) &&
          binding.value !== undefined) {
            return binding.value;
          }
        }
      }

      return node;
    },

    exit(path) {
      const {node: node} = path;

      if (node.type === 'Program' || node.type === 'BlockStatement') {
        const body = [];
        let hadRequires = false;

        for (const bodyNode of node.body) {
          if (bodyNode.type === 'VariableDeclarationStatement' &&
          bodyNode.declaration.kind === 'const') {
            let hadRequireDeclarators = false;
            const declarators = [];

            for (const decl of bodyNode.declaration.declarations) {
              if (decl.id.type !== 'BindingIdentifier') {
                declarators.push(decl);
                continue;
              }

              const source = ___R$romejs$js$ast$utils$getRequireSource_ts$default(decl.init, path.scope, true);
              if (source === undefined) {
                declarators.push(decl);
                continue;
              }

              if (___R$$priv$romejs$js$compiler$plugins$compileForBundle$legacy$inlineRequiresTransform_ts$NON_INLINED_REQUIRES.includes(source)) {
                declarators.push(decl);
                continue;
              }

              hadRequireDeclarators = true;
              hadRequires = true;
            }

            if (hadRequireDeclarators) {
              if (declarators.length > 0) {
                body.push(Object.assign({}, bodyNode, {
                  declaration: Object.assign({}, bodyNode.declaration, {
                    declarations: declarators})}));
              }
              continue;
            }
          }

          body.push(bodyNode);
        }

        if (!hadRequires) {
          return node;
        }

        return Object.assign({}, node, {
          body: body});
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compileForBundle/legacy/esToCJSTransform.ts

  const ___R$romejs$js$compiler$plugins$compileForBundle$legacy$esToCJSTransform_ts$default = {
    name: 'esToCJSTransform',
    enter(path) {
      const {node: node} = path;
      if (!___R$romejs$js$ast$core$Program_ts$program.is(node)) {
        return node;
      }

      const options = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getOptions(path.context);

      const topBody = [];
      const bottomBody = [];

      for (const bodyNode of node.body) {
        if (bodyNode.type === 'ImportDeclaration') {
          if (bodyNode.importKind === 'type') {
            continue;
          }

          const moduleId = ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getModuleId(bodyNode.source.value, options);
          if (moduleId === undefined) {
            continue;
          }

          const source = ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
            value: moduleId});

          const {specifiers: specifiers} = bodyNode;
          if (specifiers === undefined || specifiers.length === 0) {
            topBody.push(___R$romejs$js$ast$utils$template_ts$default.statement`Rome.requireNamespace(${source});`);
          } else {
            for (const specifier of specifiers) {
              if (specifier.local.importKind === 'type') {
                continue;
              }

              if (specifier.type === 'ImportSpecifier') {
                topBody.push(
                ___R$romejs$js$ast$utils$template_ts$default.statement`const ${specifier.local.name} = Rome.requireNamespace(${source}).${specifier.imported};`);
              } else if (specifier.type === 'ImportNamespaceSpecifier') {
                topBody.push(
                ___R$romejs$js$ast$utils$template_ts$default.statement`const ${specifier.local.name} = Rome.requireNamespace(${source});`);
              } else if (specifier.type === 'ImportDefaultSpecifier') {
                topBody.push(
                ___R$romejs$js$ast$utils$template_ts$default.statement`const ${specifier.local.name} = Rome.requireDefault(${source});`);
              }
            }
          }
          continue;
        }

        if (bodyNode.type === 'ExportAllDeclaration') {
          continue;
        }

        if (bodyNode.type === 'ExportNamedDeclaration') {
          if (bodyNode.exportKind === 'type') {
            continue;
          }

          const {declaration: declaration, specifiers: specifiers, source: source} = bodyNode;

          if (declaration !== undefined) {
            if (declaration.type === 'FunctionDeclaration') {
              topBody.push(
              ___R$romejs$js$ast$utils$template_ts$default.statement`exports.${declaration.id} = ${declaration.id}`);
              bottomBody.push(declaration);
              continue;
            }

            if (declaration.type === 'TSModuleDeclaration' ||
            declaration.type === 'TSEnumDeclaration' ||
            declaration.type === 'FlowInterfaceDeclaration' ||
            declaration.type === 'TypeAliasTypeAnnotation' ||
            declaration.type === 'TSInterfaceDeclaration' ||
            declaration.type === 'TSDeclareFunction' ||
            declaration.type === 'FlowOpaqueType') {
              bottomBody.push(declaration);
              continue;
            }

            if (declaration.type === 'VariableDeclarationStatement' ||
            declaration.type === 'ClassDeclaration') {
              bottomBody.push(declaration);

              for (const id of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(declaration)) {
                topBody.push(___R$romejs$js$ast$utils$template_ts$default.statement`exports.${id} = undefined;`);
                bottomBody.push(___R$romejs$js$ast$utils$template_ts$default.statement`exports.${id} = ${id};`);
              }
            }
          }

          if (specifiers !== undefined) {
            for (const specifier of specifiers) {
              if (specifier.type === 'ExportDefaultSpecifier') {}

              if (specifier.type === 'ExportNamespaceSpecifier') {}

              if (specifier.type === 'ExportSpecifier') {
                if (source === undefined) {
                  const binding = path.scope.getBinding(specifier.local.name);

                  if (binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$FunctionBinding) {
                    topBody.push(
                    ___R$romejs$js$ast$utils$template_ts$default.statement`exports.${specifier.exported} = ${specifier.local};`);
                  } else {
                    topBody.push(
                    ___R$romejs$js$ast$utils$template_ts$default.statement`exports.${specifier.exported} = undefined;`);
                    bottomBody.push(
                    ___R$romejs$js$ast$utils$template_ts$default.statement`exports.${specifier.exported} = ${specifier.local};`);
                  }
                } else {
                  topBody.push(
                  ___R$romejs$js$ast$utils$template_ts$default.statement`Object.defineProperty(exports, ${___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create(
                  {
                    value: specifier.exported.name})}, {
                    get: function() {
                      return Rome.requireNamespace(${source}).${specifier.local};
                    },
                  })`);
                }
              }
            }
          }

          continue;
        }

        if (bodyNode.type === 'ExportDefaultDeclaration') {
          const {declaration: declaration} = bodyNode;

          if (declaration.type === 'FunctionDeclaration') {
            if (declaration.id === undefined) {
              const expr = Object.assign({}, declaration, {
                type: 'FunctionExpression'});
              topBody.push(___R$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${expr};`);
            } else {
              topBody.push(declaration);
              topBody.push(
              ___R$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${declaration.id};`);
            }
            continue;
          }

          if (declaration.type === 'ClassDeclaration') {
            topBody.push(___R$romejs$js$ast$utils$template_ts$default.statement`exports.default = undefined;`);
            if (declaration.id === undefined) {
              const expr = Object.assign({}, declaration, {
                type: 'ClassExpression'});
              bottomBody.push(___R$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${expr};`);
            } else {
              bottomBody.push(declaration);
              bottomBody.push(
              ___R$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${declaration.id};`);
            }
            continue;
          }

          if (declaration.type === 'FlowDeclareOpaqueType' ||
          declaration.type === 'TSInterfaceDeclaration' ||
          declaration.type === 'TSDeclareFunction') {
            continue;
          }

          bottomBody.push(___R$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${declaration};`);

          topBody.push(___R$romejs$js$ast$utils$template_ts$default.statement`exports.default = undefined;`);

          continue;
        }

        bottomBody.push(bodyNode);
      }

      return Object.assign({}, node, {
        body: [...topBody, ...bottomBody]});
    }};

  // romejs/js-compiler/plugins/compileForBundle/metaPropertyTransform.ts

  function ___R$$priv$romejs$js$compiler$plugins$compileForBundle$metaPropertyTransform_ts$isImportMeta(node) {
    return node.type === 'MetaProperty' &&
    node.meta.name === 'import' &&
    node.property.name === 'meta';
  }

  function ___R$$priv$romejs$js$compiler$plugins$compileForBundle$metaPropertyTransform_ts$createURLString(context) {
    const str = ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
      value: 'file://' + ___R$$priv$romejs$js$compiler$plugins$compileForBundle$metaPropertyTransform_ts$getFilename(context)});
    return ___R$romejs$js$ast$utils$template_ts$default.expression`typeof __filename === 'string' ? 'file://' + __filename : ${str}`;
  }

  function ___R$$priv$romejs$js$compiler$plugins$compileForBundle$metaPropertyTransform_ts$getFilename(context) {
    const {path: path} = context;
    if (path === undefined) {
      return '';
    } else {
      return path.join();
    }
  }
  const ___R$romejs$js$compiler$plugins$compileForBundle$metaPropertyTransform_ts$default = {
    name: 'metaPropertyTransform',
    enter(path) {
      const {node: node, context: context} = path;

      if (node.type === 'MemberExpression' &&
      node.property.type === 'StaticMemberProperty' &&
      ___R$$priv$romejs$js$compiler$plugins$compileForBundle$metaPropertyTransform_ts$isImportMeta(node.object) &&
      node.property.value.type === 'Identifier' &&
      node.property.value.name === 'url') {
        return ___R$$priv$romejs$js$compiler$plugins$compileForBundle$metaPropertyTransform_ts$createURLString(context);
      }

      if (___R$$priv$romejs$js$compiler$plugins$compileForBundle$metaPropertyTransform_ts$isImportMeta(node)) {
        return ___R$romejs$js$ast$utils$template_ts$default.expression`({url: ${___R$$priv$romejs$js$compiler$plugins$compileForBundle$metaPropertyTransform_ts$createURLString(context)}})`;
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compileForBundle/scopedRomeTransform.ts

  const ___R$romejs$js$compiler$plugins$compileForBundle$scopedRomeTransform_ts$default = {
    name: 'scopedRome',

    enter(path) {
      const {node: node, scope: scope} = path;

      if (scope.node === node && scope.hasBinding('Rome')) {
        return ___R$romejs$js$ast$utils$renameBindings_ts$default(
        path,
        new Map([['Rome', scope.generateUid('Rome')]]));
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compileForBundle/asyncImportTransform.ts

  const ___R$romejs$js$compiler$plugins$compileForBundle$asyncImportTransform_ts$default = {
    name: 'asyncImport',

    enter(path) {
      const {node: node} = path;

      if (node.type === 'CallExpression' && node.callee.type === 'ImportCall') {
        return Object.assign({}, node, {
          callee: ___R$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create({
            name: 'require'})});
      }

      return node;
    }};

  // romejs/js-compiler/plugins/compileForBundle/inlineEnv.ts

  const ___R$romejs$js$compiler$plugins$compileForBundle$inlineEnv_ts$default = {
    name: 'inlineEnv',

    enter(path) {
      const {node: node} = path;

      if (node.type === 'MemberExpression' &&
      node.property.value.type === 'Identifier' &&
      node.property.value.name === 'NODE_ENV' &&
      !path.scope.hasBinding('process') &&
      ___R$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(node, 'process.env.NODE_ENV')) {
        return ___R$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
          value: 'development'});
      }

      return node;
    }};

  // romejs/js-compiler/plugins/index.ts

  const ___R$romejs$js$compiler$plugins$index_ts$stageOrder = ['pre', 'compile', 'compileForBundle'];

  const ___R$romejs$js$compiler$plugins$index_ts$hookVisitors = [___R$romejs$js$compiler$plugins$defaultHooks$index_ts$variableInjectorVisitor];

  const ___R$romejs$js$compiler$plugins$index_ts$stageTransforms = {
    pre: () => [___R$romejs$js$compiler$plugins$compile$validation$optimizeImports_ts$default, ___R$romejs$js$compiler$plugins$compile$validation$optimizeExports_ts$default, ___R$romejs$js$compiler$plugins$compile$jsx_ts$default],
    compile: () => [___R$romejs$js$compiler$plugins$compile$transpile$paramlessCatch_ts$default, ___R$romejs$js$compiler$plugins$compile$transpile$optionalChaining_ts$default, ___R$romejs$js$compiler$plugins$compile$transpile$nullishCoalescing_ts$default, ___R$romejs$js$compiler$plugins$compile$transpile$objectSpread_ts$default, ___R$romejs$js$compiler$plugins$compile$transpile$classProperties_ts$default, ___R$romejs$js$compiler$plugins$compile$transpile$templateLiterals_ts$default, ___R$romejs$js$compiler$plugins$compile$transpile$callSpread_ts$default],
    compileForBundle: (projectConfig, options) => {
      const opts = options.bundle;
      if (opts === undefined) {
        throw new Error('Expected bundle options for compileForBundle stage');
      }

      const transforms = [];

      if (opts.assetPath !== undefined) {
        transforms.push(___R$romejs$js$compiler$plugins$compileForBundle$assetTransform_ts$default);
      }
      transforms.push(___R$romejs$js$compiler$plugins$compileForBundle$metaPropertyTransform_ts$default);
      transforms.push(___R$romejs$js$compiler$plugins$compileForBundle$asyncImportTransform_ts$default);
      transforms.push(___R$romejs$js$compiler$plugins$compileForBundle$scopedRomeTransform_ts$default);
      transforms.push(___R$romejs$js$compiler$plugins$compileForBundle$inlineEnv_ts$default);

      if (opts.mode === 'modern') {
        transforms.push(___R$romejs$js$compiler$plugins$compileForBundle$modern$requireRewriteTransform_ts$default);
        transforms.push(
        opts.analyze.moduleType === 'cjs' ? ___R$romejs$js$compiler$plugins$compileForBundle$modern$cjsRootTransform_ts$default : ___R$romejs$js$compiler$plugins$compileForBundle$modern$esToRefTransform_ts$default);
      } else {
        transforms.push(___R$romejs$js$compiler$plugins$compileForBundle$legacy$inlineRequiresTransform_ts$default);
        transforms.push(___R$romejs$js$compiler$plugins$compileForBundle$legacy$esToCJSTransform_ts$default);
        transforms.push(___R$romejs$js$compiler$plugins$compileForBundle$legacy$magicCJSTransform_ts$default);
      }

      return transforms;
    }};

  // romejs/js-compiler/methods/transform.ts


  const ___R$$priv$romejs$js$compiler$methods$transform_ts$transformCaches = ___R$romejs$js$compiler$plugins$index_ts$stageOrder.map(
  () => new ___R$romejs$js$compiler$lib$Cache_ts$default());

  async function ___R$romejs$js$compiler$methods$transform_ts$default(req) {
    const stage = req.stage === undefined ? 'compile' : req.stage;

    const {options: options, project: project} = req;
    let ast = req.ast;

    const cacheQuery = ___R$romejs$js$compiler$lib$Cache_ts$default.buildQuery(req);

    const stageNo = ___R$romejs$js$compiler$plugins$index_ts$stageOrder.indexOf(stage);

    const stageCache = ___R$$priv$romejs$js$compiler$methods$transform_ts$transformCaches[stageNo];
    const cached = stageCache.get(cacheQuery);
    if (cached !== undefined) {
      return cached;
    }

    let prevStageDiagnostics = [];
    let prevStageCacheDeps = [];

    if (stageNo > 0) {
      const prevStage = await ___R$romejs$js$compiler$methods$transform_ts$default(Object.assign({}, req, {
        stage: ___R$romejs$js$compiler$plugins$index_ts$stageOrder[stageNo - 1]}));
      prevStageDiagnostics = prevStage.diagnostics;
      prevStageCacheDeps = prevStage.cacheDependencies;
      ast = prevStage.ast;
    }

    const context = new ___R$romejs$js$compiler$lib$Context_ts$default({
      ast: ast,
      project: project,
      options: options,
      origin: {
        category: 'transform'}});

    const transformFactory = ___R$romejs$js$compiler$plugins$index_ts$stageTransforms[stage];
    const transforms = transformFactory(project.config, options);

    let visitors = [...___R$romejs$js$compiler$plugins$index_ts$hookVisitors, ...(await context.normalizeTransforms(transforms))];

    const compiledAst = ___R$romejs$js$ast$core$Program_ts$program.assert(context.reduce(ast, visitors));

    const res = {
      diagnostics: [...prevStageDiagnostics, ...context.diagnostics],
      cacheDependencies: [...prevStageCacheDeps, ...context.getCacheDependencies()],
      ast: compiledAst};
    stageCache.set(cacheQuery, res);
    return res;
  }

  // romejs/node/index.ts

  const ___R$$priv$romejs$node$index_ts$mod = require('module');

  const ___R$$priv$romejs$node$index_ts$requires = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();

  function ___R$$priv$romejs$node$index_ts$getRequire(folder = ___R$romejs$path$index_ts$CWD_PATH) {
    const cached = ___R$$priv$romejs$node$index_ts$requires.get(folder);
    if (cached !== undefined) {
      return cached;
    }

    const req = ___R$$priv$romejs$node$index_ts$mod.createRequireFromPath(folder.join());
    ___R$$priv$romejs$node$index_ts$requires.set(folder, req);
    return req;
  }

  function ___R$romejs$node$index_ts$requireGlobal(name, folder) {
    return ___R$$priv$romejs$node$index_ts$getRequire(folder)(name);
  }

  // romejs/js-compiler/api/compile.ts


  const ___R$$priv$romejs$js$compiler$api$compile_ts$compileCache = new ___R$romejs$js$compiler$lib$Cache_ts$default();

  function ___R$$priv$romejs$js$compiler$api$compile_ts$extractPositionFromBabelSyntaxError(err) {
    if (!___R$romejs$typescript$helpers$index_ts$isPlainObject(err)) {
      return;
    }

    const {pos: pos} = err;
    if (typeof pos !== 'number') {
      return;
    }

    const {loc: loc} = err;
    if (!___R$romejs$typescript$helpers$index_ts$isPlainObject(loc)) {
      return;
    }

    const {line: line, column: column} = loc;
    if (typeof line !== 'number') {
      return;
    }
    if (typeof column !== 'number') {
      return;
    }

    return {
      line: ___R$romejs$ob1$index_ts$coerce1(line),
      column: ___R$romejs$ob1$index_ts$coerce0(column),
      index: ___R$romejs$ob1$index_ts$coerce0(pos)};
  }

  function ___R$$priv$romejs$js$compiler$api$compile_ts$babelInterop(req, res) {
    const {filename: filename} = req.ast;

    try {
      const babelResult = ___R$romejs$node$index_ts$requireGlobal(
      'babel-core',
      req.project.folder).transform(res.code, {
        filename: filename});

      const generatorResult = ___R$romejs$node$index_ts$requireGlobal(
      'babel-generator',
      req.project.folder).default(
      babelResult.ast,
      {
        sourceMaps: true},
      res.code);

      return Object.assign({}, res, {
        code: generatorResult.code,
        mappings: generatorResult.rawMappings});
    } catch (err) {
      const pos = ___R$$priv$romejs$js$compiler$api$compile_ts$extractPositionFromBabelSyntaxError(err);
      if (pos === undefined) {
        throw err;
      }

      const message = err.message.replace(/^(.*?):/, '').replace(/ \(\d+:\d+\)/, '').split('\n')[0].trim();

      const babelDiagnostic = {
        filename: filename,
        category: 'babel',
        message: message,

        sourceText: res.code,
        start: pos,
        end: pos,
        advice: [{
          type: 'log',
          category: 'warn',
          message: 'You are using Babel interop mode. This error is from Babel running over Rome emitted code'}]};

      return Object.assign({}, res, {
        cacheDependencies: [...res.cacheDependencies],
        diagnostics: [...res.diagnostics, babelDiagnostic]});
    }
  }

  async function ___R$romejs$js$compiler$api$compile_ts$default(req) {
    let {ast: ast} = req;
    const {sourceText: src} = req;

    let lintDiagnostics = [];
    if (req.lint === true) {
      ({ast: ast, diagnostics: lintDiagnostics} = await ___R$romejs$js$compiler$api$lint_ts$default(req));
      req = Object.assign({}, req, {
        ast: ast});
    } else {
      lintDiagnostics = ast.diagnostics;
    }

    const query = ___R$romejs$js$compiler$lib$Cache_ts$default.buildQuery(req);
    const cached = ___R$$priv$romejs$js$compiler$api$compile_ts$compileCache.get(query);
    if (cached) {
      return cached;
    }

    const {filename: filename} = ast;
    const {ast: transformedAst, diagnostics: diagnostics, cacheDependencies: cacheDependencies} = await ___R$romejs$js$compiler$methods$transform_ts$default(
    req);
    const generator = ___R$romejs$js$generator$index_ts$default(
    transformedAst,
    {
      typeAnnotations: false,
      indent: req.stage === 'compileForBundle' ? 1 : 0,
      sourceMapTarget: filename,
      sourceFileName: filename,
      inputSourceMap: req.inputSourceMap},
    src);
    let res = {
      code: generator.getCode(),
      mappings: generator.getMappings(),
      src: src,
      diagnostics: [...lintDiagnostics, ...diagnostics],
      cacheDependencies: cacheDependencies};
    ___R$$priv$romejs$js$compiler$api$compile_ts$compileCache.set(query, res);

    if (req.project.config.compiler.legacyBabelInterop) {
      res = ___R$$priv$romejs$js$compiler$api$compile_ts$babelInterop(req, res);
    }

    return res;
  }

  // romejs/js-compiler/api/analyzeDependencies/records.ts

  class ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord extends ___R$romejs$js$compiler$lib$Record_ts$default {
    constructor(data) {
      super();
      this.data = data;
    }
  }

  class ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord extends ___R$romejs$js$compiler$lib$Record_ts$default {
    constructor(data) {
      super();
      this.data = data;
    }
  }

  class ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord extends ___R$romejs$js$compiler$lib$Record_ts$default {
    constructor(node) {
      super();
      this.node = node;
    }
  }

  class ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord extends ___R$romejs$js$compiler$lib$Record_ts$default {
    constructor(node) {
      super();
      this.node = node;
    }
  }

  class ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord extends ___R$romejs$js$compiler$lib$Record_ts$default {
    constructor(node) {
      super();
      this.node = node;
    }
  }

  class ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ESExportRecord extends ___R$romejs$js$compiler$lib$Record_ts$default {
    constructor(kind, node) {
      super();
      this.node = node;
      this.kind = kind;
    }
  }

  class ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord extends ___R$romejs$js$compiler$lib$Record_ts$default {
    constructor(loc) {
      super();
      this.loc = loc;
    }
  }

  class ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord extends ___R$romejs$js$compiler$lib$Record_ts$default {
    constructor(isTop, data) {
      super();
      this.isTop = isTop;
      this.data = data;
    }
  }

  // romejs/js-compiler/api/analyzeDependencies/utils.ts

  function ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path) {
    for (const {node: node} of path.ancestryPaths) {
      if (node.type === 'TryStatement') {
        return true;
      }
    }

    return false;
  }

  function ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$isTypeKind(kind) {
    return kind === 'type' || kind === 'typeof';
  }

  function ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(kind) {
    return kind === undefined ? 'value' : kind;
  }

  function ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(kind) {
    return kind === undefined ? 'value' : kind;
  }

  function ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(kind, scope, id) {
    const binding = scope.getBinding(id.name);
    if (kind === 'value' && binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding) {
      return 'type';
    } else {
      return kind;
    }
  }

  function ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(rawKind, specifierKinds) {
    const kind = ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(rawKind);
    if (___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$isTypeKind(kind) || specifierKinds.length === 0) {
      return kind;
    }

    for (const specifierKind of specifierKinds) {
      if (specifierKind === 'value') {
        return 'value';
      }
    }
    return 'type';
  }

  function ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node) {
    if (node === undefined) {
      return 'other';
    }

    if (node.type === 'Identifier') {
      const binding = scope.getBinding(node.name);

      if (binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$FunctionBinding) {
        return 'function';
      }

      if (binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$ClassBinding) {
        return 'class';
      }

      if (binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding) {
        const {kind: kind} = binding;
        switch (kind) {
          case 'function':
          case 'class':
            return kind;}
      }
    }

    if (node.type === 'FunctionDeclaration') {
      return 'function';
    }

    if (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') {
      return 'class';
    }

    return 'other';
  }

  function ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node) {
    if (node.type === 'ReferenceIdentifier') {
      const binding = scope.getBinding(node.name);
      if (binding !== undefined) {
        return binding.node.loc;
      }
    }

    return node.loc;
  }

  // romejs/js-compiler/api/analyzeDependencies/visitors/es.ts

  const ___R$romejs$js$compiler$api$analyzeDependencies$visitors$es_ts$default = {
    name: 'analyzeDependenciesES',
    enter(path) {
      const {node: node, scope: scope, context: context} = path;

      if (node.type === 'ImportCall' && node.argument.type === 'StringLiteral') {
        context.record(
        new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
          type: 'es',
          async: true,
          kind: 'value',
          names: [],
          loc: node.argument.loc,
          source: node.argument.value,
          optional: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
          all: true}));
      }

      if (node.type === 'ExportNamedDeclaration' && node.source === undefined) {
        const valueType = ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node.declaration);
        for (const id of ___R$romejs$js$ast$utils$getBindingIdentifiers_ts$default(node)) {
          const kind = ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(
          ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(node.exportKind),
          scope,
          id);
          context.record(
          new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
            type: 'local',
            valueType: valueType,
            kind: kind,
            loc: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, id),
            name: id.name}));
        }

        const {specifiers: specifiers} = node;
        if (specifiers !== undefined) {
          for (const specifier of specifiers) {
            switch (specifier.type) {
              case 'ExportSpecifier':
                {
                  const kind = ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(
                  ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(specifier.exportKind || node.exportKind),
                  scope,
                  specifier.local);

                  context.record(
                  new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
                    type: 'local',
                    loc: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, specifier.local),
                    valueType: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, specifier.local),
                    kind: kind,
                    name: specifier.exported.name}));
                  break;
                }

              case 'ExportNamespaceSpecifier':
                throw new Error('unimplemented');

              case 'ExportDefaultSpecifier':
                throw new Error('unimplemented');}
          }
        }
      }

      if (node.type === 'ExportDefaultDeclaration') {
        context.record(
        new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
          type: 'local',
          loc: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.declaration),
          valueType: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node.declaration),
          kind: 'value',
          name: 'default'}));
      }

      if (node.type === 'ExportNamedDeclaration') {
        const {source: source} = node;
        if (source !== undefined) {
          const specifiersKinds = [];
          const exportedNames = [];

          const {specifiers: specifiers} = node;
          if (specifiers !== undefined) {
            for (const specifier of specifiers) {
              switch (specifier.type) {
                case 'ExportSpecifier':
                  {
                    const kind = ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(
                    specifier.exportKind || node.exportKind);
                    specifiersKinds.push(kind);

                    exportedNames.push({
                      name: specifier.local.name,
                      kind: kind,
                      loc: specifier.loc});

                    context.record(
                    new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
                      type: 'external',
                      kind: kind,
                      loc: specifier.loc,
                      imported: specifier.local.name,
                      exported: specifier.exported.name,
                      source: source.value}));
                    break;
                  }

                case 'ExportNamespaceSpecifier':
                  throw new Error('unimplemented');

                case 'ExportDefaultSpecifier':
                  throw new Error('unimplemented');}
            }
          }

          context.record(
          new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
            type: 'es',
            async: false,
            kind: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(node.exportKind, specifiersKinds),
            names: exportedNames,
            loc: source.loc,
            source: source.value,
            optional: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
            all: false}));
        }
      }

      if (node.type === 'TSImportEqualsDeclaration' &&
      node.moduleReference.type === 'TSExternalModuleReference') {
        context.record(
        new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
          type: 'cjs',
          kind: 'value',
          optional: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
          loc: node.loc,
          source: node.moduleReference.expression.value,
          names: [],
          all: true,
          async: false}));
      }

      if (node.type === 'ExportAllDeclaration') {
        context.record(
        new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
          type: 'es',
          async: false,
          kind: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(node.exportKind),
          optional: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
          loc: node.source.loc,
          names: [],
          source: node.source.value,
          all: true}));

        context.record(
        new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
          type: 'externalAll',
          loc: node.loc,
          kind: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(node.exportKind),
          source: node.source.value}));
      }

      if (node.type === 'ExportAllDeclaration' ||
      node.type === 'ExportDefaultDeclaration' ||
      node.type === 'ExportNamedDeclaration') {
        context.record(new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ESExportRecord(___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(node.exportKind), node));
      }

      if (node.type === 'ImportDeclaration') {
        let hasNamespaceSpecifier = false;
        const specifierKinds = [];
        const names = [];

        const {specifiers: specifiers} = node;
        if (specifiers !== undefined) {
          for (const specifier of specifiers) {
            if (specifier.type === 'ImportNamespaceSpecifier') {
              hasNamespaceSpecifier = true;
              break;
            }

            const kind = ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(
            specifier.local.importKind || node.importKind);
            specifierKinds.push(kind);

            if (specifier.type === 'ImportDefaultSpecifier') {
              names.push({
                kind: kind,
                loc: specifier.loc,
                name: 'default'});
            }

            if (specifier.type === 'ImportSpecifier') {
              names.push({
                kind: kind,
                loc: specifier.loc,
                name: specifier.imported.name});
            }
          }
        }

        context.record(
        new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
          type: 'es',
          async: false,
          kind: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(node.importKind, specifierKinds),
          loc: node.source.loc,
          optional: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
          source: node.source.value,
          all: hasNamespaceSpecifier,
          names: names}));
      }

      if (node.type === 'AwaitExpression' &&
      path.findAncestry(path => ___R$romejs$js$ast$utils$isFunctionNode_ts$default(path.node)) === undefined) {
        const {loc: loc} = node;
        if (loc === undefined) {
          throw new Error('loc is undefined on AwaitExpression we want to mark');
        }
        context.record(new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord(loc));
      }

      if (node.type === 'ReferenceIdentifier') {
        const binding = path.scope.getBinding(node.name);

        if (binding !== undefined && binding instanceof ___R$romejs$js$compiler$scope$bindings_ts$ImportBinding) {
          const {meta: meta} = binding;

          if (meta.type !== 'name') {
            return node;
          }

          const deferredExecution = path.findAncestry(
          path => ___R$romejs$js$ast$utils$isFunctionNode_ts$default(path.node) || path.node.type === 'ClassProperty');
          const isTop = deferredExecution === undefined;

          let kind = ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(meta.kind);
          if (___R$romejs$js$ast$utils$isInTypeAnnotation_ts$default(path)) {
            kind = 'type';
          }

          context.record(
          new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord(isTop, {
            kind: kind,
            loc: node.loc,
            local: node.name,
            imported: meta.imported,
            source: meta.source}));
        }
      }

      return node;
    }};

  // romejs/js-compiler/api/analyzeDependencies/visitors/cjs.ts

  const ___R$romejs$js$compiler$api$analyzeDependencies$visitors$cjs_ts$default = {
    name: 'analyzeDependenciesCJS',
    enter(path) {
      const {node: node, parent: parent, scope: scope, context: context} = path;

      if (node.type === 'CallExpression') {
        const {callee: callee, arguments: args} = node;

        const isRequire = callee.type === 'ReferenceIdentifier' &&
        callee.name === 'require' &&
        path.scope.hasBinding('require') === false;
        const sourceArg = args[0];

        if (isRequire &&
        args.length === 1 &&
        sourceArg.type === 'StringLiteral') {
          context.record(
          new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
            type: 'cjs',
            kind: 'value',
            optional: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(path),
            loc: node.loc,
            source: sourceArg.value,
            names: [],
            all: true,
            async: false}));
        }
      }

      if (node.type === 'AssignmentExpression') {
        const isModuleExports = path.scope.getBinding('module') === undefined &&
        ___R$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(node.left, 'module.exports', true);
        const isExports = path.scope.getBinding('exports') === undefined &&
        ___R$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(node.left, 'exports', true);

        if (isModuleExports || isExports) {
          context.record(new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord(node));
        }

        if (isModuleExports) {
          const {right: right} = node;

          if (___R$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.is(right)) {
            context.record(
            new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
              type: 'local',
              loc: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.right),
              valueType: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node.right),
              kind: 'value',
              name: 'default'}));

            for (const prop of right.properties) {
              if (prop.type === 'SpreadProperty' ||
              prop.key.type === 'ComputedPropertyKey' &&
              prop.key.value.type !== 'StringLiteral') {
                context.record(new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(prop));
                continue;
              }

              const key = prop.key.value;
              let name;
              if (key.type === 'Identifier') {
                name = key.name;
              } else if (key.type === 'StringLiteral') {
                name = key.value;
              } else {
                context.record(new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(key));
                continue;
              }

              let target = prop.type === 'ObjectMethod' ? prop : prop.value;

              context.record(
              new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
                type: 'local',
                loc: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, target),
                valueType: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, target),
                kind: 'value',
                name: name}));
            }
          } else {
            const source = ___R$romejs$js$ast$utils$getRequireSource_ts$default(node.right, scope);
            if (source === undefined) {
              context.record(
              new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
                type: 'local',
                loc: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.right),
                valueType: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node.right),
                kind: 'value',
                name: 'default'}));
            } else {
              context.record(
              new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
                type: 'externalAll',
                loc: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.right),
                kind: 'value',
                source: source}));

              context.record(
              new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
                type: 'external',
                kind: 'value',
                loc: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.right),
                imported: 'default',
                exported: 'default',
                source: source}));
            }
          }
        }

        if (isExports) {
          const [, parts] = ___R$romejs$js$ast$utils$getNodeReferenceParts_ts$default(node.left);

          const name = parts[1];

          context.record(
          new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
            type: 'local',
            loc: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(scope, node.right),
            valueType: ___R$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(scope, node.right),
            kind: 'value',
            name: name}));
        }
      }

      if (node.type === 'ReferenceIdentifier') {
        const binding = path.scope.getBinding(node.name);

        if (binding === undefined) {
          if (node.name === '__filename' ||
          node.name === '__dirname' ||
          node.name === 'require' ||
          node.name === 'module' ||
          node.name === 'exports') {
            context.record(new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord(node));
          }

          if (node.name === 'module' || node.name === 'exports') {
            const inMemberExpression = parent.type === 'MemberExpression' && parent.object === node;
            if (!inMemberExpression) {
              context.record(new ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(node));
            }
          }
        }
      }

      return node;
    }};

  // romejs/js-compiler/api/analyzeDependencies/visitors/index.ts

  const ___R$romejs$js$compiler$api$analyzeDependencies$visitors$index_ts$default = [___R$romejs$js$compiler$api$analyzeDependencies$visitors$es_ts$default, ___R$romejs$js$compiler$api$analyzeDependencies$visitors$cjs_ts$default];

  // romejs/js-compiler/api/analyzeDependencies/index.ts

  const ___R$$priv$romejs$js$compiler$api$analyzeDependencies$index_ts$analyzeCache = new ___R$romejs$js$compiler$lib$Cache_ts$default();

  async function ___R$romejs$js$compiler$api$analyzeDependencies$index_ts$default(req) {
    const {ast: ast, project: project} = req;

    const query = ___R$romejs$js$compiler$lib$Cache_ts$default.buildQuery(req);
    const cached = ___R$$priv$romejs$js$compiler$api$analyzeDependencies$index_ts$analyzeCache.get(query);
    if (cached) {
      return cached;
    }

    const context = new ___R$romejs$js$compiler$lib$Context_ts$default({
      ast: ast,
      project: project,
      origin: {
        category: 'analyzeDependencies'}});
    const {ast: transformedAst} = await ___R$romejs$js$compiler$methods$transform_ts$default(Object.assign({}, req, {
      stage: 'pre'}));
    context.reduce(transformedAst, ___R$romejs$js$compiler$api$analyzeDependencies$visitors$index_ts$default);

    const importFirstUsage = [];
    const seenImportFirstUsage = new Set();

    const exports = [];
    const dependenciesBySource = new Map();

    const esValueExports = [];
    const cjsExports = [];
    let firstTopAwaitLocation;

    let hasCJSRef = false;

    let hasDefaultExport = false;

    const sourcesUsedAsType = new Set();
    const sourcesUsedAsValue = new Set();
    for (const record of context.records) {
      let data;

      if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord) {
        data = record.data;
      }

      if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord && record.data.type !== 'local') {
        data = record.data;
      }

      if (data !== undefined) {
        const {kind: kind, source: source} = data;
        if (kind === 'type') {
          sourcesUsedAsType.add(source);
        } else {
          sourcesUsedAsValue.add(source);
        }
      }
    }
    for (const source of sourcesUsedAsValue) {
      sourcesUsedAsType.delete(source);
    }

    for (const record of context.records) {
      if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord) {
        exports.push({
          type: 'local',
          loc: record.node.loc,
          kind: 'value',
          valueType: 'other',
          name: '*'});
      }

      if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord) {
        let {data: data} = record;

        if (data.type === 'es' &&
        data.kind === 'value' &&
        sourcesUsedAsType.has(data.source)) {
          const names = [];

          for (const name of data.names) {
            names.push(Object.assign({}, name, {
              kind: 'type'}));
          }

          data = Object.assign({}, data, {
            kind: 'type', names: names});
        }

        const existing = dependenciesBySource.get(data.source);
        if (existing === undefined) {
          dependenciesBySource.set(data.source, data);
        } else {
          let kind;
          if (data.kind === existing.kind) {
            kind = data.kind;
          } else {
            kind = 'value';
          }

          const combinedRecord = {
            type: data.type === 'es' && existing.type === 'es' ? 'es' : 'cjs',
            kind: kind,
            optional: existing.optional && data.optional,
            async: existing.async || data.async,
            source: data.source,
            all: existing.all || data.all,
            names: [...existing.names, ...data.names],
            loc: existing.loc || data.loc};

          if (existing.kind === 'type' && data.kind === 'value') {
            dependenciesBySource.delete(data.source);
          }

          dependenciesBySource.set(data.source, combinedRecord);
        }
      } else if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord) {
        exports.push(record.data);
      } else if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord) {
        hasCJSRef = true;
      } else if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord) {
        cjsExports.push(record.node);
      } else if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ESExportRecord) {
        if (record.kind === 'value') {
          esValueExports.push(record.node);
        }
      } else if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord) {
        if (firstTopAwaitLocation === undefined) {
          firstTopAwaitLocation = record.loc;
        }
      } else if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord &&
      record.isTop &&
      record.data.kind === 'value') {
        const {data: data} = record;
        const key = data.source + ':' + data.imported;
        if (seenImportFirstUsage.has(key)) {
          continue;
        }

        seenImportFirstUsage.add(key);
        importFirstUsage.push(data);
      }
    }

    const dependencies = Array.from(
    dependenciesBySource.values());

    let moduleType = ast.sourceType === 'script' ? 'cjs' : 'es';

    if (project.config.bundler.mode === 'legacy') {
      if (cjsExports.length > 0) {
        moduleType = 'cjs';
      } else if (esValueExports.length > 0) {
        moduleType = 'es';
      } else if (hasCJSRef) {
        moduleType = 'cjs';
      } else {
        moduleType = 'unknown';
      }
    }

    for (const record of context.records) {
      if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord) {
        if (project.config.bundler.mode === 'modern' && moduleType === 'es') {}
      } else if (record instanceof ___R$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord) {
        if (moduleType === 'es') {
          context.addNodeDiagnostic(record.node, {
            category: 'analyzeDependencies',
            message: 'You cannot use CommonJS exports in an ES module'});
        }
      }
    }

    if (moduleType === 'cjs' && !hasDefaultExport) {
      exports.push({
        type: 'local',
        loc: undefined,
        kind: 'value',
        valueType: 'other',
        name: 'default'});
    }

    const res = {
      moduleType: moduleType,
      firstTopAwaitLocation: firstTopAwaitLocation,
      exports: exports,
      dependencies: dependencies,
      importFirstUsage: importFirstUsage,
      syntax: ast.syntax,
      diagnostics: [...ast.diagnostics, ...context.diagnostics]};
    ___R$$priv$romejs$js$compiler$api$analyzeDependencies$index_ts$analyzeCache.set(query, res);
    return res;
  }

  function ___R$romejs$js$compiler$api$analyzeDependencies$index_ts$mergeAnalyzeDependencies(main, second) {
    const exports = [...main.exports];

    for (const exp of second.exports) {
      if (exp.type === 'local' && exp.kind === 'type') {
        exports.push(exp);
      }

      if (exp.type === 'external' || exp.type === 'externalAll') {
        exports.push(Object.assign({}, exp, {
          kind: 'type'}));
      }
    }

    return Object.assign({}, main, {
      exports: exports,
      diagnostics: [...main.diagnostics, ...second.diagnostics]});
  }

  // romejs/js-compiler/scope/bindings.ts

  const ___R$romejs$js$compiler$scope$bindings_ts = {
    get Binding() {
      return ___R$romejs$js$compiler$scope$bindings_ts$Binding;
    },
    get ConstBinding() {
      return ___R$romejs$js$compiler$scope$bindings_ts$ConstBinding;
    },
    get LetBinding() {
      return ___R$romejs$js$compiler$scope$bindings_ts$LetBinding;
    },
    get VarBinding() {
      return ___R$romejs$js$compiler$scope$bindings_ts$VarBinding;
    },
    get ImportBinding() {
      return ___R$romejs$js$compiler$scope$bindings_ts$ImportBinding;
    },
    get ArgumentsBinding() {
      return ___R$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding;
    },
    get FunctionBinding() {
      return ___R$romejs$js$compiler$scope$bindings_ts$FunctionBinding;
    },
    get TypeBinding() {
      return ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding;
    },
    get ClassBinding() {
      return ___R$romejs$js$compiler$scope$bindings_ts$ClassBinding;
    }};
  let ___R$$priv$romejs$js$compiler$scope$bindings_ts$id = 0;

  class ___R$romejs$js$compiler$scope$bindings_ts$Binding {
    constructor(opts) {
      this.isExported = false;
      this.scope = opts.scope;
      this.name = opts.name;
      this.node = opts.node;
      this.id = ___R$$priv$romejs$js$compiler$scope$bindings_ts$id++;
    }

    setExported(isExported) {
      this.isExported = isExported;
    }
  }

  class ___R$romejs$js$compiler$scope$bindings_ts$ConstBinding extends ___R$romejs$js$compiler$scope$bindings_ts$Binding {
    constructor(opts, value) {
      super(opts);
      this.value = value;
    }
  }

  class ___R$romejs$js$compiler$scope$bindings_ts$LetBinding extends ___R$romejs$js$compiler$scope$bindings_ts$Binding {}

  class ___R$romejs$js$compiler$scope$bindings_ts$VarBinding extends ___R$romejs$js$compiler$scope$bindings_ts$Binding {}

  class ___R$romejs$js$compiler$scope$bindings_ts$ImportBinding extends ___R$romejs$js$compiler$scope$bindings_ts$Binding {
    constructor(opts, meta) {
      super(opts);
      this.meta = meta;
    }
  }

  class ___R$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding extends ___R$romejs$js$compiler$scope$bindings_ts$Binding {}

  class ___R$romejs$js$compiler$scope$bindings_ts$FunctionBinding extends ___R$romejs$js$compiler$scope$bindings_ts$Binding {}

  class ___R$romejs$js$compiler$scope$bindings_ts$TypeBinding extends ___R$romejs$js$compiler$scope$bindings_ts$ConstBinding {
    constructor(opts, valueNode, kind) {
      super(opts, valueNode);
      this.kind = kind;
    }
  }

  class ___R$romejs$js$compiler$scope$bindings_ts$ClassBinding extends ___R$romejs$js$compiler$scope$bindings_ts$Binding {}

  // romejs/js-compiler/api/createHook.ts


  function ___R$romejs$js$compiler$api$createHook_ts$default(descriptor) {
    return descriptor;
  }

  // romejs/js-compiler/types.ts

  const ___R$romejs$js$compiler$types_ts = {};

  // romejs/js-compiler/index.ts

  const ___R$romejs$js$compiler$index_ts = {
    get Context() {
      return ___R$romejs$js$compiler$lib$Context_ts$default;
    },
    get PathOptions() {
      return ___R$romejs$js$compiler$lib$Path_ts$PathOptions;
    },
    get Path() {
      return ___R$romejs$js$compiler$lib$Path_ts$default;
    },
    get Record() {
      return ___R$romejs$js$compiler$lib$Record_ts$default;
    },
    get Cache() {
      return ___R$romejs$js$compiler$lib$Cache_ts$default;
    },
    get lint() {
      return ___R$romejs$js$compiler$api$lint_ts$default;
    },
    get compile() {
      return ___R$romejs$js$compiler$api$compile_ts$default;
    },
    get analyzeDependencies() {
      return ___R$romejs$js$compiler$api$analyzeDependencies$index_ts$default;
    },
    get mergeAnalyzeDependencies() {
      return ___R$romejs$js$compiler$api$analyzeDependencies$index_ts$mergeAnalyzeDependencies;
    },
    get Scope() {
      return ___R$romejs$js$compiler$scope$Scope_ts$default;
    },
    get getPrefixedBundleNamespace() {
      return ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace;
    },
    get createHook() {
      return ___R$romejs$js$compiler$api$createHook_ts$default;
    },
    get LintResult() {
      return ___R$romejs$js$compiler$api$lint_ts$LintResult;
    },
    get CompileResult() {
      return ___R$romejs$js$compiler$api$compile_ts$CompileResult;
    },
    get HookDescriptor() {
      return ___R$romejs$js$compiler$api$createHook_ts$HookDescriptor;
    }};
  Object.keys(___R$romejs$js$compiler$scope$bindings_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$compiler$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$compiler$scope$bindings_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$compiler$constants_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$compiler$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$compiler$constants_ts[key];
      }});
  });
  Object.keys(___R$romejs$js$compiler$types_ts).forEach(function(key) {
    if (key === 'default') return undefined;
    Object.defineProperty(___R$romejs$js$compiler$index_ts, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return ___R$romejs$js$compiler$types_ts[key];
      }});
  });

  // romejs/project/types.ts

  const ___R$romejs$project$types_ts = {
    get DEFAULT_PROJECT_CONFIG_META() {
      return ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG_META;
    },
    get DEFAULT_PROJECT_CONFIG() {
      return ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG;
    }};

  const ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG_META = {
    sourceType: 'vanilla',
    folder: undefined,
    configPath: undefined,
    configHashes: [],
    configDependencies: new ___R$romejs$path$collections_ts$AbsoluteFilePathSet(),
    consumer: undefined,
    consumersChain: []};

  const ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG = {
    name: 'unknown',
    isolated: false,
    version: undefined,

    cache: {},

    develop: {
      serveStatic: true},

    bundler: {
      mode: 'modern'},

    compiler: {
      legacyBabelInterop: false},

    resolver: {},

    typeCheck: {
      enabled: false,

      libs: new ___R$romejs$path$collections_ts$AbsoluteFilePathSet()},

    dependencies: {
      enabled: false},

    format: {
      enabled: false},

    haste: {
      enabled: false,
      ignore: []},

    lint: {
      enabled: false,
      legacyEslintInterop: false,
      ignore: [],
      globals: []},

    tests: {
      enabled: false,
      folderName: '__rtests__',
      mocksFolderName: '__rmocks__',
      ignore: []},

    vsc: {
      root: ___R$romejs$path$index_ts$createAbsoluteFilePath('/')},

    files: {
      vendorPath: ___R$romejs$path$index_ts$TEMP_PATH.append('rome-remote'),
      assetExtensions: [],
      watchman: false,
      maxSize: 40000000},

    targets: new Map()};

  // romejs/path-match/parse.ts


  const ___R$$priv$romejs$path$match$parse_ts$createPathMatchParser = ___R$romejs$parser$core$index_ts$createParser(
  ParserCore => (() => {
    class PathMatchParser extends ParserCore {
      constructor(opts, mode) {
        super(opts, '@romejs/patch-match');
        this.mode = mode;
      }

      isWordCharacter(char, index, input) {
        const prevChar = input[___R$romejs$ob1$index_ts$get0(index) - 1];
        const nextChar = input[___R$romejs$ob1$index_ts$get0(index) + 1];

        if (char === '\\' && nextChar === '\\') {
          return false;
        }

        if (prevChar === '\\') {
          return true;
        }

        if (char === '/') {
          return false;
        }

        if (this.mode === 'pattern') {
          if (char === '*') {
            return false;
          }

          if (char === '#') {
            return false;
          }
        }

        return true;
      }

      tokenize(index, input) {
        const char = input[___R$romejs$ob1$index_ts$get0(index)];
        const nextChar = input[___R$romejs$ob1$index_ts$get0(index) + 1];

        if (this.mode === 'pattern') {
          if (char === '*') {
            if (nextChar === '*') {
              return this.finishToken('DoubleStar', ___R$romejs$ob1$index_ts$add(index, 2));
            } else {
              return this.finishToken('Star');
            }
          } else if (index === ___R$romejs$ob1$index_ts$number0 && char === '!') {
            return this.finishToken('Exclamation');
          } else if (char === '#') {
            return this.finishToken('Hash');
          }
        }

        if (char === '/') {
          return this.finishToken('Separator');
        } else if (char === '\\' && nextChar === '\\') {
          return this.finishToken('Separator', ___R$romejs$ob1$index_ts$add(index, 2));
        }

        const value = this.readInputFrom(
        index,
        this.isWordCharacter.bind(this));
        return this.finishValueToken('Word', value, ___R$romejs$ob1$index_ts$add(index, value.length));
      }

      eatSeparators() {
        let ate = false;
        while (this.eatToken('Separator') !== undefined) {
          ate = true;
        }
        return ate;
      }

      parsePatternSegmentPart() {
        const startPos = this.getPosition();
        const token = this.getToken();
        this.nextToken();

        switch (token.type) {
          case 'Star':
            return {
              type: 'Wildcard',
              loc: this.finishLoc(startPos)};

          case 'Word':
            return {
              type: 'Word',
              loc: this.finishLoc(startPos),
              value: token.value};

          default:
            throw this.unexpected({
              start: startPos,
              message: 'Invalid pattern segment part'});}
      }

      parseSegment() {
        const startPos = this.getPosition();
        const parts = [];

        if (this.matchToken('DoubleStar')) {
          const lookahead = this.lookaheadToken();
          if (lookahead.type === 'Separator' || lookahead.type === 'EOF') {
            this.eatToken('DoubleStar');
            this.eatSeparators();
            return {
              type: 'WildcardSegment',
              loc: this.finishLoc(startPos)};
          }
        }

        while (!this.matchToken('Hash') &&
        !this.matchToken('EOF') &&
        !this.eatSeparators()) {
          parts.push(this.parsePatternSegmentPart());
        }

        return {
          loc: this.finishLoc(startPos),
          type: 'Segment',
          parts: parts};
      }

      isWildcardOnlySegment(segment) {
        if (segment === undefined) {
          return false;
        }

        if (segment.type === 'WildcardSegment') {
          return true;
        }

        if (segment.parts.length === 1 &&
        segment.parts[0].type === 'Wildcard') {
          return true;
        }

        return false;
      }

      normalizePatternSegments(segments) {
        const normalized = [];

        if (segments.length === 1) {
          return segments;
        }

        for (const seg of segments) {
          if (normalized.length === 0 && this.isWildcardOnlySegment(seg)) {
            continue;
          }

          if (seg.type === 'Segment' && seg.parts.length === 0) {
            continue;
          }

          normalized.push(seg);
        }

        while (this.isWildcardOnlySegment(normalized[normalized.length - 1])) {
          normalized.pop();
        }

        return normalized;
      }

      parsePattern() {
        const startPos = this.getPosition();
        const segments = [];
        const negate = this.eatToken('Exclamation') !== undefined;

        while (!this.matchToken('Hash') && !this.matchToken('EOF')) {
          segments.push(this.parseSegment());
        }

        let comment = '';
        if (this.eatToken('Hash')) {
          comment = this.getRawInput(
          this.getToken().start,
          ___R$romejs$ob1$index_ts$coerce0(this.input.length));
        }

        let root = false;
        if (segments.length > 0) {
          const firstSeg = segments[0];
          root = firstSeg.type === 'Segment' && firstSeg.parts.length === 0;
        }

        const names = [];
        for (const seg of segments) {
          if (seg.type !== 'Segment' || seg.parts.length !== 1) {
            continue;
          }

          const part = seg.parts[0];
          if (part.type === 'Word') {
            names.push(part.value);
          }
        }

        return {
          type: 'Pattern',
          loc: this.finishLoc(startPos),
          root: root,
          comment: comment,
          negate: negate,
          names: names,
          segments: this.normalizePatternSegments(segments)};
      }

      parsePath() {
        const segments = [];

        this.eatSeparators();

        while (!this.matchToken('EOF')) {
          segments.push(this.parsePathSegment());
        }

        return segments;
      }

      parsePathSegment() {
        let segment = '';

        while (!this.eatSeparators() && !this.matchToken('EOF')) {
          segment += this.normalizePathSegmentToken();
        }

        return segment;
      }

      normalizePathSegmentToken() {
        const token = this.getToken();
        this.nextToken();

        if (token.type === 'Word') {
          return token.value;
        } else {
          throw this.unexpected({
            message: 'Invalid path segment'});
        }
      }
    }
    return PathMatchParser;
  })());

  function ___R$romejs$path$match$parse_ts$parsePattern(opts) {
    const parser = ___R$$priv$romejs$path$match$parse_ts$createPathMatchParser(opts, 'pattern');
    return parser.parsePattern();
  }

  // romejs/path-match/match.ts

  function ___R$$priv$romejs$path$match$match_ts$matchSegment(path, patternSeg) {
    if (patternSeg.type !== 'Segment') {
      throw new Error('Expected only plain segment');
    }

    const parts = [...patternSeg.parts];
    let buffer = path;

    function matchPart(part) {
      if (buffer.length === 0) {
        return false;
      }

      if (part.type === 'Word') {
        if (buffer.startsWith(part.value)) {
          buffer = buffer.slice(part.value.length);
        } else {
          return false;
        }
      } else if (part.type === 'Wildcard') {
        const nextPart = parts.shift();

        if (nextPart === undefined) {
          return buffer.length > 0;
        }

        while (buffer.length > 0) {
          if (matchPart(nextPart)) {
            return true;
          }

          buffer = buffer.slice(1);
        }

        return false;
      }

      return true;
    }

    while (parts.length > 0) {
      const part = parts.shift();
      if (part === undefined) {
        throw new Error('parts.length checked above');
      }

      if (matchPart(part) === false) {
        return false;
      }
    }

    return true;
  }

  function ___R$romejs$path$match$match_ts$default(pathSegs, pattern, cwdSegs) {
    const patternSegs = [...pattern.segments];
    pathSegs = [...pathSegs];

    if (patternSegs.length === 0 || pathSegs.length === 0) {
      return false;
    }

    for (const name of pattern.names) {
      if (!pathSegs.includes(name)) {
        return false;
      }
    }

    if (pattern.root && cwdSegs !== undefined) {
      cwdSegs = [...cwdSegs];

      for (const cwdSeg of cwdSegs) {
        const pathSeg = pathSegs.shift();
        if (cwdSeg === pathSeg) {
          continue;
        } else {
          return false;
        }
      }
    } else {
      const firstPatternSeg = patternSegs.shift();
      if (firstPatternSeg === undefined) {
        throw new Error('patternSegs.length already validated above');
      }

      while (pathSegs.length > 0) {
        const pathSeg = pathSegs.shift();
        if (pathSeg === undefined) {
          throw new Error('pathSegs.length already validated above');
        }

        if (___R$$priv$romejs$path$match$match_ts$matchSegment(pathSeg, firstPatternSeg)) {
          if (pathSegs.length === 0 && patternSegs.length === 0) {
            return true;
          } else {
            break;
          }
        }
      }
    }

    if (pathSegs.length === 0) {
      return false;
    }

    for (let i = 0; i < patternSegs.length; i++) {
      const patternSeg = patternSegs[i];

      if (pathSegs.length === 0) {
        return false;
      }

      if (patternSeg.type === 'WildcardSegment') {
        const nextPattern = patternSegs[i + 1];
        while (!___R$$priv$romejs$path$match$match_ts$matchSegment(pathSegs[0], nextPattern)) {
          pathSegs.shift();
        }
        continue;
      }

      const pathSeg = pathSegs.shift();
      if (pathSeg === undefined) {
        throw new Error('pathSegs.length already validated above');
      }
      if (___R$$priv$romejs$path$match$match_ts$matchSegment(pathSeg, patternSeg)) {
        continue;
      } else {
        return false;
      }
    }

    return true;
  }

  // romejs/path-match/index.ts


  function ___R$romejs$path$match$index_ts$matchPath(path, patternNode, cwdSegs) {
    const matches = ___R$romejs$path$match$match_ts$default(path.getSegments(), patternNode, cwdSegs);

    if (patternNode.negate) {
      return !matches;
    } else {
      return matches;
    }
  }

  function ___R$$priv$romejs$path$match$index_ts$getGreater(pattern, num) {
    if (pattern.segments.length > num) {
      return pattern.segments.length;
    } else {
      return num;
    }
  }

  function ___R$romejs$path$match$index_ts$matchPathPatterns(path, patterns, cwd) {
    if (patterns.length === 0) {
      return false;
    }

    let matches = 0;
    let notMatches = 0;

    const pathSegments = path.getSegments();
    const cwdSegs = cwd === undefined ? undefined : cwd.getSegments();

    for (const pattern of patterns) {
      if (pattern.segments.length === 0) {
        continue;
      }

      if (pattern.negate) {
        if (___R$romejs$path$match$match_ts$default(pathSegments, Object.assign({}, pattern, {
          negate: false}), cwdSegs)) {
          notMatches = ___R$$priv$romejs$path$match$index_ts$getGreater(pattern, notMatches);
        }
      } else {
        if (___R$romejs$path$match$match_ts$default(pathSegments, pattern, cwdSegs)) {
          matches = ___R$$priv$romejs$path$match$index_ts$getGreater(pattern, matches);
        }
      }
    }

    return matches > 0 && matches > notMatches;
  }

  // romejs/project/utils.ts

  const ___R$romejs$project$utils_ts = {
    assertHardMeta: ___R$romejs$project$utils_ts$assertHardMeta,
    arrayOfStrings: ___R$romejs$project$utils_ts$arrayOfStrings,
    arrayOfPatterns: ___R$romejs$project$utils_ts$arrayOfPatterns,
    mergeArrays: ___R$romejs$project$utils_ts$mergeArrays,
    mergeAbsoluteFilePathSets: ___R$romejs$project$utils_ts$mergeAbsoluteFilePathSets};
  function ___R$romejs$project$utils_ts$assertHardMeta(meta) {
    const {configPath: configPath, folder: folder, consumer: consumer} = meta;
    if (configPath === undefined ||
    folder === undefined ||
    consumer === undefined) {
      throw new Error('This is not a disk project');
    }

    return Object.assign({}, meta, {
      configPath: configPath,
      consumer: consumer,
      folder: folder});
  }

  function ___R$romejs$project$utils_ts$arrayOfStrings(consumer) {
    if (consumer.exists()) {
      return consumer.asArray().map(item => item.asString());
    } else {
      return [];
    }
  }

  function ___R$romejs$project$utils_ts$arrayOfPatterns(consumer) {
    return consumer.asArray().map(item => {
      return ___R$romejs$path$match$parse_ts$parsePattern({
        path: consumer.filename,
        input: item.asString(),
        offsetPosition: item.getLocation('inner-value').start});
    });
  }

  function ___R$romejs$project$utils_ts$mergeArrays(a, b) {
    if (a === undefined) {
      return a;
    }

    if (b === undefined) {
      return a;
    }

    return [...a, ...b];
  }

  function ___R$romejs$project$utils_ts$mergeAbsoluteFilePathSets(a, b) {
    if (a === undefined) {
      return a;
    }

    if (b === undefined) {
      return a;
    }

    return new ___R$romejs$path$collections_ts$AbsoluteFilePathSet([...a, ...b]);
  }

  // romejs/project/constants.ts

  const ___R$romejs$project$constants_ts = {
    get ROME_CONFIG_PACKAGE_JSON_FIELD() {
      return ___R$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD;
    },
    get ROME_CONFIG_FILENAME_VANILLA() {
      return ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAME_VANILLA;
    },
    get ROME_CONFIG_FILENAME_EXTENSIONS() {
      return ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAME_EXTENSIONS;
    },
    get ROME_CONFIG_FILENAMES() {
      return ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAMES;
    },
    get ROME_CONFIG_WARN_FILENAMES() {
      return ___R$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES;
    }};
  const ___R$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD = 'rome';

  const ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAME_VANILLA = 'rome.json';
  const ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAME_EXTENSIONS = 'rome.rjson';

  const ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAMES = [___R$romejs$project$constants_ts$ROME_CONFIG_FILENAME_VANILLA, ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAME_EXTENSIONS];

  const ___R$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES = ['romeconfig', 'romerc', 'rome.son', 'rome.config.ts', 'rome.config.js', 'rome.config.json', 'rome.config.rjson', 'rome.config.son'];

  for (const basename of ___R$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES) {
    if (basename[0] !== '.') {
      ___R$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES.push('.' + basename);
    }
  }
  for (const filename of ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.slice()) {
    ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.push('.' + filename);
  }

  // romejs/codec-semver/parse.ts


  const ___R$$priv$romejs$codec$semver$parse_ts$createSemverParser = ___R$romejs$parser$core$index_ts$createParser(
  ParserCore => (() => {
    class SemverParser extends ParserCore {
      constructor({loose: loose, ...opts}, mode) {
        super(opts, 'semver-parser');
        this.input = this.input.trimRight();
        this.mode = mode;
        this.loose = loose === undefined ? false : loose;
      }

      tokenize(index, input) {
        const char = input[___R$romejs$ob1$index_ts$get0(index)];
        const nextChar = input[___R$romejs$ob1$index_ts$get0(index) + 1];

        if (char === '<' && nextChar === '=' ||
        char === '>' && nextChar === '=' ||
        char === '~' && nextChar === '>') {
          const value = char + nextChar;
          return this.finishValueToken('Operator', value, ___R$romejs$ob1$index_ts$add(index, 2));
        }

        if (char === '^' ||
        char === '<' ||
        char === '>' ||
        char === '~' ||
        char === '=') {
          const op = char;
          return this.finishValueToken('Operator', op);
        }

        if (char === '|' && nextChar === '|') {
          return this.finishToken('Pipe', ___R$romejs$ob1$index_ts$add(index, 2));
        }

        if (char === '*') {
          return this.finishToken('Star');
        }

        if (input[___R$romejs$ob1$index_ts$get0(index) - 1] === ' ' &&
        char === '-' &&
        nextChar === ' ') {
          return this.finishToken('RangeDash');
        }

        if (char === '-') {
          return this.finishToken('Dash');
        }

        if (char === '+') {
          return this.finishToken('Plus');
        }

        if (char === '.') {
          return this.finishToken('Dot');
        }

        if (___R$romejs$parser$core$index_ts$isDigit(char)) {
          const value = this.readInputFrom(index, ___R$romejs$parser$core$index_ts$isDigit);
          return this.finishValueToken(
          'Number',
          Number(value),
          ___R$romejs$ob1$index_ts$add(index, value.length));
        }

        if (___R$romejs$parser$core$index_ts$isAlpha(char)) {
          const value = this.readInputFrom(index, ___R$romejs$parser$core$index_ts$isAlpha);
          return this.finishValueToken('Word', value, ___R$romejs$ob1$index_ts$add(index, value.length));
        }

        if (char === ' ' || char === '\t') {
          return this.finishToken('Space');
        }

        return undefined;
      }

      eatSpaceToken() {
        while (this.eatToken('Space') !== undefined);
      }

      parseVersionOrWildcard() {
        const startPos = this.getPosition();
        const startToken = this.getToken();
        const version = this.parseVersion();

        if (this.isWildcardToken(startToken) &&
        version.minor === undefined &&
        version.patch === undefined &&
        version.prerelease.length === 0 &&
        version.build.length === 0) {
          return {
            type: 'Wildcard',
            loc: this.finishLoc(startPos)};
        }

        return version;
      }

      parseVersion() {
        const startPos = this.getPosition();
        const startToken = this.getToken();

        if (this.isVersionCharacter(startToken)) {
          this.nextToken();
        }

        const major = this.parseVersionNumber();
        let minor = undefined;
        let patch = undefined;

        if (this.eatToken('Dot')) {
          minor = this.parseVersionNumber();
        } else if (this.mode === 'version') {
          throw this.unexpected({
            message: 'A minor number is required for a version'});
        }

        if (this.eatToken('Dot')) {
          patch = this.parseVersionNumber();
        } else if (this.mode === 'version') {
          throw this.unexpected({
            message: 'A patch number is required for a version'});
        }

        if (this.matchToken('Dot')) {
          throw this.unexpected({message: 'Too many parts for version'});
        }

        let prerelease = [];
        if (this.eatToken('Dash') || this.loose && this.matchToken('Word')) {
          prerelease = this.parseVersionQualifierParts();
        }

        let build = [];
        if (this.eatToken('Plus')) {
          build = this.parseVersionQualifierParts();
        }

        if (major !== undefined && minor !== undefined && patch !== undefined) {
          return {
            type: 'AbsoluteVersion',
            loc: this.finishLoc(startPos),
            major: major,
            minor: minor,
            patch: patch,
            prerelease: prerelease,
            build: build};
        } else {
          return {
            type: 'WildcardVersion',
            loc: this.finishLoc(startPos),
            major: major,
            minor: minor,
            patch: patch,
            prerelease: prerelease,
            build: build};
        }
      }

      parseVersionQualifierParts() {
        const parts = [];
        do {
          parts.push(this.parseVersionQualifierPart());
        } while (this.eatToken('Dot') !== undefined);
        return parts;
      }

      parseVersionQualifierPart() {
        const parts = [];

        do {
          const token = this.getToken();

          if (token.type === 'Number' || token.type === 'Word') {
            this.nextToken();
            parts.push(token.value);
          } else if (token.type === 'Dash') {
            this.nextToken();
            parts.push('-');
          } else {
            throw this.unexpected({message: 'Invalid version qualifier part'});
          }
        } while (this.matchToken('Number') ||
        this.matchToken('Word') ||
        this.matchToken('Dash'));

        if (parts.length === 1 && typeof parts[0] === 'number') {
          return parts[0];
        } else {
          return parts.join('');
        }
      }

      isWildcardToken(token) {
        if (token.type === 'Star') {
          return true;
        }

        if (token.type === 'Word') {
          return token.value === 'x' || token.value === 'X';
        }

        return false;
      }

      parseVersionNumber() {
        const token = this.getToken();

        if (token.type === 'Number') {
          this.nextToken();
          return token.value;
        }

        if (this.isWildcardToken(token)) {
          if (this.mode === 'version') {
            throw this.unexpected({
              message: 'Wildcard aren\'t allowed in a hard version'});
          }

          this.nextToken();
        } else {
          throw this.unexpected({
            message: 'This isn\'t a valid version part, expected a number'});
        }

        return undefined;
      }

      parseLogicalOr(left) {
        this.nextToken();
        this.eatSpaceToken();

        const right = this.parseExpression();
        return {
          loc: this.finishLoc(this.getLoc(left).start),
          type: 'LogicalOr',
          left: left,
          right: right};
      }

      validateRangeSide(node) {
        if (node.type === 'WildcardVersion' ||
        node.type === 'AbsoluteVersion') {
          return node;
        }

        if (node.type === 'Wildcard' && this.loose) {
          return node;
        }

        throw this.unexpected({
          message: 'A semver range can only be defined with versions',
          start: this.getLoc(node).start});
      }

      parseVersionRange(left) {
        this.nextToken();
        this.eatSpaceToken();

        const right = this.parseVersionOrWildcard();

        return {
          type: 'VersionRange',
          loc: this.finishLoc(this.getLoc(left).start),
          left: this.validateRangeSide(left),
          right: this.validateRangeSide(right)};
      }

      parseWildcard() {
        const startPos = this.getPosition();
        this.nextToken();
        return {type: 'Wildcard', loc: this.finishLoc(startPos)};
      }

      parseAtomOperator(token) {
        const startPos = this.getPosition();
        this.nextToken();
        this.eatSpaceToken();

        const version = this.parseVersionOrWildcard();

        return {
          type: 'Comparator',
          loc: this.finishLoc(startPos),
          operator: token.value,
          version: version};
      }

      isVersionCharacter(token) {
        if (this.loose && token.type === 'Word') {
          return token.value === 'v';
        }

        return false;
      }

      parseAtomStartPipe() {
        if (this.loose) {
          return this.parseWildcard();
        } else {
          throw this.unexpected({
            message: 'Bare pipes are only allowed in loose mode'});
        }
      }

      parseAtomStartWord(token) {
        if (this.isWildcardToken(token)) {
          return this.parseWildcard();
        } else if (this.isVersionCharacter(token)) {
          return this.parseVersion();
        } else {
          throw this.unexpected({
            message: ___R$romejs$string$markup$escape_ts$markup`Unexpected word <emphasis>${token.value}</emphasis>`});
        }
      }

      parseAtom() {
        const token = this.getToken();

        switch (token.type) {
          case 'Number':
            return this.parseVersion();

          case 'Operator':
            return this.parseAtomOperator(token);

          case 'Star':
            return this.parseWildcard();

          case 'Pipe':
            return this.parseAtomStartPipe();

          case 'Word':
            return this.parseAtomStartWord(token);

          default:
            throw this.unexpected({message: 'Unknown start of atom'});}
      }

      parseLogicalAnd(left) {
        const right = this.parseExpression();

        return {
          type: 'LogicalAnd',
          left: left,
          right: right,
          loc: {
            filename: this.filename,
            start: this.getLoc(left).start,
            end: this.getLoc(right).end}};
      }

      parseExpression() {
        const left = this.parseAtom();
        this.eatSpaceToken();

        if (this.matchToken('RangeDash')) {
          return this.parseVersionRange(left);
        }

        if (this.matchToken('Pipe')) {
          return this.parseLogicalOr(left);
        }

        if (!this.matchToken('EOF')) {
          return this.parseLogicalAnd(left);
        }

        return left;
      }

      parseInitialRange() {
        this.eatSpaceToken();

        if (this.matchToken('EOF') && this.loose) {
          return this.parseWildcard();
        }

        const expr = this.parseExpression();
        this.finalize();

        return expr;
      }

      parseInitialVersion() {
        const node = this.parseInitialRange();

        if (node.type !== 'AbsoluteVersion') {
          throw this.unexpected({
            message: 'Unexpected value for version',
            start: this.getLoc(node).start});
        }

        return node;
      }
    }
    return SemverParser;
  })());

  function ___R$romejs$codec$semver$parse_ts$parseSemverRange(opts) {
    return ___R$$priv$romejs$codec$semver$parse_ts$createSemverParser(opts, 'range').parseInitialRange();
  }

  function ___R$romejs$codec$semver$parse_ts$parseSemverVersion(opts) {
    return ___R$$priv$romejs$codec$semver$parse_ts$createSemverParser(opts, 'version').parseInitialVersion();
  }

  // romejs/codec-semver/compare.ts


  function ___R$$priv$romejs$codec$semver$compare_ts$compareIdentifiers(a, b) {
    if (b === undefined) {
      return 0;
    }

    if (typeof a === 'string' || typeof b === 'string') {
      return String(a).localeCompare(String(b));
    }

    if (a < b) {
      return -1;
    }

    if (a > b) {
      return 1;
    }

    return 0;
  }
  function ___R$$priv$romejs$codec$semver$compare_ts$compareMain(version, range) {
    return ___R$$priv$romejs$codec$semver$compare_ts$compareIdentifiers(version.major, range.major) ||
    ___R$$priv$romejs$codec$semver$compare_ts$compareIdentifiers(version.minor, range.minor) ||
    ___R$$priv$romejs$codec$semver$compare_ts$compareIdentifiers(version.patch, range.patch);
  }

  function ___R$$priv$romejs$codec$semver$compare_ts$comparePre(version, range) {
    if (version.prerelease.length > 0 && range.prerelease.length === 0) {
      return -1;
    } else if (version.prerelease.length === 0 && range.prerelease.length > 0) {
      return 1;
    } else if (version.prerelease.length === 0 && range.prerelease.length === 0) {
      return 0;
    }

    let i = 0;
    do {
      const a = version.prerelease[i];
      const b = range.prerelease[i];

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return ___R$$priv$romejs$codec$semver$compare_ts$compareIdentifiers(a, b);
      }
    } while (++i);

    throw new Error('Unreachable');
  }

  function ___R$romejs$codec$semver$compare_ts$default(version, range) {
    return ___R$$priv$romejs$codec$semver$compare_ts$compareMain(version, range) || ___R$$priv$romejs$codec$semver$compare_ts$comparePre(version, range);
  }

  // romejs/codec-semver/satisfies.ts

  function ___R$$priv$romejs$codec$semver$satisfies_ts$buildVersion(major, minor, patch) {
    return {
      type: 'WildcardVersion',
      major: major,
      minor: minor,
      patch: patch,
      prerelease: [],
      build: []};
  }

  function ___R$$priv$romejs$codec$semver$satisfies_ts$compareOp(op, version, range) {
    if (range.type === 'Wildcard') {
      return true;
    }

    switch (op) {
      case '=':
        return ___R$romejs$codec$semver$compare_ts$default(version, range) === 0;

      case '<':
        return ___R$romejs$codec$semver$compare_ts$default(version, range) < 0;

      case '>':
        return ___R$romejs$codec$semver$compare_ts$default(version, range) > 0;

      case '>=':
        return ___R$romejs$codec$semver$compare_ts$default(version, range) >= 0;

      case '<=':
        return ___R$romejs$codec$semver$compare_ts$default(version, range) <= 0;

      case '^':
        {
          if (___R$$priv$romejs$codec$semver$satisfies_ts$compareOp('>=', version, range) === false) {
            return false;
          }

          const {major: major, minor: minor, patch: patch} = range;

          if (major === 0) {
            if (minor === 0) {
              return ___R$$priv$romejs$codec$semver$satisfies_ts$compareOp('<', version, ___R$$priv$romejs$codec$semver$satisfies_ts$buildVersion(0, 0, patch + 1));
            } else {
              return ___R$$priv$romejs$codec$semver$satisfies_ts$compareOp('<', version, ___R$$priv$romejs$codec$semver$satisfies_ts$buildVersion(0, minor + 1, 0));
            }
          }

          return ___R$$priv$romejs$codec$semver$satisfies_ts$compareOp('<', version, ___R$$priv$romejs$codec$semver$satisfies_ts$buildVersion(major + 1, 0, 0));
        }

      case '~>':
      case '~':
        {
          if (___R$$priv$romejs$codec$semver$satisfies_ts$compareOp('>=', version, range) === false) {
            return false;
          }

          const {major: major, minor: minor} = range;

          if (minor === undefined) {
            return ___R$$priv$romejs$codec$semver$satisfies_ts$compareOp('<', version, ___R$$priv$romejs$codec$semver$satisfies_ts$buildVersion(major + 1, minor, 0));
          }

          return ___R$$priv$romejs$codec$semver$satisfies_ts$compareOp('<', version, ___R$$priv$romejs$codec$semver$satisfies_ts$buildVersion(major, minor + 1, 0));
        }

      default:
        throw new Error('Unknown operator ' + op);}
  }

  function ___R$$priv$romejs$codec$semver$satisfies_ts$inRange(version, left, right) {
    if (left.type === 'Wildcard' || right.type === 'Wildcard') {
      return true;
    }

    return ___R$$priv$romejs$codec$semver$satisfies_ts$compareOp('>=', version, left) && ___R$$priv$romejs$codec$semver$satisfies_ts$compareOp('<=', version, right);
  }

  function ___R$$priv$romejs$codec$semver$satisfies_ts$collectVersions(range) {
    switch (range.type) {
      case 'AbsoluteVersion':
      case 'WildcardVersion':
        return [range];

      case 'Wildcard':
        return [];

      case 'Comparator':
        return ___R$$priv$romejs$codec$semver$satisfies_ts$collectVersions(range.version);

      case 'LogicalAnd':
      case 'LogicalOr':
      case 'VersionRange':
        return [...___R$$priv$romejs$codec$semver$satisfies_ts$collectVersions(range.left), ...___R$$priv$romejs$codec$semver$satisfies_ts$collectVersions(range.right)];

      default:
        throw new Error('Unknown range type');}
  }

  function ___R$romejs$codec$semver$satisfies_ts$default(version, range) {
    const res = ___R$$priv$romejs$codec$semver$satisfies_ts$satisfiesSub(version, range);
    if (res === false) {
      return false;
    }

    if (version.prerelease.length > 0) {
      const versions = ___R$$priv$romejs$codec$semver$satisfies_ts$collectVersions(range);

      for (const comparator of versions) {
        if (comparator.prerelease.length > 0) {
          if (comparator.major === version.major &&
          comparator.minor === version.minor &&
          comparator.patch === version.patch) {
            return true;
          }
        }
      }

      return false;
    }

    return true;
  }

  function ___R$$priv$romejs$codec$semver$satisfies_ts$satisfiesSub(version, range) {
    switch (range.type) {
      case 'AbsoluteVersion':
      case 'WildcardVersion':
        return ___R$$priv$romejs$codec$semver$satisfies_ts$compareOp('=', version, range);

      case 'Wildcard':
        return true;

      case 'Comparator':
        return ___R$$priv$romejs$codec$semver$satisfies_ts$compareOp(range.operator, version, range.version);

      case 'LogicalAnd':
        return ___R$$priv$romejs$codec$semver$satisfies_ts$satisfiesSub(version, range.left) && ___R$$priv$romejs$codec$semver$satisfies_ts$satisfiesSub(version, range.right);

      case 'LogicalOr':
        return ___R$$priv$romejs$codec$semver$satisfies_ts$satisfiesSub(version, range.left) || ___R$$priv$romejs$codec$semver$satisfies_ts$satisfiesSub(version, range.right);

      case 'VersionRange':
        return ___R$$priv$romejs$codec$semver$satisfies_ts$inRange(version, range.left, range.right) ||
        ___R$$priv$romejs$codec$semver$satisfies_ts$inRange(version, range.right, range.left);}
  }

  // romejs/codec-semver/utils.ts

  function ___R$romejs$codec$semver$utils_ts$normalizeUserVersion(ver, opts) {
    if (typeof ver === 'string') {
      return ___R$romejs$codec$semver$parse_ts$parseSemverVersion(Object.assign({}, opts, {
        input: ver}));
    } else if (ver.type === 'AbsoluteVersion') {
      return ver;
    } else {
      throw new Error('Not a valid version: ' + ver.type);
    }
  }

  function ___R$romejs$codec$semver$utils_ts$normalizeUserRange(range, opts) {
    if (typeof range === 'string') {
      return ___R$romejs$codec$semver$parse_ts$parseSemverRange(Object.assign({}, opts, {
        input: range}));
    } else {
      return range;
    }
  }

  // romejs/codec-semver/stringify.ts

  function ___R$$priv$romejs$codec$semver$stringify_ts$compactRight(parts) {
    for (let i = parts.length - 1; i >= 0; i--) {
      const part = parts[i];
      if (part !== undefined) {
        return parts.slice(0, i + 1);
      }
    }

    return [];
  }

  const ___R$$priv$romejs$codec$semver$stringify_ts$WILDCARD = '*';

  function ___R$romejs$codec$semver$stringify_ts$default(node) {
    switch (node.type) {
      case 'WildcardVersion':
      case 'AbsoluteVersion':
        {
          let str = ___R$$priv$romejs$codec$semver$stringify_ts$compactRight([node.major, node.minor, node.patch]).map(part => part === undefined ? ___R$$priv$romejs$codec$semver$stringify_ts$WILDCARD : part).join('.');

          if (node.prerelease.length > 0) {
            str += '-' + node.prerelease.join('.');
          }
          if (node.build.length > 0) {
            str += '+' + node.build.join('.');
          }
          return str;
        }

      case 'Wildcard':
        return ___R$$priv$romejs$codec$semver$stringify_ts$WILDCARD;

      case 'Comparator':
        return '' + node.operator + ___R$romejs$codec$semver$stringify_ts$default(node.version);

      case 'LogicalAnd':
        return ___R$romejs$codec$semver$stringify_ts$default(node.left) + ' ' + ___R$romejs$codec$semver$stringify_ts$default(node.right);

      case 'LogicalOr':
        return ___R$romejs$codec$semver$stringify_ts$default(node.left) + ' || ' + ___R$romejs$codec$semver$stringify_ts$default(node.right);

      case 'VersionRange':
        return ___R$romejs$codec$semver$stringify_ts$default(node.left) + ' - ' + ___R$romejs$codec$semver$stringify_ts$default(node.right);}
  }

  // romejs/codec-semver/index.ts


  function ___R$romejs$codec$semver$index_ts$sortSemverVersions(rawVersions, opts) {
    const versions = rawVersions.map(ver => ___R$romejs$codec$semver$utils_ts$normalizeUserVersion(ver, opts));
    return versions.sort((a, b) => ___R$romejs$codec$semver$compare_ts$default(a, b));
  }

  function ___R$romejs$codec$semver$index_ts$maxSatisfyingSemver(rawVersions, rawRange, opts) {
    const versions = ___R$romejs$codec$semver$index_ts$sortSemverVersions(rawVersions, opts).reverse();
    const range = ___R$romejs$codec$semver$utils_ts$normalizeUserRange(rawRange, opts);

    for (const version of versions) {
      if (___R$romejs$codec$semver$satisfies_ts$default(version, range)) {
        return version;
      }
    }

    return undefined;
  }

  function ___R$romejs$codec$semver$index_ts$minSatisfyingSemver(rawVersions, rawRange, opts) {
    const versions = ___R$romejs$codec$semver$index_ts$sortSemverVersions(rawVersions, opts);
    const range = ___R$romejs$codec$semver$utils_ts$normalizeUserRange(rawRange, opts);

    for (const version of versions) {
      if (___R$romejs$codec$semver$satisfies_ts$default(version, range)) {
        return version;
      }
    }

    return undefined;
  }

  function ___R$romejs$codec$semver$index_ts$satisfiesSemver(rawVersion, rawRange, opts) {
    try {
      const version = ___R$romejs$codec$semver$utils_ts$normalizeUserVersion(rawVersion, opts);
      const range = ___R$romejs$codec$semver$utils_ts$normalizeUserRange(rawRange, opts);
      return ___R$romejs$codec$semver$satisfies_ts$default(version, range);
    } catch (err) {
      if (err instanceof ___R$romejs$diagnostics$errors_ts$DiagnosticsError) {
        return false;
      } else {
        throw err;
      }
    }
  }

  // romejs/project/load.ts

  const ___R$romejs$project$load_ts = {
    loadCompleteProjectConfig: ___R$romejs$project$load_ts$loadCompleteProjectConfig,
    normalizeProjectConfig: ___R$romejs$project$load_ts$normalizeProjectConfig};
  const ___R$$priv$romejs$project$load_ts$crypto = require('crypto');
  const ___R$$priv$romejs$project$load_ts$WATCHMAN_CONFIG_FILENAME = '.watchmanconfig';
  const ___R$$priv$romejs$project$load_ts$IGNORE_FILENAMES = ['.gitignore', '.hgignore'];

  function ___R$romejs$project$load_ts$loadCompleteProjectConfig(projectFolder, configPath) {
    const {partial: partial, meta: meta} = ___R$$priv$romejs$project$load_ts$loadPartialProjectConfig(projectFolder, configPath);
    const {consumer: consumer} = meta;

    const defaultConfig = Object.assign({}, ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG, {
      vsc: Object.assign({
        root: projectFolder}, ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG.vsc)});

    const config = Object.assign({}, ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG, {
      name: consumer.get('name').asString(projectFolder.getBasename()),
      isolated: partial.isolated === undefined ? ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG.isolated : partial.isolated}, ___R$$priv$romejs$project$load_ts$mergePartialConfig(defaultConfig, partial));

    for (const filename of ___R$$priv$romejs$project$load_ts$IGNORE_FILENAMES) {
      const possiblePath = config.vsc.root.append(filename);
      meta.configDependencies.add(possiblePath);

      if (___R$romejs$fs$index_ts$existsSync(possiblePath)) {
        const file = ___R$romejs$fs$index_ts$readFileTextSync(possiblePath);
        const lines = file.split('\n');

        let index = ___R$romejs$ob1$index_ts$number0;

        consumer.handleThrownDiagnostics(() => {
          const patterns = lines.map((line, i) => {
            const pattern = ___R$romejs$path$match$parse_ts$parsePattern({
              input: line,
              path: possiblePath,
              offsetPosition: {
                index: index,
                line: ___R$romejs$ob1$index_ts$coerce1(i),
                column: ___R$romejs$ob1$index_ts$number0}});

            index = ___R$romejs$ob1$index_ts$add(index, line.length);

            index = ___R$romejs$ob1$index_ts$inc(index);

            return pattern;
          });

          config.lint.ignore = [...config.lint.ignore, ...patterns];
        });
      }
    }

    if (partial.files.watchman === undefined) {
      for (const dir of new ___R$romejs$path$collections_ts$AbsoluteFilePathSet([projectFolder, config.vsc.root])) {
        const watchmanConfigPath = dir.append(___R$$priv$romejs$project$load_ts$WATCHMAN_CONFIG_FILENAME);
        meta.configDependencies.add(watchmanConfigPath);
        if (___R$romejs$fs$index_ts$existsSync(watchmanConfigPath)) {
          config.files.watchman = true;
        }
      }
    }

    return {
      config: config,
      meta: meta};
  }

  function ___R$$priv$romejs$project$load_ts$loadPartialProjectConfig(projectFolder, configPath) {
    const configFile = ___R$romejs$fs$index_ts$readFileTextSync(configPath);
    const res = ___R$romejs$codec$json$index_ts$consumeJSONExtra({
      path: configPath,
      input: configFile});

    return ___R$romejs$project$load_ts$normalizeProjectConfig(res, configPath, configFile, projectFolder);
  }

  function ___R$romejs$project$load_ts$normalizeProjectConfig(res, configPath, configFile, projectFolder) {
    let {consumer: consumer} = res;

    const isInPackageJson = configPath.getBasename() === 'package.json';
    if (isInPackageJson) {
      consumer = consumer.get(___R$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD);
    }

    const hash = ___R$$priv$romejs$project$load_ts$crypto.createHash('sha256').update(configFile).digest('hex');

    const config = {
      compiler: {},
      bundler: {},
      cache: {},
      lint: {},
      haste: {},
      resolver: {},
      develop: {},
      typeCheck: {},
      format: {},
      tests: {},
      files: {},
      vsc: {},
      dependencies: {},
      targets: new Map()};

    let sourceType = 'vanilla';
    if (isInPackageJson) {
      sourceType = 'package';
    } else if (configPath.getBasename() === ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAME_EXTENSIONS) {
      sourceType = 'extensions';
    }

    const meta = {
      sourceType: sourceType,
      folder: projectFolder,
      configPath: configPath,
      consumer: consumer,
      consumersChain: [consumer],
      configHashes: [hash],
      configDependencies: new ___R$romejs$path$collections_ts$AbsoluteFilePathSet([configPath])};

    consumer.markUsedProperty('name');

    if (consumer.has('version')) {
      const version = consumer.get('version');

      consumer.handleThrownDiagnostics(() => {
        config.version = ___R$romejs$codec$semver$parse_ts$parseSemverRange({
          path: consumer.filename,
          input: version.asString(),
          offsetPosition: version.getLocation('inner-value').start});
      });
    }

    if (consumer.has('isolated')) {
      config.isolated = consumer.get('isolated').asBoolean();
    }

    const cache = consumer.get('cache');
    if (cache.exists()) {}

    const resolver = consumer.get('resolver');
    if (resolver.exists()) {}

    const bundler = consumer.get('bundler');
    if (bundler.exists()) {
      if (bundler.has('mode')) {
        config.bundler.mode = bundler.get('mode').asStringSet(['modern', 'legacy']);
      }
    }

    const haste = consumer.get('haste');
    if (haste.exists()) {
      if (haste.has('enabled')) {
        config.haste.enabled = haste.get('enabled').asBoolean();
      }

      if (haste.has('ignore')) {
        config.haste.ignore = ___R$romejs$project$utils_ts$arrayOfPatterns(haste.get('ignore'));
      }
    }

    const typeChecking = consumer.get('typeChecking');
    if (typeChecking.exists()) {
      if (typeChecking.has('enabled')) {
        config.typeCheck.enabled = typeChecking.get('enabled').asBoolean();
      }

      if (typeChecking.has('libs')) {
        const libs = ___R$$priv$romejs$project$load_ts$normalizeTypeCheckingLibs(
        projectFolder,
        typeChecking.get('libs'));
        config.typeCheck.libs = libs.files;
        meta.configDependencies = new ___R$romejs$path$collections_ts$AbsoluteFilePathSet([...meta.configDependencies, ...libs.folders, ...libs.files]);
      }
    }

    const dependencies = consumer.get('dependencies');
    if (dependencies.exists()) {
      if (dependencies.has('enabled')) {
        config.dependencies.enabled = dependencies.get('dependencies').asBoolean();
      }
    }

    const lint = consumer.get('lint');
    if (lint.exists()) {
      if (lint.has('enabled')) {
        config.lint.enabled = lint.get('enabled').asBoolean();
      }

      if (lint.has('ignore')) {
        config.lint.ignore = ___R$romejs$project$utils_ts$arrayOfPatterns(lint.get('ignore'));
      }

      if (lint.has('globals')) {
        config.lint.globals = ___R$romejs$project$utils_ts$arrayOfStrings(lint.get('globals'));
      }

      if (lint.has('legacyEslintInterop')) {
        config.lint.legacyEslintInterop = lint.get('legacyBabelInterop').asBoolean();
      }
    }

    const format = consumer.get('format');
    if (format.exists()) {
      if (format.has('enabled')) {
        config.format.enabled = format.get('enabled').asBoolean();
      }
    }

    const testing = consumer.get('testing');
    if (testing.exists()) {
      if (testing.has('enabled')) {
        config.tests.enabled = testing.get('enabled').asBoolean();
      }

      if (testing.has('folderName')) {
        config.tests.folderName = testing.get('folderName').asString();
      }

      if (testing.has('ignore')) {
        config.tests.ignore = ___R$romejs$project$utils_ts$arrayOfPatterns(testing.get('ignore'));
      }
    }

    const develop = consumer.get('develop');
    if (develop.exists()) {
      if (develop.has('serveStatic')) {
        config.develop.serveStatic = develop.get('serveStatic').asBoolean();
      }
    }

    const files = consumer.get('files');
    if (files.exists()) {
      if (files.has('watchman')) {
        config.files.watchman = files.get('watchman').asBoolean();
      }

      if (files.has('vendorPath')) {
        config.files.vendorPath = projectFolder.resolve(
        files.get('vendorPath').asString());
      }

      if (files.has('maxSize')) {
        config.files.maxSize = files.get('maxSize').asNumber();
      }

      if (files.has('assetExtensions')) {
        config.files.assetExtensions = files.get('assetExtensions').asArray().map(item => item.asString());
      }
    }

    const vsc = consumer.get('vsc');
    if (vsc.exists()) {
      if (vsc.has('root')) {
        config.vsc.root = projectFolder.resolve(vsc.get('root').asString());
      }
    }

    const compiler = consumer.get('compiler');
    if (compiler.exists()) {
      if (compiler.has('legacyBabelInterop')) {
        config.compiler.legacyBabelInterop = compiler.get('legacyBabelInterop').asBoolean();
      }
    }

    const targets = consumer.get('targets');
    if (targets.exists()) {
      for (const [name, object] of targets.asMap()) {
        const target = {
          constraints: object.get('constraints').asImplicitArray().map(item => item.asString())};
        object.enforceUsedProperties('config target property');
        config.targets.set(name, target);
      }
    }

    const _extends = consumer.get('extends');

    consumer.enforceUsedProperties('config property');

    if (_extends.exists()) {
      return ___R$$priv$romejs$project$load_ts$extendProjectConfig(projectFolder, _extends, config, meta);
    }

    return {
      partial: config,
      meta: meta};
  }

  function ___R$$priv$romejs$project$load_ts$normalizeTypeCheckingLibs(projectFolder, consumer) {
    const libFiles = new ___R$romejs$path$collections_ts$AbsoluteFilePathSet();

    const folders = ___R$romejs$project$utils_ts$arrayOfStrings(
    consumer).map(libFolder => projectFolder.resolve(libFolder));

    for (const folder of folders) {
      const files = ___R$romejs$fs$index_ts$readdirSync(folder);
      for (const file of files) {
        const stats = ___R$romejs$fs$index_ts$lstatSync(file);
        if (stats.isFile()) {
          libFiles.add(file);
        } else if (stats.isDirectory()) {
          folders.push(file);
        }
      }
    }

    return {
      files: libFiles,
      folders: folders};
  }

  function ___R$$priv$romejs$project$load_ts$extendProjectConfig(projectFolder, extendsStrConsumer, config, meta) {
    const extendsRelative = extendsStrConsumer.asString();

    if (extendsRelative === 'parent') {}

    const extendsPath = projectFolder.resolve(extendsRelative);
    const {partial: extendsObj, meta: extendsMeta} = ___R$$priv$romejs$project$load_ts$loadPartialProjectConfig(
    extendsPath.getParent(),
    extendsPath);

    for (const path of extendsMeta.configDependencies) {
      if (path.equal(extendsPath)) {
        throw extendsStrConsumer.unexpected('Recursive config value');
      }
    }

    const merged = ___R$$priv$romejs$project$load_ts$mergePartialConfig(extendsObj, config);

    const lintIgnore = ___R$romejs$project$utils_ts$mergeArrays(extendsObj.lint.ignore, config.lint.ignore);
    if (lintIgnore !== undefined) {
      merged.lint.ignore = lintIgnore;
    }

    const lintGlobals = ___R$romejs$project$utils_ts$mergeArrays(extendsObj.lint.globals, config.lint.globals);
    if (lintGlobals !== undefined) {
      merged.lint.globals = lintGlobals;
    }

    const hasteIgnore = ___R$romejs$project$utils_ts$mergeArrays(extendsObj.haste.ignore, config.haste.ignore);
    if (hasteIgnore !== undefined) {
      merged.haste.ignore = hasteIgnore;
    }

    const testingIgnore = ___R$romejs$project$utils_ts$mergeArrays(
    extendsObj.tests.ignore,
    config.tests.ignore);
    if (testingIgnore !== undefined) {
      merged.tests.ignore = testingIgnore;
    }

    const typeCheckingLibs = ___R$romejs$project$utils_ts$mergeAbsoluteFilePathSets(
    extendsObj.typeCheck.libs,
    config.typeCheck.libs);
    if (typeCheckingLibs !== undefined) {
      merged.typeCheck.libs = typeCheckingLibs;
    }

    return {
      partial: merged,
      meta: Object.assign({}, meta, {
        consumersChain: [...meta.consumersChain, ...extendsMeta.consumersChain],
        configDependencies: new ___R$romejs$path$collections_ts$AbsoluteFilePathSet([...meta.configDependencies, ...extendsMeta.configDependencies, extendsPath]),
        configHashes: [...meta.configHashes, ...extendsMeta.configHashes]})};
  }

  function ___R$$priv$romejs$project$load_ts$mergePartialConfig(a, b) {
    return {
      cache: Object.assign({}, a.cache, b.cache),
      compiler: Object.assign({}, a.compiler, b.compiler),
      lint: Object.assign({}, a.lint, b.lint),
      develop: Object.assign({}, a.develop, b.develop),
      bundler: Object.assign({}, a.bundler, b.bundler),
      dependencies: Object.assign({}, a.dependencies, b.dependencies),
      resolver: Object.assign({}, a.resolver, b.resolver),
      haste: Object.assign({}, a.haste, b.haste),
      typeCheck: Object.assign({}, a.typeCheck, b.typeCheck),
      tests: Object.assign({}, a.tests, b.tests),
      format: Object.assign({}, a.format, b.format),
      files: Object.assign({}, a.files, b.files),
      vsc: Object.assign({}, a.vsc, b.vsc),
      targets: new Map([...a.targets.entries(), ...b.targets.entries()])};
  }

  // romejs/project/save.ts

  const ___R$romejs$project$save_ts = {
    modifyProjectConfig: ___R$romejs$project$save_ts$modifyProjectConfig};
  async function ___R$romejs$project$save_ts$modifyProjectConfig(softMeta, callbacks) {
    const meta = ___R$romejs$project$utils_ts$assertHardMeta(softMeta);
    const {configPath: configPath, sourceType: sourceType} = meta;

    await callbacks.pre(meta);

    const configFile = await ___R$romejs$fs$index_ts$readFileText(configPath);
    const res = ___R$romejs$codec$json$index_ts$consumeJSONExtra({
      path: configPath,
      input: configFile});

    const {consumer: consumer} = res;
    if (sourceType === 'package') {
      await callbacks.modify(consumer.get(___R$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD));
    } else {
      await callbacks.modify(consumer);
    }

    let stringified;
    if (res.hasExtensions) {
      stringified = ___R$romejs$codec$json$index_ts$stringifyJSON(res);
    } else {
      stringified = JSON.stringify(consumer.asUnknown(), null, '  ');
    }

    try {
      const res = ___R$romejs$codec$json$index_ts$consumeJSONExtra({
        path: configPath,
        input: stringified});

      ___R$romejs$project$load_ts$normalizeProjectConfig(res, configPath, stringified, meta.folder);
    } catch (err) {
      let diagnostics = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
      if (diagnostics === undefined) {
        throw err;
      }

      diagnostics = diagnostics.map(diag => {
        return diag.filename === configPath.join() ? Object.assign({}, diag, {
          sourceText: stringified}) : diag;
      });

      throw new ___R$romejs$diagnostics$errors_ts$DiagnosticsError('Diagnostics produced while testing new project config', diagnostics);
    }
  }

  // romejs/project/transport.ts

  const ___R$romejs$project$transport_ts = {
    serializeJSONProjectConfig: ___R$romejs$project$transport_ts$serializeJSONProjectConfig,
    hydrateJSONProjectConfig: ___R$romejs$project$transport_ts$hydrateJSONProjectConfig};
  function ___R$romejs$project$transport_ts$serializeJSONProjectConfig(config) {
    const targets = {};
    for (const [name, target] of config.targets) {
      targets[name] = target;
    }

    return Object.assign({}, config, {
      vsc: Object.assign({}, config.vsc, {
        root: config.vsc.root.join()}),
      typeCheck: Object.assign({}, config.typeCheck, {
        libs: Array.from(config.typeCheck.libs, path => path.join())}),
      files: Object.assign({}, config.files, {
        vendorPath: config.files.vendorPath.join()}),
      targets: targets});
  }

  function ___R$romejs$project$transport_ts$hydrateJSONProjectConfig(config) {
    return Object.assign({}, config, {
      files: Object.assign({}, config.files, {
        vendorPath: ___R$romejs$path$index_ts$createAbsoluteFilePath(config.files.vendorPath)}),
      vsc: Object.assign({}, config.vsc, {
        root: ___R$romejs$path$index_ts$createAbsoluteFilePath(config.vsc.root)}),
      typeCheck: Object.assign({}, config.typeCheck, {
        libs: new ___R$romejs$path$collections_ts$AbsoluteFilePathSet(config.typeCheck.libs.map(str => ___R$romejs$path$index_ts$createAbsoluteFilePath(str)))}),
      targets: new Map(Object.entries(config.targets))});
  }

  // romejs/project/index.ts


  // romejs/js-ast-utils/removeLoc.ts

  const ___R$$priv$romejs$js$ast$utils$removeLoc_ts$removeLocTransform = [{
    name: 'removeLocTransform',
    enter(path) {
      const {node: node} = path;
      if (node.loc === undefined) {
        return node;
      } else {
        const newNode = Object.assign({}, node);
        delete newNode.loc;

        for (const key in newNode) {
          if (newNode[key] === undefined) {
            delete newNode[key];
          }
        }

        return newNode;
      }
    }}];

  function ___R$romejs$js$ast$utils$removeLoc_ts$default(ast) {
    const context = new ___R$romejs$js$compiler$lib$Context_ts$default({
      ast: ___R$romejs$js$ast$core$Program_ts$MOCK_PROGRAM,
      project: {
        folder: undefined,
        config: ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG}});
    return context.reduce(ast, ___R$$priv$romejs$js$ast$utils$removeLoc_ts$removeLocTransform);
  }

  // romejs/js-ast-utils/isIdentifierish.ts

  function ___R$romejs$js$ast$utils$isIdentifierish_ts$default(node) {
    return node.type === 'Identifier' ||
    node.type === 'JSXIdentifier' ||
    node.type === 'JSXReferenceIdentifier' ||
    node.type === 'BindingIdentifier' ||
    node.type === 'AssignmentIdentifier' ||
    node.type === 'ReferenceIdentifier';
  }

  // romejs/js-ast-utils/template.ts


  const ___R$$priv$romejs$js$ast$utils$template_ts$templateCache = new Map();

  function ___R$$priv$romejs$js$ast$utils$template_ts$getTemplate(strs) {
    const cached = ___R$$priv$romejs$js$ast$utils$template_ts$templateCache.get(strs);
    if (cached) {
      return cached;
    }

    const pathCount = strs.length - 1;

    let placeholders = {};
    const placeholderIds = [];
    for (let i = 0; i < pathCount; i++) {
      const id = '__' + String(i) + '__';
      placeholderIds.push(id);
      placeholders[id] = undefined;
    }

    let code = '';
    for (let i = 0; i < strs.length; i++) {
      code += strs[i];

      const placeholder = placeholderIds[i];
      if (placeholder) {
        code += placeholder;
      }
    }

    let ast = ___R$romejs$js$parser$index_ts$parseJS({
      input: code,
      sourceType: 'template',
      path: ___R$romejs$path$index_ts$createUnknownFilePath('template')});

    ast = ___R$romejs$js$ast$core$Program_ts$program.assert(___R$romejs$js$ast$utils$removeLoc_ts$default(ast));

    const collectPlaceholderPaths = path => {
      const {node: node} = path;
      if (___R$romejs$js$ast$utils$isIdentifierish_ts$default(node) && node.name in placeholders) {
        placeholders[node.name] = {
          type: node.type,
          path: path.getPathKeys()};
      }
      return node;
    };
    const context = new ___R$romejs$js$compiler$lib$Context_ts$default({
      ast: ast,
      project: {
        folder: undefined,
        config: ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG}});
    context.reduce(ast, [{name: 'collectPlaceholderPaths', enter: collectPlaceholderPaths}]);

    const placeholderPaths = [];
    for (const id in placeholders) {
      const path = placeholders[id];
      if (path === undefined) {
        throw new Error('Failed to find placeholder path for ' + id);
      } else {
        placeholderPaths.push(path);
      }
    }

    return {ast: ast, placeholderPaths: placeholderPaths};
  }

  function ___R$$priv$romejs$js$ast$utils$template_ts$createIdentifier(substitute, expectedIdType) {
    if (typeof substitute === 'string') {
      return {
        type: expectedIdType,
        name: substitute};
    } else {
      return substitute;
    }
  }

  function ___R$romejs$js$ast$utils$template_ts$default(strs, ...substitutions) {
    const {ast: ast, placeholderPaths: placeholderPaths} = ___R$$priv$romejs$js$ast$utils$template_ts$getTemplate(strs);

    if (!substitutions.length) {
      return ast;
    }

    if (placeholderPaths.length !== substitutions.length) {
      throw new Error('Expected subtituions to be the same length as paths');
    }

    const newAst = Object.assign({}, ast);

    for (let i = 0; i < placeholderPaths.length; i++) {
      const {type: type, path: path} = placeholderPaths[i];

      const substitute = ___R$$priv$romejs$js$ast$utils$template_ts$createIdentifier(substitutions[i], type);
      let target = newAst;

      for (let i = 0; i < path.length; i++) {
        const key = path[i];
        const isLast = i === path.length - 1;

        if (isLast) {
          target[key] = substitute;
        } else {
          let currTarget = target[key];
          if (Array.isArray(currTarget)) {
            currTarget = currTarget.slice();
          } else {
            currTarget = Object.assign({}, currTarget);
          }
          target[key] = currTarget;
          target = currTarget;
        }
      }
    }

    return newAst;
  }

  ___R$romejs$js$ast$utils$template_ts$default.expression = (strs, ...substitutions) => {
    var ___R$;
    const first = (___R$ = ___R$romejs$js$ast$utils$template_ts$default, ___R$.statement.apply(___R$, [strs, ...substitutions]));

    if (first.type !== 'ExpressionStatement') {
      throw new Error('Single statement should be an ExpressionStatement');
    }

    return first.expression;
  };

  ___R$romejs$js$ast$utils$template_ts$default.statement = (strs, ...substitutions) => {
    const ast = ___R$romejs$js$ast$core$Program_ts$program.assert(___R$romejs$js$ast$utils$template_ts$default.apply(null, [strs, ...substitutions]));

    const body = ast.body;
    if (body.length !== 1) {
      throw new Error('More than one statement isn\'t allowed for a template.');
    }
    return body[0];
  };

  // romejs/js-ast-utils/isTypeExpressionWrapperNode.ts

  function ___R$romejs$js$ast$utils$isTypeExpressionWrapperNode_ts$default(node) {
    return node.type === 'FlowTypeCastExpression' || node.type === 'TSAsExpression';
  }

  // romejs/js-ast-utils/isInTypeAnnotation.ts

  function ___R$$priv$romejs$js$ast$utils$isInTypeAnnotation_ts$getTypeNode(path) {
    const {parent: parent, parentPath: parentPath} = path;
    if (parent === undefined || parentPath === undefined) {
      return undefined;
    }

    if (___R$romejs$js$ast$utils$isTypeNode_ts$default(parent)) {
      return parent;
    }

    if (___R$romejs$js$ast$utils$isTypeNode_ts$default(parentPath.parent)) {
      return parentPath.parent;
    }
  }

  function ___R$romejs$js$ast$utils$isInTypeAnnotation_ts$default(path) {
    const match = ___R$$priv$romejs$js$ast$utils$isInTypeAnnotation_ts$getTypeNode(path);
    if (match === undefined) {
      return false;
    }

    if (___R$romejs$js$ast$utils$isTypeExpressionWrapperNode_ts$default(match)) {
      return false;
    } else {
      return true;
    }
  }

  // romejs/js-ast-utils/getRequireSource.ts

  const ___R$$priv$romejs$js$ast$utils$getRequireSource_ts$ROME_DEFAULT_REQUIRE = ['Rome', 'requireDefault'];
  const ___R$$priv$romejs$js$ast$utils$getRequireSource_ts$ROME_NAMESPACE_REQUIRE = ['Rome', 'requireNamespace'];

  function ___R$romejs$js$ast$utils$getRequireSource_ts$default(node, scope, allowStaticMember = false) {
    if (node === undefined) {
      return;
    }

    if (allowStaticMember &&
    node.type === 'MemberExpression' &&
    node.property.type === 'StaticMemberProperty') {
      node = node.object;
    }

    if (node.type !== 'CallExpression') {
      return;
    }

    const {arguments: args, callee: callee} = node;

    const [firstArg] = args;
    if (args.length !== 1 || firstArg.type !== 'StringLiteral') {
      return;
    }

    const validRequireCallee = callee.type === 'ReferenceIdentifier' &&
    callee.name === 'require' &&
    scope.getBinding('require') === undefined;

    const validRomeRequreCallee = (___R$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(callee, ___R$$priv$romejs$js$ast$utils$getRequireSource_ts$ROME_DEFAULT_REQUIRE) ||
    ___R$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(callee, ___R$$priv$romejs$js$ast$utils$getRequireSource_ts$ROME_NAMESPACE_REQUIRE)) &&
    scope.getBinding('Rome') === undefined;

    if (validRequireCallee || validRomeRequreCallee) {
      return firstArg.value;
    }
  }

  // romejs/js-ast-utils/index.ts


  // romejs/consume/Consumer.ts


  function ___R$$priv$romejs$consume$Consumer_ts$isComputedPart(part) {
    return typeof part === 'number' || !___R$romejs$js$ast$utils$isValidIdentifierName_ts$default(part);
  }

  function ___R$$priv$romejs$consume$Consumer_ts$joinPath(path) {
    let str = '';

    for (let i = 0; i < path.length; i++) {
      const part = path[i];
      const nextPart = path[i + 1];

      if (___R$$priv$romejs$consume$Consumer_ts$isComputedPart(part)) {
        const inner = typeof part === 'number' ? String(part) : ___R$romejs$string$escape$escapeString_ts$default(part, {
          quote: '\''});

        str += '[' + inner + ']';
      } else {
        if (nextPart === undefined || ___R$$priv$romejs$consume$Consumer_ts$isComputedPart(nextPart)) {
          str += part;
        } else {
          str += part + '.';
        }
      }
    }

    return str;
  }

  class ___R$romejs$consume$Consumer_ts$default {
    constructor(opts) {
      this.path = opts.filePath;
      this.filename = this.path === undefined ? undefined : this.path.join();

      this.value = opts.value;
      this.parent = opts.parent;
      this.keyPath = opts.objectPath;
      this.context = opts.context;
      this.onDefinition = opts.onDefinition;
      this.propertyMetadata = opts.propertyMetadata;
      this.usedNames = new Set();
      this.forkCache = new Map();

      this.hasHandledUnexpected = false;
      this.handleUnexpected = opts.handleUnexpectedDiagnostic;
    }

    async capture(callback) {
      let diagnostics = [];
      const definitions = [];

      const consumer = this.clone({
        onDefinition(def) {
          definitions.push(def);
        },
        handleUnexpectedDiagnostic(diag) {
          diagnostics.push(diag);
        }});

      const result = await callback(consumer);
      return {result: result, definitions: definitions, diagnostics: diagnostics};
    }

    handleThrownDiagnostics(callback) {
      if (this.handleUnexpected === undefined) {
        callback();
      } else {
        try {
          callback();
        } catch (err) {
          const diags = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
          if (diags === undefined) {
            throw err;
          } else {
            for (const diag of diags) {
              this.handleUnexpected(diag);
            }
          }
        }
      }
    }

    declareDefinition(def) {
      if (this.onDefinition !== undefined) {
        this.onDefinition(Object.assign({}, def, {
          objectPath: this.keyPath,
          metadata: this.propertyMetadata}));
      }
    }

    getDiagnosticPointer(target = 'all') {
      return this.context.getDiagnosticPointer(this.keyPath, target);
    }

    getLocation(target) {
      const pointer = this.getDiagnosticPointer(target);
      if (pointer === undefined) {
        return {
          filename: this.filename,
          start: ___R$romejs$parser$core$types_ts$UNKNOWN_POSITION,
          end: ___R$romejs$parser$core$types_ts$UNKNOWN_POSITION};
      } else {
        return {
          filename: pointer.filename,
          start: pointer.start,
          end: pointer.end};
      }
    }

    getLocationRange(startIndex, endIndex = startIndex, target) {
      const loc = this.getLocation(target);
      if (loc.start === ___R$romejs$parser$core$types_ts$UNKNOWN_POSITION) {
        return loc;
      }

      const {start: start, end: end} = loc;

      if (start.line !== end.line) {
        return loc;
      }

      return Object.assign({}, loc, {
        start: Object.assign({}, start, {
          column: ___R$romejs$ob1$index_ts$add(start.column, startIndex),
          index: ___R$romejs$ob1$index_ts$add(start.index, startIndex)}),
        end: Object.assign({}, start, {
          column: ___R$romejs$ob1$index_ts$add(start.column, endIndex),
          index: ___R$romejs$ob1$index_ts$add(start.index, endIndex)})});
    }

    getKey() {
      return this.keyPath[this.keyPath.length - 1];
    }

    hasChangedFromSource() {
      const originalValue = this.context.getOriginalValue(this.keyPath);
      return !this.wasInSource() || this.value !== originalValue;
    }

    wasInSource() {
      return this.getDiagnosticPointer() !== undefined;
    }

    generateUnexpectedMessage(msg, opts) {
      const {at: at = 'suffix', atParent: atParent = false} = opts;
      const {parent: parent} = this;

      let target = this;

      if (atParent) {
        if (parent === undefined) {
          return msg;
        } else {
          target = parent;
        }
      }

      if (at === 'suffix') {
        msg += ' at <emphasis>' + ___R$$priv$romejs$consume$Consumer_ts$joinPath(target.keyPath) + '</emphasis>';
      } else {
        msg = '<emphasis>' + ___R$$priv$romejs$consume$Consumer_ts$joinPath(target.keyPath) + '</emphasis> ' + msg;
      }

      return msg;
    }

    unexpected(msg, opts = {}) {
      const {target: target = 'value'} = opts;
      let {loc: loc} = opts;

      const {filename: filename} = this;
      let pointer = this.getDiagnosticPointer(target);
      const fromSource = pointer !== undefined;

      msg = this.generateUnexpectedMessage(msg, opts);

      const advice = [...(opts.advice || [])];

      if (fromSource) {
        if (this.hasChangedFromSource()) {
          advice.push({
            type: 'log',
            category: 'warn',
            message: 'Our internal value has been modified since we read the original source'});
        }
      } else {
        let consumer = this;
        do {
          const possiblePointer = consumer.getDiagnosticPointer(target);
          if (possiblePointer !== undefined) {
            pointer = possiblePointer;
            break;
          }
          consumer = consumer.parent;
        } while (consumer !== undefined);

        if (consumer === undefined && filename === undefined) {
          throw new Error(msg);
        }

        if (this.parent === undefined || !this.parent.wasInSource()) {
          advice.push({
            type: 'log',
            category: 'warn',
            message: 'This value was expected to be found at <emphasis>' + ___R$$priv$romejs$consume$Consumer_ts$joinPath(
            this.keyPath) + '</emphasis> but was not in the original source'});
        }
      }

      if (pointer === undefined) {
        throw new Error(msg);
      }

      if (loc === undefined) {
        loc = {
          filename: pointer.filename,
          start: pointer.start,
          end: pointer.end};
      }

      const diagnostic = Object.assign({
        category: this.context.category,
        filename: this.filename,
        message: msg}, loc, {
        language: pointer.language,
        mtime: pointer.mtime,
        sourceText: pointer.sourceText,
        advice: advice});

      const errMsg = 'Error occurred while consuming at ' + loc.filename + ' (' + loc.start.line + ':' + loc.start.column + '): ' + msg;
      const err = new ___R$romejs$diagnostics$errors_ts$DiagnosticsError(errMsg, [diagnostic]);

      if (this.handleUnexpected === undefined) {
        throw err;
      } else {
        if (this.shouldDispatchUnexpected()) {
          this.handleUnexpected(diagnostic);
          this.hasHandledUnexpected = true;
        }

        return err;
      }
    }

    shouldDispatchUnexpected() {
      if (this.hasHandledUnexpected) {
        return false;
      }

      const {parent: parent} = this;
      if (parent !== undefined) {
        return parent.shouldDispatchUnexpected();
      }

      return true;
    }

    clone(opts) {
      return new ___R$romejs$consume$Consumer_ts$default(Object.assign({
        onDefinition: this.onDefinition,
        handleUnexpectedDiagnostic: this.handleUnexpected,
        filePath: this.path,
        context: this.context,
        value: this.value,
        parent: this.parent,
        objectPath: this.keyPath,
        propertyMetadata: this.propertyMetadata}, opts));
    }

    fork(key, value, propertyMetadata) {
      const cached = this.forkCache.get(String(key));
      if (cached !== undefined &&
      cached.value === value &&
      (cached.propertyMetadata === undefined ||
      cached.propertyMetadata === propertyMetadata)) {
        return cached;
      }

      const forked = this.clone({
        propertyMetadata: propertyMetadata,
        value: value,
        parent: this,
        objectPath: [...this.keyPath, key]});
      this.forkCache.set(String(key), forked);
      return forked;
    }

    _normalizeValueForSet(value) {
      if (value instanceof Set) {
        return Array.from(value);
      }

      if (value instanceof Map) {
        const obj = {};
        for (const [key, val] of value) {
          obj[key] = val;
        }
        return obj;
      }

      return value;
    }

    getValue(def) {
      if (this.exists()) {
        return this.value;
      } else {
        return def;
      }
    }

    setValue(rawValue) {
      const value = this._normalizeValueForSet(rawValue);
      this.value = value;

      const {parent: parent, keyPath: keyPath} = this;
      if (parent === undefined || keyPath.length === 0) {
        return this;
      }

      const parentValue = parent.asUnknown();
      if (parentValue === undefined ||
      parentValue === null ||
      typeof parentValue !== 'object') {
        throw parent.unexpected('Attempted to set a property on a non-object');
      }

      const parentObj = parent.asUnknownObject();
      const key = this.getKey();
      parentObj[String(key)] = value;
      parent.setValue(parentObj);

      return this;
    }

    has(key) {
      return this.get(key).asUnknown() !== undefined;
    }

    setProperty(key, value) {
      return this.get(key).setValue(value);
    }

    get(key, metadata) {
      const value = this.asUnknownObject();
      this.markUsedProperty(key);
      return this.fork(key, value[key], metadata);
    }

    markUsedProperty(name) {
      this.usedNames.add(name);
    }

    enforceUsedProperties(type = 'property', recursive = true) {
      if (!this.isObject()) {
        return;
      }

      for (const [key, value] of this.asMap(false, false)) {
        if (!this.usedNames.has(key)) {
          value.unexpected('Unknown <emphasis>' + key + '</emphasis> ' + type, {
            target: 'key',
            at: 'suffix',
            atParent: true});
        }

        if (recursive) {
          value.enforceUsedProperties(type, true);
        }
      }
    }

    pushArray(item) {
      this.concatArray([item]);
      return this;
    }

    concatArray(items) {
      const arr = this.asPlainArray();
      this.setValue(arr.concat(items));
      return this;
    }

    asJSONValue() {
      const {value: value} = this;

      switch (typeof value) {
        case 'number':
        case 'string':
        case 'boolean':
          return value;}

      if (value === null) {
        return null;
      }

      if (Array.isArray(value)) {
        return this.asJSONArray();
      }

      if (this.isObject()) {
        return this.asJSONObject();
      }

      this.unexpected('Expected a JSON value');
      return '';
    }

    asJSONArray() {
      const arr = [];
      for (const value of this.asArray()) {
        arr.push(value.asJSONValue());
      }
      return arr;
    }

    asJSONObject() {
      const obj = {};
      for (const [key, value] of this.asMap()) {
        obj[key] = value.asJSONPropertyValue();
      }
      return obj;
    }

    asJSONPropertyValue() {
      if (this.exists()) {
        return this.asJSONValue();
      } else {
        return undefined;
      }
    }

    exists() {
      return this.value !== undefined;
    }

    isObject() {
      const {value: value} = this;
      return typeof value === 'object' &&
      value !== null &&
      value.constructor === Object;
    }

    keys(optional) {
      return Object.keys(this.asUnknownObject(optional));
    }

    asUnknownObject(optional = false) {
      this.declareDefinition({
        type: 'object',
        default: undefined,
        required: !optional});

      if (optional === true && !this.exists()) {
        return {};
      }

      const {value: value} = this;
      if (!this.isObject()) {
        this.unexpected('Expected object');
        return {};
      }

      return Object.assign({}, value);
    }

    asMap(optional, markUsed = true) {
      const value = this.asUnknownObject(optional);
      const map = new Map();
      for (const key in value) {
        if (markUsed) {
          this.markUsedProperty(key);
        }
        map.set(key, this.fork(key, value[key]));
      }
      return map;
    }

    asSet(optional) {
      const arr = this.asArray(optional);
      const setVals = new Set();
      const set = new Set();

      for (let i = 0; i < arr.length; i++) {
        const consumer = arr[i];
        const value = consumer.asUnknown();
        if (setVals.has(value)) {
          continue;
        }

        setVals.add(value);
        set.add(consumer);
      }

      return set;
    }

    asPlainArray(optional = false) {
      this.declareDefinition({
        type: 'array',
        default: undefined,
        required: !optional});

      if (optional === true && !this.exists()) {
        return [];
      }

      const {value: value} = this;

      if (!Array.isArray(value)) {
        this.unexpected('Expected array');
        return [];
      }

      return [...value];
    }

    asArray(optional) {
      const arr = this.asPlainArray(optional);

      return arr.map((val, index) => {
        return this.fork(index, val);
      });
    }

    asImplicitArray() {
      if (Array.isArray(this.asUnknown())) {
        return this.asArray();
      } else if (!this.exists()) {
        return [];
      } else {
        return [this];
      }
    }

    asDateOrVoid(def) {
      this.declareDefinition({
        type: 'date',
        default: def,
        required: false});
      if (this.exists()) {
        return this._asDate(def);
      } else {
        return undefined;
      }
    }

    asDate(def) {
      this.declareDefinition({
        type: 'date',
        default: def,
        required: true});
      return this._asDate(def);
    }

    _asDate(def) {
      const value = this.getValue(def);
      if (!(value instanceof Date)) {
        this.unexpected('Expected a date');
        return new Date();
      }
      return value;
    }

    asBooleanOrVoid(def) {
      this.declareDefinition({
        type: 'boolean',
        default: def,
        required: false});
      if (this.exists()) {
        return this._asBoolean(def);
      } else {
        return undefined;
      }
    }

    asBoolean(def) {
      this.declareDefinition({
        type: 'boolean',
        default: def,
        required: true});
      return this._asBoolean(def);
    }

    _asBoolean(def) {
      const value = this.getValue(def);
      if (typeof value !== 'boolean') {
        this.unexpected('Expected a boolean');
        return false;
      }
      return value;
    }

    asStringOrVoid(def) {
      this.declareDefinition({
        type: 'string',
        default: def,
        required: false});

      if (this.exists()) {
        return this.asString(def);
      } else {
        return undefined;
      }
    }

    asString(def) {
      this.declareDefinition({
        type: 'string',
        default: def,
        required: true});
      return this._asString(def);
    }

    _asString(def) {
      const value = this.getValue(def);
      if (typeof value !== 'string') {
        this.unexpected('Expected a string');
        return '';
      }
      return value;
    }

    asStringSet(validValues, def) {
      const value = this.asString(String(def));

      if (validValues.includes(value)) {
        return value;
      } else {
        this.unexpected('Invalid value <emphasis>' + value + '</emphasis>', {
          target: 'value',
          advice: [{
            type: 'log',
            category: 'info',
            message: 'Possible values are'}, {
            type: 'list',
            list: validValues.map(str => String(str))}]});
        return validValues[0];
      }
    }

    asStringSetOrVoid(validValues) {
      if (this.exists()) {
        return this.asStringSet(validValues);
      } else {
        return undefined;
      }
    }

    asBigIntOrVoid(def) {
      this.declareDefinition({
        type: 'bigint',
        default: def,
        required: false});
      if (this.exists()) {
        return this._asBigInt(def);
      } else {
        return undefined;
      }
    }

    asBigInt(def) {
      this.declareDefinition({
        type: 'bigint',
        default: def,
        required: true});
      return this._asBigInt(def);
    }

    _asBigInt(def) {
      const value = this.getValue(def);

      if (typeof value === 'number') {
        return BigInt(value);
      }

      if (typeof value === 'bigint') {
        return value;
      }

      this.unexpected('Expected a bigint');
      return BigInt('0');
    }

    asNumberOrVoid(def) {
      this.declareDefinition({
        type: 'number',
        default: def,
        required: false});

      if (this.exists()) {
        return this._asNumber(def);
      } else {
        return undefined;
      }
    }

    asZeroIndexedNumber() {
      return ___R$romejs$ob1$index_ts$coerce0(this.asNumber());
    }

    asOneIndexedNumber() {
      return ___R$romejs$ob1$index_ts$coerce1(this.asNumber());
    }

    asNumber(def) {
      this.declareDefinition({
        type: 'number',
        default: def,
        required: true});
      return this._asNumber(def);
    }

    asNumberInRange(opts) {
      const num = this._asNumber(opts.default);

      const {min: min, max: max} = opts;

      this.declareDefinition({
        type: 'number-range',
        default: opts.default,
        required: true,

        min: min,
        max: max});

      if (min !== undefined && max !== undefined && (num < min || num > max)) {
        this.unexpected('Expected number between ' + min + ' and ' + max);
        return num;
      }

      if (min !== undefined && num < min) {
        this.unexpected('Expected number higher than ' + min);
      }

      if (max !== undefined && num > max) {
        this.unexpected('Expected number lower than ' + max);
      }

      return num;
    }

    _asNumber(def) {
      const value = this.getValue(def);
      if (typeof value !== 'number') {
        this.unexpected('Expected a number');
        return 0;
      }
      return value;
    }

    asUnknown() {
      return this.value;
    }

    asAny() {
      return this.value;
    }
  }

  // romejs/consume/index.ts

  const ___R$romejs$consume$index_ts$EMPTY_CONSUME_CONTEXT = {
    category: 'unknown',

    getOriginalValue() {
      return undefined;
    },

    getDiagnosticPointer() {
      return undefined;
    }};

  const ___R$$priv$romejs$consume$index_ts$EMPTY_CONSUME_OPTIONS = {
    propertyMetadata: undefined,
    value: undefined,
    handleUnexpectedDiagnostic: undefined,
    onDefinition: undefined,
    filePath: undefined,
    context: ___R$romejs$consume$index_ts$EMPTY_CONSUME_CONTEXT,
    objectPath: [],
    parent: undefined};

  function ___R$romejs$consume$index_ts$consume(opts) {
    return new ___R$romejs$consume$Consumer_ts$default(Object.assign({}, ___R$$priv$romejs$consume$index_ts$EMPTY_CONSUME_OPTIONS, opts, {
      context: Object.assign({}, ___R$romejs$consume$index_ts$EMPTY_CONSUME_CONTEXT, opts.context)}));
  }

  function ___R$romejs$consume$index_ts$consumeUnknown(value) {
    return new ___R$romejs$consume$Consumer_ts$default(Object.assign({}, ___R$$priv$romejs$consume$index_ts$EMPTY_CONSUME_OPTIONS, {
      value: value}));
  }

  // romejs/pretty-format/index.ts


  const ___R$$priv$romejs$pretty$format$index_ts$DEFAULT_OPTIONS = {
    escapeMarkup: false,
    maxDepth: Infinity,
    color: false,
    indent: '',
    depth: 0,
    stack: [],
    compact: false};

  const ___R$$priv$romejs$pretty$format$index_ts$INDENT = '  ';

  function ___R$$priv$romejs$pretty$format$index_ts$maybeEscapeMarkup(str, opts) {
    if (opts.escapeMarkup) {
      return ___R$romejs$string$markup$escape_ts$escapeMarkup(str);
    } else {
      return str;
    }
  }

  const ___R$romejs$pretty$format$index_ts$CUSTOM_PRETTY_FORMAT = Symbol();

  function ___R$romejs$pretty$format$index_ts$default(obj, rawOpts = {}) {
    const opts = Object.assign({}, ___R$$priv$romejs$pretty$format$index_ts$DEFAULT_OPTIONS, rawOpts);

    if (opts.maxDepth === opts.depth) {
      return '[depth exceeded]';
    }

    switch (typeof obj) {
      case 'symbol':
        {
          const val = ___R$$priv$romejs$pretty$format$index_ts$maybeEscapeMarkup(___R$$priv$romejs$pretty$format$index_ts$formatSymbol(obj), opts);
          return opts.color ? ___R$romejs$string$ansi$format_ts$formatAnsi.green(val) : val;
        }

      case 'string':
        {
          const val = ___R$$priv$romejs$pretty$format$index_ts$maybeEscapeMarkup(___R$$priv$romejs$pretty$format$index_ts$formatString(obj), opts);
          return opts.color ? ___R$romejs$string$ansi$format_ts$formatAnsi.green(val) : val;
        }

      case 'bigint':
      case 'number':
        {
          const val = ___R$romejs$pretty$format$index_ts$formatNumber(obj);
          return opts.color ? ___R$romejs$string$ansi$format_ts$formatAnsi.yellow(val) : val;
        }

      case 'boolean':
        {
          const val = ___R$$priv$romejs$pretty$format$index_ts$formatBoolean(obj);
          return opts.color ? ___R$romejs$string$ansi$format_ts$formatAnsi.yellow(val) : val;
        }

      case 'undefined':
        {
          const val = ___R$$priv$romejs$pretty$format$index_ts$formatUndefined();
          return opts.color ? ___R$romejs$string$ansi$format_ts$formatAnsi.brightBlack(val) : val;
        }

      case 'function':
        return ___R$$priv$romejs$pretty$format$index_ts$formatFunction(obj, opts);

      case 'object':
        return ___R$$priv$romejs$pretty$format$index_ts$formatObjectish(obj, opts);

      default:
        throw new Error('Unknown type');}
  }

  function ___R$$priv$romejs$pretty$format$index_ts$joinList(items, opts) {
    if (items.length === 0) {
      return '';
    }

    const lines = [];

    for (const item of items) {
      lines.push('' + opts.indent + item);
    }

    return lines.join('\n');
  }

  function ___R$$priv$romejs$pretty$format$index_ts$isNativeFunction(val) {
    return val.toString().endsWith('{ [native code] }');
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatSymbol(val) {
    return String(val);
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatString(val) {
    return ___R$romejs$string$escape$escapeString_ts$default(val, {
      quote: '\''});
  }

  function ___R$romejs$pretty$format$index_ts$formatNumber(val) {
    if (typeof val === 'bigint') {
      return ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(val, '_');
    } else if (isNaN(val)) {
      return 'NaN';
    } else if (Object.is(val, -0)) {
      return '-0';
    } else if (isFinite(val)) {
      return ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(val, '_');
    } else if (Object.is(val, -Infinity)) {
      return '-Infinity';
    } else if (Object.is(val, +Infinity)) {
      return 'Infinity';
    } else {
      throw new Error('Don\'t know how to format this number');
    }
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatUndefined() {
    return 'undefined';
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatNull() {
    return 'null';
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatBoolean(val) {
    return val === true ? 'true' : 'false';
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatFunction(val, opts) {
    const name = val.name === '' ? 'anonymous' : ___R$$priv$romejs$pretty$format$index_ts$maybeEscapeMarkup(val.name, opts);
    let label = 'Function ' + name;

    if (___R$$priv$romejs$pretty$format$index_ts$isNativeFunction(val)) {
      label = 'Native' + label;
    }

    if (Object.keys(val).length === 0) {
      return label;
    }

    return ___R$$priv$romejs$pretty$format$index_ts$formatObject(label, val, opts, []);
  }

  function ___R$$priv$romejs$pretty$format$index_ts$getExtraObjectProps(obj, opts) {
    const props = [];
    const ignoreKeys = {};

    if (obj instanceof Map) {
      for (const [key, val] of obj) {
        const formattedKey = typeof key === 'string' ? ___R$$priv$romejs$pretty$format$index_ts$formatKey(key, opts) : ___R$romejs$pretty$format$index_ts$default(key, opts);
        props.push(formattedKey + ' => ' + ___R$romejs$pretty$format$index_ts$default(val, opts));
      }
    } else if (___R$romejs$typescript$helpers$index_ts$isIterable(obj)) {
      let i = 0;
      for (const val of obj) {
        ignoreKeys[String(i++)] = val;
        props.push(___R$romejs$pretty$format$index_ts$default(val, opts));
      }
    }

    return {ignoreKeys: ignoreKeys, props: props};
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatKey(rawKey, opts) {
    const key = ___R$$priv$romejs$pretty$format$index_ts$maybeEscapeMarkup(rawKey, opts);

    if (/[^A-Za-z0-9_$]/g.test(key)) {
      return ___R$$priv$romejs$pretty$format$index_ts$formatString(key);
    } else {
      return key;
    }
  }

  const ___R$romejs$pretty$format$index_ts$PRIORITIZE_KEYS = ['id', 'type', 'kind', 'key', 'name', 'value'];

  function ___R$$priv$romejs$pretty$format$index_ts$sortKeys(obj) {
    const sortedKeys = new Set(Object.keys(obj).sort(___R$romejs$string$utils$naturalCompare_ts$naturalCompare));

    const priorityKeys = [];
    const otherKeys = [];
    const objectKeys = [];

    for (const key of ___R$romejs$pretty$format$index_ts$PRIORITIZE_KEYS) {
      if (sortedKeys.has(key)) {
        priorityKeys.push({key: key, object: false});
        sortedKeys.delete(key);
      }
    }

    for (const key of sortedKeys) {
      const val = obj[key];

      let isObject = false;
      if (typeof val === 'object' && val != null && Object.keys(val).length > 0) {
        isObject = true;
      }
      if (Array.isArray(val) && val.length > 0) {
        isObject = true;
      }
      if (isObject) {
        objectKeys.push({key: key, object: true});
      } else {
        otherKeys.push({key: key, object: false});
      }
    }

    return [...priorityKeys, ...otherKeys, ...objectKeys];
  }

  function ___R$$priv$romejs$pretty$format$index_ts$lineCount(str) {
    return str.split('\n').length;
    ___R$$priv$romejs$pretty$format$index_ts$formatKey;
  }

  function ___R$$priv$romejs$pretty$format$index_ts$lineCountCompare(a, b) {
    return ___R$$priv$romejs$pretty$format$index_ts$lineCount(a) - ___R$$priv$romejs$pretty$format$index_ts$lineCount(b);
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatObject(label, obj, opts, labelKeys) {
    const {stack: stack} = opts;
    if (stack.length > 0 && stack.includes(obj)) {
      label = 'Circular ' + label + ' ' + stack.indexOf(obj);
      return opts.color ? ___R$romejs$string$ansi$format_ts$formatAnsi.cyan(label) : label;
    }

    const nextOpts = Object.assign({}, opts, {
      stack: [...stack, obj],
      depth: opts.depth + 1,
      indent: opts.indent + ___R$$priv$romejs$pretty$format$index_ts$INDENT});
    const {ignoreKeys: ignoreKeys, props: props} = ___R$$priv$romejs$pretty$format$index_ts$getExtraObjectProps(obj, nextOpts);

    const objProps = [];

    for (const {key: key, object: object} of ___R$$priv$romejs$pretty$format$index_ts$sortKeys(obj)) {
      const val = obj[key];
      if (key in ignoreKeys && ignoreKeys[key] === val) {
        continue;
      }

      if (opts.compact && val === undefined) {
        continue;
      }

      if (labelKeys.includes(key)) {
        continue;
      }

      const prop = ___R$$priv$romejs$pretty$format$index_ts$formatKey(key, opts) + ': ' + ___R$romejs$pretty$format$index_ts$default(val, nextOpts);
      if (object) {
        objProps.push(prop);
      } else {
        props.push(prop);
      }
    }

    for (const prop of objProps.sort(___R$$priv$romejs$pretty$format$index_ts$lineCountCompare)) {
      props.push(prop);
    }

    for (const sym of Object.getOwnPropertySymbols(obj)) {
      const val = Reflect.get(obj, sym);
      props.push(___R$romejs$pretty$format$index_ts$default(sym, opts) + ': ' + ___R$romejs$pretty$format$index_ts$default(val, nextOpts));
    }

    let open = '{';
    let close = '}';
    if (___R$romejs$typescript$helpers$index_ts$isIterable(obj)) {
      open = '[';
      close = ']';
    }

    let inner = ___R$$priv$romejs$pretty$format$index_ts$joinList(props, nextOpts);
    if (inner !== '') {
      if (props.length === 1 && !inner.includes('\n')) {
        inner = inner.trim();
      } else {
        inner = '\n' + inner + '\n' + opts.indent;
      }
    }

    label = opts.color ? ___R$romejs$string$ansi$format_ts$formatAnsi.cyan(label) : label;
    return label + ' ' + open + inner + close;
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatRegExp(val) {
    return String(val);
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatDate(val) {
    return val.toISOString();
  }

  function ___R$$priv$romejs$pretty$format$index_ts$formatObjectish(val, opts) {
    if (val === null) {
      const val = ___R$$priv$romejs$pretty$format$index_ts$formatNull();
      return opts.color ? ___R$romejs$string$ansi$format_ts$formatAnsi.bold(val) : val;
    }

    if (val instanceof RegExp) {
      const str = ___R$$priv$romejs$pretty$format$index_ts$formatRegExp(val);
      return opts.color ? ___R$romejs$string$ansi$format_ts$formatAnsi.red(str) : str;
    }

    if (val instanceof Date) {
      const str = ___R$$priv$romejs$pretty$format$index_ts$formatDate(val);
      return opts.color ? ___R$romejs$string$ansi$format_ts$formatAnsi.magenta(str) : str;
    }

    let label = 'null';

    if (val.constructor !== undefined) {
      label = ___R$$priv$romejs$pretty$format$index_ts$maybeEscapeMarkup(val.constructor.name, opts);
    }

    let labelKeys = [];

    if (typeof val.type === 'string') {
      label = ___R$$priv$romejs$pretty$format$index_ts$maybeEscapeMarkup(val.type, opts);
      labelKeys.push('type');
    } else if (typeof val.kind === 'string') {
      label = ___R$$priv$romejs$pretty$format$index_ts$maybeEscapeMarkup(val.kind, opts);
      labelKeys.push('kind');
    }

    return ___R$$priv$romejs$pretty$format$index_ts$formatObject(label, val, opts, labelKeys);
  }

  // romejs/codec-json/stringify.ts

  function ___R$$priv$romejs$codec$json$stringify_ts$joinList(open, close, indent, items) {
    if (items.length === 0) {
      return open + close;
    }

    if (items.length === 1) {
      const first = items[0].trim();

      if (first[0] !== '/') {
        return open + first + close;
      }
    }

    return [open, ...items, indent + close].join('\n');
  }

  function ___R$$priv$romejs$codec$json$stringify_ts$stringifyKey(key) {
    if (___R$romejs$codec$json$parse_ts$isValidWord(key)) {
      return key;
    } else {
      return ___R$romejs$string$escape$escapeString_ts$default(key, {
        ignoreWhitespaceEscapes: true,
        json: true});
    }
  }

  function ___R$romejs$codec$json$stringify_ts$stringifyComments(indent, comments) {
    return comments.map(node => {
      if (node.type === 'BlockComment') {
        return indent + '/*' + node.value + '*/';
      } else {
        return indent + '//' + node.value;
      }
    });
  }

  function ___R$$priv$romejs$codec$json$stringify_ts$stringifyPrimitives(value) {
    if (value === null) {
      return 'null';
    }

    if (value instanceof Number ||
    value instanceof String ||
    value instanceof Boolean) {
      value = value.valueOf();
    }

    switch (typeof value) {
      case 'symbol':
      case 'function':
      case 'undefined':
        return 'null';

      case 'boolean':
        return value ? 'true' : 'false';

      case 'string':
        return ___R$romejs$string$escape$escapeString_ts$default(value, {json: true, ignoreWhitespaceEscapes: true});

      case 'bigint':
        throw new Error('Do not know how to serialize a BigInt');

      case 'number':
        return ___R$romejs$pretty$format$index_ts$formatNumber(value);}

    return undefined;
  }

  function ___R$$priv$romejs$codec$json$stringify_ts$sortMapKeys(map) {
    return new Set(Array.from(map.keys()).sort(___R$romejs$string$utils$naturalCompare_ts$naturalCompare));
  }

  function ___R$$priv$romejs$codec$json$stringify_ts$sortMap(map) {
    const sortedMap = new Map();
    const sortedKeys = ___R$$priv$romejs$codec$json$stringify_ts$sortMapKeys(map);

    for (const key of ___R$romejs$pretty$format$index_ts$PRIORITIZE_KEYS) {
      if (sortedKeys.has(key)) {
        sortedKeys.delete(key);

        const val = map.get(key);
        if (val === undefined) {
          throw new Error('Expected value');
        }

        sortedMap.set(key, val);
      }
    }

    for (const key of sortedKeys) {
      const val = map.get(key);
      if (val === undefined) {
        throw new Error('Expected value');
      }

      sortedMap.set(key, val);
    }

    return sortedMap;
  }

  function ___R$$priv$romejs$codec$json$stringify_ts$getComments(consumer, opts) {
    const comments = opts.comments.get(consumer.keyPath.join('.'));
    if (comments === undefined) {
      return {
        inner: [],
        outer: []};
    } else {
      return comments;
    }
  }

  function ___R$$priv$romejs$codec$json$stringify_ts$stringifyArray(consumer, info) {
    const {level: level, prevIndent: prevIndent, nextIndent: nextIndent, stack: stack} = info;

    let buff = [];

    const arr = consumer.asArray();
    for (const consumer of arr) {
      const comments = ___R$$priv$romejs$codec$json$stringify_ts$getComments(consumer, info).outer;
      buff = buff.concat(___R$romejs$codec$json$stringify_ts$stringifyComments(nextIndent, comments));

      const element = ___R$$priv$romejs$codec$json$stringify_ts$stringifyConsumer(consumer, {
        comments: info.comments,
        isTopLevel: false,
        level: level + 1,
        stack: stack});
      buff.push('' + nextIndent + element);
    }

    const innerComments = ___R$$priv$romejs$codec$json$stringify_ts$getComments(consumer, info).inner;
    buff = buff.concat(___R$romejs$codec$json$stringify_ts$stringifyComments(nextIndent, innerComments));

    return ___R$$priv$romejs$codec$json$stringify_ts$joinList('[', ']', prevIndent, buff);
  }

  function ___R$$priv$romejs$codec$json$stringify_ts$stringifyPlainObject(consumer, info) {
    const {level: level, prevIndent: prevIndent, stack: stack, isTopLevel: isTopLevel} = info;
    let {nextIndent: nextIndent} = info;

    let buff = [];
    const map = consumer.asMap();

    for (const [key, consumer] of map) {
      const value = consumer.asUnknown();

      if (typeof value === 'function' ||
      typeof value === 'undefined' ||
      typeof value === 'symbol') {
        map.delete(key);
      }
    }

    let propLevel = level + 1;

    if (isTopLevel && level === 0) {
      propLevel = 0;
      nextIndent = '';
    }

    for (const [key, consumer] of ___R$$priv$romejs$codec$json$stringify_ts$sortMap(map)) {
      const comments = ___R$$priv$romejs$codec$json$stringify_ts$getComments(consumer, info).outer;
      buff = buff.concat(___R$romejs$codec$json$stringify_ts$stringifyComments(nextIndent, comments));

      const propKey = ___R$$priv$romejs$codec$json$stringify_ts$stringifyKey(key);
      const propValue = ___R$$priv$romejs$codec$json$stringify_ts$stringifyConsumer(consumer, {
        comments: info.comments,
        isTopLevel: false,
        level: propLevel,
        stack: stack});
      buff.push('' + nextIndent + propKey + ': ' + propValue);
    }

    const hasProps = buff.length > 0;

    const innerComments = ___R$$priv$romejs$codec$json$stringify_ts$getComments(consumer, info).inner;
    buff = buff.concat(___R$romejs$codec$json$stringify_ts$stringifyComments(nextIndent, innerComments));

    if (level === 0 && isTopLevel) {
      if (hasProps) {
        return buff.join('\n');
      } else if (buff.length > 0) {
        buff = buff.map(str => {
          return '  ' + str;
        });
      }
    }

    return ___R$$priv$romejs$codec$json$stringify_ts$joinList('{', '}', prevIndent, buff);
  }

  function ___R$$priv$romejs$codec$json$stringify_ts$stringifyObject(consumer, value, opts) {
    const {isTopLevel: isTopLevel, level: level, stack: stack} = opts;

    const info = {
      comments: opts.comments,
      isTopLevel: isTopLevel,
      nextIndent: '  '.repeat(level + 1),
      prevIndent: level === 0 ? '' : '  '.repeat(level - 1),
      level: level,
      stack: stack};

    try {
      stack.add(value);

      if (Array.isArray(value) || value instanceof Set) {
        return ___R$$priv$romejs$codec$json$stringify_ts$stringifyArray(consumer, info);
      }

      return ___R$$priv$romejs$codec$json$stringify_ts$stringifyPlainObject(consumer, info);
    } finally {
      stack.delete(value);
    }
  }

  function ___R$romejs$codec$json$stringify_ts$stringifyRootConsumer(consumer, pathToComments) {
    const opts = {
      comments: pathToComments,
      isTopLevel: true,
      level: 0,
      stack: new Set()};

    const inner = ___R$$priv$romejs$codec$json$stringify_ts$stringifyConsumer(consumer, opts);
    const comments = ___R$$priv$romejs$codec$json$stringify_ts$getComments(consumer, opts);
    const outer = ___R$romejs$codec$json$stringify_ts$stringifyComments('', comments.outer);

    return [...outer, inner].join('\n');
  }

  function ___R$$priv$romejs$codec$json$stringify_ts$stringifyConsumer(consumer, opts) {
    const value = consumer.asUnknown();

    const asPrim = ___R$$priv$romejs$codec$json$stringify_ts$stringifyPrimitives(value);
    if (asPrim !== undefined) {
      return asPrim;
    }

    if (opts.stack.has(value)) {
      throw new TypeError('Recursive');
    }

    return ___R$$priv$romejs$codec$json$stringify_ts$stringifyObject(consumer, value, opts);
  }

  // romejs/codec-json/index.ts


  function ___R$romejs$codec$json$index_ts$consumeJSON(opts) {
    return ___R$romejs$codec$json$index_ts$consumeJSONExtra(opts).consumer;
  }

  function ___R$romejs$codec$json$index_ts$consumeJSONExtra(opts) {
    const parser = ___R$romejs$codec$json$parse_ts$default(opts);
    const {value: value, context: context} = parser.parse();

    return {
      hasExtensions: parser.hasExtensions,
      consumer: ___R$romejs$consume$index_ts$consume({
        filePath: parser.path,
        context: context,
        objectPath: [],
        value: value,
        parent: undefined}),
      comments: parser.pathToComments};
  }

  function ___R$romejs$codec$json$index_ts$parseJSON(opts) {
    return ___R$romejs$codec$json$parse_ts$default(opts).parse().value;
  }

  function ___R$romejs$codec$json$index_ts$tokenizeJSON(opts) {
    return ___R$romejs$codec$json$parse_ts$default(opts).tokenizeAll();
  }

  function ___R$romejs$codec$json$index_ts$stringifyJSON(opts) {
    return ___R$romejs$codec$json$stringify_ts$stringifyRootConsumer(opts.consumer, opts.comments);
  }

  // romejs/v8/InspectorClient.ts


  class ___R$romejs$v8$InspectorClient_ts$InspectorClientCloseError extends Error {
    constructor() {
      super('Inspector connection closed');
    }
  }

  class ___R$romejs$v8$InspectorClient_ts$default {
    constructor(socket) {
      this.socket = socket;
      this.id = 0;

      this.subscriptions = new Map();
      this.callbacks = new Map();

      this.alive = true;

      this.init();
    }

    end() {
      this.socket.end();
    }

    init() {
      const {socket: socket} = this;

      socket.errorEvent.subscribe(err => {
        this.alive = false;
        for (const [, {reject: reject}] of this.callbacks) {
          reject(err);
        }
        this.callbacks.clear();
        this.end();
      });

      socket.endEvent.subscribe(() => {
        this.alive = false;
        for (const [, {reject: reject}] of this.callbacks) {
          reject(new ___R$romejs$v8$InspectorClient_ts$InspectorClientCloseError());
        }
        this.callbacks.clear();
      });

      socket.completeFrameEvent.subscribe(frame => {
        const json = frame.payload.toString();
        const data = ___R$romejs$codec$json$index_ts$consumeJSON({
          input: json});

        const id = data.get('id').asNumberOrVoid();
        if (id !== undefined) {
          const handler = this.callbacks.get(id);
          if (handler !== undefined) {
            if (data.has('error')) {
              const errorMessage = data.get('error').get('message').asString();
              handler.reject(new Error(errorMessage));
            } else {
              handler.resolve(data.get('result'));
            }
            this.callbacks.delete(id);
          }
          return undefined;
        }

        const method = data.get('method').asStringOrVoid();
        if (method !== undefined) {
          const subs = this.subscriptions.get(method);
          if (subs !== undefined) {
            for (const sub of subs) {
              const {callback: callback, once: once} = sub;
              callback(data.get('params'));
              if (once) {
                subs.delete(sub);
              }
            }
          }
        }
      });
    }

    subscribe(method, sub) {
      let subs = this.subscriptions.get(method);
      if (subs === undefined) {
        subs = new Set();
        this.subscriptions.set(method, subs);
      }
      subs.add(sub);
    }

    assertAlive() {
      if (!this.alive) {
        throw new Error('InspectorClient has no active socket');
      }
    }

    async wait(method) {
      return new Promise(resolve => {
        this.assertAlive();
        this.subscribe(method, {
          once: true,
          callback: resolve});
      });
    }

    call(method, params) {
      const id = ++this.id;

      return new Promise((resolve, reject) => {
        this.assertAlive();
        this.callbacks.set(id, {resolve: resolve, reject: reject});

        this.socket.sendJSON({
          id: id,
          method: method,
          params: params});
      });
    }
  }

  // romejs/v8/CoverageCollector.ts

  const ___R$$priv$romejs$v8$CoverageCollector_ts$inspector = require('inspector');
  function ___R$$priv$romejs$v8$CoverageCollector_ts$createCoverageFileStats(covered, uncovered) {
    const total = uncovered + covered;
    return {
      uncovered: uncovered,
      covered: covered,
      total: total,
      percent: total === 0 ? 100 : 100 / total * covered};
  }

  class ___R$romejs$v8$CoverageCollector_ts$default {
    constructor() {
      this.sourceMaps = new Map();
    }

    addSourceMap(filename, code, map) {
      this.sourceMaps.set(filename, {
        ranges: [],
        map: map,
        code: code});
    }

    addCoverage(entries) {
      for (const entry of entries) {
        const filename = ___R$romejs$v8$utils_ts$urlToFilename(entry.url);

        const data = this.sourceMaps.get(filename);
        if (data === undefined) {
          continue;
        }

        for (const {ranges: ranges, functionName: functionName, isBlockCoverage: isBlockCoverage} of entry.functions) {
          data.ranges = data.ranges.concat(
          ranges.map(range => {
            let kind = 'expression';
            if (functionName !== '') {
              kind = 'function';
            } else if (isBlockCoverage) {
              kind = 'branch';
            }
            return Object.assign({
              kind: kind}, range);
          }));
        }
      }
    }

    generate() {
      const insertedLocs = new Map();
      const locs = [];

      for (const data of this.sourceMaps.values()) {
        const {ranges: ranges, code: code, map: map} = data;

        let line = ___R$romejs$ob1$index_ts$number1;
        let column = ___R$romejs$ob1$index_ts$number0;
        let index = ___R$romejs$ob1$index_ts$number0;
        const indexCache = new Map();
        function findIndex(newIndex) {
          const cached = indexCache.get(newIndex);
          if (cached !== undefined) {
            return cached;
          }

          if (newIndex < index) {
            throw new Error('Expected newIndex(' + newIndex + ') >= index(' + index + ')');
          }

          if (___R$romejs$ob1$index_ts$get0(newIndex) > code.length) {
            throw new Error('Expected newIndex(' + newIndex + ') <= code.length(' + code.length + ')');
          }

          while (index < newIndex) {
            const char = code[___R$romejs$ob1$index_ts$get0(index)];
            if (char === '\n') {
              line = ___R$romejs$ob1$index_ts$inc(line);
              column = ___R$romejs$ob1$index_ts$number0;
            } else {
              column = ___R$romejs$ob1$index_ts$inc(column);
            }
            index = ___R$romejs$ob1$index_ts$inc(index);
          }

          const pos = {
            index: newIndex,
            line: line,
            column: column};
          indexCache.set(newIndex, pos);
          return pos;
        }

        const offsets = [];
        for (const {startOffset: startOffset, endOffset: endOffset} of ranges) {
          offsets.push(___R$romejs$ob1$index_ts$coerce0(startOffset));
          offsets.push(___R$romejs$ob1$index_ts$coerce0(endOffset));
        }
        offsets.sort((a, b) => ___R$romejs$ob1$index_ts$get0(a) - ___R$romejs$ob1$index_ts$get0(b));
        for (const index of offsets) {
          findIndex(index);
        }

        const sourceMap = new ___R$romejs$codec$source$map$SourceMapConsumer_ts$default(map);
        for (const {kind: kind, startOffset: startOffset, endOffset: endOffset, count: count} of ranges) {
          const originalStart = findIndex(___R$romejs$ob1$index_ts$coerce0(startOffset));
          const originalEnd = findIndex(___R$romejs$ob1$index_ts$coerce0(endOffset));

          const sourceStart = sourceMap.approxOriginalPositionFor(
          originalStart.line,
          originalStart.column);
          if (sourceStart === undefined) {
            continue;
          }

          const sourceEnd = sourceMap.approxOriginalPositionFor(
          originalEnd.line,
          originalEnd.column);
          if (sourceEnd === undefined) {
            continue;
          }

          if (sourceStart.source !== sourceEnd.source) {
            throw new Error('Expected the same source for start and end: ' + sourceStart.source + ' !== ' + sourceEnd.source);
          }

          const key = sourceStart.source + ':' + String(startOffset) + '-' + String(
          endOffset);
          const alreadyInserted = insertedLocs.get(key);
          if (alreadyInserted !== undefined) {
            alreadyInserted.count += count;
            continue;
          }

          const loc = {
            kind: kind,
            filename: sourceStart.source,
            count: count,
            start: {
              index: ___R$romejs$ob1$index_ts$coerce0(startOffset),
              line: sourceStart.line,
              column: sourceStart.column},
            end: {
              index: ___R$romejs$ob1$index_ts$coerce0(endOffset),
              line: sourceEnd.line,
              column: sourceEnd.column}};
          insertedLocs.set(key, loc);
          locs.push(loc);
        }
      }

      const rangesByFile = new Map();
      for (const loc of locs) {
        let ranges = rangesByFile.get(loc.filename);
        if (ranges === undefined) {
          ranges = [];
          rangesByFile.set(loc.filename, ranges);
        }
        ranges.push(loc);
      }

      const files = [];
      for (const [filename, ranges] of rangesByFile) {
        const coveredLines = new Set();
        const uncoveredLines = new Set();

        let uncoveredFunctions = new Set();
        let coveredFunctions = new Set();
        let uncoveredBranches = new Set();
        let coveredBranches = new Set();

        for (const {count: count, kind: kind, start: start, end: end} of ranges) {
          for (let i = start.line; i <= end.line; i = ___R$romejs$ob1$index_ts$inc(i)) {
            if (count === 0) {
              uncoveredLines.add(i);
            } else {
              coveredLines.add(i);
            }
          }

          if (kind === 'function') {
            if (count === 0) {
              uncoveredBranches.add(start.index);
              uncoveredFunctions.add(start.line);
            } else {
              coveredFunctions.add(start.line);
              coveredBranches.add(start.index);
            }
          } else if (kind === 'branch') {
            if (count === 0) {
              uncoveredBranches.add(start.index);
            } else {
              coveredBranches.add(start.index);
            }
          }
        }

        for (const line of coveredLines) {
          uncoveredLines.delete(line);
        }

        for (const index of coveredBranches) {
          uncoveredBranches.delete(index);
        }

        for (const index of coveredFunctions) {
          uncoveredFunctions.delete(index);
        }

        if (uncoveredLines.size === 0 &&
        uncoveredBranches.size === 0 &&
        uncoveredFunctions.size === 0) {
          continue;
        }

        files.push({
          filename: filename,
          lines: ___R$$priv$romejs$v8$CoverageCollector_ts$createCoverageFileStats(coveredLines.size, uncoveredLines.size),
          branches: ___R$$priv$romejs$v8$CoverageCollector_ts$createCoverageFileStats(
          coveredBranches.size,
          uncoveredBranches.size),
          functions: ___R$$priv$romejs$v8$CoverageCollector_ts$createCoverageFileStats(
          coveredFunctions.size,
          uncoveredFunctions.size)});
      }
      return files;
    }
  }

  // romejs/v8/index.ts

  const ___R$romejs$v8$index_ts$sourceMapManager = ___R$romejs$v8$sourceMapManager_ts

  // romejs/diagnostics/derive.ts

  const ___R$romejs$diagnostics$derive_ts = {
    mergeDiagnostics: ___R$romejs$diagnostics$derive_ts$mergeDiagnostics,
    getDiagnosticHeader: ___R$romejs$diagnostics$derive_ts$getDiagnosticHeader,
    deriveRootAdviceFromDiagnostic: ___R$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic,
    deriveDiagnosticFromError: ___R$romejs$diagnostics$derive_ts$deriveDiagnosticFromError,
    getErrorStackAdvice: ___R$romejs$diagnostics$derive_ts$getErrorStackAdvice,
    addOriginsToDiagnostics: ___R$romejs$diagnostics$derive_ts$addOriginsToDiagnostics,
    addOriginsToDiagnostic: ___R$romejs$diagnostics$derive_ts$addOriginsToDiagnostic};
  function ___R$$priv$romejs$diagnostics$derive_ts$normalizeArray(val) {
    if (Array.isArray(val)) {
      return val;
    } else {
      return [];
    }
  }

  function ___R$romejs$diagnostics$derive_ts$mergeDiagnostics(rootDiag, ...diags) {
    let mergedAdvice = [...___R$$priv$romejs$diagnostics$derive_ts$normalizeArray(rootDiag.advice)];

    for (const diag of diags) {
      mergedAdvice = [...mergedAdvice, ...___R$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(diag).advice, ...___R$$priv$romejs$diagnostics$derive_ts$normalizeArray(diag.advice)];
    }

    return Object.assign({}, rootDiag, {
      advice: mergedAdvice});
  }

  function ___R$romejs$diagnostics$derive_ts$getDiagnosticHeader(opts) {
    const {start: start, filename: filename} = opts;

    if (filename === undefined) {
      return 'unknown';
    }

    if (start === undefined) {
      return '<filelink target="' + filename + '" />';
    }

    return '<filelink target="' + filename + '" line="' + start.line + '" column="' + start.column + '" />';
  }

  function ___R$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(diag, opts = {
    skipFrame: false,
    includeHeaderInAdvice: true,
    outdated: false}) {
    const advice = [];

    let header = ___R$romejs$diagnostics$derive_ts$getDiagnosticHeader({
      start: diag.start,
      filename: diag.filename});

    if (diag.category !== undefined) {
      header += ' <emphasis>' + diag.category + '</emphasis>';
    }

    if (diag.fixable === true) {
      header += ' <inverse> FIXABLE </inverse>';
    }

    if (opts.outdated === true) {
      header += ' <inverse> OUTDATED </inverse>';
    }

    if (opts.includeHeaderInAdvice === true) {
      advice.push({
        type: 'log',
        category: 'none',
        message: header});
    }

    advice.push({
      type: 'log',
      category: 'error',
      message: diag.message});

    if (opts.skipFrame === false) {
      if (diag.start !== undefined && diag.end !== undefined) {
        advice.push({
          type: 'frame',
          sourceText: diag.sourceText,
          filename: diag.filename,
          mtime: diag.mtime,
          marker: diag.marker,
          start: diag.start,
          end: diag.end});
      } else if (diag.marker !== undefined) {
        advice.push({
          type: 'log',
          category: 'error',
          message: diag.marker});
      }
    }

    return {header: header, advice: advice};
  }

  function ___R$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(opts) {
    const {error: error, filename: filename} = opts;

    let targetFilename = filename;
    let targetCode = undefined;
    let targetLoc = undefined;

    const structErr = ___R$romejs$v8$errors_ts$getErrorStructure(error);
    let {frames: frames, message: message, advice: advice} = structErr;

    const {cleanFrames: cleanFrames} = opts;
    if (cleanFrames !== undefined) {
      frames = cleanFrames(frames);
    }

    for (const frame of frames) {
      if (frame.filename === undefined) {
        continue;
      }

      targetFilename = frame.filename;
      targetLoc = ___R$romejs$v8$errors_ts$getSourceLocationFromErrorFrame(frame);
      break;
    }

    advice = [...___R$romejs$diagnostics$derive_ts$getErrorStackAdvice(error, undefined, frames), ...advice];

    return {
      filename: targetFilename,
      start: targetLoc === undefined ? undefined : targetLoc.start,
      end: targetLoc === undefined ? undefined : targetLoc.end,
      sourceText: targetCode,
      category: opts.category,
      message: message,
      advice: advice};
  }

  function ___R$romejs$diagnostics$derive_ts$getErrorStackAdvice(errorLike, title, _frames) {
    const error = ___R$romejs$v8$errors_ts$getErrorStructure(errorLike);
    const {stack: stack} = error;

    const advice = [];
    const frames = _frames === undefined ? error.frames : _frames;

    if (frames.length === 0 && stack !== undefined) {
      if (title !== undefined) {
        advice.push({
          type: 'log',
          category: 'info',
          message: title});
      }

      let cleanStack = stack;
      let removeMessage = error.name + ': ' + error.message;
      if (cleanStack.startsWith(removeMessage)) {
        cleanStack = cleanStack.slice(removeMessage.length);
      }

      advice.push({
        type: 'log',
        category: 'error',
        message: ___R$romejs$string$markup$escape_ts$escapeMarkup(cleanStack)});
    } else {
      const adviceFrames = frames.map(frame => {
        const {
          typeName: typeName,
          functionName: functionName,
          methodName: methodName,
          filename: filename,
          lineNumber: lineNumber,
          columnNumber: columnNumber,
          isEval: isEval,
          isNative: isNative,
          isConstructor: isConstructor,
          isAsync: isAsync} = frame;

        const prefixes = [];
        if (isAsync) {
          prefixes.push('await');
        }
        if (isEval) {
          prefixes.push('eval');
        }
        if (isConstructor) {
          prefixes.push('new');
        }
        const prefix = prefixes.length === 0 ? undefined : prefixes.join(' ');

        let object = typeName;
        let property = '<anonymous>';
        if (functionName !== undefined) {
          property = functionName;
        }
        if (methodName !== undefined) {
          property = methodName;
        }

        let suffix;
        if (isNative) {
          suffix = 'native';
        }

        return {
          suffix: suffix,
          prefix: prefix,
          object: object,
          property: property,
          filename: filename,
          line: lineNumber,
          column: columnNumber};
      });

      advice.push({
        type: 'stacktrace',
        title: title,
        frames: adviceFrames});
    }

    return advice;
  }

  function ___R$romejs$diagnostics$derive_ts$addOriginsToDiagnostics(origins, diagnostics) {
    return diagnostics.map(diag => {
      return ___R$romejs$diagnostics$derive_ts$addOriginsToDiagnostic(origins, diag);
    });
  }

  function ___R$romejs$diagnostics$derive_ts$addOriginsToDiagnostic(origins, diag) {
    const newOrigins = diag.origins === undefined ? origins : [...origins, ...diag.origins];
    return Object.assign({}, diag, {
      origins: newOrigins});
  }

  // romejs/diagnostics/wrap.ts

  const ___R$romejs$diagnostics$wrap_ts = {
    catchDiagnostics: ___R$romejs$diagnostics$wrap_ts$catchDiagnostics};

  async function ___R$romejs$diagnostics$wrap_ts$catchDiagnostics(origin, promise) {
    try {
      const value = await promise();

      return {value: value, diagnostics: undefined};
    } catch (err) {
      const diagnostics = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);

      if (diagnostics) {
        return {
          value: undefined,
          diagnostics: ___R$romejs$diagnostics$derive_ts$addOriginsToDiagnostics([origin], diagnostics)};
      } else {
        throw err;
      }
    }
  }

  // romejs/string-diff/index.ts


  const ___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE = -1;
  const ___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT = 1;
  const ___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL = 0;
  const ___R$romejs$string$diff$index_ts$constants = {
    DELETE: ___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE,
    EQUAL: ___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL,
    ADD: ___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT};

  function ___R$romejs$string$diff$index_ts$groupDiffByLines(rawDiffs) {
    const diffsByLine = [];

    let line = [];
    function flushLine() {
      if (line.length > 0) {
        diffsByLine.push(line);
        line = [];
      }
    }

    for (const tuple of rawDiffs) {
      const [type, text] = tuple;

      if (type === ___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE) {
        line.push(tuple);
        continue;
      }

      const parts = text.split('\n');

      if (parts.length <= 1) {
        line.push(tuple);
        continue;
      }

      const [currentLine, ...futureLines] = parts;

      if (currentLine !== '') {
        line.push([type, currentLine]);
      }

      for (const newLine of futureLines) {
        flushLine();
        line.push([type, newLine]);
      }
    }

    flushLine();

    return diffsByLine;
  }

  function ___R$romejs$string$diff$index_ts$default(text1, text2) {
    return ___R$$priv$romejs$string$diff$index_ts$main(text1, text2, true);
  }

  function ___R$$priv$romejs$string$diff$index_ts$main(text1, text2, fixUnicode = false) {
    if (text1 === text2) {
      if (text1) {
        return [[___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL, text1]];
      }
      return [];
    }

    let commonlength = ___R$$priv$romejs$string$diff$index_ts$commonPrefix(text1, text2);
    let commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);

    commonlength = ___R$$priv$romejs$string$diff$index_ts$commonSuffix(text1, text2);
    let commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);

    let diffs = ___R$$priv$romejs$string$diff$index_ts$compute(text1, text2);

    if (commonprefix) {
      diffs.unshift([___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL, commonprefix]);
    }
    if (commonsuffix) {
      diffs.push([___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL, commonsuffix]);
    }
    ___R$$priv$romejs$string$diff$index_ts$cleanupMerge(diffs, fixUnicode);
    return diffs;
  }

  function ___R$$priv$romejs$string$diff$index_ts$compute(text1, text2) {
    let diffs = [];

    if (!text1) {
      return [[___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT, text2]];
    }

    if (!text2) {
      return [[___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE, text1]];
    }

    let longtext = text1.length > text2.length ? text1 : text2;
    let shorttext = text1.length > text2.length ? text2 : text1;
    let i = longtext.indexOf(shorttext);
    if (i !== -1) {
      diffs = [[___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT, longtext.substring(0, i)], [___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL, shorttext], [___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT, longtext.substring(i + shorttext.length)]];

      if (text1.length > text2.length) {
        diffs[0][0] = diffs[2][0] = ___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE;
      }
      return diffs;
    }

    if (shorttext.length === 1) {
      return [[___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE, text1], [___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT, text2]];
    }

    let hm = ___R$$priv$romejs$string$diff$index_ts$halfMatch(text1, text2);
    if (hm) {
      let text1_a = hm[0];
      let text1_b = hm[1];
      let text2_a = hm[2];
      let text2_b = hm[3];
      let mid_common = hm[4];

      let diffs_a = ___R$$priv$romejs$string$diff$index_ts$main(text1_a, text2_a);
      let diffs_b = ___R$$priv$romejs$string$diff$index_ts$main(text1_b, text2_b);

      return diffs_a.concat([[___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL, mid_common]], diffs_b);
    }

    return ___R$$priv$romejs$string$diff$index_ts$bisect(text1, text2);
  }

  function ___R$$priv$romejs$string$diff$index_ts$bisect(text1, text2) {
    let text1_length = text1.length;
    let text2_length = text2.length;
    let max_d = Math.ceil((text1_length + text2_length) / 2);
    let v_offset = max_d;
    let v_length = 2 * max_d;
    let v1 = new Array(v_length);
    let v2 = new Array(v_length);

    for (let x = 0; x < v_length; x++) {
      v1[x] = -1;
      v2[x] = -1;
    }
    v1[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    let delta = text1_length - text2_length;

    let front = delta % 2 !== 0;

    let k1start = 0;
    let k1end = 0;
    let k2start = 0;
    let k2end = 0;
    for (let d = 0; d < max_d; d++) {
      for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
        let k1_offset = v_offset + k1;
        let x1;
        if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
          x1 = v1[k1_offset + 1];
        } else {
          x1 = v1[k1_offset - 1] + 1;
        }
        let y1 = x1 - k1;
        while (x1 < text1_length &&
        y1 < text2_length &&
        text1.charAt(x1) === text2.charAt(y1)) {
          x1++;
          y1++;
        }
        v1[k1_offset] = x1;
        if (x1 > text1_length) {
          k1end += 2;
        } else if (y1 > text2_length) {
          k1start += 2;
        } else if (front) {
          let k2_offset = v_offset + delta - k1;
          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
            let x2 = text1_length - v2[k2_offset];
            if (x1 >= x2) {
              return ___R$$priv$romejs$string$diff$index_ts$bisectSplit(text1, text2, x1, y1);
            }
          }
        }
      }

      for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
        let k2_offset = v_offset + k2;
        let x2;
        if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
          x2 = v2[k2_offset + 1];
        } else {
          x2 = v2[k2_offset - 1] + 1;
        }
        let y2 = x2 - k2;
        while (x2 < text1_length &&
        y2 < text2_length &&
        text1.charAt(text1_length - x2 - 1) ===
        text2.charAt(text2_length - y2 - 1)) {
          x2++;
          y2++;
        }
        v2[k2_offset] = x2;
        if (x2 > text1_length) {
          k2end += 2;
        } else if (y2 > text2_length) {
          k2start += 2;
        } else if (!front) {
          let k1_offset = v_offset + delta - k2;
          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
            let x1 = v1[k1_offset];
            let y1 = v_offset + x1 - k1_offset;

            x2 = text1_length - x2;
            if (x1 >= x2) {
              return ___R$$priv$romejs$string$diff$index_ts$bisectSplit(text1, text2, x1, y1);
            }
          }
        }
      }
    }

    return [[___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE, text1], [___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT, text2]];
  }

  function ___R$$priv$romejs$string$diff$index_ts$bisectSplit(text1, text2, x, y) {
    let text1a = text1.substring(0, x);
    let text2a = text2.substring(0, y);
    let text1b = text1.substring(x);
    let text2b = text2.substring(y);

    let diffs = ___R$$priv$romejs$string$diff$index_ts$main(text1a, text2a);
    let diffsb = ___R$$priv$romejs$string$diff$index_ts$main(text1b, text2b);

    return diffs.concat(diffsb);
  }

  function ___R$$priv$romejs$string$diff$index_ts$commonPrefix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
      return 0;
    }

    let pointermin = 0;
    let pointermax = Math.min(text1.length, text2.length);
    let pointermid = pointermax;
    let pointerstart = 0;
    while (pointermin < pointermid) {
      if (text1.substring(pointerstart, pointermid) ==
      text2.substring(pointerstart, pointermid)) {
        pointermin = pointermid;
        pointerstart = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }

    if (___R$$priv$romejs$string$diff$index_ts$is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
      pointermid--;
    }

    return pointermid;
  }

  function ___R$$priv$romejs$string$diff$index_ts$commonSuffix(text1, text2) {
    if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
      return 0;
    }

    let pointermin = 0;
    let pointermax = Math.min(text1.length, text2.length);
    let pointermid = pointermax;
    let pointerend = 0;
    while (pointermin < pointermid) {
      if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
      text2.substring(text2.length - pointermid, text2.length - pointerend)) {
        pointermin = pointermid;
        pointerend = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }

    if (___R$$priv$romejs$string$diff$index_ts$is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
      pointermid--;
    }

    return pointermid;
  }

  function ___R$$priv$romejs$string$diff$index_ts$halfMatch(text1, text2) {
    let longtext = text1.length > text2.length ? text1 : text2;
    let shorttext = text1.length > text2.length ? text2 : text1;
    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
      return undefined;
    }

    let hm1 = ___R$$priv$romejs$string$diff$index_ts$halfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));

    let hm2 = ___R$$priv$romejs$string$diff$index_ts$halfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));

    let hm;
    if (!hm1 && !hm2) {
      return undefined;
    } else if (!hm2) {
      hm = hm1;
    } else if (!hm1) {
      hm = hm2;
    } else {
      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }

    if (hm === undefined) {
      throw new Error('Expected half match');
    }

    let text1_a, text1_b, text2_a, text2_b;
    if (text1.length > text2.length) {
      text1_a = hm[0];
      text1_b = hm[1];
      text2_a = hm[2];
      text2_b = hm[3];
    } else {
      text2_a = hm[0];
      text2_b = hm[1];
      text1_a = hm[2];
      text1_b = hm[3];
    }
    let mid_common = hm[4];
    return [text1_a, text1_b, text2_a, text2_b, mid_common];
  }

  function ___R$$priv$romejs$string$diff$index_ts$halfMatchI(longtext, shorttext, i) {
    let seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    let j = -1;
    let best_common = '';
    let best_longtext_a = '';
    let best_longtext_b = '';
    let best_shorttext_a = '';
    let best_shorttext_b = '';
    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
      let prefixLength = ___R$$priv$romejs$string$diff$index_ts$commonPrefix(
      longtext.substring(i),
      shorttext.substring(j));
      let suffixLength = ___R$$priv$romejs$string$diff$index_ts$commonSuffix(
      longtext.substring(0, i),
      shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common =
        shorttext.substring(j - suffixLength, j) +
        shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }

    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return undefined;
    }
  }

  function ___R$$priv$romejs$string$diff$index_ts$cleanupMerge(diffs, fix_unicode) {
    diffs.push([___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL, '']);
    let pointer = 0;
    let count_delete = 0;
    let count_insert = 0;
    let text_delete = '';
    let text_insert = '';
    let commonlength;
    while (pointer < diffs.length) {
      if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
        diffs.splice(pointer, 1);
        continue;
      }
      switch (diffs[pointer][0]) {
        case ___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          pointer++;
          break;
        case ___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          pointer++;
          break;
        case ___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL:
          let previous_equality = pointer - count_insert - count_delete - 1;
          if (fix_unicode) {
            if (previous_equality >= 0 &&
            ___R$$priv$romejs$string$diff$index_ts$ends_with_pair_start(diffs[previous_equality][1])) {
              let stray = diffs[previous_equality][1].slice(-1);
              diffs[previous_equality][1] = diffs[previous_equality][1].slice(
              0,
              -1);
              text_delete = stray + text_delete;
              text_insert = stray + text_insert;
              if (!diffs[previous_equality][1]) {
                diffs.splice(previous_equality, 1);
                pointer--;
                let k = previous_equality - 1;
                if (diffs[k] && diffs[k][0] === ___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT) {
                  count_insert++;
                  text_insert = diffs[k][1] + text_insert;
                  k--;
                }
                if (diffs[k] && diffs[k][0] === ___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE) {
                  count_delete++;
                  text_delete = diffs[k][1] + text_delete;
                  k--;
                }
                previous_equality = k;
              }
            }
            if (___R$$priv$romejs$string$diff$index_ts$starts_with_pair_end(diffs[pointer][1])) {
              let stray = diffs[pointer][1].charAt(0);
              diffs[pointer][1] = diffs[pointer][1].slice(1);
              text_delete += stray;
              text_insert += stray;
            }
          }
          if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
            diffs.splice(pointer, 1);
            break;
          }
          if (text_delete.length > 0 || text_insert.length > 0) {
            if (text_delete.length > 0 && text_insert.length > 0) {
              commonlength = ___R$$priv$romejs$string$diff$index_ts$commonPrefix(text_insert, text_delete);
              if (commonlength !== 0) {
                if (previous_equality >= 0) {
                  diffs[previous_equality][1] += text_insert.substring(
                  0,
                  commonlength);
                } else {
                  diffs.splice(0, 0, [___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                  pointer++;
                }
                text_insert = text_insert.substring(commonlength);
                text_delete = text_delete.substring(commonlength);
              }

              commonlength = ___R$$priv$romejs$string$diff$index_ts$commonSuffix(text_insert, text_delete);
              if (commonlength !== 0) {
                diffs[pointer][1] =
                text_insert.substring(text_insert.length - commonlength) +
                diffs[pointer][1];
                text_insert = text_insert.substring(
                0,
                text_insert.length - commonlength);
                text_delete = text_delete.substring(
                0,
                text_delete.length - commonlength);
              }
            }

            let n = count_insert + count_delete;
            if (text_delete.length === 0 && text_insert.length === 0) {
              diffs.splice(pointer - n, n);
              pointer = pointer - n;
            } else if (text_delete.length === 0) {
              diffs.splice(pointer - n, n, [___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT, text_insert]);
              pointer = pointer - n + 1;
            } else if (text_insert.length === 0) {
              diffs.splice(pointer - n, n, [___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE, text_delete]);
              pointer = pointer - n + 1;
            } else {
              diffs.splice(
              pointer - n,
              n,
              [___R$$priv$romejs$string$diff$index_ts$DIFF_DELETE, text_delete],
              [___R$$priv$romejs$string$diff$index_ts$DIFF_INSERT, text_insert]);
              pointer = pointer - n + 2;
            }
          }
          if (pointer !== 0 && diffs[pointer - 1][0] === ___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL) {
            diffs[pointer - 1][1] += diffs[pointer][1];
            diffs.splice(pointer, 1);
          } else {
            pointer++;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;}
    }
    if (diffs[diffs.length - 1][1] === '') {
      diffs.pop();
    }

    let changes = false;
    pointer = 1;

    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] === ___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL &&
      diffs[pointer + 1][0] === ___R$$priv$romejs$string$diff$index_ts$DIFF_EQUAL) {
        if (diffs[pointer][1].substring(
        diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
          diffs[pointer][1] =
          diffs[pointer - 1][1] +
          diffs[pointer][1].substring(
          0,
          diffs[pointer][1].length - diffs[pointer - 1][1].length);
          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
          diffs.splice(pointer - 1, 1);
          changes = true;
        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
        diffs[pointer + 1][1]) {
          diffs[pointer - 1][1] += diffs[pointer + 1][1];
          diffs[pointer][1] =
          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
          diffs[pointer + 1][1];
          diffs.splice(pointer + 1, 1);
          changes = true;
        }
      }
      pointer++;
    }

    if (changes) {
      ___R$$priv$romejs$string$diff$index_ts$cleanupMerge(diffs, fix_unicode);
    }
  }

  function ___R$$priv$romejs$string$diff$index_ts$is_surrogate_pair_start(charCode) {
    return charCode >= 55296 && charCode <= 56319;
  }

  function ___R$$priv$romejs$string$diff$index_ts$is_surrogate_pair_end(charCode) {
    return charCode >= 56320 && charCode <= 57343;
  }

  function ___R$$priv$romejs$string$diff$index_ts$starts_with_pair_end(str) {
    return ___R$$priv$romejs$string$diff$index_ts$is_surrogate_pair_end(str.charCodeAt(0));
  }

  function ___R$$priv$romejs$string$diff$index_ts$ends_with_pair_start(str) {
    return ___R$$priv$romejs$string$diff$index_ts$is_surrogate_pair_start(str.charCodeAt(str.length - 1));
  }

  // romejs/diagnostics/helpers.ts

  const ___R$romejs$diagnostics$helpers_ts = {
    buildSuggestionAdvice: ___R$romejs$diagnostics$helpers_ts$buildSuggestionAdvice,
    truncateSourceText: ___R$romejs$diagnostics$helpers_ts$truncateSourceText};
  function ___R$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(value, items, minRating = 0.8, formatItem) {
    const advice = [];

    const ratings = ___R$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(value, items, minRating);

    const strings = ratings.map(item => {
      const {target: target} = item;
      if (formatItem === undefined) {
        return target;
      } else {
        return formatItem(target);
      }
    });

    const topRatingFormatted = strings.shift();
    if (topRatingFormatted === undefined) {
      return advice;
    }

    const topRatingRaw = ratings[0].target;

    if (topRatingRaw === value) {}

    if (strings.length === 1) {
      advice.push({
        type: 'log',
        category: 'info',
        message: 'Did you mean <emphasis>' + topRatingFormatted + '</emphasis> or <emphasis>' + strings[0] + '</emphasis>?'});
    } else {
      advice.push({
        type: 'log',
        category: 'info',
        message: 'Did you mean <emphasis>' + topRatingFormatted + '</emphasis>?'});

      advice.push({
        type: 'diff',
        diff: ___R$romejs$string$diff$index_ts$default(value, topRatingRaw)});

      if (strings.length > 0) {
        advice.push({
          type: 'log',
          category: 'info',
          message: 'Or one of these?'});

        advice.push({
          type: 'list',
          list: strings,
          truncate: 20});
      }
    }

    if (topRatingRaw !== value &&
    topRatingRaw.toLowerCase() === value.toLowerCase()) {
      advice.push({
        type: 'log',
        category: 'warn',
        message: 'This operation is case sensitive'});
    }

    return advice;
  }

  function ___R$romejs$diagnostics$helpers_ts$truncateSourceText(code, start, end) {
    const lines = code.split(___R$romejs$js$parser$utils$whitespace_ts$NEWLINE);

    const fromLine = Math.max(___R$romejs$ob1$index_ts$get1(start.line) - 10, 0);
    const toLine = Math.max(___R$romejs$ob1$index_ts$get1(end.line) + 10, lines.length);

    const capturedLines = lines.slice(fromLine, toLine);
    return '\n'.repeat(fromLine) + capturedLines.join('\n');
  }

  // romejs/diagnostics/DiagnosticsProcessor.ts


  const ___R$$priv$romejs$diagnostics$DiagnosticsProcessor_ts$DEFAULT_UNIQUE = [['category', 'filename', 'message', 'start.line', 'start.column']];

  class ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default {
    constructor(options) {
      this.diagnostics = [];
      this.filters = [];
      this.options = options;
      this.includedKeys = new Set();
      this.unique =
      options.unique === undefined ? ___R$$priv$romejs$diagnostics$DiagnosticsProcessor_ts$DEFAULT_UNIQUE : options.unique;
      this.throwAfter = undefined;
    }

    static createImmediateThrower(origins) {
      const diagnostics = new ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default({
        origins: origins,
        onDiagnostics() {
          diagnostics.maybeThrowDiagnosticsError();
        }});
      return diagnostics;
    }

    setThrowAfter(num) {
      this.throwAfter = num;
    }

    maybeThrowDiagnosticsError() {
      if (this.hasDiagnostics()) {
        throw new ___R$romejs$diagnostics$errors_ts$DiagnosticsError('Thrown by DiagnosticsProcessor', this.getPartialDiagnostics());
      }
    }

    hasDiagnostics() {
      return this.diagnostics.length > 0;
    }

    addFilter(diag) {
      this.filters.push(diag);
    }

    doesMatchFilter(diag) {
      for (const filter of this.filters) {
        if (filter.message !== undefined && filter.message !== diag.message) {
          continue;
        }

        if (filter.filename !== undefined && filter.filename !== diag.filename) {
          continue;
        }

        if (filter.category !== undefined && filter.category !== diag.category) {
          continue;
        }

        if (filter.start !== undefined && diag.start !== undefined) {
          if (filter.start.line !== diag.start.line ||
          filter.start.column !== diag.start.column) {
            continue;
          }
        }

        return true;
      }

      return false;
    }

    buildDedupeKeys(diag) {
      let {start: start} = diag;

      const keys = [];

      for (const rule of this.unique) {
        const parts = [];

        if (rule.includes('category')) {
          parts.push('category:' + diag.category);
        }

        if (rule.includes('filename')) {
          parts.push('filename:' + String(diag.filename));
        }

        if (rule.includes('message')) {
          parts.push('message:' + diag.message);
        }

        if (start !== undefined) {
          if (rule.includes('start.line')) {
            parts.push('start.line:' + start.line);
          }

          if (rule.includes('start.column')) {
            parts.push('start.column:' + start.column);
          }
        }

        const key = parts.join(',');
        keys.push(key);
      }

      return keys;
    }

    addDiagnostic(diag, origin) {
      return this.addDiagnostics([diag], origin).length > 0;
    }

    addDiagnostics(diags, origin) {
      const {max: max} = this.options;
      const added = [];

      const origins = this.options.origins === undefined ? [] : [...this.options.origins];
      if (origin !== undefined) {
        origins.push(origin);
      }
      diags = ___R$romejs$diagnostics$derive_ts$addOriginsToDiagnostics(origins, diags);

      diagLoop: for (const diag of diags) {
        if (max !== undefined && this.diagnostics.length > max) {
          break;
        }

        if (this.doesMatchFilter(diag)) {
          continue;
        }

        const keys = this.buildDedupeKeys(diag);

        for (const key of keys) {
          if (this.includedKeys.has(key)) {
            continue diagLoop;
          }
        }

        this.diagnostics.push(diag);
        added.push(diag);

        for (const key of keys) {
          this.includedKeys.add(key);
        }
      }

      const {onDiagnostics: onDiagnostics} = this.options;
      if (onDiagnostics !== undefined && added.length > 0) {
        onDiagnostics(added);
      }

      const {throwAfter: throwAfter} = this;
      if (throwAfter !== undefined && this.diagnostics.length >= throwAfter) {
        this.maybeThrowDiagnosticsError();
      }

      return added;
    }

    getPartialDiagnostics() {
      return [...this.diagnostics];
    }

    getCompleteDiagnostics(markupOptions = {}) {
      return ___R$romejs$diagnostics$normalize_ts$normalizeDiagnostics(this.diagnostics, markupOptions);
    }

    getCompleteSortedDiagnostics(markupOptions = {}) {
      return this.getCompleteDiagnostics(markupOptions).sort((a, b) => {
        if (a.filename === undefined || b.filename === undefined) {
          return 0;
        } else {
          return ___R$romejs$string$utils$naturalCompare_ts$naturalCompare(a.filename, b.filename);
        }
      });
    }

    clear() {
      this.includedKeys = new Set();
      this.diagnostics = [];
    }
  }

  // romejs/diagnostics/constants.ts

  const ___R$romejs$diagnostics$constants_ts = {
    get INTERNAL_ERROR_LOG_ADVICE() {
      return ___R$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE;
    }};
  const ___R$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE = {
    type: 'log',
    category: 'warn',
    message: 'This diagnostic was derived from an internal Rome error. The problem likely isn\'t with your code. Please report this if necessary'};

  // romejs/diagnostics/index.ts


  // romejs/cli-diagnostics/types.ts

  const ___R$romejs$cli$diagnostics$types_ts = {};

  // romejs/cli-reporter/Progress.ts


  const ___R$$priv$romejs$cli$reporter$Progress_ts$BOUNCER_INTERVAL = 1000 / 30;
  const ___R$$priv$romejs$cli$reporter$Progress_ts$BOUNCER_WIDTH = 20;

  const ___R$$priv$romejs$cli$reporter$Progress_ts$DEFAULT_PROGRESS_OPTIONS = {
    name: undefined,
    initDelay: undefined,
    elapsed: true,
    eta: true};

  class ___R$romejs$cli$reporter$Progress_ts$default {
    constructor(reporter, opts = {}, onEnd) {
      this.reporter = reporter;
      this.opts = Object.assign({}, ___R$$priv$romejs$cli$reporter$Progress_ts$DEFAULT_PROGRESS_OPTIONS, opts);

      this.textStack = [];
      this.text = undefined;
      this.title = undefined;

      this.pausedStart = undefined;
      this.pausedElapsed = 0;

      this.startTime = Date.now();
      this.lastRenderTime = Date.now();
      this.lastRenderCurrent = 0;

      this.closed = false;
      this.current = 0;
      this.approximateTotal = false;
      this.total = undefined;
      this.approximateETA = undefined;
      this.onEnd = onEnd;

      this.delay = 60;
      this.renderEvery = 0;

      this.paused = false;

      this.streamToBouncerStart = new Map();
      this.startBouncer();

      this.queueRender(opts.initDelay);
      this.initName(opts.name);
    }

    initName(name) {
      if (name === undefined) {
        return;
      }
    }

    processRemoteClientMessage(msg) {
      switch (msg.type) {
        case 'PROGRESS_SET_CURRENT':
          return this.setCurrent(msg.current);

        case 'PROGRESS_SET_TOTAL':
          return this.setTotal(msg.total, msg.approximate);

        case 'PROGRESS_SET_TITLE':
          return this.setTitle(msg.title);

        case 'PROGRESS_SET_TEXT':
          return this.setText(msg.text);

        case 'PROGRESS_PUSH_TEXT':
          return this.pushText(msg.text);

        case 'PROGRESS_POP_TEXT':
          return this.popText(msg.text);

        case 'PROGRESS_SET_APPROXIMATE_ETA':
          return this.setApproximateETA(msg.duration);

        case 'PROGRESS_TICK':
          return this.tick();

        case 'PROGRESS_END':
          return this.end();

        case 'PROGRESS_RESUME':
          return this.resume();

        case 'PROGRESS_PAUSE':
          return this.pause();}
    }

    resume() {
      if (!this.paused || this.pausedStart === undefined) {
        return;
      }

      this.pausedElapsed += Date.now() - this.pausedStart;
      this.pausedStart = undefined;
      this.paused = false;
      this.render();
    }

    pause() {
      if (this.paused) {
        return;
      }

      this.pausedStart = Date.now();
      this.paused = true;
      this.render();
    }

    getElapsedTime() {
      return Date.now() - this.startTime - this.pausedElapsed;
    }

    getBouncerPosition(stream) {
      const start = this.streamToBouncerStart.get(stream);
      if (start === undefined) {
        return 0;
      } else {
        return start;
      }
    }

    startBouncer() {
      const queueTick = () => {
        this.bouncerTimer = setTimeout(tick, ___R$$priv$romejs$cli$reporter$Progress_ts$BOUNCER_INTERVAL);
      };

      const tick = this.reporter.wrapCallback(() => {
        if (this.paused) {
          queueTick();
          return;
        }

        const elapsedTime = this.getElapsedTime();
        const elapsedFrames = Math.round(elapsedTime / ___R$$priv$romejs$cli$reporter$Progress_ts$BOUNCER_INTERVAL);

        for (const stream of this.reporter.streams) {
          const width = stream.columns - ___R$$priv$romejs$cli$reporter$Progress_ts$BOUNCER_WIDTH;

          let position = elapsedFrames % width;

          const totalBounces = Math.floor(elapsedFrames / width);
          if (totalBounces % 2 === 1) {
            position = width - position;
          }

          this.streamToBouncerStart.set(stream, position);
        }

        queueTick();
        this.render();
      });

      queueTick();
    }

    setCurrent(current) {
      if (this.closed) {
        return;
      }

      this.current = current;

      if (this.renderTimer === undefined) {
        this.queueRender();
      }

      if (this.isRenderDue()) {
        this.render();
      }

      if (this.total !== undefined && this.current >= this.total) {
        this.end();
      }
    }

    setApproximateETA(duration) {
      this.approximateETA = duration;
    }

    setTotal(total, approximate = false) {
      this.total = total;
      this.approximateTotal = approximate;
      this.renderEvery = Math.round(total / 100);
      this.endBouncer();
      this.queueRender();
    }

    setTitle(title) {
      this.title = this.reporter.stripMarkup(title);
      this.queueRender();
    }

    setText(text) {
      if (this.closed) {
        return;
      }

      this.text = this.reporter.stripMarkup(text);
      this.queueRender();
    }

    pushText(text) {
      this.setText(text);
      this.textStack.push(text);
    }

    popText(text) {
      const {textStack: textStack} = this;
      const index = textStack.indexOf(text);
      if (index === -1) {
        throw new Error('No pushed text: ' + text);
      }

      textStack.splice(index, 1);

      const last = textStack[textStack.length - 1];
      this.setText(last === undefined ? '' : last);
    }

    tick() {
      this.setCurrent(this.current + 1);
    }

    queueRender(delay = this.delay) {
      if (this.closed) {
        return;
      }

      if (this.renderTimer !== undefined) {
        return;
      }

      this.renderTimer = setTimeout(
      this.reporter.wrapCallback(() => {
        this.render();
      }),
      delay);
    }

    endBouncer() {
      if (this.bouncerTimer !== undefined) {
        clearTimeout(this.bouncerTimer);
      }
      this.bouncerTimer = undefined;
    }

    endRender() {
      if (this.renderTimer !== undefined) {
        clearTimeout(this.renderTimer);
      }
      this.renderTimer = undefined;
    }

    end() {
      this.closed = true;
      this.endBouncer();
      this.endRender();
      this.reporter.clearLineAll();

      if (this.onEnd !== undefined) {
        this.onEnd();
      }
    }

    isRenderDue() {
      const isDue = this.current > this.lastRenderCurrent + this.renderEvery;
      if (isDue) {
        const timeSinceLastRender = Date.now() - this.lastRenderTime;
        return timeSinceLastRender > 1000;
      } else {
        return false;
      }
    }

    isBoldCharacter(i, ranges) {
      for (const [start, end] of ranges) {
        if (start >= i && end <= i) {
          return true;
        }
      }

      return false;
    }

    splitCharacters(str, boldRanges) {
      return str.split('').map((char, i) => {
        if (this.isBoldCharacter(i, boldRanges)) {
          return [i, ___R$romejs$string$ansi$format_ts$formatAnsi.bold(char)];
        } else {
          return [i, char];
        }
      });
    }

    buildProgressBouncer(stream, bar) {
      let start = this.getBouncerPosition(stream);
      let fullBar = '';
      for (const [i, char] of bar) {
        const isBounce = i >= start && i < start + ___R$$priv$romejs$cli$reporter$Progress_ts$BOUNCER_WIDTH;

        if (isBounce) {
          if (this.paused) {
            fullBar += ___R$romejs$string$ansi$format_ts$formatAnsi.inverse(char);
          } else {
            fullBar += ___R$romejs$string$ansi$format_ts$formatAnsi.white(___R$romejs$string$ansi$format_ts$formatAnsi.bgYellow(char));
          }
        } else {
          fullBar += char;
        }
      }
      return fullBar;
    }

    buildProgressBar(stream, bar, total) {
      const ratio = Math.min(Math.max(this.current / total, 0), 1);

      const completeLength = Math.round(stream.columns * ratio);
      let fullBar = '';
      for (const [i, char] of bar) {
        if (i < completeLength) {
          if (this.paused) {
            fullBar += ___R$romejs$string$ansi$format_ts$formatAnsi.inverse(char);
          } else {
            fullBar += ___R$romejs$string$ansi$format_ts$formatAnsi.white(___R$romejs$string$ansi$format_ts$formatAnsi.bgGreen(char));
          }
        } else {
          fullBar += char;
        }
      }
      return fullBar;
    }

    buildBar(stream) {
      const {total: total, current: current, text: text, title: title} = this;

      const boldRanges = [];

      let prefix = '';
      if (title !== undefined) {
        prefix += title;

        boldRanges.push([0, prefix.length - 1]);
      }
      if (text !== undefined) {
        if (title !== undefined) {
          prefix += ': ';
        }
        prefix += text;
      }

      let suffix = '';

      const elapsed = this.getElapsedTime();

      if (this.opts.elapsed) {
        suffix += 'elapsed ' + ___R$romejs$string$utils$humanizeTime_ts$humanizeTime(elapsed) + ' ';
      }

      if (current > 0) {
        const averagePerItem = elapsed / current;

        if (this.opts.eta) {
          if (this.approximateETA !== undefined &&
          elapsed < this.approximateETA) {
            const left = elapsed - this.approximateETA;
            suffix += 'eta ~' + ___R$romejs$string$utils$humanizeTime_ts$humanizeTime(left) + ' ';
          } else if (total !== undefined) {
            const itemsLeft = total - current;

            const eta = itemsLeft * averagePerItem;
            suffix += 'eta ' + ___R$romejs$string$utils$humanizeTime_ts$humanizeTime(eta) + ' ';
          } else {
            const ops = Math.round(1000 / averagePerItem);
            suffix += ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(ops) + ' op/s ';
          }
        }

        suffix += ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(current);
        if (total !== undefined) {
          suffix += '/';
          if (this.approximateTotal) {
            suffix += '~';
          }
          suffix += ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(total);
        }
      }

      const width = stream.columns - 3;

      const spacerLength = Math.max(0, width - prefix.length - suffix.length);
      const spacer = ' '.repeat(spacerLength);

      prefix = prefix.slice(0, width - spacerLength - suffix.length);

      const raw = ' ' + prefix + spacer + ' ' + suffix;

      boldRanges.push([raw.length - suffix.length, raw.length - 1]);

      const chars = this.splitCharacters(raw, boldRanges);

      if (total === undefined) {
        return this.buildProgressBouncer(stream, chars);
      } else {
        return this.buildProgressBar(stream, chars, total);
      }
    }

    render() {
      if (this.closed) {
        return;
      }

      this.endRender();

      this.lastRenderCurrent = this.current;
      this.lastRenderTime = Date.now();

      for (const stream of this.reporter.getStreams(false)) {
        if (stream.format === 'ansi') {
          stream.write(___R$romejs$string$ansi$escapes_ts$escapes.cursorTo(0));
          stream.write(this.buildBar(stream));
        }
      }
    }
  }

  // romejs/cli-reporter/util.ts

  const ___R$$priv$romejs$cli$reporter$util_ts$formatOpts = {
    maxDepth: 5};

  function ___R$romejs$cli$reporter$util_ts$interpolate(msg, args) {
    let argIndex = 0;

    let interpolated = msg.replace(/%s/g, () => {
      return ___R$romejs$pretty$format$index_ts$default(args[argIndex++], ___R$$priv$romejs$cli$reporter$util_ts$formatOpts);
    });

    if (argIndex < args.length) {
      interpolated += ' ';
      interpolated += args.slice(argIndex).map(arg => ___R$romejs$string$markup$escape_ts$escapeMarkup(___R$romejs$pretty$format$index_ts$default(arg, ___R$$priv$romejs$cli$reporter$util_ts$formatOpts))).join(' ');
    }

    return interpolated;
  }

  // romejs/events/Event.ts


  class ___R$romejs$events$Event_ts$default {
    constructor(opts) {
      this.subscriptions = new Set();
      this.rootSubscription = undefined;
      this.name = opts.name;
      this.options = opts;
    }

    onSubscriptionChange() {}

    onError(err) {
      const {onError: onError} = this.options;
      if (onError !== undefined) {
        onError(err);
      }
    }

    clear() {
      this.subscriptions.clear();
    }

    hasSubscribers() {
      return this.hasSubscriptions();
    }

    hasSubscriptions() {
      return this.rootSubscription !== undefined;
    }

    send(param) {
      const {rootSubscription: rootSubscription} = this;
      if (rootSubscription === undefined) {
        return undefined;
      }

      rootSubscription(param);

      for (const callback of this.subscriptions) {
        callback(param);
      }
    }

    async call(param) {
      const {rootSubscription: rootSubscription, subscriptions: subscriptions} = this;
      if (rootSubscription === undefined) {
        throw new Error('No subscription for event ' + this.name);
      }

      try {
        if (this.options.serial === true) {
          const ret = await rootSubscription(param);
          for (const callback of subscriptions) {
            await callback(param);
          }
          return ret;
        } else {
          const res = await Promise.all([rootSubscription(param), ...Array.from(subscriptions, callback => callback(param))]);

          return res[0];
        }
      } catch (err) {
        this.onError(err);
        throw err;
      }
    }

    wait(val, timeout) {
      return new Promise((resolve, reject) => {
        let timeoutId;
        let timedOut = false;

        if (timeout !== undefined) {
          timeoutId = setTimeout(() => {
            timedOut = true;
            listener.unsubscribe();
            reject(
            new Error('Timed out after waiting ' + timeout + 'ms for ' + this.name));
          }, timeout);
        }

        const listener = this.subscribe(param => {
          if (timedOut) {
            return val;
          }

          if (timeoutId !== undefined) {
            clearTimeout(timeoutId);
          }

          listener.unsubscribe();
          resolve(param);
          return val;
        });
      });
    }

    async callOptional(param) {
      if (this.rootSubscription === undefined) {
        return undefined;
      } else {
        return this.call(param);
      }
    }

    subscribe(callback, makeRoot) {
      if (this.options.unique === true && this.subscriptions.size !== 0) {
        throw new Error('Event ' + this.name + ' only allows a single subscription');
      }

      if (this.rootSubscription === callback ||
      this.subscriptions.has(callback)) {
        throw new Error('Cannot double subscribe a callback');
      }

      if (this.rootSubscription === undefined) {
        this.rootSubscription = callback;
      } else if (makeRoot === true) {
        this.subscriptions.add(this.rootSubscription);
        this.rootSubscription = callback;
      } else {
        this.subscriptions.add(callback);
      }

      this.onSubscriptionChange();

      return {
        unsubscribe: () => {
          this.unsubscribe(callback);
        }};
    }

    unsubscribe(callback) {
      if (this.subscriptions.has(callback)) {
        this.subscriptions.delete(callback);
        this.onSubscriptionChange();
        return undefined;
      }

      if (callback === this.rootSubscription) {
        this.rootSubscription = Array.from(this.subscriptions)[0];
        this.onSubscriptionChange();
        return undefined;
      }

      throw new Error('Not a current subscription');
    }
  }

  // romejs/events/BridgeError.ts

  class ___R$romejs$events$BridgeError_ts$default extends Error {
    constructor(message) {
      super(message);
    }
  }

  // romejs/events/BridgeEvent.ts


  function ___R$$priv$romejs$events$BridgeEvent_ts$validateDirection(event, eventDirection, bridgeType, verb) {
    if (event.direction === eventDirection && event.bridge.type === bridgeType) {
      throw new Error('The ' + eventDirection + ' event "' + event.name + '" cannot be ' + verb + ' by a ' + bridgeType + ' bridge');
    }
  }

  class ___R$romejs$events$BridgeEvent_ts$default extends ___R$romejs$events$Event_ts$default {
    constructor(opts, bridge) {
      super(opts);

      this.bridge = bridge;
      this.requestCallbacks = new Map();
      this.direction = opts.direction;
    }

    clear() {
      super.clear();
      this.requestCallbacks.clear();
    }

    end(err) {
      for (const {reject: reject} of this.requestCallbacks.values()) {
        reject(err);
      }
    }

    onSubscriptionChange() {
      ___R$$priv$romejs$events$BridgeEvent_ts$validateDirection(this, 'server->client', 'client', 'subscribed');
      ___R$$priv$romejs$events$BridgeEvent_ts$validateDirection(this, 'server<-client', 'server', 'subscribed');
      this.bridge.sendSubscriptions();
    }

    dispatchRequest(param) {
      return super.call(param);
    }

    dispatchResponse(id, data) {
      const callbacks = this.requestCallbacks.get(id);
      if (!callbacks) {
        return undefined;
      }

      this.requestCallbacks.delete(id);

      if (data.responseStatus === 'success') {
        callbacks.resolve(data.value);
      } else if (data.responseStatus === 'error') {
        callbacks.reject(this.bridge.buildError(data.value, data.metadata));
      } else {}

      if (callbacks.completed !== undefined) {
        callbacks.completed();
      }
    }

    hasSubscribers() {
      return this.bridge.listeners.has(this.name);
    }

    validateCanSend() {
      ___R$$priv$romejs$events$BridgeEvent_ts$validateDirection(this, 'server<-client', 'client', 'called');
      ___R$$priv$romejs$events$BridgeEvent_ts$validateDirection(this, 'server->client', 'server', 'called');
    }

    send(param) {
      if (!this.hasSubscribers()) {
        return undefined;
      }

      this.validateCanSend();
      this.bridge.assertAlive();
      this.bridge.sendMessage({
        type: 'request',
        event: this.name,
        param: param,
        priority: false});
    }

    async call(param, opts = {}) {
      const {priority: priority = false, timeout: timeout} = opts;
      this.validateCanSend();

      try {
        return await new Promise((resolve, reject) => {
          this.bridge.assertAlive();

          const id = this.bridge.getNextMessageId();

          let completed;
          if (timeout !== undefined) {
            const timeoutId = setTimeout(() => {
              this.requestCallbacks.delete(id);

              reject(
              new ___R$romejs$events$BridgeError_ts$default('Timeout of ' + String(timeout) + 'ms for ' + this.name + '(' + String(
              JSON.stringify(param)) + ') event exceeded'));
            }, timeout);

            completed = () => {
              clearTimeout(timeoutId);
            };
          }

          this.requestCallbacks.set(id, {
            completed: completed,
            reject: reject,
            resolve: resolve});

          this.bridge.sendMessage({
            id: id,
            event: this.name,
            param: param,
            type: 'request',
            priority: priority});
        });
      } catch (err) {
        this.onError(err);
        throw err;
      }
    }
  }

  // romejs/events/Bridge.ts


  class ___R$romejs$events$Bridge_ts$default {
    constructor(opts) {
      this.errorTransports = new Map();

      this.alive = true;
      this.type = opts.type;
      this.opts = opts;

      this.messageIdCounter = 0;
      this.events = new Map();

      this.hasHandshook = false;
      this.handshakeEvent = new ___R$romejs$events$Event_ts$default({name: 'Bridge.handshake'});
      this.endEvent = new ___R$romejs$events$Event_ts$default({name: 'Bridge.end', serial: true});

      this.listeners = new Set();

      this.prioritizedResponses = new Set();
      this.deprioritizedResponseQueue = [];

      this.postHandshakeQueue = [];

      this.heartbeatEvent = this.createEvent({
        name: 'Bridge.heartbeat',
        direction: 'server<->client'});
      this.heartbeatEvent.subscribe(() => {
        return undefined;
      });

      this.clear();
      this.init();
    }

    attachEndSubscriptionRemoval(subscription) {
      this.endEvent.subscribe(() => {
        subscription.unsubscribe();
      });
    }

    monitorHeartbeat(timeout, onExceeded) {
      this.heartbeatTimeout = setTimeout(async () => {
        try {
          await this.heartbeatEvent.call(undefined, {timeout: timeout});
          this.monitorHeartbeat(timeout, onExceeded);
        } catch (err) {
          if (err instanceof ___R$romejs$events$BridgeError_ts$default) {
            if (this.alive) {
              onExceeded();
            }
          } else {
            throw err;
          }
        }
      }, 1000);
    }

    clearPrioritization(id) {
      this.prioritizedResponses.delete(id);

      if (this.prioritizedResponses.size === 0) {
        for (const msg of this.deprioritizedResponseQueue) {
          this.sendMessage(msg);
        }
        this.deprioritizedResponseQueue = [];
      }
    }

    async handshake(opts = {}) {
      if (this.hasHandshook) {
        throw new Error('Already performed handshake');
      }

      const {timeout: timeout, second: second = false} = opts;

      if (!second) {
        this.sendMessage({
          type: 'handshake',
          first: true,
          subscriptions: this.getSubscriptions()});
      }

      const res = await this.handshakeEvent.wait(undefined, timeout);

      if (res.first) {
        this.sendMessage({
          type: 'handshake',
          first: false,
          subscriptions: this.getSubscriptions()});
      }

      this.receivedSubscriptions(res.subscriptions);

      this.hasHandshook = true;

      for (const msg of this.postHandshakeQueue) {
        this.sendMessage(msg);
      }
      this.postHandshakeQueue = [];
    }

    getSubscriptions() {
      const names = [];
      for (const event of this.events.values()) {
        if (event.hasSubscriptions()) {
          names.push(event.name);
        }
      }
      return names;
    }

    sendSubscriptions() {
      if (!this.hasHandshook) {
        return undefined;
      }

      this.sendMessage({
        type: 'subscriptions',
        names: this.getSubscriptions()});
    }

    receivedSubscriptions(names) {
      this.listeners = new Set(names);
    }

    init() {}

    clear() {
      for (const [, event] of this.events) {
        event.clear();
      }
    }

    getNextMessageId() {
      return ++this.messageIdCounter;
    }

    createEvent(opts) {
      if (this.events.has(opts.name)) {
        throw new Error('Duplicate event');
      }

      const event = new ___R$romejs$events$BridgeEvent_ts$default(opts, this);
      this.events.set(opts.name, event);
      return event;
    }

    assertAlive() {
      if (this.alive === false) {
        throw new Error('Bridge is dead');
      }
    }

    endWithError(err) {
      if (this.alive === false) {
        return undefined;
      }

      this.alive = false;

      for (const [, event] of this.events) {
        event.end(err);
      }
      this.clear();

      if (this.heartbeatTimeout !== undefined) {
        clearTimeout(this.heartbeatTimeout);
      }

      this.endEvent.send(err);
    }

    end(message = 'Connection died') {
      this.endWithError(new ___R$romejs$events$BridgeError_ts$default(message));
    }

    buildError(value, data) {
      const transport = this.errorTransports.get(value.name);
      if (transport === undefined) {
        return ___R$romejs$v8$errors_ts$createErrorFromStructure(value);
      } else {
        return transport.hydrate(value, data);
      }
    }

    buildErrorResponse(id, event, errRaw) {
      const err = errRaw instanceof Error ? errRaw : new Error(String(errRaw));

      const tranport = this.errorTransports.get(err.name);
      const metadata = tranport === undefined ? {} : tranport.serialize(err);

      return {
        id: id,
        event: event,
        type: 'response',
        responseStatus: 'error',
        value: ___R$romejs$v8$errors_ts$getErrorStructure(err),
        metadata: metadata};
    }

    addErrorTransport(name, transport) {
      this.errorTransports.set(name, transport);
    }

    sendMessage(msg) {
      if (msg.type !== 'handshake' && !this.hasHandshook) {
        this.postHandshakeQueue.push(msg);
        return;
      }

      this.assertAlive();

      if (msg.type === 'response') {
        if (this.prioritizedResponses.size > 0 &&
        !this.prioritizedResponses.has(msg.id)) {
          this.deprioritizedResponseQueue.push(msg);
          return;
        }

        if (this.prioritizedResponses.has(msg.id)) {
          this.clearPrioritization(msg.id);
        }
      }

      const {opts: opts} = this;
      opts.sendMessage(msg);
      if (opts.onSendMessage !== undefined) {
        opts.onSendMessage(msg);
      }
    }

    handleJSONMessage(str) {
      try {
        const data = JSON.parse(str);
        this.handleMessage(data);
      } catch (err) {
        if (err instanceof SyntaxError) {
          this.endWithError(
          new ___R$romejs$events$BridgeError_ts$default('Error parsing message JSON: ' + err.message));
        } else {
          this.endWithError(err);
        }
      }
    }

    handleMessage(msg) {
      try {
        this.assertAlive();

        if (msg.type === 'handshake') {
          this.handshakeEvent.send({
            subscriptions: msg.subscriptions,
            first: msg.first});
        }

        if (msg.type === 'subscriptions') {
          this.receivedSubscriptions(msg.names);
        }

        if (msg.type === 'request') {
          this.handleMessageRequest(msg);
        }

        if (msg.type === 'response') {
          this.handleMessageResponse(msg);
        }
      } catch (err) {
        this.endWithError(err);
      }
    }

    handleMessageResponse(data) {
      const {id: id, event: event} = data;
      if (id === undefined) {
        throw new Error('Expected id');
      }
      if (event === undefined) {
        throw new Error('Expected event');
      }

      const eventHandler = this.events.get(event);
      if (eventHandler === undefined) {
        throw new Error('Unknown event');
      }

      eventHandler.dispatchResponse(id, data);
    }

    handleMessageRequest(data) {
      const {id: id, event: event, param: param, priority: priority} = data;
      if (event === undefined) {
        throw new Error('Expected event in message request but received none');
      }

      const eventHandler = this.events.get(event);
      if (eventHandler === undefined) {
        throw new Error('Unknown event ' + event);
      }

      if (id === undefined) {
        eventHandler.dispatchRequest(param);
      } else {
        if (priority) {
          this.prioritizedResponses.add(id);
        }

        eventHandler.dispatchRequest(param).then(value => {
          this.sendMessage({
            event: event,
            id: id,
            type: 'response',
            responseStatus: 'success',
            value: value});
        }).catch(err => {
          this.sendMessage(this.buildErrorResponse(id, event, err));
        }).catch(err => this.endWithError(err));
      }
    }
  }

  // romejs/events/bridgeCreators.ts

  const ___R$romejs$events$bridgeCreators_ts = {
    createBridgeFromWebSocketInterface: ___R$romejs$events$bridgeCreators_ts$createBridgeFromWebSocketInterface,
    createBridgeFromBrowserWebSocket: ___R$romejs$events$bridgeCreators_ts$createBridgeFromBrowserWebSocket,
    createBridgeFromSocket: ___R$romejs$events$bridgeCreators_ts$createBridgeFromSocket,
    createBridgeFromLocal: ___R$romejs$events$bridgeCreators_ts$createBridgeFromLocal,
    createBridgeFromChildProcess: ___R$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess,
    createBridgeFromParentProcess: ___R$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess};
  const ___R$$priv$romejs$events$bridgeCreators_ts$SOCKET_LENGTH = /^(\d+)\:/;

  function ___R$$priv$romejs$events$bridgeCreators_ts$stringify(obj) {
    return JSON.stringify(obj, (key, value) => {
      const type = typeof value;

      if (value === undefined || value === null) {
        return value;
      }

      if (type === 'string' || type === 'number' || type === 'boolean') {
        return value;
      }

      if (Array.isArray(value) || value.constructor === Object) {
        return value;
      }

      throw new Error('Illegal data type not allowed in JSON: ' + ___R$romejs$pretty$format$index_ts$default(
      value) + ' in ' + ___R$romejs$pretty$format$index_ts$default(obj));
    });
  }

  function ___R$romejs$events$bridgeCreators_ts$createBridgeFromWebSocketInterface(CustomBridge, inf, opts) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: data => {
        inf.sendJSON(data);
      }}));

    const {socket: socket} = inf;

    bridge.endEvent.subscribe(() => {
      socket.end();
    });

    inf.completeFrameEvent.subscribe(frame => {
      const json = frame.payload.toString();
      bridge.handleJSONMessage(json);
    });

    socket.on('error', err => {
      bridge.endWithError(err);
    });

    socket.on('end', () => {
      bridge.end('RPC WebSocket died');
    });

    return bridge;
  }

  function ___R$romejs$events$bridgeCreators_ts$createBridgeFromBrowserWebSocket(CustomBridge, socket, opts) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: data => {
        socket.send(___R$$priv$romejs$events$bridgeCreators_ts$stringify(data));
      }}));

    bridge.endEvent.subscribe(() => {
      socket.close();
    });

    socket.onmessage = function(event) {
      bridge.handleJSONMessage(String(event.data));
    };

    socket.onclose = () => {
      bridge.end('RPC WebSocket disconnected');
    };

    return bridge;
  }

  function ___R$romejs$events$bridgeCreators_ts$createBridgeFromSocket(CustomBridge, socket, opts) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: data => {
        const serialized = ___R$$priv$romejs$events$bridgeCreators_ts$stringify(data);
        socket.write(serialized.length + ':' + serialized);
      }}));

    bridge.endEvent.subscribe(() => {
      socket.end();
    });

    let buff = '';
    let messageLength = 0;
    socket.setEncoding('utf8');
    function checkForPossibleMessage() {
      if (messageLength > 0 && buff.length >= messageLength) {
        const msg = buff.slice(0, messageLength);

        buff = buff.slice(messageLength);
        messageLength = 0;

        bridge.handleJSONMessage(msg);
      }

      if (messageLength === 0 && buff !== '') {
        const possibleLength = buff.match(___R$$priv$romejs$events$bridgeCreators_ts$SOCKET_LENGTH);
        if (possibleLength != null) {
          messageLength = Number(possibleLength[1]);

          buff = buff.slice(possibleLength[0].length);

          checkForPossibleMessage();
        }
      }
    }

    socket.on('data', chunk => {
      buff += chunk;
      checkForPossibleMessage();
    });

    socket.on('error', err => {
      bridge.endWithError(err);
    });

    socket.on('end', () => {
      bridge.end('Socket disconnected');
    });

    return bridge;
  }

  function ___R$romejs$events$bridgeCreators_ts$createBridgeFromLocal(CustomBridge, opts) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      type: 'server&client',
      sendMessage: msg => {
        bridge.handleMessage(msg);
      }}));

    return bridge;
  }

  function ___R$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess(CustomBridge, proc, opts) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: data => {
        proc.send(data);
      }}));

    bridge.endEvent.subscribe(() => {
      proc.kill();
    });

    proc.on('error', err => {
      bridge.endWithError(err);
    });

    proc.on('message', msg => {
      bridge.handleMessage(msg);
    });

    proc.on('close', () => {
      bridge.end('RPC child process died');
    });

    return bridge;
  }

  function ___R$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess(CustomBridge, opts) {
    const bridge = new CustomBridge(Object.assign({}, opts, {
      sendMessage: data => {
        if (typeof process.send === 'function') {
          process.send(data);
        } else {
          throw new Error('No process.send found');
        }
      }}));

    process.on('message', data => {
      bridge.handleMessage(data);
    });

    process.on('exit', () => {
      bridge.end('RPC self process died');
    });

    return bridge;
  }

  // romejs/events/types.ts

  const ___R$romejs$events$types_ts = {};

  // romejs/events/index.ts


  // romejs/cli-reporter/Reporter.ts

  const ___R$$priv$romejs$cli$reporter$Reporter_ts$stream = require('stream');

  let ___R$$priv$romejs$cli$reporter$Reporter_ts$remoteProgressIdCounter = 0;

  const ___R$$priv$romejs$cli$reporter$Reporter_ts$INDENT = '  ';

  class ___R$romejs$cli$reporter$Reporter_ts$default {
    constructor(opts = {}) {
      this.wrapCallback = callback => {
        const {wrapperFactory: wrapperFactory} = this;
        if (wrapperFactory === undefined) {
          return callback;
        } else {
          return wrapperFactory(callback);
        }
      };
      this.programName =
      opts.programName === undefined ? 'rome' : opts.programName;
      this.programVersion = opts.programVersion;

      this.noProgress = process.env.CI === '1';
      this.isVerbose = Boolean(opts.verbose);

      this.silent = opts.silent === true;
      this.startTime = opts.startTime === undefined ? Date.now() : opts.startTime;
      this.hasClearScreen =
      opts.hasClearScreen === undefined ? true : opts.hasClearScreen;
      this.activeElements = new Set();
      this.indentLevel = 0;
      this.indentString = '';
      this.enabled = opts.disabled === true ? 0 : 1;
      this.markupOptions =
      opts.markupOptions === undefined ? {} : opts.markupOptions;
      this.hasSpacer = false;
      this.shouldRedirectOutToErr = false;

      this.wrapperFactory = opts.wrapperFactory;

      this.remoteClientProgressBars = new Map();
      this.remoteServerProgressBars = new Map();

      this.sendRemoteServerMessage = new ___R$romejs$events$Event_ts$default({
        name: 'sendRemoteServerMessage'});
      this.sendRemoteClientMessage = new ___R$romejs$events$Event_ts$default({
        name: 'sendRemoteClientMessage'});

      this.isRemote = opts.useRemoteProgressBars === true;

      this.outStreams = new Set();
      this.errStreams = new Set();
      this.streams = new Set();

      if (opts.streams !== undefined) {
        for (const stream of opts.streams) {
          this.addStream(stream);
        }
      }
    }

    attachStdoutStreams(stdout, stderr, format) {
      const columns = stdout === undefined || stdout.columns === undefined ? ___R$romejs$cli$reporter$Reporter_ts$default.DEFAULT_COLUMNS : stdout.columns;

      if (format === undefined) {
        format = stdout !== undefined && stdout.isTTY === true ? 'ansi' : 'none';
      }

      const columnsUpdated = new ___R$romejs$events$Event_ts$default({
        name: 'columnsUpdated'});

      const outStream = {
        type: 'out',
        format: format,
        columns: columns,
        write(chunk) {
          if (stdout !== undefined) {
            stdout.write(chunk);
          }
        },
        teardown() {}};

      const errStream = Object.assign({
        type: 'error'}, outStream, {
        write(chunk) {
          if (stderr !== undefined) {
            stderr.write(chunk);
          }
        }});

      if (outStream.format === 'ansi' && stdout !== undefined) {
        const onStdoutResize = () => {
          if (stdout !== undefined && stdout.columns !== undefined) {
            const {columns: columns} = stdout;
            columnsUpdated.send(columns);
            this.setStreamColumns([outStream, errStream], columns);
          }
        };

        outStream.teardown = () => {
          stdout.off('resize', onStdoutResize);
        };

        stdout.on('resize', onStdoutResize);
      }

      this.addStream(outStream);
      this.addStream(errStream);

      return {
        columnsUpdated: columnsUpdated,
        stdout: outStream,
        stderr: errStream};
    }

    static fromProcess(opts = {}) {
      const reporter = new ___R$romejs$cli$reporter$Reporter_ts$default(Object.assign({}, opts, {
        markupOptions: Object.assign({
          cwd: ___R$romejs$path$index_ts$CWD_PATH}, opts.markupOptions)}));

      reporter.attachStdoutStreams(process.stdout, process.stderr);

      return reporter;
    }

    processRemoteClientMessage(msg) {
      if (msg.type === 'PROGRESS_CREATE') {
        this.remoteClientProgressBars.set(
        msg.id,
        this.progressLocal({}, () => {
          this.sendRemoteServerMessage.call({
            type: 'ENDED',
            id: msg.id});
        }));
        return;
      }

      let bar = this.remoteClientProgressBars.get(msg.id);
      if (bar === undefined) {
        throw new Error('Remote reporter message for progress bar ' + msg.id + ' that does not exist');
      }

      bar.processRemoteClientMessage(msg);

      if (msg.type === 'PROGRESS_END') {
        this.remoteClientProgressBars.delete(msg.id);
      }
    }

    receivedRemoteServerMessage(msg) {
      switch (msg.type) {
        case 'ENDED':
          const progress = this.remoteServerProgressBars.get(msg.id);
          if (progress !== undefined) {
            progress.end();
          }}
    }

    getMessagePrefix(stream) {
      stream;
      return '';
    }

    normalizeMessage(stream, tty, opts) {
      let msg = stream.format !== 'none' || opts.nonTTY === undefined ? tty : opts.nonTTY;

      if (opts.noPrefix !== true) {
        msg = this.getMessagePrefix(stream) + msg;
      }

      const {indentString: indentString} = this;
      if (indentString !== '' && msg !== '') {
        msg = indentString + msg.replace(/\n([^\n])/g, '\n' + indentString + '$1');
      }

      this.hasSpacer = msg === '' || msg[msg.length - 1] === '\n';

      return msg;
    }

    redirectOutToErr(should) {
      this.shouldRedirectOutToErr = should;
    }

    setStreamColumns(streams, columns) {
      for (const stream of streams) {
        if (!this.streams.has(stream)) {
          throw new Error('Trying to setStreamColumns on a stream that isn\'t attached to this Reporter');
        }

        stream.columns = columns;
      }

      for (const elem of this.activeElements) {
        elem.render();
      }
    }

    addStream(stream) {
      if (this.silent) {
        return;
      }

      this.streams.add(stream);

      if (stream.type === 'error' || stream.type === 'all') {
        this.errStreams.add(stream);
      }

      if (stream.type === 'out' || stream.type === 'all') {
        this.outStreams.add(stream);
      }
    }

    removeStream(stream) {
      if (stream.teardown !== undefined) {
        stream.teardown();
      }
      this.streams.delete(stream);
      this.outStreams.delete(stream);
      this.errStreams.delete(stream);
    }

    isEnabled(stderr) {
      return this.getStreams(stderr).size > 0;
    }

    getStreams(stderr) {
      if (this.enabled === 0) {
        return new Set();
      }

      if (this.shouldRedirectOutToErr) {
        return this.errStreams;
      }

      if (stderr) {
        return this.errStreams;
      }

      return this.outStreams;
    }

    enable() {
      let alreadyDisabled = false;

      this.enabled++;

      return () => {
        if (alreadyDisabled) {
          throw new Error('Already disabled Reporter');
        }

        this.enabled--;
        alreadyDisabled = true;
      };
    }

    teardown() {
      for (const stream of this.streams) {
        this.removeStream(stream);
      }

      for (const elem of this.activeElements) {
        elem.end();
      }
      this.activeElements.clear();
    }

    fork(opts = {}) {
      return new ___R$romejs$cli$reporter$Reporter_ts$default(Object.assign({
        streams: [...this.streams],
        verbose: this.isVerbose,
        markupOptions: this.markupOptions,
        wrapperFactory: this.wrapperFactory}, opts));
    }

    indent(callback) {
      this.indentLevel++;
      this.updateIndent();

      if (callback !== undefined) {
        callback();
        this.dedent();
      }
    }

    noIndent(callback) {
      const prevIndentLevel = this.indentLevel;
      this.indentLevel = 0;
      this.updateIndent();
      callback();
      this.indentLevel = prevIndentLevel;
      this.updateIndent();
    }

    dedent() {
      this.indentLevel--;
      this.updateIndent();
    }

    updateIndent() {
      this.indentString = ___R$$priv$romejs$cli$reporter$Reporter_ts$INDENT.repeat(this.indentLevel);
    }

    prependEmoji(stream, msg, emoji, fallback) {
      if (stream.format === 'none') {
        return emoji + ' ' + msg;
      } else {
        if (fallback === undefined) {
          return msg;
        } else {
          return fallback + ' ' + msg;
        }
      }
    }

    table(head, rawBody) {
      head = head.map(field => ___R$romejs$string$ansi$format_ts$formatAnsi.bold(___R$romejs$string$ansi$format_ts$formatAnsi.underline(field)));

      const rows = [head];
      for (const row of rawBody) {
        rows.push(
        row.map(field => {
          if (typeof field === 'number') {
            return ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(field);
          } else {
            return field;
          }
        }));
      }

      const cols = [];
      for (let i = 0; i < head.length; i++) {
        var ___R$;
        const widths = rows.map(row => ___R$romejs$string$ansi$format_ts$stripAnsi(row[i]).length);
        cols[i] = (___R$ = Math, ___R$.max.apply(___R$, [...widths]));
      }

      const builtRows = rows.map(row => {
        for (let i = 0; i < row.length; i++) {
          const field = row[i];
          const padding = cols[i] - ___R$romejs$string$ansi$format_ts$stripAnsi(field).length;

          row[i] = field + ' '.repeat(padding);
        }
        return row.join(' ');
      });

      this.logAll(builtRows.join('\n'));
    }

    verboseInspect(val) {
      if (this.isVerbose) {
        this.inspect(val);
      }
    }

    inspect(value) {
      for (const stream of this.getStreams(false)) {
        let formatted = value;

        if (typeof formatted !== 'number' && typeof formatted !== 'string') {
          formatted = ___R$romejs$pretty$format$index_ts$default(formatted, {color: stream.format === 'ansi'});
        }

        this.logOneNoMarkup(stream, String(formatted));
      }
    }

    clearLineAll() {
      for (const stream of this.getStreams(false)) {
        this.clearLineSpecific(stream);
      }
    }

    clearLineSpecific(stream) {
      stream.write(___R$romejs$string$ansi$escapes_ts$escapes.eraseLine);
      stream.write(___R$romejs$string$ansi$escapes_ts$escapes.cursorTo(0));
    }

    writeAll(msg, opts = {}) {
      for (const stream of this.getStreams(opts.stderr)) {
        this.writeSpecific(stream, msg, opts);
      }
    }

    writeSpecific(stream, msg, opts = {}) {
      if (!this.isEnabled(opts.stderr)) {
        return;
      }

      this.hasClearScreen = false;

      if (stream.format === 'ansi' && this.activeElements.size > 0) {
        this.clearLineSpecific(stream);
      }

      stream.write(msg);
    }

    getTotalTime() {
      return Date.now() - this.startTime;
    }

    clear() {
      for (const stream of this.getStreams(false)) {
        if (stream.format === 'ansi') {
          stream.write(___R$romejs$string$ansi$escapes_ts$escapes.clearScreen);
        }
      }
      this.hasClearScreen = true;
    }

    heading(text) {
      this.optionalSpacer();
      const tty = ___R$romejs$string$ansi$format_ts$formatAnsi.inverse(___R$romejs$string$ansi$format_ts$formatAnsi.bold(' ' + text + ' '));
      this.logAll(tty, {
        nonTTY: '## ' + text});
      this.spacer();
    }

    banner(command) {
      let msg = this.programName + ' ' + command;
      if (this.programVersion !== undefined) {
        msg += ' v' + this.programVersion;
      }
      this.logAll(___R$romejs$string$ansi$format_ts$formatAnsi.bold(msg), {
        nonTTY: '# ' + msg});
    }

    footer() {
      const totalTime = (this.getTotalTime() / 1000).toFixed(2);
      const msg = 'Done in ' + totalTime + 's.';
      for (const stream of this.getStreams(false)) {
        this.logOneNoMarkup(stream, this.prependEmoji(stream, msg, '\u2728'));
      }
    }

    section(title, callback) {
      this.hr('<emphasis>' + title + '</emphasis>');
      this.indent(() => {
        callback();
        this.spacer();
      });
    }

    hr(text) {
      const {hasClearScreen: hasClearScreen} = this;

      this.optionalSpacer();

      if (hasClearScreen && text === undefined) {
        return;
      }

      for (const stream of this.getStreams(false)) {
        const prefix = this.markupify(
        stream,
        text === undefined ? '' : ' ' + text + ' ');
        const prefixLength = ___R$romejs$string$ansi$format_ts$stripAnsi(prefix).length;
        const barLength = Math.max(0, stream.columns - prefixLength);
        this.logOneNoMarkup(stream, prefix + '\u2501'.repeat(barLength));
      }

      this.optionalSpacer();
    }

    step(current, total, msg) {
      if (msg.endsWith('?')) {
        msg = ___R$romejs$string$utils$removeSuffix_ts$removeSuffix(msg, '?') + '...?';
      } else {
        msg += '...';
      }

      this.logAll(___R$romejs$string$ansi$format_ts$formatAnsi.dim('[' + current + '/' + total + ']') + ' ' + msg, {
        nonTTY: '[' + current + '/' + total + '] ' + msg});
    }

    optionalSpacer() {
      if (!this.hasSpacer) {
        this.spacer();
      }
    }

    spacer() {
      this.logAll('');
    }

    stripMarkup(str) {
      return ___R$romejs$string$markup$format_ts$stripMarkupTags(str, this.markupOptions);
    }

    markupify(stream, str) {
      if (stream.format === 'ansi') {
        return ___R$romejs$string$markup$format_ts$markupToAnsi(str, this.markupOptions);
      } else if (stream.format === 'html') {
        return ___R$romejs$string$markup$format_ts$stripMarkupTags(str);
      } else {
        return ___R$romejs$string$markup$format_ts$stripMarkupTags(str);
      }
    }

    logAll(tty, opts = {}) {
      for (const stream of this.getStreams(opts.stderr)) {
        this.logOne(stream, tty, opts);
      }
    }

    logAllNoMarkup(msg, opts = {}) {
      for (const stream of this.getStreams(opts.stderr)) {
        this.logOneNoMarkup(stream, msg, opts);
      }
    }

    logOne(stream, tty, opts = {}) {
      const msg = stream.format !== 'none' || opts.nonTTY === undefined ? tty : opts.nonTTY;
      const formatted = this.markupify(stream, msg);
      this.logOneNoMarkup(stream, formatted, opts);
    }

    logOneNoMarkup(stream, tty, opts = {}) {
      if (!this.isEnabled(opts.stderr)) {
        return;
      }

      const msg = this.normalizeMessage(stream, tty, opts);
      this.writeSpecific(stream, msg + '\n', opts);
    }

    logAllWithCategory(msg, args, opts) {
      for (const stream of this.getStreams(opts.stderr)) {
        const prefix = this.getMessagePrefix(stream) + opts.prefix;

        const msgMarkup = this.markupify(stream, msg);

        let inner = ___R$romejs$cli$reporter$util_ts$interpolate(msgMarkup, args);

        if (stream.format === 'ansi') {
          const width = stream.columns;
          const allowedWidth = width - prefix.length - ___R$$priv$romejs$cli$reporter$Reporter_ts$INDENT.length * this.indentLevel;
          if (___R$romejs$string$ansi$format_ts$stripAnsi(inner).length > allowedWidth) {
            const lines = ___R$romejs$string$ansi$split_ts$splitAnsiLines(inner, allowedWidth);
            inner = String(lines.shift());

            for (const line of lines) {
              inner += '\n' + ' '.repeat(prefix.length) + line;
            }
          }
        }

        let outer = '';
        if (___R$romejs$string$ansi$format_ts$hasAnsiColor(inner)) {
          outer = inner;
          inner = prefix;
        }

        let tty = ___R$romejs$string$ansi$format_ts$formatAnsi.bold(opts.format(prefix)) + opts.format(inner) + outer;
        let nonTTY = prefix + inner + outer;
        if (opts.suffix !== undefined) {
          tty += opts.format(___R$romejs$string$ansi$format_ts$formatAnsi.bold(opts.suffix));
          nonTTY += opts.suffix;
        }

        this.logOneNoMarkup(stream, tty, Object.assign({
          nonTTY: nonTTY,

          noPrefix: true}, opts));
      }
    }

    success(msg, ...args) {
      this.logAllWithCategory(msg, args, {
        prefix: '\u2714 ',
        format: ___R$romejs$string$ansi$format_ts$formatAnsi.green});
    }

    error(msg, ...args) {
      this.logAllWithCategory(msg, args, {
        format: ___R$romejs$string$ansi$format_ts$formatAnsi.red,
        prefix: '\u2716 ',
        stderr: true});
    }

    errorObj(err) {
      this.error(err.stack || err.message || err.name || 'Unknown Error');
    }

    question(msg, ...args) {
      this.logAllWithCategory(msg, args, {
        prefix: '\u2753 ',
        format: ___R$romejs$string$ansi$format_ts$formatAnsi.magenta});
    }

    info(msg, ...args) {
      this.logAllWithCategory(msg, args, {
        prefix: '\u2139 ',
        format: ___R$romejs$string$ansi$format_ts$formatAnsi.blue});
    }

    warn(msg, ...args) {
      this.logAllWithCategory(msg, args, {
        prefix: '\u26a0 ',
        suffix: ' \u26a0',
        format: ___R$romejs$string$ansi$format_ts$formatAnsi.yellow,
        stderr: true});
    }

    verbose(msg, ...args) {
      if (this.isVerbose) {
        this.verboseForce(msg, args);
      }
    }

    verboseForce(msg, ...args) {
      this.logAllWithCategory(msg, args, {
        prefix: '\u26a1 ',
        format: ___R$romejs$string$ansi$format_ts$formatAnsi.brightBlack});
    }

    command(command) {
      for (const stream of this.getStreams(false)) {
        this.logOneNoMarkup(stream, ___R$romejs$string$ansi$format_ts$formatAnsi.dim('$ ' + command), {
          nonTTY: '$ ' + command});
      }
    }

    _getListIndentation() {
      return this.indentLevel === 0 ? '  ' : '';
    }

    processedList(items, callback, opts = {}) {
      if (items.length === 0) {
        return;
      }

      const indent = this._getListIndentation();

      let tuples;
      if (opts.reverse === true) {
        tuples = items.reverse().map((item, i) => [items.length - i, item]);
      } else {
        tuples = items.map((item, i) => [i, item]);
      }

      let truncatedCount = 0;
      if (opts.truncate !== undefined) {
        tuples = tuples.slice(0, opts.truncate);
        truncatedCount = items.length - tuples.length;
      }

      let indentLength = indent.length;

      if (opts.ordered) {
        const highestVisible = Math.max(
        tuples[0][0],
        tuples[tuples.length - 1][0]);

        const numLen = ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(highestVisible + 1).length + 1;

        indentLength += numLen + 1;

        for (const [index, item] of tuples) {
          callback(item, str => {
            const num = ___R$romejs$string$ansi$pad_ts$rightPad(___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(index + 1) + '.', numLen);
            this.logAll('' + indent + ___R$romejs$string$ansi$format_ts$formatAnsi.dim(num) + ' ' + str, {
              nonTTY: '' + indent + num + ' ' + str});
          });
        }
      } else {
        indentLength += 2;

        for (const [, item] of tuples) {
          callback(item, str => {
            this.logAll('' + indent + ___R$romejs$string$ansi$format_ts$formatAnsi.dim('-') + ' ' + str, {
              nonTTY: indent + '- ' + str});
          });
        }
      }

      if (truncatedCount > 0) {
        const indent = ' '.repeat(indentLength);
        this.logAll(indent + 'and <number>' + truncatedCount + '</number> others...');
      }
    }

    list(items, opts = {}) {
      this.processedList(items, (str, display) => display(str), opts);
    }

    progress(opts) {
      if (this.isRemote) {
        return this.progressRemote(opts);
      } else {
        return this.progressLocal(opts);
      }
    }

    progressLocal(opts, onEnd) {
      const bar = new ___R$romejs$cli$reporter$Progress_ts$default(this, opts, () => {
        this.activeElements.delete(bar);
        if (onEnd !== undefined) {
          onEnd();
        }
      });
      this.activeElements.add(bar);
      return bar;
    }

    progressRemote(opts) {
      const id = process.pid + ':' + ___R$$priv$romejs$cli$reporter$Reporter_ts$remoteProgressIdCounter++;

      this.sendRemoteClientMessage.send({
        type: 'PROGRESS_CREATE',
        opts: opts,
        id: id});

      let closed = false;

      const dispatch = message => {
        if (!closed) {
          this.sendRemoteClientMessage.send(message);
        }
      };

      const end = () => {
        this.activeElements.delete(progress);
        this.remoteServerProgressBars.delete(id);
        closed = true;
      };

      const progress = {
        render() {},

        setCurrent: current => {
          dispatch({
            type: 'PROGRESS_SET_CURRENT',
            current: current,
            id: id});
        },

        setTotal: (total, approximate = false) => {
          dispatch({
            type: 'PROGRESS_SET_TOTAL',
            total: total,
            approximate: approximate,
            id: id});
        },

        setTitle: title => {
          dispatch({
            type: 'PROGRESS_SET_TITLE',
            title: title,
            id: id});
        },

        setText: text => {
          dispatch({
            type: 'PROGRESS_SET_TEXT',
            text: text,
            id: id});
        },

        setApproximateETA: duration => {
          dispatch({
            type: 'PROGRESS_SET_APPROXIMATE_ETA',
            duration: duration,
            id: id});
        },

        pushText: text => {
          dispatch({
            type: 'PROGRESS_PUSH_TEXT',
            text: text,
            id: id});
        },

        popText: text => {
          dispatch({
            type: 'PROGRESS_POP_TEXT',
            text: text,
            id: id});
        },

        tick: () => {
          dispatch({
            type: 'PROGRESS_TICK',
            id: id});
        },

        end: () => {
          dispatch({
            type: 'PROGRESS_END',
            id: id});
        },

        pause: () => {
          dispatch({
            type: 'PROGRESS_PAUSE',
            id: id});
        },

        resume: () => {
          dispatch({
            type: 'PROGRESS_RESUME',
            id: id});
        }};

      this.remoteServerProgressBars.set(id, {
        end: end});

      this.activeElements.add(progress);

      return progress;
    }
  }
  ___R$romejs$cli$reporter$Reporter_ts$default.DEFAULT_COLUMNS = 100;

  // romejs/cli-reporter/types.ts

  const ___R$romejs$cli$reporter$types_ts = {};

  // romejs/cli-reporter/index.ts


  // romejs/cli-diagnostics/ansiHighlightCode.ts


  function ___R$romejs$cli$diagnostics$ansiHighlightCode_ts$default(opts) {
    if (opts.language === 'js') {
      return ___R$$priv$romejs$cli$diagnostics$ansiHighlightCode_ts$ansiHighlightJS(
      opts.input,
      opts.sourceType === 'unknown' ? 'script' : opts.sourceType);
    }

    if (opts.language === 'json') {
      return ___R$$priv$romejs$cli$diagnostics$ansiHighlightCode_ts$ansiHighlightJSON(opts.path, opts.input);
    }

    return opts.input;
  }

  function ___R$$priv$romejs$cli$diagnostics$ansiHighlightCode_ts$reduce(input, tokens, callback) {
    let prevEnd = 0;
    let buff = '';

    for (const token of tokens) {
      const start = ___R$romejs$ob1$index_ts$get0(token.start);
      const end = ___R$romejs$ob1$index_ts$get0(token.end);
      let value = input.slice(start, end);

      buff += input.slice(prevEnd, start);
      prevEnd = end;

      const lines = value.split('\n');

      const values = lines.map(line => {
        return callback(token, line);
      });

      buff += values.join('\n');
    }

    return buff;
  }

  function ___R$$priv$romejs$cli$diagnostics$ansiHighlightCode_ts$invalidHighlight(line) {
    return ___R$romejs$string$ansi$format_ts$formatAnsi.bold(___R$romejs$string$ansi$format_ts$formatAnsi.bgRed(line));
  }

  function ___R$$priv$romejs$cli$diagnostics$ansiHighlightCode_ts$ansiHighlightJSON(path, input) {
    const tokens = ___R$romejs$codec$json$index_ts$tokenizeJSON({
      input: input,

      path: path});

    return ___R$$priv$romejs$cli$diagnostics$ansiHighlightCode_ts$reduce(input, tokens, (token, line) => {
      switch (token.type) {
        case 'BlockComment':
        case 'LineComment':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.brightBlack(line);

        case 'String':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.green(line);

        case 'Number':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.magenta(line);

        case 'Word':
          switch (token.value) {
            case 'true':
            case 'false':
            case 'null':
              return ___R$romejs$string$ansi$format_ts$formatAnsi.cyan(line);

            default:
              return line;}

        case 'Comma':
        case 'Colon':
        case 'Dot':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.yellow(line);

        case 'BracketOpen':
        case 'BracketClose':
        case 'BraceOpen':
        case 'BraceClose':
        case 'Minus':
        case 'Plus':
          return line;

        case 'Invalid':
          return ___R$$priv$romejs$cli$diagnostics$ansiHighlightCode_ts$invalidHighlight(line);

        case 'EOF':
        case 'SOF':
          return '';}
    });
  }

  function ___R$$priv$romejs$cli$diagnostics$ansiHighlightCode_ts$ansiHighlightJS(input, sourceType) {
    const tokens = ___R$romejs$js$parser$index_ts$tokenizeJS(input, {
      sourceType: sourceType,

      path: ___R$romejs$path$index_ts$createUnknownFilePath('unknown')});

    return ___R$$priv$romejs$cli$diagnostics$ansiHighlightCode_ts$reduce(input, tokens, (token, line) => {
      const {type: type} = token;

      switch (type.label) {
        case 'break':
        case 'case':
        case 'catch':
        case 'continue':
        case 'debugger':
        case 'default':
        case 'do':
        case 'else':
        case 'finally':
        case 'for':
        case 'function':
        case 'if':
        case 'return':
        case 'switch':
        case 'throw':
        case 'try':
        case 'var':
        case 'const':
        case 'while':
        case 'with':
        case 'new':
        case 'this':
        case 'super':
        case 'class':
        case 'extends':
        case 'export':
        case 'import':
        case 'null':
        case 'true':
        case 'false':
        case 'in':
        case 'instanceof':
        case 'typeof':
        case 'void':
        case 'delete':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.cyan(line);

        case 'num':
        case 'bigint':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.magenta(line);

        case 'regexp':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.magenta(line);

        case 'string':
        case 'template':
        case '`':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.green(line);

        case 'invalid':
          return ___R$$priv$romejs$cli$diagnostics$ansiHighlightCode_ts$invalidHighlight(line);

        case 'comment':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.brightBlack(line);

        case ',':
        case ';':
        case ':':
        case '::':
        case '${':
        case '.':
        case '?':
        case '?.':
          return ___R$romejs$string$ansi$format_ts$formatAnsi.yellow(line);

        case '[':
        case ']':
        case '{':
        case '{|':
        case '}':
        case '|}':
        case '(':
        case ')':
          return line;

        case '=>':
        case '...':
        case '@':
        case '#':
        case '=':
        case '_=':
        case '++/--':
        case '!':
        case '~':
        case '??':
        case '||':
        case '&&':
        case '|':
        case '^':
        case '&':
        case '==/!=':
        case '</>':
        case '<</>>':
        case '+/-':
        case '%':
        case '*':
        case '/':
        case '**':
        case 'jsxName':
        case 'jsxText':
        case 'jsxTagStart':
        case 'jsxTagEnd':
        case 'name':
        case 'eof':
          return line;}
    });
  }

  // romejs/cli-diagnostics/utils.ts

  function ___R$romejs$cli$diagnostics$utils_ts$showInvisibles(str) {
    let ret = '';
    for (const cha of str) {
      switch (cha) {
        case ' ':
          ret += '\xb7';
          break;
        case '\n':
          ret += '\u23ce\n';
          break;
        case '\t':
          ret += '\u21b9';
          break;
        default:
          ret += cha;
          break;}
    }
    return ret;
  }

  function ___R$romejs$cli$diagnostics$utils_ts$cleanEquivalentString(str) {
    str = ___R$romejs$string$ansi$format_ts$stripAnsi(str);

    str = str.replace(/[\s\n]+/g, ' ');

    str = str.replace(/\.+$/, '');

    str = str.replace(/^"(.*?)"$/, '$1');

    return str;
  }

  function ___R$romejs$cli$diagnostics$utils_ts$splitLines(src) {
    return src.replace(/\t/g, ' ').split(___R$romejs$js$parser$utils$whitespace_ts$NEWLINE);
  }

  function ___R$romejs$cli$diagnostics$utils_ts$toLines(opts) {
    const highlighted = ___R$romejs$cli$diagnostics$ansiHighlightCode_ts$default(opts);
    const lines = ___R$romejs$cli$diagnostics$utils_ts$splitLines(highlighted);
    return lines;
  }

  // romejs/cli-diagnostics/constants.ts

  const ___R$romejs$cli$diagnostics$constants_ts = {
    get GUTTER() {
      return ___R$romejs$cli$diagnostics$constants_ts$GUTTER;
    },
    get CODE_FRAME_INDENT() {
      return ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT;
    },
    get CODE_FRAME_SELECTED_INDENT() {
      return ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT;
    },
    get FILENAME_INDENT() {
      return ___R$romejs$cli$diagnostics$constants_ts$FILENAME_INDENT;
    },
    get MAX_CODE_FRAME_LINES() {
      return ___R$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES;
    },
    get HALF_MAX_CODE_FRAME_LINES() {
      return ___R$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES;
    },
    get CODE_FRAME_CONTEXT_LINES() {
      return ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES;
    }};
  const ___R$romejs$cli$diagnostics$constants_ts$GUTTER = ' \u2502 ';
  const ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT = '  ';
  const ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT = ___R$romejs$string$ansi$format_ts$formatAnsi.red('>') + ' ';
  const ___R$romejs$cli$diagnostics$constants_ts$FILENAME_INDENT = '  ';

  const ___R$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES = 8;
  const ___R$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES = ___R$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES / 2;
  const ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES = 2;

  // romejs/cli-diagnostics/buildPatchCodeFrame.ts

  function ___R$$priv$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(diffs) {
    return diffs.map(([type, text]) => {
      if (type === ___R$romejs$string$diff$index_ts$constants.DELETE) {
        return ___R$romejs$string$ansi$format_ts$formatAnsi.red(___R$romejs$cli$diagnostics$utils_ts$showInvisibles(text));
      } else if (type === ___R$romejs$string$diff$index_ts$constants.ADD) {
        return ___R$romejs$string$ansi$format_ts$formatAnsi.green(___R$romejs$cli$diagnostics$utils_ts$showInvisibles(text));
      } else {
        return text;
      }
    }).join('');
  }

  const ___R$$priv$romejs$cli$diagnostics$buildPatchCodeFrame_ts$DELETE_MARKER = ___R$romejs$string$ansi$format_ts$formatAnsi.red('-');
  const ___R$$priv$romejs$cli$diagnostics$buildPatchCodeFrame_ts$ADD_MARKER = ___R$romejs$string$ansi$format_ts$formatAnsi.green('+');

  function ___R$romejs$cli$diagnostics$buildPatchCodeFrame_ts$default(rawDiffs) {
    const diffsByLine = ___R$romejs$string$diff$index_ts$groupDiffByLines(rawDiffs);
    let lastVisibleLine = -1;

    const shownLines = new Set();
    for (let i = 0; i < diffsByLine.length; i++) {
      const diffs = diffsByLine[i];

      let hasChange = false;
      for (const [type] of diffs) {
        if (type === ___R$romejs$string$diff$index_ts$constants.DELETE || type === ___R$romejs$string$diff$index_ts$constants.ADD) {
          hasChange = true;
          break;
        }
      }

      if (hasChange) {
        for (let start = i - ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES; start < i + ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES; start++) {
          shownLines.add(start);

          if (start > lastVisibleLine) {
            lastVisibleLine = start;
          }
        }
      }
    }

    const lineLength = String(lastVisibleLine).length;

    const noGutter = diffsByLine.length === 1;

    const frame = [];
    let lastDisplayedLine = -1;
    for (let i = 0; i < diffsByLine.length; i++) {
      if (shownLines.has(i) === false) {
        continue;
      }

      const diffs = diffsByLine[i];
      const lineNo = i + 1;

      if (noGutter) {
        frame.push('  ' + ___R$$priv$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(diffs));
        lastDisplayedLine = lineNo;
        continue;
      }

      const deletions = [];
      const addition = [];

      let hasDeletions = false;
      let hasAddition = false;

      for (const tuple of diffs) {
        let [type] = tuple;

        if (type === ___R$romejs$string$diff$index_ts$constants.DELETE) {
          hasDeletions = true;
          deletions.push(tuple);
        }

        if (type === ___R$romejs$string$diff$index_ts$constants.ADD) {
          hasAddition = true;
          addition.push(tuple);
        }

        if (type === ___R$romejs$string$diff$index_ts$constants.EQUAL) {
          addition.push(tuple);
          deletions.push(tuple);
        }
      }

      if (lastDisplayedLine !== lineNo - 1 && lastDisplayedLine !== -1) {
        frame.push(
        ___R$romejs$string$ansi$format_ts$formatAnsi.bold(___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT + '.'.repeat(lineLength) + ___R$romejs$cli$diagnostics$constants_ts$GUTTER));
      }

      const gutter = ___R$romejs$string$ansi$format_ts$formatAnsi.bold(
      ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT + ___R$romejs$string$ansi$pad_ts$leftPad(String(lineNo), lineLength) + ___R$romejs$cli$diagnostics$constants_ts$GUTTER);

      if (hasAddition) {
        frame.push(gutter + ___R$$priv$romejs$cli$diagnostics$buildPatchCodeFrame_ts$ADD_MARKER + ' ' + ___R$$priv$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(addition));
      }

      if (hasDeletions) {
        frame.push(gutter + ___R$$priv$romejs$cli$diagnostics$buildPatchCodeFrame_ts$DELETE_MARKER + ' ' + ___R$$priv$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(deletions));
      }

      if (!hasAddition && !hasDeletions) {
        frame.push(gutter + '  ' + ___R$$priv$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(addition));
      }

      lastDisplayedLine = lineNo;
    }

    return frame.join('\n');
  }

  // romejs/cli-diagnostics/buildMessageCodeFrame.ts

  function ___R$romejs$cli$diagnostics$buildMessageCodeFrame_ts$default(allLines, start, end, maybeMarkerMessage) {
    let markerMessage = maybeMarkerMessage === undefined ? '' : maybeMarkerMessage;

    const startLineIndex = ___R$romejs$ob1$index_ts$coerce1to0(start.line);

    let endLineIndex = ___R$romejs$ob1$index_ts$coerce1to0(end.line);
    let endLineCol = end.column;

    let markerOffset = end.column;
    let markerSize = ___R$romejs$ob1$index_ts$number0;

    let contextStartIndex = ___R$romejs$ob1$index_ts$coerce0(
    Math.max(0, ___R$romejs$ob1$index_ts$get0(startLineIndex) - ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES));
    let contextEndIndex = ___R$romejs$ob1$index_ts$coerce0(
    Math.min(
    allLines.length - 1,
    ___R$romejs$ob1$index_ts$get0(endLineIndex) + ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES));

    let formattedLines = [];
    for (let i = contextStartIndex; i <= contextEndIndex; i = ___R$romejs$ob1$index_ts$inc(i)) {
      let line = allLines[___R$romejs$ob1$index_ts$get0(i)];
      if (line === undefined) {
        continue;
      }

      if (line.trim() === '' &&
      formattedLines.length === 0 &&
      i !== startLineIndex) {
        continue;
      }

      const shouldHighlight = i >= startLineIndex && i <= endLineIndex;

      if (shouldHighlight) {
        let startCol = ___R$romejs$ob1$index_ts$number0;
        let endCol = ___R$romejs$ob1$index_ts$coerce0(line.length);

        if (i === startLineIndex) {
          startCol = start.column;
        }

        if (i === endLineIndex) {
          endCol = endLineCol;

          if (endCol > startCol) {
            markerSize = ___R$romejs$ob1$index_ts$sub(endCol, startCol);
            markerOffset = ___R$romejs$ob1$index_ts$sub(markerOffset, markerSize);
          }
        }
      }

      const lineNo = ___R$romejs$ob1$index_ts$coerce0to1(i);
      let gutter = '' + String(lineNo) + ___R$romejs$cli$diagnostics$constants_ts$GUTTER;

      if (shouldHighlight) {
        gutter = '' + ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT + gutter;
      } else {
        gutter = '' + ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT + gutter;
      }

      formattedLines.push({
        gutter: gutter,
        line: ___R$romejs$string$markup$escape_ts$escapeMarkup(line),
        lineIndex: i});
    }

    if (formattedLines.length === 0 ||
    end.line === ___R$romejs$ob1$index_ts$number1Neg1 ||
    start.line === ___R$romejs$ob1$index_ts$number1Neg1) {
      return ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT + markerMessage;
    }

    const pruned = formattedLines.length > ___R$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES + 2;
    if (pruned) {
      const start = formattedLines.slice(0, ___R$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES);
      const end = formattedLines.slice(-___R$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES);
      formattedLines = start.concat([undefined], end);
    }

    for (let i = formattedLines.length - 1; i >= 0; i--) {
      const info = formattedLines[i];
      if (info !== undefined && info.line === '') {
        formattedLines.pop();
      } else {
        break;
      }
    }

    const noGutter = allLines.length === 1;

    const lastLine = formattedLines[formattedLines.length - 1];
    if (lastLine === undefined) {
      throw new Error('Expected there to be a last line');
    }

    const maxVisibleLineNo = ___R$romejs$ob1$index_ts$get0(lastLine.lineIndex) + 1;
    const maxGutterLength = String(maxVisibleLineNo).length + ___R$romejs$cli$diagnostics$constants_ts$GUTTER.length + ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT.length;

    if (markerMessage !== '' && start.line === end.line) {
      const markerLine = ___R$romejs$string$ansi$format_ts$stripAnsi(allLines[___R$romejs$ob1$index_ts$get0(___R$romejs$ob1$index_ts$coerce1to0(start.line))]);
      const text = markerLine.slice(___R$romejs$ob1$index_ts$get0(start.column), ___R$romejs$ob1$index_ts$get0(end.column));
      if (___R$romejs$cli$diagnostics$utils_ts$cleanEquivalentString(text) === ___R$romejs$cli$diagnostics$utils_ts$cleanEquivalentString(markerMessage)) {
        markerMessage = '';
      }
    }

    const pointerLength = Math.max(___R$romejs$ob1$index_ts$get0(markerSize), 1);
    const pointer = ___R$romejs$string$ansi$format_ts$formatAnsi.red(
    ___R$romejs$string$ansi$format_ts$formatAnsi.bold('^'.repeat(pointerLength)));
    const pointerIndent = ' '.repeat(___R$romejs$ob1$index_ts$get0(markerOffset));

    const noMarkerLine = ___R$romejs$ob1$index_ts$get0(markerOffset) === 0 && pointerLength === 1 && markerMessage === '';

    if (noGutter) {
      const result = [...allLines].map(line => ___R$romejs$string$markup$escape_ts$escapeMarkup(line));
      if (!noMarkerLine) {
        result.push('' + pointerIndent + pointer + ' ' + markerMessage);
      }
      return ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT + result.join('\n' + ___R$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT);
    }

    const markerGutterIndent = ' '.repeat(
    maxGutterLength - ___R$romejs$cli$diagnostics$constants_ts$GUTTER.length);
    const markerLine = '' + markerGutterIndent + ___R$romejs$string$ansi$format_ts$formatAnsi.bold(
    ___R$romejs$cli$diagnostics$constants_ts$GUTTER) + pointerIndent + pointer + ' ' + markerMessage;

    const omittedDots = '...';
    const omittedLine = ___R$romejs$string$ansi$pad_ts$leftPad(
    ___R$romejs$string$ansi$format_ts$formatAnsi.bold(omittedDots) + ___R$romejs$cli$diagnostics$constants_ts$GUTTER,
    maxGutterLength);

    const result = [];
    for (const selection of formattedLines) {
      if (!selection) {
        result.push(omittedLine);
        continue;
      }

      const {gutter: gutter, line: line, lineIndex: lineIndex} = selection;

      if (noGutter) {
        result.push(line);
      } else {
        result.push(___R$romejs$string$ansi$format_ts$formatAnsi.bold(___R$romejs$string$ansi$pad_ts$leftPad(gutter, maxGutterLength)) + line);
      }
      if (lineIndex === endLineIndex && !noMarkerLine) {
        result.push(markerLine);
      }
    }

    const frame = result.join('\n');
    return frame;
  }

  // romejs/cli-diagnostics/printAdvice.ts


  function ___R$romejs$cli$diagnostics$printAdvice_ts$default(item, opts) {
    switch (item.type) {
      case 'log':
        return ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printLog(item, opts);

      case 'list':
        return ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printList(item, opts);

      case 'diff':
        return ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printDiff(item, opts);

      case 'code':
        return ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printCode(item, opts);

      case 'frame':
        return ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printFrame(item, opts);

      case 'stacktrace':
        return ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printStacktrace(item, opts);

      case 'action':
        return ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printAction(item, opts);

      case 'inspect':
        return ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printInspect(item, opts);}
  }

  function ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printInspect(item, opts) {
    const {reporter: reporter} = opts;
    reporter.indent();
    reporter.inspect(item.data);
    reporter.dedent();
    return false;
  }

  function ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printDiff(item, opts) {
    const frame = ___R$romejs$cli$diagnostics$buildPatchCodeFrame_ts$default(item.diff);
    if (frame === '') {
      return true;
    }

    opts.reporter.logAll(___R$romejs$string$markup$escape_ts$escapeMarkup(frame));
    return false;
  }

  function ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printList(item, opts) {
    if (item.list.length === 0) {
      return true;
    } else {
      opts.reporter.list(item.list, {
        truncate: opts.flags.verboseDiagnostics ? undefined : item.truncate,
        reverse: item.reverse,
        ordered: item.ordered});
      return false;
    }
  }

  function ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printCode(item, opts) {
    const {reporter: reporter} = opts;
    const {code: code} = item;
    reporter.indent();
    reporter.logAll(___R$romejs$string$markup$escape_ts$escapeMarkup(code));
    reporter.dedent();
    return false;
  }

  function ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printFrame(item, opts) {
    const {reporter: reporter} = opts;
    const {start: start, end: end, filename: filename, sourceText: sourceText, marker: marker} = item;

    let cleanMarker = '';
    if (marker !== undefined) {
      cleanMarker = ___R$romejs$string$ansi$format_ts$formatAnsi.bold(___R$$priv$romejs$cli$diagnostics$printAdvice_ts$cleanMessage(marker));
    }

    let lines;
    if (sourceText !== undefined) {
      lines = ___R$romejs$cli$diagnostics$utils_ts$toLines({
        path: ___R$romejs$path$index_ts$createUnknownFilePath(filename),
        input: sourceText,
        sourceType: item.sourceType,
        language: item.language});
    } else if (filename !== undefined) {
      lines = opts.fileSources.get(filename);
    }
    if (lines === undefined) {
      lines = [];
    }

    const frame = ___R$romejs$cli$diagnostics$buildMessageCodeFrame_ts$default(lines, start, end, cleanMarker);
    if (frame.trim() === '') {
      return true;
    }

    reporter.logAll(___R$romejs$string$markup$escape_ts$escapeMarkup(frame));
    return false;
  }

  function ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printAction(item, opts) {
    const {reporter: reporter} = opts;
    reporter.logAll('<bold>' + item.message + '</bold>');
    reporter.logAll('You have the following choices:');
    reporter.list(
    item.buttons.map(button => {
      return button.text + ': `' + button.command + '`';
    }));
    return false;
  }

  function ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printStacktrace(item, opts) {
    const {diagnostic: diagnostic} = opts;
    const {frames: frames} = item;

    let shownCodeFrames = 0;

    const isFirstPart = diagnostic.advice[0] === item;
    if (!isFirstPart) {
      opts.reporter.info(item.title === undefined ? 'Stack trace' : item.title);
      opts.reporter.spacer();
    }

    opts.reporter.processedList(
    frames,
    (frame, display) => {
      const {
        filename: filename,
        object: object,
        suffix: suffix,
        property: property,
        prefix: prefix,
        line: line,
        column: column,
        language: language,
        sourceText: code} = frame;

      const logParts = [];

      if (prefix !== undefined) {
        logParts.push(___R$romejs$string$ansi$format_ts$formatAnsi.dim(___R$romejs$string$markup$escape_ts$escapeMarkup(prefix)));
      }

      const objParts = [];
      if (object !== undefined) {
        objParts.push(___R$romejs$string$ansi$format_ts$formatAnsi.magenta(___R$romejs$string$markup$escape_ts$escapeMarkup(object)));
      }
      if (property !== undefined) {
        objParts.push(___R$romejs$string$ansi$format_ts$formatAnsi.cyan(___R$romejs$string$markup$escape_ts$escapeMarkup(property)));
      }
      if (objParts.length > 0) {
        logParts.push(objParts.join('.'));
      }

      if (suffix !== undefined) {
        logParts.push(___R$romejs$string$ansi$format_ts$formatAnsi.green(___R$romejs$string$markup$escape_ts$escapeMarkup(suffix)));
      }

      if (filename !== undefined &&
      line !== undefined &&
      column !== undefined) {
        const header = ___R$romejs$diagnostics$derive_ts$getDiagnosticHeader({
          filename: filename,
          start: {
            index: ___R$romejs$ob1$index_ts$number0Neg1,
            line: line,
            column: column}});

        if (logParts.length === 0) {
          logParts.push(header);
        } else {
          logParts.push('(' + ___R$romejs$string$ansi$format_ts$formatAnsi.dim(header) + ')');
        }
      }

      display(logParts.join(' '));

      if (shownCodeFrames < 2 &&
      filename !== undefined &&
      line !== undefined &&
      column !== undefined) {
        const pos = {
          index: ___R$romejs$ob1$index_ts$number0Neg1,
          line: line,
          column: column};

        const skipped = ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printFrame(
        {
          type: 'frame',
          language: language,
          filename: filename,
          sourceType: 'module',
          marker: undefined,
          mtime: undefined,
          start: pos,
          end: pos,
          sourceText: code},
        opts);
        if (!skipped) {
          opts.reporter.spacer();
          shownCodeFrames++;
        }
      }
    },
    {
      ordered: true,
      truncate: item.truncate});

    return false;
  }

  function ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$printLog(item, opts) {
    const {reporter: reporter} = opts;
    const {message: message, category: category} = item;

    if (message !== undefined) {
      switch (category) {
        case 'none':
          reporter.logAll(message);
          break;

        case 'warn':
          reporter.warn(message);
          break;

        case 'info':
          reporter.info(message);
          break;

        case 'question':
          reporter.question(message);
          break;

        case 'error':
          reporter.error(message);
          break;

        default:
          throw new Error('Unknown message item log category ' + category);}
    }

    return item.compact;
  }

  function ___R$$priv$romejs$cli$diagnostics$printAdvice_ts$cleanMessage(msg) {
    msg = msg.trim();
    if (msg.endsWith('.')) {
      msg = msg.slice(0, -1);
    }
    return msg;
  }

  // romejs/cli-diagnostics/banners/success.json

  const ___R$romejs$cli$diagnostics$banners$success_json$default = {'palettes': [[240, 240, 240], [240, 240, 225], [225, 225, 210], [225, 210, 210], [240, 225, 225], [210, 210, 195], [210, 195, 180], [195, 195, 165], [195, 180, 165], [225, 210, 195], [195, 195, 180], [225, 225, 225], [180, 180, 150], [180, 165, 150], [195, 180, 150], [195, 165, 150], [180, 165, 135], [180, 150, 135], [195, 165, 135], [225, 225, 195], [210, 210, 180], [210, 180, 150], [210, 180, 165], [225, 180, 180], [240, 180, 165], [240, 195, 195], [225, 195, 180], [165, 135, 120], [165, 150, 120], [195, 135, 120], [225, 150, 135], [240, 165, 165], [225, 180, 165], [225, 195, 165], [150, 120, 105], [150, 135, 105], [180, 150, 120], [195, 120, 105], [210, 135, 105], [210, 150, 120], [195, 150, 135], [210, 195, 165], [180, 105, 75], [195, 105, 90], [180, 90, 75], [240, 180, 180], [240, 225, 210], [240, 240, 210], [150, 120, 90], [180, 135, 120], [210, 150, 135], [210, 165, 150], [195, 150, 120], [225, 180, 150], [195, 120, 90], [180, 105, 90], [225, 165, 135], [225, 210, 180], [240, 210, 195], [225, 195, 195], [180, 135, 105], [225, 180, 135], [210, 135, 120], [225, 165, 150], [240, 180, 150], [210, 180, 180], [165, 135, 90], [180, 120, 90], [195, 135, 105], [225, 150, 120], [180, 135, 135], [210, 150, 150], [210, 195, 195], [210, 195, 210], [150, 135, 135], [195, 195, 195], [225, 210, 225], [180, 180, 135], [165, 120, 90], [240, 150, 135], [240, 165, 135], [240, 165, 150], [180, 90, 60], [180, 165, 165], [165, 135, 135], [180, 180, 180], [165, 150, 135], [150, 90, 45], [150, 75, 45], [210, 165, 135], [165, 165, 165], [165, 120, 75], [180, 135, 90], [150, 60, 45], [165, 105, 60], [165, 90, 60], [150, 105, 105], [210, 210, 210], [165, 105, 75], [225, 165, 165], [180, 120, 75], [165, 90, 75], [135, 90, 75], [195, 180, 180], [240, 195, 180], [135, 120, 120], [165, 135, 105], [150, 105, 75], [225, 150, 150], [240, 210, 180], [165, 150, 150], [165, 150, 105], [225, 135, 120], [210, 120, 105], [150, 90, 75], [180, 120, 105], [180, 150, 105], [240, 195, 165], [180, 165, 120], [225, 135, 135], [180, 105, 105], [195, 120, 120], [150, 75, 60], [105, 15, 15], [105, 15, 0], [120, 30, 30], [120, 30, 15], [105, 45, 30], [150, 90, 60], [210, 120, 120], [165, 75, 75], [90, 30, 30], [90, 15, 15], [120, 15, 30], [120, 15, 15], [90, 0, 0], [135, 45, 45], [165, 105, 90], [210, 105, 90], [135, 75, 45], [240, 210, 210], [225, 240, 225], [60, 30, 15], [45, 0, 0], [60, 15, 15], [75, 30, 15], [120, 60, 60], [195, 90, 75], [150, 45, 45], [75, 0, 15], [60, 0, 0], [75, 0, 0], [150, 105, 60], [135, 90, 45], [60, 45, 30], [105, 30, 30], [120, 15, 0], [150, 75, 75], [120, 105, 90], [105, 60, 45], [120, 75, 45], [60, 15, 0], [75, 15, 15], [105, 30, 15], [195, 105, 105], [165, 60, 60], [135, 15, 15], [180, 180, 165], [105, 90, 90], [30, 15, 15], [60, 30, 30], [135, 60, 60], [150, 45, 30], [150, 75, 30], [240, 225, 195], [75, 15, 0], [90, 15, 0], [120, 45, 30], [240, 150, 150], [105, 90, 75], [105, 75, 60], [105, 105, 105], [45, 45, 45], [30, 30, 15], [180, 60, 45], [165, 60, 30], [180, 90, 45], [135, 75, 30], [195, 135, 90], [135, 60, 45], [135, 75, 60], [90, 60, 30], [90, 60, 45], [30, 15, 0], [15, 15, 15], [45, 30, 15], [195, 90, 60], [180, 105, 60], [120, 75, 30], [105, 60, 30], [120, 60, 30], [15, 0, 0], [75, 45, 45], [180, 75, 30], [180, 120, 60], [90, 45, 30], [60, 45, 45], [60, 45, 60], [45, 30, 30], [75, 45, 30], [75, 45, 15], [195, 105, 75], [165, 45, 30], [165, 45, 15], [30, 0, 15], [45, 15, 15], [135, 60, 30], [210, 105, 60], [195, 120, 75], [75, 60, 30], [120, 120, 105], [165, 75, 60], [135, 45, 15], [195, 60, 45], [90, 30, 45], [165, 75, 30], [135, 90, 60], [135, 105, 60], [165, 90, 90], [120, 45, 45], [165, 75, 45], [210, 135, 60], [135, 90, 30], [165, 60, 45], [105, 75, 45], [195, 135, 45], [135, 105, 75], [75, 30, 30], [135, 105, 90], [195, 120, 45], [180, 105, 30], [135, 120, 90], [150, 60, 60], [180, 75, 75], [150, 60, 15], [150, 75, 15], [165, 120, 105], [180, 90, 90], [195, 90, 105], [210, 105, 105], [0, 0, 0], [15, 0, 15], [180, 105, 45], [120, 60, 45], [120, 60, 15], [90, 30, 15], [30, 0, 0], [15, 15, 0], [165, 90, 45], [180, 90, 30], [105, 30, 0], [180, 75, 45], [135, 45, 0], [120, 45, 15], [105, 45, 15], [45, 15, 0], [195, 90, 90], [90, 60, 60], [120, 75, 60], [135, 45, 30], [90, 45, 15], [225, 240, 240], [105, 75, 75], [150, 60, 30], [165, 180, 180], [180, 45, 60], [150, 45, 15], [135, 135, 135], [180, 60, 30], [90, 105, 105], [150, 135, 120], [105, 60, 60], [105, 45, 45], [225, 150, 105], [120, 120, 120], [105, 30, 45], [210, 150, 105], [90, 90, 90], [15, 30, 15], [45, 0, 15], [135, 30, 30], [180, 45, 30], [135, 30, 15], [75, 75, 75], [15, 15, 30], [0, 0, 15], [195, 60, 30], [210, 60, 45], [195, 90, 45], [210, 105, 75], [120, 90, 90], [45, 30, 45], [90, 45, 45], [0, 15, 0], [195, 75, 45], [195, 75, 60], [30, 30, 0], [135, 120, 105], [225, 195, 210], [60, 60, 60], [0, 15, 15], [15, 30, 45], [45, 45, 60], [30, 15, 30], [150, 30, 15], [30, 30, 30], [90, 75, 90], [90, 15, 30], [165, 165, 150], [120, 105, 60], [120, 120, 60], [60, 60, 45], [30, 45, 30], [60, 15, 30], [120, 30, 45], [60, 30, 45], [90, 90, 75], [135, 150, 60], [90, 90, 30], [30, 45, 45], [90, 75, 75], [120, 105, 105], [75, 30, 45], [60, 75, 60], [75, 15, 30], [45, 15, 30], [45, 60, 45], [120, 120, 90], [90, 15, 45], [75, 75, 60], [150, 150, 135], [75, 75, 45], [225, 120, 120], [75, 60, 60], [105, 105, 75], [120, 135, 90], [90, 90, 60], [135, 45, 60], [135, 30, 45], [75, 90, 75], [60, 75, 45], [210, 90, 60], [120, 45, 60], [150, 150, 150], [105, 120, 60], [105, 105, 60], [30, 30, 45], [135, 75, 75], [150, 45, 60], [225, 135, 90], [195, 105, 60], [195, 210, 195], [120, 75, 75], [90, 60, 75], [195, 135, 75], [210, 120, 75], [210, 225, 225], [150, 75, 90], [225, 135, 75], [210, 90, 75], [165, 120, 120], [210, 135, 75], [225, 105, 75], [180, 75, 60], [105, 45, 60], [225, 120, 75], [150, 90, 30], [165, 60, 75], [75, 45, 60], [225, 105, 60], [225, 90, 45], [225, 60, 30], [150, 30, 30], [150, 90, 90], [210, 135, 90], [150, 135, 90], [240, 75, 45], [135, 60, 75], [150, 105, 90], [240, 90, 60], [240, 105, 75], [210, 105, 45], [195, 150, 105], [240, 90, 45], [210, 120, 90], [45, 45, 30], [240, 105, 45], [210, 120, 45], [240, 90, 30], [210, 90, 45], [225, 120, 90], [195, 240, 195], [135, 240, 135], [75, 255, 60], [45, 255, 30], [45, 240, 30], [90, 225, 60], [105, 210, 75], [120, 135, 75], [195, 165, 165], [120, 150, 60], [30, 255, 0], [180, 180, 105], [165, 105, 105], [45, 240, 0], [45, 210, 0], [75, 105, 30], [30, 195, 0], [30, 225, 0], [30, 240, 0], [60, 240, 15], [90, 225, 30], [60, 195, 15], [30, 120, 15], [45, 105, 30], [105, 195, 30], [90, 225, 15], [75, 240, 30], [120, 195, 45], [105, 135, 30], [150, 165, 75], [180, 195, 30], [240, 75, 30], [165, 165, 45], [90, 225, 45], [105, 210, 45], [195, 165, 90], [135, 255, 135], [75, 255, 75], [90, 255, 90], [135, 240, 120], [165, 240, 150], [225, 240, 210], [90, 180, 75], [30, 135, 0], [135, 165, 45], [75, 210, 60], [90, 180, 30], [45, 210, 15], [150, 150, 60], [165, 195, 30], [225, 135, 60], [150, 210, 15], [135, 180, 45], [135, 225, 60], [210, 240, 210], [210, 240, 195], [195, 225, 195], [45, 165, 30], [30, 210, 15], [30, 150, 15], [15, 135, 0], [120, 165, 45], [45, 195, 15], [105, 90, 30], [105, 135, 45], [120, 180, 45], [105, 210, 30], [105, 195, 60], [120, 210, 45], [90, 120, 30], [210, 180, 105], [180, 180, 90], [135, 195, 60], [120, 210, 60], [135, 165, 60], [240, 135, 45], [180, 165, 75], [120, 165, 75], [195, 150, 75], [165, 180, 45], [120, 225, 30], [105, 165, 15], [75, 255, 45], [165, 240, 165], [150, 240, 150], [45, 135, 45], [30, 210, 0], [45, 120, 15], [150, 165, 60], [135, 195, 30], [90, 210, 30], [210, 120, 60], [135, 225, 105], [90, 255, 75], [120, 150, 45], [150, 240, 135], [90, 210, 75], [105, 90, 45], [60, 210, 15], [195, 180, 105], [195, 165, 105], [150, 165, 45], [195, 75, 15], [195, 60, 0], [135, 210, 15], [60, 240, 0], [150, 120, 15], [60, 195, 0], [75, 240, 15], [180, 240, 180], [105, 255, 90], [105, 150, 45], [105, 150, 30], [60, 240, 30], [75, 240, 60], [45, 225, 0], [150, 120, 75], [195, 180, 120], [210, 165, 120], [180, 165, 105], [210, 180, 120], [240, 105, 15], [165, 180, 30], [105, 240, 0], [135, 210, 30], [150, 165, 15], [120, 180, 30], [105, 240, 90], [60, 255, 45], [45, 255, 15], [90, 150, 30], [90, 240, 75], [90, 210, 15], [120, 90, 45], [105, 225, 60], [225, 195, 135], [165, 150, 90], [150, 165, 90], [225, 105, 30], [225, 120, 15], [120, 210, 15], [195, 120, 30], [150, 255, 150], [75, 135, 15], [105, 165, 75], [105, 210, 15], [180, 150, 90], [225, 165, 120], [210, 195, 135], [165, 135, 75], [210, 165, 105], [195, 165, 30], [75, 240, 0], [135, 210, 0], [165, 165, 30], [120, 165, 105], [75, 225, 0], [150, 180, 90], [180, 195, 105], [165, 180, 75], [150, 210, 30], [90, 240, 0], [210, 90, 30], [165, 90, 30], [195, 150, 90], [75, 210, 30], [225, 180, 120], [180, 135, 75], [225, 165, 90], [150, 180, 75], [225, 90, 30], [195, 120, 60], [210, 120, 30], [210, 180, 30], [135, 225, 0], [195, 150, 15], [225, 75, 30], [210, 75, 30], [195, 195, 150], [60, 255, 30], [195, 240, 180], [195, 30, 0], [165, 30, 15], [120, 150, 75], [210, 165, 75], [225, 165, 60], [195, 195, 45], [150, 165, 30], [195, 135, 60], [210, 195, 120], [240, 75, 15], [225, 150, 15], [240, 180, 15], [210, 165, 15], [210, 165, 45], [225, 90, 15], [210, 90, 15], [240, 120, 30], [210, 225, 180], [150, 120, 30], [45, 75, 0], [75, 120, 15], [75, 180, 30], [75, 195, 15], [195, 150, 60], [90, 195, 15], [120, 210, 30], [180, 165, 60], [195, 195, 105], [150, 225, 90], [135, 225, 75], [210, 150, 90], [195, 180, 30], [180, 180, 45], [225, 120, 30], [165, 195, 0], [165, 180, 15], [195, 165, 15], [225, 180, 30], [240, 180, 30], [225, 195, 15], [150, 225, 15], [135, 75, 15], [180, 180, 15], [195, 135, 30], [135, 225, 90], [180, 240, 165], [105, 255, 105], [150, 225, 135], [75, 225, 15], [195, 150, 45], [210, 165, 60], [120, 195, 30], [120, 225, 60], [195, 195, 75], [225, 180, 105], [225, 180, 45], [180, 225, 15], [180, 195, 90], [195, 210, 180], [90, 195, 30], [60, 225, 0], [105, 195, 45], [135, 150, 75], [165, 105, 45], [150, 135, 30], [105, 240, 15], [90, 240, 45], [195, 210, 105], [195, 195, 90], [210, 180, 90], [210, 195, 45], [150, 240, 0], [210, 180, 45], [225, 150, 90], [225, 150, 75], [60, 180, 0], [75, 210, 15], [90, 240, 15], [90, 240, 60], [210, 135, 45], [210, 150, 15], [225, 165, 30], [120, 90, 75], [225, 195, 120], [225, 165, 105], [240, 195, 30], [240, 195, 15], [210, 135, 30], [240, 165, 60], [210, 150, 30], [240, 195, 45], [240, 210, 30], [240, 180, 45], [225, 165, 45], [225, 150, 45], [225, 90, 60], [240, 150, 45], [150, 105, 45], [165, 105, 30], [210, 180, 135], [225, 195, 45], [225, 120, 45], [225, 180, 75], [225, 135, 30], [210, 165, 90], [240, 165, 45], [210, 105, 30], [225, 105, 45], [225, 75, 45], [225, 135, 45], [240, 150, 30], [150, 120, 60], [165, 120, 60], [180, 135, 15], [210, 150, 45], [225, 165, 75], [225, 150, 30], [240, 210, 15], [195, 90, 30], [240, 210, 150]], 'rows': [[[0, 95]], [[0, 95]], [[0, 95]], [[0, 25], 1, 1, 2, 1, 1, 3, 4, 1, 1, 5, 5, 2, 0, [1, 3], [0, 54]], [[0, 24], 2, 2, 5, 6, 7, 7, 8, 7, 9, 9, 7, 7, 10, 1, 5, 5, 1, [0, 54]], [[0, 22], 11, 1, 2, 12, 6, 13, 14, 15, 14, 14, 13, [14, 3], 8, 10, 7, 10, 11, [0, 54]], [[0, 21], 11, 3, 6, 7, 12, 15, [16, 3], 14, 14, 16, 16, [14, 4], 8, 8, 2, 1, 1, [0, 52]], [[0, 20], 11, 2, 8, [14, 3], 15, 15, 16, 16, 17, 18, 15, 17, [15, 4], 14, 8, 19, 20, 20, 1, [0, 18], 1, 3, 3, 1, [0, 29]], [[0, 19], 11, 5, 8, 14, 14, 21, 22, 16, 21, 14, 15, 15, 17, 17, 15, 17, 15, 18, 15, 16, 14, 8, 12, 5, 1, [0, 18], 23, 24, 25, 26, 1, [0, 28]], [[0, 17], 1, 1, 10, 12, 13, 15, 14, [21, 4], 18, 15, 17, 15, 27, 17, 28, 16, 16, 15, 28, 13, 16, 13, 6, 5, 11, [0, 16], 4, 29, 30, 31, 32, 4, [0, 28]], [[0, 17], 2, 10, 8, 14, 16, 15, 15, 21, 22, 18, 22, 33, 21, 14, 17, 17, 34, 35, 16, 15, 17, 36, 17, 16, 16, 13, 8, 5, [0, 16], 6, 37, 38, 39, 30, 2, [0, 28]], [[0, 17], 11, 6, 14, 16, 16, 18, 40, 17, 41, 17, 17, [22, 3], 17, 22, 21, 15, 21, 15, 17, 16, 36, 17, 27, 16, 14, 9, 1, [0, 15], 6, 42, 43, 37, 39, 2, [0, 4], 1, 1, [0, 22]], [[0, 17], 1, 10, 16, 18, 15, 22, 27, 27, 18, 17, 17, 15, 22, 22, 16, 21, 15, 22, 22, 21, 18, 36, 36, 27, 27, 16, 13, 8, 5, [0, 15], 8, 42, 44, 43, 39, 9, 0, 0, 1, 26, 45, 26, 46, [0, 21]], [[0, 17], 2, 47, 41, 18, 15, 21, 15, 48, 49, 50, 51, 40, 51, 40, 40, 52, 40, 51, 53, 51, 27, 18, 18, 17, 28, 16, 13, 16, 10, [0, 15], 15, 54, 42, 55, 56, 57, 1, 0, 6, 56, 24, 58, 59, 4, [0, 20]], [[0, 17], 11, 8, 14, [36, 3], 52, 60, 29, [50, 5], [39, 4], 52, 18, 15, 21, 21, 27, 27, 28, 15, 16, 8, 1, [0, 14], 17, 54, 54, 38, 61, 33, 0, 1, 29, 62, 63, 64, 24, 65, 3, 2, 1, [0, 17]], [[0, 17], 11, 8, 18, 66, 67, 67, 68, 39, [30, 7], 62, [69, 3], 40, 15, 22, 18, 36, 18, 15, 14, 14, 8, 1, [0, 14], 70, 67, 67, 37, 56, 53, 1, 9, 55, 37, 38, 38, 71, 72, 73, 74, 75, 3, 76, [0, 15]], [[0, 15], 1, 5, 7, 77, 18, 78, 54, 37, 38, 69, 30, 79, 80, 80, 30, 80, 81, 30, 69, 38, 38, 52, 15, 22, 22, 21, 16, 16, 15, 14, 14, 2, [0, 14], 15, 54, 42, 55, 38, 30, 26, 40, 42, 82, 82, 54, 22, 0, 83, 84, 3, 76, 85, 85, 2, [0, 13]], [[0, 15], 1, 19, 86, 16, 18, 78, 54, 38, 62, 30, 81, 64, [81, 3], 24, 24, 63, 30, 69, 38, 52, 15, 14, 22, 21, 14, 15, 14, 15, 8, 2, [0, 14], 65, 38, 68, 68, 39, 54, 42, 67, 42, 87, 88, 42, 89, 26, 27, 8, 4, 72, 72, 90, 90, [0, 13]], [[0, 16], 1, 5, 14, 36, 91, 67, 38, 39, 81, [24, 6], 45, 24, 63, 69, 38, 52, 51, 21, 21, 14, [15, 3], 16, 14, 32, 26, 46, 1, [0, 11], 22, 67, 67, 92, 92, 42, 93, 42, 94, 95, 95, 54, 69, 39, 39, 40, 18, 96, 15, 11, 97, [0, 13]], [[0, 17], 2, 7, 36, 98, 54, 68, 69, 81, [24, 8], 81, 30, 62, 29, 18, 21, 51, [16, 4], 18, 52, 63, 31, 99, 22, 46, [0, 9], 9, 60, 42, 98, 42, 100, 42, 101, 67, 98, 88, 88, 67, 63, 64, 81, 56, 39, 67, 102, 103, 11, 11, [0, 12]], [[0, 17], 2, 13, 36, 98, 54, 38, 39, 81, 31, 31, [24, 6], 64, 79, 62, 62, 40, 40, 51, 18, 40, 36, 18, 36, 52, 30, 81, 31, 31, 99, 23, 58, 46, 4, 1, 0, 1, 2, 15, 60, 68, 68, 42, 98, 67, 37, 39, 68, 98, 98, 42, 39, 33, 104, 64, 56, 56, 39, 50, 27, 105, 103, [0, 12]], [[0, 17], 2, 8, 106, 107, 54, 38, 39, 63, [31, 3], [24, 5], 81, 30, [62, 3], 40, 40, 18, [36, 4], 60, 39, 30, 81, 31, 31, 24, 81, 108, 50, 51, 22, 51, 50, 68, 68, 29, 68, 37, 68, 68, 29, 39, 50, 78, 95, 82, 39, [109, 2], 63, 39, 69, 56, 56, 39, 96, 110, [0, 12]], [[0, 17], 1, 12, 111, 98, 54, 68, 39, 81, 63, [81, 4], 31, 24, 63, 56, 112, 113, 37, 37, 67, 114, 78, 52, 29, [115, 2], 116, 52, 62, 81, 81, 31, 24, 64, 56, 50, 39, 39, 30, 56, 50, 50, 29, 115, [67, 4], 37, 68, 68, 67, 100, 89, 109, 117, 39, 39, 56, 63, 64, 56, 49, 83, [0, 12]], [[0, 17], 1, 2, 118, 98, 37, 38, 62, 69, 56, 81, 63, 30, 119, 62, 50, 120, 121, 122, 123, 124, [125, 2], 126, 127, 78, 52, 37, 44, 49, 47, 22, 39, 30, 81, 63, 56, 50, 50, 62, 68, 39, 89, 56, 56, 39, 67, 98, 95, [128, 2], 95, 94, 42, 67, 68, 39, 53, 64, 56, 81, [24, 4], 51, 5, [0, 12]], [[0, 18], 5, 118, 128, 98, 101, 37, 37, 62, 30, 30, 129, 130, [131, 2], 132, 133, 134, [135, 2], 123, [136, 2], 137, 52, 52, 38, 138, 37, 3, 1, 72, 49, 39, 38, 39, 62, 38, 38, 68, 89, 89, 50, 69, 62, 54, 98, 94, [87, 3], [139, 3], 128, 92, 68, 56, 30, 63, 64, 24, 63, 24, 24, 140, [0, 12]], [[0, 18], 141, 12, 142, 143, 144, 145, 146, 122, 147, 44, 148, 123, 149, [150, 3], [151, 2], 124, 136, 43, 38, 37, 67, 68, 37, 138, 68, 13, 97, 0, 4, 6, 18, 60, [67, 4], 68, 52, 68, 68, 54, 98, 128, [87, 3], 128, 152, [128, 2], 139, 153, 98, 68, 39, 30, 81, 64, 64, 24, 24, 32, 4, [0, 11]], [[0, 19], 5, 154, [143, 4], 155, 44, 112, 130, 156, 124, [123, 3], [134, 2], 157, 62, 69, 38, 54, 54, [38, 3], 37, 36, 5, [0, 4], 1, 9, 158, 159, 160, 114, [98, 5], 94, [128, 2], 87, [153, 2], 87, 139, 87, 128, 139, 101, 68, 62, 39, 81, 64, 81, 69, 98, 18, 1, [0, 10]], [[0, 19], 1, 105, [143, 2], 161, 162, 163, 164, 81, 30, 165, 156, 166, 156, 166, 148, 164, 30, 69, 62, 37, 54, 54, 62, 69, 113, 68, 16, 167, 2, 1, 0, 0, 11, 168, 169, 170, 171, 172, 173, 88, 128, 95, 94, 98, [100, 3], [98, 3], 128, [87, 4], 128, 68, 38, 80, 63, 80, 62, 78, 21, 174, [0, 10]], [[0, 19], 1, 167, 161, 151, 175, 176, 177, 62, 178, 81, 30, [129, 2], 113, 62, [81, 3], 30, 62, 38, 37, 37, 54, 62, 38, 67, 48, 179, 180, 16, 10, 181, 182, 183, 170, 136, 184, 185, 186, 42, 42, [88, 3], 128, 95, 94, 94, [98, 3], 128, [87, 3], 187, 128, 188, 62, 81, 24, 50, 107, 36, 57, 1, [0, 9]], [[0, 20], 2, 114, 189, 190, 101, 55, 30, 81, 81, 63, 30, 81, 31, 24, 24, 81, 81, 30, 62, 38, 38, 113, 54, 38, 37, 43, 191, 160, 145, 192, 193, 194, 169, 195, 145, 184, 185, 196, 54, 54, 42, 95, 197, 94, 94, 87, 87, 153, 187, 198, 199, 198, 160, 187, 87, 187, 200, 101, 37, 63, 25, 104, 64, 68, 16, 5, [0, 9]], [[0, 20], 1, 67, 113, 30, 119, 55, 112, [30, 3], 62, 29, 63, 24, 24, 63, 30, 69, [38, 3], 37, 54, 37, 43, 67, 127, 185, 144, 194, 201, [169, 2], 202, 95, 203, 82, 54, 68, 68, 67, 94, [197, 2], 204, [94, 3], 128, 205, [206, 2], 207, 208, 154, 209, 210, 205, 60, 62, 63, 32, 117, 89, 8, 11, [0, 9]], [[0, 20], 1, 60, 211, 62, 113, 44, 112, 79, 30, 119, 62, 62, 68, 30, 80, 30, 69, 69, [38, 3], 37, 54, 42, 82, 94, 212, 213, 214, 201, [169, 2], 215, 131, 216, 217, 218, 68, 62, 68, 42, 197, 42, [100, 3], 98, 98, 94, 128, 200, 205, [209, 2], [205, 2], 219, 220, 1, 51, 62, 32, 109, 22, 1, [0, 10]], [[0, 21], 18, 100, 38, 42, 122, 37, 62, 37, 164, 62, 30, 37, 38, 69, 39, 39, 38, 38, 37, 37, 54, 54, 42, 221, 222, 223, 126, 169, 194, [169, 2], 224, 155, 225, 186, 54, 68, 29, 68, [42, 3], [100, 4], 98, 98, 152, 87, 87, 139, 187, 153, 226, 227, 167, 0, 3, 53, 104, 58, 32, 1, [0, 10]], [[0, 21], 14, 197, 54, 95, 88, [122, 2], 228, 55, 55, 37, 37, 54, [38, 4], 37, [54, 4], 55, 229, 212, 230, 143, [169, 3], 215, 180, 189, 230, 231, 60, [68, 3], 42, 94, 42, [100, 4], 91, 98, 94, 87, [187, 2], 232, 153, 227, 48, 46, 1, 4, 63, 117, 104, 23, 1, [0, 10]], [[0, 21], 9, 98, 42, 94, 216, 95, 101, 115, 55, 37, 55, 55, 95, [38, 3], 37, 37, 54, 55, 67, 54, 55, 177, 233, 144, [169, 2], 194, 169, 215, 234, 199, 216, 235, 67, [68, 3], 100, 94, 98, 100, 67, 100, 91, 91, 98, 128, 87, 187, 198, 232, 226, 236, 5, 0, 0, 1, 51, 117, 104, 24, 1, [0, 10]], [[0, 21], 1, 106, 98, 218, 139, 95, 54, 68, 37, 54, 55, 55, 101, 54, 38, 37, 54, 54, 55, 42, 42, 100, 101, 127, 131, 214, 169, [194, 2], 169, 237, 221, 82, 173, 235, 128, [68, 3], 100, 94, 94, 98, [100, 2], 91, 98, 152, 87, 87, 139, 232, 153, 238, 20, 1, [0, 3], 22, 24, 24, 53, 46, [0, 10]], [[0, 22], 6, 98, 218, 87, 216, 177, 101, 55, 228, 177, 189, 190, 98, 38, 54, 54, 42, 98, 98, 42, 42, 160, 193, 201, [169, 2], [194, 3], 144, 95, 225, 239, 240, 187, 67, 68, 68, 67, [94, 5], [128, 2], 87, [187, 3], 198, 241, 2, [0, 5], 72, 24, 117, 32, 2, [0, 10]], [[0, 23], 17, 42, 67, 128, 189, 125, 242, [243, 2], 130, 189, 101, 54, 54, 42, 98, 101, 98, 42, 114, 144, [201, 2], [169, 2], [194, 3], 170, 101, 244, 245, 94, 232, 160, 100, 92, 67, 42, 95, 87, 88, [139, 2], 187, 216, [200, 3], 160, 9, [0, 6], 2, 63, 45, 58, 46, [0, 10]], [[0, 23], 4, 246, 54, 67, 29, 101, 247, 248, 249, 130, 37, 98, 188, 100, 42, 95, 98, 42, 98, 237, 169, 250, 251, 169, [194, 3], 201, 193, 170, 127, 252, 173, 199, 253, 226, 78, 137, 98, 94, 128, 187, 200, 254, 200, [254, 2], 199, 160, 255, 140, [0, 7], 22, 32, 26, 4, [0, 10]], [[0, 24], 2, 48, 98, 37, 62, 130, 129, 71, 115, 62, 54, 95, 42, 94, 95, 42, 42, 159, 256, 194, 250, 194, 169, 194, [169, 2], 194, 257, 102, 258, 203, 259, 258, 216, 127, 159, 128, 94, 94, [87, 3], 187, 216, [200, 2], 159, 145, 124, 6, [0, 7], 1, 3, 2, 1, [0, 10]], [[0, 25], 6, 226, 67, 37, 37, 129, 71, 121, 37, 54, 101, 122, 95, 95, 42, 128, 215, 169, 251, 256, 169, [194, 6], 142, 144, 260, 261, 262, 263, [205, 2], 264, 200, 139, 187, 216, [200, 2], [139, 2], 199, 265, 144, 124, 17, [0, 21]], [[0, 25], 1, 17, 98, 42, 43, 266, [249, 2], 42, 54, 55, 127, 122, 95, 94, 205, 169, 257, 251, 237, 170, [194, 6], 257, 267, 268, 177, 93, 189, 131, 162, 127, 264, 260, 264, [263, 2], 216, 88, 253, 265, 201, 144, 163, 114, 1, [0, 20]], [[0, 25], 1, 2, 102, 98, 101, 247, 44, 221, 44, 55, 98, 205, 253, 122, 253, 215, 194, 257, 215, 268, 237, [194, 6], [257, 2], 209, 145, 139, 264, 269, 255, 162, 127, 270, 264, 163, 260, 263, 93, 155, 215, 201, 143, 134, 189, 5, [0, 20]], [[0, 26], 271, 272, 98, 98, 87, 226, 98, 42, 42, 137, [131, 2], 205, 195, 169, 194, 169, 202, 148, 144, 194, [251, 2], [194, 4], 251, 201, 159, 263, 177, 222, 172, 124, 175, 145, 163, 216, 273, 230, 216, 145, 195, 193, 201, 123, 93, 274, [0, 20]], [[0, 26], 1, 267, 190, 68, 100, 67, 67, 54, 67, 190, 144, 142, 265, [169, 2], 201, 215, 267, 275, 144, [194, 8], 193, 144, 255, 264, 263, 276, 185, 172, 263, 126, 173, 258, 88, 255, 145, 142, 215, 257, 161, 269, 277, [0, 20]], [[0, 25], 1, 15, 125, 142, 246, 98, 42, 95, 55, 98, 205, 215, 237, 142, 169, 194, 169, 170, 272, 134, 215, [194, 8], 214, 237, 256, 131, 126, 269, 273, 278, 217, 258, 216, 200, 163, 264, 270, 145, 144, 257, 256, 216, 279, [0, 20]], [[0, 24], 1, 280, 148, 162, 169, 237, 190, 94, 88, 139, 205, 144, 237, 255, 161, [194, 2], 215, 237, 281, 127, 215, [194, 2], 251, [194, 5], 256, 282, 170, [256, 2], 265, 175, 230, 203, 283, 101, 270, 177, [264, 2], 255, 142, 194, 145, 233, 182, 11, [0, 19]], [[0, 23], 11, 284, 282, 132, 169, 194, 169, 205, 87, 139, 199, 255, 177, 155, 145, 193, 194, [215, 2], 155, 285, 237, 169, [194, 6], 251, 194, 214, 282, 205, [201, 2], 256, 215, 155, 185, 211, 286, 98, 127, [264, 2], 270, 142, 251, 177, 222, 169, 97, [0, 19]], [[0, 22], 11, 287, 144, 215, 257, [194, 2], 169, 145, 198, 187, 200, 216, 222, 163, 162, 169, 250, 288, 145, 229, 155, 170, [194, 9], 251, 255, 253, 144, [250, 2], 251, 289, 290, 291, 196, 69, 226, [127, 2], 270, 142, 256, 292, 216, 183, 75, [0, 19]], [[0, 21], 97, 293, [169, 2], 201, 194, 257, 194, 294, 169, 205, 200, 216, 95, 216, 163, 205, 214, 250, 215, 134, 292, 255, 215, [194, 5], 251, [194, 4], 265, 253, 127, 193, 250, 295, 201, 143, 233, 296, 69, 37, 255, 205, 270, 142, 162, 172, 264, 257, 75, [0, 19]], [[0, 20], 11, 293, 194, 169, 250, [194, 4], 294, 194, 193, 215, 131, 221, 93, 190, 192, 201, 250, 289, 123, 273, 255, 208, 169, [194, 5], 251, [194, 3], 193, 127, 177, 145, 201, [250, 2], 201, 131, 297, 298, 299, 253, 142, 205, 215, 126, 225, 199, 288, 85, [0, 19]], [[0, 20], 284, [194, 2], 169, 201, [194, 2], 251, [194, 2], [169, 2], 194, 144, 177, 101, 22, 300, [250, 2], 251, 301, 302, 145, 169, [194, 6], [251, 2], [194, 2], 257, 144, 189, 253, 215, 201, 303, 250, 251, 290, 304, 305, 255, 265, 151, 163, 263, 255, 306, 257, 75, [0, 19]], [[0, 19], 85, 169, [194, 5], 251, 201, 251, [194, 2], [169, 3], 307, 59, 308, 309, [201, 2], 310, 311, 312, 313, [169, 3], [194, 3], 257, [194, 5], 214, 302, 253, 155, 256, 201, 250, 295, 214, 82, 223, [134, 2], 314, 123, 169, 194, 169, 315, 85, [0, 19]], [[0, 18], 97, 315, [194, 3], 182, 181, 168, 206, [194, 7], 316, 73, 103, 194, [201, 2], [194, 2], 294, 194, [169, 4], 215, 162, 317, 162, 215, 256, [194, 3], 215, [253, 2], 145, 256, 169, 265, 256, 145, 296, 213, 184, 177, 169, 313, 315, 313, 301, 318, [0, 19]], [[0, 17], 97, 287, [194, 2], 169, 315, 287, 319, 320, 321, 322, [194, 3], 251, [194, 3], 83, 110, 257, 201, 250, 194, [169, 7], 323, 155, 324, 136, 253, 285, 289, 256, [194, 2], 209, 253, 229, 144, 194, 215, 162, 144, 273, 298, 263, [169, 2], [194, 2], 315, 325, 277, [0, 19]], [[0, 16], 2, 309, [194, 3], 313, 309, 326, 327, 328, 321, 329, [194, 7], 330, 331, 201, [250, 2], [194, 2], [169, 10], 215, 302, 229, 162, 169, 194, 214, 229, 160, 159, 289, 251, 143, 155, 317, 142, 169, 208, 332, [194, 2], 215, 170, 277, [0, 19]], [[0, 15], 141, 287, [194, 2], 294, 194, 315, [333, 3], 309, 333, 182, 315, 194, 169, [194, 4], 251, 169, 295, 250, [194, 2], [169, 8], [313, 3], [169, 2], 145, 229, 255, 214, 194, 144, 160, 139, 200, 144, 313, 334, 189, 162, 215, 335, 146, 215, 194, 224, 317, 287, [0, 19]], [[0, 15], 85, 169, 170, [169, 3], 315, 207, 309, 336, 326, 337, 326, 182, [194, 6], 201, 144, 256, 303, 194, [169, 10], [313, 3], 183, 313, 144, 253, 131, 214, 194, 205, [128, 2], 253, 335, 313, 159, 242, 144, 294, 302, 170, 169, 282, 338, 309, 141, [0, 18]], [[0, 15], 168, 96, 121, 180, [169, 2], 315, 309, 339, 337, 340, 220, 341, 182, [194, 7], 144, 237, 144, 193, 194, [169, 10], [313, 2], 169, [313, 2], 144, 253, 127, 169, 144, 190, [107, 2], 136, 334, 170, 242, 177, [215, 2], 267, 215, 229, 131, 206, 3, [0, 18]], [[0, 14], 11, 208, 120, 342, 228, 215, 169, 194, 343, 344, 345, 346, 287, 293, 321, [194, 5], 251, 194, 257, 162, 347, 237, [169, 9], [313, 6], 315, 313, 237, 189, 255, 215, 237, 98, 91, 196, 348, 335, 302, 122, 132, 183, 302, 237, 347, 317, 170, 103, [0, 18]], [[0, 14], 97, 251, 120, 112, 55, 142, 294, 194, 315, 309, 333, 349, [350, 2], 182, 315, [194, 6], 257, 256, 127, 282, 169, 313, [169, 2], 313, [169, 2], [313, 3], [169, 2], [313, 5], 315, 127, 171, 144, 208, 159, 196, 351, 101, 282, 144, 171, 136, 169, 131, 224, 352, 237, 208, 105, [0, 18]], [[0, 14], 353, 169, 115, 62, 43, 145, 294, 169, 315, 301, 329, 350, 354, 355, 287, 356, 201, [194, 7], 215, 229, [169, 2], 215, 237, 335, 169, 183, 315, 313, [183, 2], 315, [313, 2], 169, 313, 335, 313, 208, 357, 146, 183, 144, 351, 196, 78, 101, 317, 170, 358, 144, 237, 334, 144, 224, 208, 343, 2, [0, 17]], [[0, 13], 11, 182, 209, 62, 62, 44, 142, 294, [169, 2], 183, 315, 309, 326, 168, 287, 194, 201, [194, 5], 169, 194, 169, 282, 142, 169, 215, 224, 335, 208, 323, 335, 215, 313, [335, 2], 313, 169, [313, 2], [335, 2], 315, 170, 228, 131, 170, 359, 360, 78, 91, 122, 162, 131, 237, 335, 208, 170, 157, 209, 170, 10, [0, 17]], [[0, 13], 361, 194, 362, 62, 38, 114, 193, [169, 2], [194, 3], 182, 363, 330, 315, 194, 251, [194, 6], [169, 2], 282, 177, 169, 215, 282, 323, 332, 352, 171, 229, 131, 215, [313, 5], [335, 2], 313, 315, 302, 228, 145, 364, 365, 101, 78, 91, 165, 162, 142, [215, 2], 170, 165, 282, 208, 74, [0, 17]], [[0, 13], 366, 154, 37, 62, 37, 146, 194, [169, 3], [194, 2], 201, [169, 4], [194, 4], [251, 2], [194, 3], 237, 122, 145, 215, 352, 131, 215, 313, 144, 282, 189, 282, 145, 169, [313, 2], 335, 313, [335, 2], 208, 195, [367, 2], 94, 368, 172, 55, 211, 351, 369, 299, 94, 195, 215, 242, 131, 208, 168, 1, [0, 16]], [[0, 12], 1, 2, 49, 30, 39, 78, 237, 251, [169, 3], 194, 257, 250, 289, [169, 2], 194, 169, 251, [194, 3], 251, 194, 169, 313, 215, [171, 2], 142, 334, 171, 144, 313, 315, 215, 335, 237, [282, 2], 144, 313, 335, 315, 215, 323, [208, 2], 202, 370, 102, 371, 196, 148, 196, 360, 196, 299, 364, 101, 215, 282, 352, 169, 206, 2, [0, 16]], [[0, 11], 1, 20, 246, 98, 54, 68, 114, 215, 251, [169, 3], 194, [201, 2], 323, 169, 313, [169, 2], 251, 169, [194, 3], [169, 2], 313, 169, 237, 157, 171, 144, 347, 171, [335, 2], [313, 2], 169, 215, 282, 189, 237, 313, 169, 334, 224, [335, 2], 195, 96, 78, 82, 372, 172, 102, 106, 55, 157, 145, 190, 281, 215, 146, 323, 315, 5, [0, 16]], [[0, 11], 72, 107, 42, 95, 128, 55, 190, 256, 310, 251, 169, 194, 251, 201, 256, 317, [169, 4], [194, 2], [169, 2], [194, 2], 313, 169, 313, 335, 159, 130, 229, 237, 101, 131, 313, 315, 169, 335, 195, 215, [189, 2], 162, 169, 282, 131, 215, 323, 162, 122, 42, 101, [360, 2], 163, 246, 67, 228, 324, 335, 170, 208, 237, 224, 335, 340, [0, 16]], [[0, 10], 46, 137, 82, 211, 43, 122, 128, 226, 193, 310, 201, 257, [251, 3], 144, 285, 256, 169, 313, 169, 313, 194, 313, 169, [194, 2], 315, 183, 315, 335, 302, 247, 171, 162, 44, 347, [313, 3], [208, 3], 282, 44, 189, 215, 155, 131, 237, 229, 44, 147, [351, 2], 261, 365, 373, 253, 78, 137, 130, 323, 313, 285, 144, 374, 206, 321, 11, [0, 15]], [[0, 9], 1, 28, 258, 95, 95, 112, 42, 128, 268, [201, 4], [251, 2], 194, 334, 324, 256, 194, [169, 2], 313, 194, [169, 3], 214, [194, 3], 214, 302, 171, 145, 144, 242, 136, 215, 315, [208, 4], 237, 228, 221, 317, 155, 189, [195, 2], 215, 144, 157, 43, 211, 138, 375, 273, 228, 48, 44, 285, 208, 229, 282, 352, 282, 136, 103, [0, 15]], [[0, 9], 14, 376, 42, 67, 95, 43, 42, 101, 237, 257, 201, 142, 169, 201, 251, 194, 237, 324, 193, [194, 2], [169, 2], 313, [169, 2], 335, 323, [169, 2], 335, 237, 137, 228, 170, 208, 114, 101, 155, 301, 335, [313, 2], 169, 144, 190, 221, 324, 302, 130, 334, [335, 3], 202, 115, 67, 43, 365, 217, 93, 107, 98, 347, 215, 242, 155, 377, 157, 184, 370, [0, 15]], [[0, 8], 9, 88, 261, 43, 54, 68, 37, 54, 98, 268, 209, 265, 205, 170, 201, [295, 2], 237, 324, 193, 251, 194, [169, 2], 313, [169, 2], 215, 237, 313, 315, 215, 142, 98, 101, 142, 208, 146, 55, 242, [208, 2], 335, 315, 183, 215, 242, 95, 136, 205, 130, 155, 208, 315, 335, 195, 102, 106, 78, 95, 299, 351, 197, 98, 130, 162, 130, 131, 253, 44, 82, 127, 4, [0, 14]], [[0, 7], 2, 236, 230, 95, 43, 54, 67, 54, 38, 38, 68, 68, 67, 114, 159, 142, 201, 250, 265, 155, 215, 251, [194, 2], [169, 2], 315, 169, 144, 131, 294, 313, 378, 363, 98, 211, 229, 145, 323, 101, 44, 125, 208, 301, 170, [208, 2], 157, 55, 221, 145, 228, 148, 144, [315, 2], 335, 170, 48, 78, 78, 82, 379, 304, 373, 130, 131, 130, 125, 317, 373, 304, 165, 5, [0, 14]], [[0, 7], 6, 87, 173, 95, 54, 37, 55, 54, 38, 38, 62, 39, 30, 69, 38, 29, 246, 281, 201, 237, 144, [251, 2], 194, [169, 2], 208, 315, 131, 253, 214, 313, 325, 343, 128, 95, 130, 228, 282, 229, 101, 122, 131, 325, 285, [170, 2], 101, 67, 247, 131, 357, 266, 131, 170, [315, 2], 335, 159, 66, 246, 98, 217, 379, 297, 373, 125, 101, 290, 317, 290, 304, 351, 103, [0, 14]], [[0, 6], 4, 280, 88, 173, 95, 113, 38, 38, 42, 101, 42, 54, 68, 62, 62, 38, 39, 108, 30, 202, 256, 170, 169, [194, 3], 294, 313, 315, 229, 130, 289, [313, 2], 208, 102, 101, 155, 268, 55, 253, 190, 137, 157, 133, 229, 323, 155, 44, 67, 247, 131, 237, [247, 2], 131, 208, [301, 2], 170, 236, 106, 66, 211, 379, 380, 381, 382, 101, 136, [215, 2], 216, 304, 83, [0, 14]], [[0, 6], 3, 236, 173, 87, 94, 54, 37, 38, 38, 62, 38, 55, 122, 189, 122, 114, 55, 50, 62, 202, 201, [215, 2], 257, [194, 2], [169, 3], 282, 130, 215, 313, 315, 335, 357, 247, 285, 144, 226, 42, 177, 383, 98, 305, 136, 323, 155, 147, 188, 384, 93, 237, 282, 43, 157, 170, [208, 3], 209, 106, 385, 211, 380, 372, 386, 223, 130, 387, 215, 313, 215, 185, 89, [0, 14]], [[0, 6], 5, 36, 88, 87, 98, 54, 42, 42, 54, 38, 39, 30, 56, 39, 115, 388, 268, 159, 237, 215, [201, 2], 215, 169, 201, 194, [169, 3], 282, 242, 323, [313, 2], 215, 281, 44, 189, 215, 142, 98, 221, 177, 98, 188, 95, 170, 215, 157, 94, 54, 54, 101, 155, 268, 55, 189, 142, [208, 2], 237, 102, 60, 211, 389, 390, 379, 391, 197, 221, 162, 335, 313, 162, 373, 9, [0, 13]], [[0, 6], 83, 48, 88, 88, 95, 54, 54, 42, 44, 54, 54, 68, [39, 4], 50, 63, 246, 265, 169, 201, 169, 215, 144, 193, [215, 2], 169, 237, 228, 237, 313, 169, 215, 237, 114, 122, 170, 313, 253, 211, 155, 190, 392, 42, 136, 334, 190, 91, 101, 122, 42, 44, 125, 107, 91, 200, 334, 155, 224, 255, 44, 82, [393, 2], 365, 394, 371, 373, 127, [144, 2], 170, 131, 37, 47, [0, 12]], [[0, 6], 72, 281, [216, 2], 88, 98, 113, 68, 78, 42, 221, 128, 98, 67, 43, 37, 62, 63, 115, 161, 145, 331, 395, 143, 145, 162, 237, 282, 334, 215, [114, 2], 323, 313, 335, 215, 190, 101, 131, 335, 237, 82, 93, 237, 38, 100, 373, 131, 159, 66, 137, 165, 190, 78, 101, 229, 137, 42, 253, 242, 334, 173, 196, 211, 396, 393, 217, 37, 371, 211, 233, 101, 233, 125, 144, 136, 89, [0, 12]], [[0, 6], 11, 202, 253, 88, 139, 216, 114, 33, 51, 30, 108, 39, 54, 137, 146, 132, 127, 146, 255, 175, 161, 5, 181, 289, [255, 2], 215, 323, 282, 237, 159, 247, 136, 208, 335, 208, 205, 98, 189, 215, 208, 95, 221, 144, 98, 188, 95, 357, 131, 246, 78, 101, 317, 101, 91, 189, 146, 67, 365, 221, 132, 397, 244, 373, 393, 398, 399, 115, 188, 359, 261, 189, 298, 400, 139, 162, 230, 59, [0, 11]], [0, 0, 401, 402, 403, 404, 403, 405, 406, 407, 408, 357, 409, 13, 410, [411, 3], 412, 30, 30, 413, 151, 414, [411, 2], 415, 11, 284, 256, 255, 127, 416, 417, 418, 414, 419, 420, 421, 422, 423, 335, 208, 137, 101, 334, 424, 425, 426, [414, 2], 427, 426, 428, 429, 98, 78, 430, [411, 9], 431, 259, 292, 380, 432, 433, 434, 420, 414, [420, 2], 426, 435, 436, 177, 282, 42, 174, 401, 437, 438, 404, 403, 439, 440, 441, 442, 0], [0, 441, [411, 8], 443, 272, 300, 202, 444, [411, 3], 445, 101, 62, 120, 151, 414, [411, 2], 446, 0, 90, 201, 205, 447, 419, [411, 7], 448, 323, 208, 357, 37, 447, 419, [411, 7], 421, 122, 78, 449, [411, 9], 450, 451, 126, 217, 452, [411, 8], 453, 360, 162, 173, 454, [411, 8], 401, 0], [455, [411, 2], 403, 456, 1, 1, 457, 458, 459, 460, 208, [201, 2], 461, [411, 3], 462, 200, 255, 162, 175, 414, [411, 2], 440, 0, 75, 201, 463, [411, 3], 459, 423, 191, 464, 465, 466, 467, 334, 208, 237, 468, [411, 3], 469, 470, 199, 471, 472, 473, 474, 136, 60, 475, [411, 3], 475, 221, 190, 115, 128, 114, 100, 476, 203, 477, [411, 2], 420, 478, 78, 226, 479, 480, 481, 482, 211, 200, 429, [411, 2], 483, 455, 1, 1, 442, 401, 402, 401, 0], [484, [411, 2], 485, [0, 3], 1, 340, 193, [251, 2], 295, 310, 461, [411, 3], 462, 253, 145, 144, 161, 414, [411, 2], 402, 0, 0, 486, [411, 3], 487, 313, 169, 162, 136, 162, 190, 55, 229, 144, 488, [411, 3], 454, 100, 253, 130, 68, 61, 188, 92, 221, 98, 430, [411, 3], 489, 44, 163, 388, 137, 132, 128, 391, 399, 490, [411, 2], 491, 128, 114, 139, 365, 492, [298, 2], 189, 42, 422, [411, 2], 493, [0, 8]], [441, [411, 2], 494, 442, [0, 3], 11, 179, 195, [201, 3], 444, [411, 3], 495, 253, 142, 215, 161, 419, [411, 2], 496, 0, 0, 497, [411, 2], 419, 498, [169, 2], 317, 377, 131, 268, 107, 98, 177, 499, [411, 2], 414, 500, 392, 101, [114, 2], 152, 91, 501, 286, 101, 327, [411, 3], 502, 373, 172, 189, 197, 131, 127, 503, 504, 505, [411, 2], 506, 507, 185, 82, 492, 196, 503, 298, 189, 211, 508, [411, 2], 509, 456, [0, 7]], [510, [411, 4], 511, 441, 401, 141, 10, 234, 191, [205, 2], 512, [411, 3], 513, 199, 142, 161, 144, 514, [411, 2], 496, 0, 0, 515, [411, 2], 516, 228, 202, 169, 285, 243, 282, 302, 517, 92, 216, 420, [411, 2], 421, 518, 519, [60, 3], 106, 66, 520, 521, 92, 327, [411, 3], 489, 373, 189, 42, 239, 273, 127, 298, 522, 523, [411, 4], 524, 525, 526, 376, 391, 186, 122, 365, 527, [411, 4], 528, 441, 401, 141, [0, 3]], [141, 529, [411, 6], 530, 485, 12, 199, 127, 177, 429, [411, 3], 531, 179, 340, 83, 103, 532, [411, 2], 496, 0, 0, [411, 3], 533, 216, 268, 170, 229, 130, 282, 237, 78, 116, 534, [411, 3], 535, 521, 536, 392, 60, 60, 78, 78, 66, 521, 537, 538, [411, 9], 163, 221, 539, 540, 506, [411, 6], 419, 541, 542, 186, 211, 239, 506, [411, 6], 530, 543, 0, 0], [0, 455, 494, [411, 7], 402, 6, 180, 270, 544, [411, 3], 545, 3, [0, 3], 494, [411, 2], 496, 0, 0, [411, 3], 546, 273, 192, 323, 131, 242, 155, 208, 92, 547, 227, [411, 3], 491, 548, 549, 392, 92, [78, 3], 550, 551, 537, 538, [411, 9], 225, 122, 298, 398, 552, 553, [411, 7], 554, 380, 351, 196, 555, 553, [411, 7], 496, 0], [[0, 3], 401, 485, 494, [411, 5], 141, 3, 220, 556, [411, 3], 401, [0, 4], 494, [411, 2], 496, 0, 0, 532, [411, 2], 557, 82, 127, 317, 215, 189, 155, 335, 67, 392, 78, 414, [411, 2], 421, 68, 549, 519, 91, 66, 78, 66, 66, 501, 66, 558, [411, 3], 559, 269, 142, 209, 139, 451, 298, 304, 360, 365, 364, 92, 560, 561, 562, [411, 5], 540, 380, [196, 2], 563, 480, 525, 427, [411, 5], 141], [[0, 6], 141, 402, [411, 3], 455, 0, 0, 442, [411, 3], 401, [0, 4], 403, [411, 2], 441, 0, 0, 485, [411, 2], 414, 564, 291, 172, 155, 93, 269, 162, 107, 565, 66, 566, [411, 2], 414, 94, 567, 364, 286, 66, 91, 568, 479, 569, 568, 570, [411, 3], 560, 231, 519, 518, 501, 568, 399, 432, 571, 360, 66, [106, 2], 572, 573, 574, 575, [411, 3], 576, 577, 571, 563, 578, [571, 2], 380, 579, 402, [411, 3], 455], [[0, 7], 442, [411, 3], 442, [0, 3], 580, [411, 2], 484, [0, 3], 141, [411, 3], 581, 0, 0, 455, [411, 3], 541, 582, 583, 290, 101, 190, 132, 242, 572, 568, 584, [411, 3], 467, 360, 371, 567, 392, 188, 568, 565, 585, 586, 587, [411, 3], 588, 589, 519, [590, 2], 436, 360, 577, 591, 577, 197, 218, 100, 572, 592, 593, 594, [411, 3], 595, 596, 577, 571, 597, 598, [577, 2], 360, 599, [411, 3], 442], [510, 496, 401, 442, 1, 0, 141, 485, [411, 2], 494, [0, 4], 485, [411, 2], 403, 456, 0, 141, 440, [411, 2], 529, 141, [0, 3], 484, [411, 3], 541, 600, 199, 601, 602, 603, 604, 94, 589, 605, 606, [411, 3], 607, 608, 521, 471, 609, 610, 611, 521, 612, 613, [411, 3], 614, 564, 67, 501, 590, 521, 548, 492, 615, 616, 554, 617, 618, 619, 620, 621, 622, [411, 2], 414, 623, 397, 450, 505, 624, 619, 573, 571, 625, 626, [411, 2], 494, 0], [627, [411, 8], 530, 456, [0, 4], 1, 628, [411, 7], 404, 401, [0, 5], 629, 419, [411, 7], 630, 258, 173, 631, 632, 633, 419, [411, 7], 634, 521, 590, 635, [411, 9], 611, 636, 637, 638, [411, 8], 414, 639, 197, 187, 447, [411, 8], 530, 456, 0], [141, 510, 496, 628, 494, 404, 529, 511, 441, 442, [0, 7], 581, 440, 403, 404, 529, 628, 441, 141, [0, 6], 271, 640, 641, 630, 506, [414, 2], 642, 643, 644, 60, 189, 175, 645, 239, 646, 633, 647, 506, 414, 420, 648, 610, 649, 536, 590, 650, [411, 9], 474, 636, 651, 652, 638, 653, 524, 562, 414, 506, 562, 622, 654, 655, 656, 631, 470, 657, 658, 659, 553, [414, 2], 660, 441, 442, 0, 0], [[0, 29], 4, 9, 33, 53, 365, 351, 54, 98, 252, 269, 122, 94, 551, 364, 226, 128, 661, 595, 589, 662, 663, 254, 302, 664, [549, 2], 536, 665, 666, 667, 668, 589, 67, 669, 670, 185, 88, 67, 92, 60, 519, 548, 671, 672, 673, 668, [667, 3], 663, 674, 586, 359, 231, 586, 589, 258, 397, 661, 675, 676, 53, [0, 4]], [[0, 27], 1, 57, 364, [676, 2], 391, 677, 360, 128, 244, 678, [186, 2], 669, 542, 98, 153, 679, 235, 631, 204, 680, 671, 637, 680, 190, 392, 519, 681, 590, 636, 682, 667, 671, 92, 93, 564, 397, 683, 231, 371, 218, 384, [371, 2], 612, 684, 637, [667, 2], 620, 586, 675, 620, 675, 669, 397, 676, [685, 2], 573, 542, 573, 53, [0, 4]], [[0, 27], 1, 686, 670, 687, 688, 689, 690, 223, 244, 691, 692, 88, 211, 615, 685, 94, 693, 694, 572, 645, 534, 160, 679, 695, 672, 696, 204, 218, 188, 392, 521, 697, 672, 619, 605, 67, 268, 255, 263, 254, 564, 674, 235, 263, 127, 177, 492, 698, 682, 699, 673, 632, 569, 673, 699, 687, 700, 259, 685, [573, 3], 698, 701, [0, 4]]]};

  // romejs/cli-diagnostics/banners/error.json

  const ___R$romejs$cli$diagnostics$banners$error_json$default = {'palettes': [[0, 0, 0], [15, 0, 0], [30, 15, 15], [30, 15, 30], [15, 15, 15], [75, 60, 60], [45, 30, 30], [30, 30, 30], [90, 75, 75], [120, 90, 90], [105, 75, 75], [60, 45, 45], [90, 75, 60], [90, 60, 60], [105, 90, 90], [180, 135, 135], [150, 120, 120], [165, 135, 120], [120, 105, 90], [150, 120, 105], [105, 75, 90], [45, 45, 45], [30, 30, 15], [195, 165, 165], [195, 165, 150], [165, 120, 120], [180, 150, 150], [165, 135, 135], [15, 0, 15], [75, 60, 45], [165, 150, 135], [210, 165, 165], [210, 180, 180], [225, 180, 180], [135, 105, 105], [60, 30, 30], [60, 60, 45], [210, 180, 165], [225, 195, 180], [225, 195, 195], [75, 45, 45], [45, 15, 15], [135, 120, 105], [180, 150, 135], [195, 150, 150], [135, 105, 90], [240, 210, 195], [240, 195, 195], [30, 15, 0], [150, 135, 120], [180, 165, 150], [240, 210, 210], [240, 195, 180], [105, 90, 75], [135, 120, 120], [225, 180, 165], [210, 165, 150], [240, 210, 180], [60, 45, 30], [120, 105, 105], [240, 225, 210], [225, 210, 195], [195, 150, 135], [75, 75, 60], [180, 165, 165], [240, 225, 225], [225, 195, 165], [195, 165, 135], [210, 150, 135], [210, 180, 150], [180, 135, 105], [195, 180, 165], [165, 120, 90], [165, 105, 75], [180, 120, 105], [210, 165, 135], [195, 135, 120], [225, 165, 150], [195, 150, 120], [210, 195, 180], [150, 90, 75], [225, 180, 150], [180, 120, 90], [195, 135, 105], [150, 75, 45], [180, 135, 120], [45, 15, 30], [210, 150, 120], [165, 105, 90], [165, 120, 105], [135, 90, 75], [135, 90, 90], [180, 120, 75], [165, 90, 60], [150, 90, 45], [135, 60, 30], [135, 75, 60], [150, 105, 75], [180, 150, 120], [15, 15, 0], [165, 135, 105], [240, 195, 165], [180, 105, 75], [165, 90, 45], [195, 135, 90], [150, 90, 60], [135, 90, 60], [150, 105, 90], [150, 135, 105], [45, 45, 30], [210, 135, 120], [195, 120, 90], [180, 105, 60], [165, 75, 45], [105, 75, 60], [210, 135, 105], [225, 150, 105], [225, 135, 105], [210, 120, 90], [195, 105, 75], [195, 120, 75], [195, 90, 60], [180, 90, 45], [150, 75, 30], [135, 75, 45], [240, 150, 105], [240, 135, 105], [210, 105, 75], [180, 90, 60], [195, 105, 60], [150, 75, 60], [135, 90, 45], [255, 150, 105], [240, 150, 120], [240, 165, 120], [240, 165, 135], [225, 120, 90], [180, 75, 45], [180, 75, 30], [165, 75, 30], [225, 150, 135], [255, 165, 120], [240, 180, 150], [255, 195, 165], [240, 150, 135], [210, 105, 60], [195, 90, 45], [150, 60, 15], [150, 60, 30], [45, 30, 45], [225, 165, 135], [255, 150, 120], [255, 210, 180], [225, 120, 75], [165, 90, 75], [195, 120, 105], [255, 210, 195], [255, 195, 180], [255, 180, 165], [240, 120, 90], [180, 105, 105], [120, 90, 75], [240, 135, 90], [255, 135, 105], [255, 180, 150], [195, 120, 120], [135, 120, 90], [255, 165, 135], [240, 180, 165], [165, 60, 30], [150, 60, 45], [180, 105, 90], [240, 165, 150], [255, 165, 150], [165, 75, 60], [165, 105, 60], [120, 105, 75], [240, 135, 120], [240, 120, 105], [195, 90, 75], [135, 45, 30], [255, 135, 90], [210, 120, 75], [225, 150, 120], [225, 135, 90], [240, 120, 75], [135, 45, 15], [75, 45, 30], [150, 120, 90], [240, 135, 75], [180, 75, 60], [150, 105, 105], [210, 105, 90], [135, 75, 30], [120, 90, 60], [255, 150, 135], [225, 120, 105], [120, 45, 15], [120, 60, 15], [210, 135, 90], [165, 60, 45], [105, 45, 0], [135, 105, 75], [180, 90, 75], [105, 60, 15], [225, 105, 75], [210, 90, 75], [210, 90, 60], [195, 75, 45], [105, 30, 0], [120, 75, 45], [120, 60, 30], [120, 30, 15], [120, 30, 0], [135, 30, 0], [150, 45, 15], [165, 45, 15], [165, 60, 15], [105, 30, 15], [105, 45, 15], [75, 60, 30], [105, 15, 0], [105, 0, 0], [120, 0, 0], [120, 15, 0], [135, 15, 0], [150, 30, 0], [90, 0, 0], [75, 0, 0], [75, 15, 0], [90, 15, 0], [90, 30, 0], [120, 60, 45], [45, 30, 15], [150, 45, 0], [165, 30, 0], [165, 45, 0], [180, 60, 30], [135, 45, 0], [120, 45, 0], [225, 165, 165], [105, 75, 45], [90, 30, 15], [120, 45, 30], [60, 30, 15], [180, 45, 0], [45, 0, 0], [90, 30, 30], [150, 45, 30], [120, 45, 45], [105, 60, 45], [30, 0, 0], [180, 60, 45], [195, 15, 0], [225, 135, 75], [105, 30, 30], [105, 15, 15], [60, 0, 0], [135, 30, 30], [180, 0, 0], [210, 0, 0], [195, 105, 90], [120, 30, 30], [165, 0, 0], [120, 75, 60], [210, 150, 105], [240, 150, 90], [135, 60, 45], [135, 60, 15], [165, 15, 0], [195, 0, 0], [195, 75, 30], [195, 60, 30], [180, 15, 0], [255, 150, 90], [165, 30, 15], [165, 45, 30], [105, 45, 30], [195, 75, 60], [90, 45, 15], [150, 30, 15], [180, 45, 30], [225, 105, 60], [225, 105, 90], [150, 15, 0], [210, 90, 45], [210, 120, 105], [90, 60, 45], [225, 135, 120], [225, 120, 60], [90, 45, 30], [135, 30, 15], [195, 105, 45], [75, 30, 15], [45, 15, 0], [180, 60, 15], [60, 15, 15], [195, 90, 30], [180, 75, 15], [165, 60, 0], [150, 75, 15], [105, 60, 60], [150, 60, 0], [180, 90, 30], [165, 75, 15], [180, 105, 45], [165, 90, 30], [180, 120, 60], [165, 105, 45], [150, 90, 30], [135, 60, 0], [120, 90, 105], [165, 150, 150], [75, 30, 0], [75, 30, 30], [135, 105, 120], [60, 15, 0], [135, 120, 135], [165, 135, 150], [90, 60, 75], [60, 60, 60], [75, 60, 75], [150, 135, 135], [255, 0, 0], [240, 0, 0], [225, 45, 15], [135, 75, 15], [105, 90, 105], [60, 45, 60], [195, 60, 15], [60, 30, 0], [75, 15, 15], [225, 30, 0], [120, 60, 0], [45, 30, 0], [225, 0, 0], [225, 15, 0], [195, 165, 180], [90, 75, 90], [150, 0, 0], [195, 30, 0], [210, 15, 15], [180, 150, 165], [150, 120, 135], [75, 75, 75], [75, 45, 15], [195, 45, 0], [210, 30, 30], [225, 60, 30], [210, 75, 30], [240, 45, 15], [210, 30, 15], [225, 75, 30], [180, 30, 0], [210, 15, 0], [105, 90, 60], [240, 210, 165], [225, 105, 45], [75, 45, 60], [60, 60, 30], [165, 120, 75], [60, 45, 15], [210, 105, 45], [225, 90, 45], [210, 30, 0], [240, 60, 30], [240, 45, 30], [210, 45, 15], [195, 150, 105], [105, 45, 45], [240, 15, 0], [240, 75, 45], [150, 45, 45], [150, 105, 60], [255, 75, 60], [45, 45, 15], [90, 90, 75], [180, 60, 0]], 'rows': [[[0, 52], 1, [0, 47]], [[0, 51], 2, [0, 4], 1, [0, 43]], [[0, 46], 3, 0, 0, 4, 1, 5, 6, 6, 1, 7, 2, 2, 4, 4, [0, 40]], [[0, 46], 5, 1, 0, 4, 8, 9, 10, 10, 8, 11, 12, 13, 11, 5, [0, 40]], [[0, 42], 4, [0, 3], 14, 6, 2, 5, 9, 15, 16, 17, 16, 18, 16, 19, 14, 20, 0, 1, 1, [0, 37]], [[0, 40], 11, 6, 21, 2, 3, 22, 16, 9, 8, 16, 17, 23, 23, 24, 25, 26, 23, 27, 27, 9, 0, 28, 14, [0, 37]], [[0, 37], 7, 0, 0, 6, 19, 5, 11, 29, 9, 30, 27, 15, 24, 23, 31, 23, 24, 32, 31, 32, 33, 24, 27, 11, 5, 34, 9, 35, 6, [0, 4], 11, 28, [0, 28]], [[0, 31], 4, [0, 3], 2, 36, 12, 6, 13, 18, 18, 27, 13, 19, 16, 24, 31, 33, 32, 32, 37, 31, 24, 32, 38, 38, 39, 32, 26, 34, 10, 34, 23, 13, 40, 28, 41, 2, 10, 42, 2, [0, 28]], [[0, 31], 7, 0, 0, 1, 12, 9, 19, 19, 10, 24, 17, 43, 24, 31, 44, 31, 38, [33, 4], 37, 37, 33, [39, 4], 33, 44, 19, 16, 31, 23, 27, 45, 17, 16, 14, 9, 6, [0, 28]], [[0, 27], 4, 0, 7, 0, 11, 21, 11, 11, 14, 43, 26, 17, 43, 38, 31, 31, 33, 46, [38, 7], 33, 38, [39, 3], 38, 39, 38, 47, 37, 17, 23, 31, 44, 27, 27, 9, 16, 15, 48, 0, 1, 1, [0, 25]], [[0, 27], 4, 11, 13, 8, 16, 9, 16, 18, 49, 26, 39, 16, 50, 46, 39, 38, 39, 51, 46, 52, 38, 52, 38, 38, 52, 38, 38, 39, 39, 46, 38, 47, 46, 47, 47, 33, 32, 37, 31, 17, 27, 23, 31, 31, 16, 53, 8, 1, [0, 25]], [[0, 25], 21, 11, 5, 8, 54, 27, 37, 27, 26, 31, 33, 49, 32, 55, 24, 38, 46, 47, 47, 51, 46, 38, [55, 3], 52, 52, 33, 56, 47, 39, [47, 3], 46, 47, 46, 47, 38, 33, 37, 31, 31, 32, 31, 26, 16, 16, 10, [0, 26]], [[0, 26], 14, 18, 14, 16, 37, 33, 38, 38, 24, 38, 24, 37, 38, 56, 52, 46, 57, 38, 46, 47, 31, 56, 37, 37, 55, 52, 55, 37, 52, [33, 3], 38, 39, 39, 46, 47, 46, 38, 55, 33, 32, 33, 24, 16, 32, 27, 34, 12, 5, 6, [0, 23]], [[0, 25], 28, 58, 26, 59, 43, 38, 33, 39, 60, 61, 38, 57, 24, 38, 55, 46, 55, 56, 37, 46, 33, 24, 56, 24, 38, 31, 37, 62, 55, 33, 55, 37, 31, 33, 47, 39, 33, 52, 46, 38, 55, 38, 33, 33, 31, 17, 23, 27, 27, 63, 14, 1, 0, 7, [0, 21]], [[0, 25], 1, 0, 64, 5, 49, 39, 38, 47, 65, 60, 38, 46, 66, 57, 52, 52, 67, 68, 69, 46, 55, 38, 56, 70, 62, 55, 56, 56, 31, 31, 37, 55, 55, 37, 39, 38, 38, 33, 52, 47, 38, 38, [33, 3], 44, 31, 26, 27, 8, 6, 13, 20, 13, [0, 21]], [[0, 23], 4, 6, 8, 1, 71, 34, 34, [46, 3], 60, 51, 46, 57, 66, 66, 55, 52, 62, 72, 66, 55, 55, 31, 55, 73, 74, 68, 68, 62, 62, 56, 37, 56, 33, 55, 37, 33, 52, 38, 33, 46, 38, 33, 37, 33, 33, 37, 37, 23, 44, 17, 27, 42, 34, 13, 1, [0, 20]], [[0, 24], 14, 5, 59, 23, 44, 19, 38, [46, 4], 52, 55, 55, 75, 55, 69, 76, 73, 56, 62, 77, 55, 55, 68, 74, 62, 76, 78, 74, 62, [56, 3], 55, 37, 31, 33, 55, 33, 47, 33, 33, 37, 39, 38, 37, 37, 32, 26, 34, 53, 27, 9, 7, [0, 21]], [[0, 21], 1, 2, 2, 8, 16, 42, 79, 37, 19, 17, 46, 57, 52, 52, 55, 56, 55, 75, 69, 75, 70, 76, 76, 62, 56, 38, 56, 56, 55, 56, 74, 80, 76, 70, 75, [62, 4], 24, 55, 56, 37, 31, 33, 55, 33, 33, 38, [37, 3], 19, 53, 43, 27, 63, 0, 4, [0, 20]], [[0, 22], 2, 13, 45, 43, 43, 37, 52, 31, 67, 81, [52, 3], 69, 69, 55, 81, 56, 56, 76, 68, 82, 83, 75, 55, 62, 56, 56, 75, 80, 84, 72, 83, 85, 78, 78, 72, 78, 24, 69, 78, 56, 62, 31, 24, [37, 5], 31, 17, 30, 62, 34, 0, 11, 4, 2, [0, 19]], [[0, 22], 86, 11, 42, 17, 37, 62, 55, 38, 56, 75, [55, 4], 67, 75, 81, 56, 75, 75, 87, 73, 73, 88, 69, 78, 70, 70, 62, 72, 84, 80, 75, 74, 85, 89, 90, 72, 85, 75, 85, [62, 3], 56, 37, 56, 37, 55, 37, 31, 17, 24, 44, 35, 5, 5, 36, 11, [0, 19]], [[0, 21], 4, 4, 91, 53, 17, 37, 55, 69, 52, 66, 75, 62, 81, 56, 81, 75, 68, 81, 69, 70, 78, 87, 92, 93, 94, 78, 83, 82, 82, 88, 82, 95, 96, 78, 82, 74, 97, 72, 97, 74, 89, 85, 85, 98, 62, 56, 62, 56, 56, 62, 56, 31, 44, 43, 44, 9, 16, 12, 8, 11, 21, 99, [0, 17]], [[0, 20], 7, 2, 40, 19, 37, 43, 100, 38, 66, 66, 101, 75, 78, 62, 68, 68, 87, 75, 78, 77, 74, 83, 76, 83, 102, 103, 102, 104, 102, 105, 95, 82, 95, 105, 100, 76, 106, 107, 96, 72, 80, 90, 72, 89, 85, 56, 43, 43, 62, 67, 62, 24, 37, 56, 24, 43, 108, 43, 26, 34, 8, 109, 1, [0, 17]], [[0, 20], 11, 11, 9, 45, 17, 69, 55, 85, 55, 55, 66, 75, 70, 83, 83, 110, 87, 87, 111, 87, 83, 82, 82, 111, 112, 113, 103, [102, 2], 84, 84, 73, 95, 88, 97, 88, 106, 96, 106, 88, 97, 97, 72, 72, 85, 62, 85, 85, 98, 98, 62, [24, 3], 56, 62, 62, 17, 18, 63, 4, 21, 6, [0, 17]], [[0, 21], 12, 53, 114, 107, 43, 66, 66, 52, 55, 81, 87, 83, 115, 116, [117, 3], [115, 2], 118, 119, 102, 120, 119, 121, 122, 113, 93, 123, 93, 84, 105, 73, [124, 4], 97, 106, [105, 2], 97, 80, 70, 76, 85, 85, 98, 17, 62, 62, 56, 44, 24, 56, 43, 19, 12, 22, 29, 8, 1, [0, 17]], [[0, 20], 58, 58, 34, 43, 56, 24, 56, 55, 81, 81, 75, 68, 110, 117, [125, 2], [126, 2], 117, [115, 2], 118, 115, 117, 118, 127, 121, 128, [122, 2], 129, 128, 94, 94, 105, 130, 84, [124, 3], [105, 2], 131, 73, 83, 72, 74, 70, [62, 3], 98, 24, 43, 43, 56, 62, 45, 19, 18, 5, 99, [0, 18]], [[0, 20], 8, 114, 40, 34, [55, 3], 66, 66, 56, 78, 76, 110, 126, 125, [132, 2], 133, 134, [135, 5], 133, 136, 127, 121, 137, 122, 138, 122, 103, 139, [123, 3], 95, 95, 84, 84, 124, 105, [82, 4], 72, 89, 62, 67, [62, 3], 43, 24, 62, 17, 19, 13, 1, [0, 19]], [[0, 20], 5, 50, 19, 43, 56, 55, [66, 3], 81, 75, 140, 133, [125, 2], [132, 2], 141, 142, 143, [101, 3], 142, 144, 126, 136, 145, 121, 146, 122, 138, [139, 3], 147, [148, 2], 123, 84, 84, 105, 88, [82, 3], 73, 88, 89, 85, 67, 56, [62, 3], 24, 24, 43, 17, 44, 40, [0, 19]], [[0, 20], 149, 42, 37, [107, 2], 85, 69, 66, 55, 56, 77, 150, 133, 125, 126, 132, 151, 135, 143, 152, [52, 3], 101, 144, 126, 136, 153, 127, 145, 121, 122, 137, 138, [139, 2], [123, 2], 84, 84, 130, 154, 74, 74, 155, 82, 73, 154, 89, 76, [85, 3], 62, 43, 24, 37, 56, 43, 45, 1, [0, 19]], [[0, 21], 109, 18, 69, 55, [66, 3], 69, 56, 81, 135, 125, [126, 3], 151, 142, 143, 156, 152, 101, 157, 158, 133, 126, 159, [153, 3], 145, 121, 146, 122, [137, 2], 113, 139, 113, 130, 154, 160, 74, 76, 83, 82, 73, 154, 82, 68, 56, 85, 43, 62, 44, 44, 56, 62, 114, 161, 2, 5, 6, [0, 17]], [[0, 20], 4, 29, 45, 90, 98, 69, 66, 55, 75, 56, 55, 135, 126, [162, 2], 163, 151, 164, 157, 152, 52, [157, 2], 164, 133, 126, 136, [153, 3], 127, [121, 2], 122, 137, 113, 139, [148, 2], 84, 154, 160, 165, 83, [155, 2], 73, 73, 72, 62, 33, 55, 31, 56, 37, 55, 55, 56, 43, 25, 27, 19, 11, [0, 17]], [[0, 19], 6, 58, 10, 166, 75, 81, 69, 69, 75, 77, 75, 142, 144, [162, 3], 163, 132, 167, 164, 158, 168, 143, 142, 144, 126, [136, 2], [153, 2], [127, 2], [121, 2], 128, 137, 113, 169, [148, 2], 170, 130, 154, 171, 82, 76, 155, 73, 73, 74, 85, 31, 33, 52, 38, 38, 46, 38, 38, 33, 24, 15, 10, 5, 6, [0, 16]], [[0, 19], 6, 10, 5, 42, 98, 81, 55, 55, 81, 75, 150, 172, 133, [162, 4], 163, 133, 135, 167, 164, 173, 144, 133, 126, [136, 2], 153, [127, 3], 121, [128, 3], 113, [148, 4], 170, 174, 154, 155, 76, 155, 93, 175, 74, 62, 62, 24, 55, [46, 3], 47, 39, 38, 37, 24, 27, 9, 6, 1, [0, 15]], [[0, 19], 6, 176, 17, 43, 67, 75, 75, 55, 81, 75, 77, 150, 125, [162, 4], 126, 125, 133, [135, 3], 133, 177, 178, [136, 2], 153, [127, 2], 119, 179, [128, 2], 93, 174, 84, [148, 2], 180, 95, 84, 93, 171, 155, 171, [105, 2], 88, 76, 62, 62, 24, 37, 55, 38, 33, 47, 33, 23, 17, 27, 34, 9, 6, [0, 15]], [[0, 19], 4, 6, 161, 43, 24, 75, 81, 52, 81, 77, 81, 150, 117, [162, 2], 181, 162, 126, 163, 151, 133, [144, 2], 133, 126, [136, 2], 118, 182, 127, [119, 3], 128, 93, 93, 174, 170, 148, 95, 180, 95, 95, 130, 154, [171, 2], 94, 105, 88, 76, [85, 3], [62, 3], 56, 31, 24, 37, 24, 62, 34, 6, [0, 16]], [[0, 18], 4, 6, 29, 40, 161, 98, 56, 66, 55, 55, 77, 150, 183, 184, 185, 162, 181, [163, 2], 126, 133, [135, 2], 144, 133, 177, 117, [136, 2], 118, 182, [119, 3], 128, 93, 174, 113, 170, 95, 180, [186, 2], 95, 84, 154, 73, 93, 93, 154, 74, 85, [62, 4], 98, 62, 24, 56, 56, 31, 43, 17, 9, 6, [0, 16]], [[0, 18], 99, 187, 114, 188, 45, 89, 69, 66, 55, 81, 87, 87, 183, 184, 159, 162, 163, [126, 2], 151, [135, 4], 133, 177, [136, 3], [118, 2], 127, [119, 2], [128, 2], 174, 113, 148, 95, 95, [186, 2], 95, 95, 130, 171, 103, [105, 2], 74, 56, 62, 17, 85, 85, 43, 62, 62, 24, 56, 37, 37, 43, 34, 161, 11, [0, 15]], [[0, 18], 1, 22, 35, 107, 43, 56, 37, 69, 69, 75, 87, 150, 183, 153, 189, [162, 2], 163, 132, 151, [167, 2], [135, 2], [133, 2], 117, [136, 2], [118, 2], [127, 2], 119, 179, 190, 113, [170, 2], 148, [95, 4], 84, 95, 95, 123, 84, 80, 89, 191, 43, 85, 89, [85, 3], 62, 24, 56, 37, 55, 24, 16, 59, 5, 2, [0, 14]], [[0, 20], 6, 161, 17, 43, 24, 56, 75, 87, [150, 2], 117, 184, 189, [162, 2], [163, 2], 151, [135, 3], [133, 2], 126, 117, 136, [118, 2], 136, 192, 127, 119, 179, 128, 113, 170, [148, 3], [95, 6], 193, 84, 80, 88, 89, 107, 89, 85, 17, 85, [62, 3], 55, 55, 56, 19, 9, 10, 11, [0, 15]], [[0, 21], 29, 194, 45, 67, 67, 68, 87, 83, 115, 184, [162, 4], [163, 2], 151, 195, [167, 2], 133, 126, 196, 136, 118, 127, [136, 2], 118, 127, 119, 179, 128, 113, 169, [148, 4], [95, 5], 197, 198, 124, 97, [107, 4], 19, 89, 85, 62, 56, [55, 3], 24, 42, 29, 4, [0, 15]], [[0, 20], 6, 40, 45, [98, 3], 78, 78, 83, 199, 153, [162, 3], 181, [163, 4], 151, 133, [126, 2], 117, 136, [127, 2], 118, 136, 118, 127, 119, 179, 128, 174, 200, [148, 5], [95, 4], [201, 2], 198, 106, 107, 188, 107, 202, 89, 85, 98, 56, 55, 52, 38, 24, 19, 29, 2, 1, [0, 15]], [[0, 21], 4, 29, 187, 58, 70, 70, 73, 92, 182, [162, 4], 181, [162, 4], [126, 2], 196, [136, 2], [127, 4], 136, 127, 119, [179, 2], 203, 174, 170, 148, [95, 7], 198, [201, 3], 204, 106, 107, [89, 3], 85, 85, 56, 37, 55, 55, 44, 45, 5, 6, [0, 16]], [[0, 23], 29, 161, 70, 70, 72, 102, 153, [162, 5], 126, 162, [159, 3], [136, 2], 205, [127, 2], 121, [179, 2], 127, 206, 179, 121, [128, 2], 84, 84, 170, [95, 4], 84, 84, 95, 197, [201, 5], 96, 97, 107, 19, 85, 85, 62, 56, 56, 24, 62, 16, 10, 6, [0, 16]], [[0, 23], 36, 42, 100, 78, 82, 118, 162, 189, 162, 153, 159, 162, [126, 2], 159, [136, 2], 127, [207, 2], 121, 208, 121, [128, 2], 127, 207, 128, 190, [174, 2], 130, 174, 84, 170, [84, 4], 130, 84, 197, 201, [209, 2], [201, 3], 210, 72, 107, 89, 85, 98, 56, 56, 24, 62, 19, 53, 11, 2, [0, 15]], [[0, 22], 1, 187, 12, 85, 78, 83, 184, 189, [153, 3], 146, 122, 119, 179, [128, 2], [113, 3], [137, 2], 138, [137, 3], 121, 208, 139, [148, 2], 170, 84, 84, [124, 2], 84, 84, 93, 93, 73, 93, 211, 201, [209, 3], [201, 2], 204, 106, 188, 107, 89, 98, 62, 24, 56, 24, 43, 9, 5, 7, [0, 15]], [[0, 22], 1, 161, 100, 78, 78, 82, 184, 136, [153, 2], 121, 137, 148, 186, 180, 197, 212, [213, 2], 214, [215, 2], 216, [137, 2], 113, 137, 138, 217, [186, 2], 212, [218, 2], 219, 197, 211, [198, 2], 124, 105, 93, 124, 201, [209, 3], [201, 2], 204, 106, 89, 202, 107, 89, 43, 62, 89, 161, 13, 11, 2, 2, [0, 15]], [[0, 22], 99, 220, 89, 75, 83, 111, 184, [153, 2], 145, 146, 139, 148, 186, 213, 221, 222, 223, 224, 225, [226, 2], 216, 138, 137, 113, 137, 169, 215, 214, 213, 221, 227, [228, 2], [229, 2], 230, [231, 2], 219, 84, 130, 197, [209, 4], 201, 198, 232, 188, 90, 89, 43, 56, 56, 15, 45, 19, 18, 53, 5, 2, [0, 14]], [[0, 23], 233, 90, 150, 83, 118, 162, 189, 153, 129, [122, 2], 113, [169, 3], 216, [234, 2], 235, [226, 2], 236, 237, [137, 2], 139, 215, 238, 213, 209, [213, 2], [209, 2], 212, [197, 2], 219, [209, 2], 219, 95, 198, [201, 2], 239, [197, 3], 106, 89, 89, 85, 85, 77, 240, 55, 62, 45, 29, 109, 11, [0, 15]], [[0, 23], 109, 241, 83, 111, 199, [162, 2], 153, 145, 146, 208, 237, 215, 186, 218, 230, 228, 221, 214, 234, [226, 2], 138, 129, 121, 113, 186, 239, 213, [209, 2], 221, 227, 229, [242, 2], 219, 243, 218, [209, 2], 197, 201, 209, 201, 197, 198, 95, 95, 105, 70, 62, 85, 62, 155, 179, 78, 62, 17, 6, 0, 4, [0, 15]], [[0, 23], 4, 244, 83, 111, 184, [162, 2], 153, 145, 146, 245, 225, 223, 218, 246, 2, 40, 247, 180, 215, 248, 234, 146, 184, 127, 113, 238, 239, [197, 2], 213, 224, 249, 250, 35, 21, 251, 246, 229, [209, 3], [201, 2], 239, 198, 95, [193, 2], 105, 72, 98, 62, 74, 252, 253, 111, 85, 27, 49, 13, 28, [0, 15]], [[0, 24], 58, 87, 111, 254, [189, 2], 162, 185, 145, 208, 121, 252, 170, 255, 227, 256, 180, 248, 169, 200, 217, 136, 133, 118, 137, 238, 239, [197, 3], 248, 170, 96, 228, [257, 2], 247, 230, 227, 230, 209, [201, 2], 239, 198, 95, 193, 84, 175, 72, 70, 85, 258, 259, 260, 102, 17, 16, 34, 12, [0, 16]], [[0, 22], 1, 6, 90, 87, 119, 153, [189, 2], 162, 126, 162, 125, 133, 117, 261, 203, [200, 4], 113, 200, 121, 125, 133, 118, 137, 186, [239, 2], 197, 95, [170, 2], 248, 180, [262, 2], 197, 212, [209, 2], 201, [239, 3], 95, 124, 95, 193, 73, 82, 70, 171, 223, 263, 260, 190, 58, 2, 2, 5, 11, [0, 15]], [[0, 22], 2, 1, 264, 265, 112, 153, [189, 2], 266, 151, 134, 162, [136, 2], 127, 121, 252, [237, 2], 169, 137, 121, 126, 167, 133, 127, 169, 215, [239, 2], 197, 186, [148, 3], [170, 2], [267, 2], 95, 197, 209, 201, [239, 2], 197, [95, 3], 268, 105, 82, 72, 130, 223, 269, 270, 171, 13, 6, [0, 18]], [[0, 24], 244, 92, 122, 153, 185, 162, 132, [125, 2], 126, 205, 271, 272, [237, 3], 137, 121, 127, 162, 133, 135, 117, 121, 169, 215, 238, [239, 2], 186, [170, 2], 148, 215, 180, 148, 95, 186, [239, 2], 197, 95, 95, 148, 170, 95, 95, 268, 84, 175, 82, 148, 214, 235, 273, 155, 19, 11, [0, 18]], [[0, 23], 1, 251, 124, 122, 153, 185, 162, 274, 132, 125, 126, 159, 205, 127, [207, 2], 127, 118, 136, [126, 2], 151, 135, 136, 121, 148, 215, 186, [239, 2], 238, [148, 2], 170, [148, 3], [186, 3], 95, 84, 93, [174, 2], 84, 95, [268, 2], 95, 84, 93, 214, 226, 275, 276, 85, 12, 48, [0, 18]], [[0, 25], 277, 145, 153, 185, 162, 181, 132, 133, 167, 151, [133, 4], [144, 2], 133, [163, 2], 195, 135, 136, 121, 215, [186, 2], 239, 213, 238, 215, [148, 3], 169, [148, 2], 169, [148, 4], 113, 93, 93, 84, 268, 239, 268, 130, 174, [226, 2], 216, 154, 19, 114, 6, [0, 18]], [[0, 25], 277, 205, 153, 185, 189, 181, 163, 132, [167, 6], 173, 167, 151, [126, 2], 167, 173, 196, 278, 215, 213, 186, [239, 2], 238, 148, [169, 7], 148, [215, 2], [148, 2], 113, 93, 84, 268, 197, 84, [203, 2], 226, 235, 216, 171, 34, 19, 233, [0, 18]], [[0, 25], 279, [153, 2], [185, 2], [181, 2], 132, 167, [173, 3], [167, 3], 151, 126, [162, 2], 151, 144, 136, 278, 186, 213, [239, 2], 238, 186, [200, 2], [137, 2], [169, 5], 148, 147, 268, 95, 84, 93, 93, 123, 84, 93, 111, 261, 280, 275, 281, 78, 62, 89, 11, 1, [0, 17]], [[0, 25], 277, 205, 153, [185, 2], 181, [163, 2], 133, 167, 164, 173, 195, 177, 126, 205, 282, 162, 125, 167, 144, 283, 137, 186, 209, 201, [239, 2], 148, 113, [137, 4], 138, 237, 137, [113, 2], 148, [268, 2], 148, 113, 93, 84, 84, 128, 102, 179, 284, 216, 237, 70, 45, 233, 11, 22, [0, 17]], [[0, 25], 211, 127, 153, [185, 2], 181, [163, 2], 126, 144, 135, [178, 2], 159, 205, 285, 153, [125, 2], 173, 133, 127, 252, 186, 213, [209, 2], 239, 95, 113, 137, [128, 2], [137, 4], 113, 93, 174, 148, 268, 84, 113, 93, 84, 84, 93, 102, 119, 286, 128, 190, 89, 45, 287, 2, [0, 18]], [[0, 25], 211, 127, 153, [185, 2], [181, 3], 126, 151, 126, 283, 205, 127, 207, 271, [126, 3], 177, 118, 179, 113, 186, 213, 209, 239, 201, 197, 169, 137, [128, 3], [137, 2], [113, 2], [93, 3], 84, 123, 93, 128, 84, 84, 103, 128, 261, 288, 118, 286, 75, 98, 13, [0, 19]], [[0, 25], 124, 127, 289, [185, 2], [159, 3], [126, 3], 136, 207, 146, 271, 208, [153, 3], 145, 208, 137, 148, 186, [213, 5], 215, [137, 2], [128, 3], 137, 169, 148, 113, [93, 3], 84, 103, 93, 103, 123, 84, 93, 203, 261, [140, 2], 89, 6, 11, 2, [0, 18]], [[0, 25], 211, 145, 289, [185, 5], [159, 2], 136, 127, 207, [208, 3], 272, 216, 146, 138, 217, 234, 238, 213, [209, 2], [213, 3], 214, 113, 137, [128, 3], 113, 148, 215, 148, 84, 84, [103, 3], 93, 103, [84, 3], 102, 288, 286, 155, 264, 22, [0, 20]], [[0, 25], 290, 145, 289, [185, 6], [205, 2], 127, 121, 137, 127, 177, 283, 275, [226, 2], 214, 213, 209, 221, 218, [221, 3], 213, 186, 148, [137, 3], 190, 113, 148, 248, 186, 268, [123, 2], 84, 113, 93, 103, 123, 84, 84, 93, 192, 133, 111, 287, [0, 21]], [[0, 25], 241, [145, 2], [153, 4], [205, 3], 145, 121, 137, 127, 177, 133, 144, 127, 137, 291, 224, [221, 2], [230, 2], [221, 3], 212, 180, 148, 113, [137, 2], 113, 200, [148, 2], 186, 197, 95, 95, 148, 123, 93, 103, [123, 2], 84, 103, 252, 208, 119, 175, 48, [0, 20]], [[0, 25], 73, [145, 2], [153, 2], [282, 4], 207, 121, 208, 121, 136, [126, 2], 177, 127, 128, 148, 213, 212, 221, 230, [221, 4], 212, 243, 170, 113, [169, 3], 148, 147, 268, [239, 3], 197, 186, 148, 113, 103, 123, 148, 123, 113, 248, 280, 80, [277, 2], [0, 20]], [[0, 25], 219, 292, [145, 2], [282, 3], 207, 285, [208, 2], 137, [121, 2], [127, 3], 128, 169, 215, 213, 243, 212, 209, 221, 209, 230, [221, 2], 243, 180, [148, 2], 169, [147, 2], 186, 238, 239, 213, [209, 2], 239, [268, 2], 103, 123, 84, 148, 139, 102, 130, 293, 294, 279, [0, 20]], [[0, 25], 209, 93, [145, 3], [285, 3], 271, [138, 3], 137, 139, [137, 2], 139, [147, 2], 238, 213, 197, 239, 209, 221, [230, 4], 221, 209, 213, 238, [215, 2], [238, 3], 239, 213, [209, 2], 239, [268, 2], 84, 123, [148, 2], 123, 261, 210, 294, 187, 244, [0, 20]], [[0, 25], 246, 139, [145, 2], [285, 2], 146, 271, 295, 236, [147, 3], 238, [123, 2], 139, 147, 238, 186, [209, 2], 239, 213, 209, [230, 2], [229, 3], [230, 2], 209, 213, [238, 3], [213, 3], [209, 3], 186, 268, 123, 268, [148, 2], 123, 119, 105, 210, 296, [0, 21]], [[0, 26], 277, 129, 121, 146, 297, 271, 298, 299, 234, [238, 2], [239, 2], 268, 147, 300, 147, [238, 2], [214, 2], 186, [213, 2], 221, [230, 2], 257, 228, 257, 228, 230, 221, 213, [238, 2], [213, 2], [209, 4], 239, [268, 5], 148, 113, 123, 277, 1, [0, 21]], [[0, 26], 294, 122, [146, 2], [138, 2], 295, 299, 217, 147, 239, 230, 221, 213, 224, 214, [225, 2], 284, [226, 3], 225, 224, 222, [227, 2], 228, 229, [257, 3], 229, 213, 238, 239, 213, [209, 4], 231, 209, [239, 4], 186, 148, 107, 301, [0, 23]], [[0, 27], 84, [146, 2], 138, [298, 2], [138, 2], 302, 239, 230, 224, 214, 226, 169, 137, 200, 169, 248, 215, [291, 2], 186, 291, 212, 213, 221, 230, 228, [246, 2], 228, 213, 238, 239, [209, 3], [231, 3], 209, 201, 239, [201, 2], 239, 95, 25, 8, 3, [0, 22]], [[0, 27], 277, 146, 208, 138, 298, [138, 3], 234, 209, 221, 215, 137, [121, 2], 129, 138, 139, [169, 2], [215, 2], 248, 95, 186, 213, 209, 213, 209, 229, 246, 257, 209, 213, 209, [231, 3], [209, 2], 231, [209, 5], 239, 267, 16, 13, 11, [0, 22]], [[0, 27], 294, 137, [138, 5], 217, 238, 221, 214, 137, 145, [127, 2], 122, 303, 139, 103, 147, [186, 2], 268, [239, 2], [213, 4], 209, 228, 257, 221, [209, 2], [231, 2], [209, 4], 230, [231, 3], 209, 239, 107, 59, 11, 59, 11, [0, 21]], [[0, 28], 95, [138, 4], 304, 302, 213, 230, 239, 139, 121, 127, 145, 292, [305, 2], 306, 268, 193, [268, 2], 239, 268, 238, [213, 2], 209, 230, 228, 257, 230, 209, 221, [231, 2], [209, 4], [230, 4], 209, 201, 27, 35, 21, 14, 20, [0, 21]], [[0, 28], 244, 139, 138, [298, 2], 217, 234, 213, 219, 239, 147, 121, 127, 145, 119, 182, 307, 308, 103, 308, 309, 123, [300, 2], 310, 238, 213, 209, 229, 257, 246, 229, 230, 221, [209, 6], [230, 2], 229, [231, 2], 250, 14, 2, 8, 311, 14, [0, 21]], [[0, 29], 95, 217, 295, [217, 2], 234, 238, 209, 239, 148, 121, 127, 118, [184, 2], 199, [112, 2], 120, 112, 103, 139, 300, 268, 239, 209, 230, 257, [246, 2], 229, 230, [209, 2], 201, [239, 2], [209, 2], 230, [229, 2], 230, 231, 9, 6, 6, 8, 312, 6, [0, 21]], [[0, 29], 293, [217, 3], 299, [302, 2], [239, 2], 148, 121, 127, 126, 117, 118, 119, 129, 122, 129, 92, 175, 148, 147, 268, 197, 209, 228, 246, [251, 2], 229, 231, [209, 2], [239, 3], 209, [230, 2], 229, 230, 229, 13, 5, 2, 11, 312, 8, 8, 1, [0, 20]], [[0, 30], 186, [217, 4], 302, 209, 239, 123, 129, 127, 136, 118, 127, [129, 2], 112, [139, 2], 103, 148, [239, 3], 231, 257, 246, 251, 246, 313, [209, 3], [239, 2], [209, 2], 230, [229, 3], 314, 8, 2, 7, 54, 54, 8, 315, 11, 2, 22, [0, 18]], [[0, 30], 293, [234, 2], [299, 2], 302, 209, 239, 123, 122, 207, 127, 128, 112, 137, [122, 2], 139, 234, 186, 95, 239, 197, 230, 229, 257, [251, 2], 294, [231, 2], 209, 201, 239, [209, 2], 230, [229, 3], 316, 13, 86, 4, 14, 311, 5, 317, 318, 319, 1, 6, 5, 6, [0, 16]], [[0, 30], 1, 95, [234, 2], 302, 234, 230, 231, 239, 139, 146, 121, 139, 122, 103, 175, 123, 139, 147, 238, 197, 213, 209, 229, 316, 246, [251, 2], 246, 231, [209, 5], [230, 2], 229, 313, 229, 5, 11, 1, 320, 14, 5, 8, 23, 16, 5, 1, 1, 6, 5, 5, 4, [0, 14]], [[0, 30], 11, 290, 234, 238, 234, 238, 213, 228, 231, 197, 148, 139, 147, 103, [175, 2], 123, 103, 268, [209, 2], 230, 229, 257, [246, 2], [251, 2], 246, 231, [209, 4], [230, 3], 229, 316, 6, 11, 1, 6, 321, 5, 320, 322, 54, 311, 319, 6, 2, 6, 11, 5, 8, 21, [0, 13]], [[0, 22], 260, [323, 11], 324, 213, 209, [229, 2], 230, 275, [323, 5], 325, 123, 326, 209, 229, 257, [246, 2], 251, 260, [323, 4], [231, 4], 260, [323, 4], 8, 1, 4, [11, 3], 14, 311, 8, 5, 8, 11, 4, 0, 1, 6, 8, 327, 8, 6, [0, 11]], [[0, 22], 260, [323, 11], 324, [209, 2], 231, [229, 2], 260, [323, 5], 324, 268, 198, 231, 257, 246, [251, 3], 260, [323, 4], [230, 4], 260, [323, 4], 2, 1, 21, 109, 7, 321, 8, 328, 14, 10, 2, 22, 1, 0, 2, 14, 5, 5, 8, 327, 8, 2, [0, 9]], [[0, 22], 260, [323, 11], 324, 201, 230, 229, 230, 221, 324, [323, 6], 329, 198, 231, 246, 251, 1, [251, 2], 260, [323, 4], [230, 4], 260, [323, 4], 0, 7, 2, 2, 11, 5, 11, 11, 54, 8, 2, 29, 6, 1, 6, 5, 59, 322, 315, 8, 322, 54, 8, 4, [0, 7]], [[0, 22], 260, [323, 4], 220, 330, [244, 2], 294, 331, 123, 231, [209, 2], 230, 228, 259, [323, 7], 332, 333, 231, [251, 5], 260, [323, 4], 229, [230, 2], 229, 260, [323, 4], 4, 2, 28, 6, 11, 11, 7, 322, 9, 5, 2, 14, 40, 1, 22, 8, 64, 26, 16, 315, 14, 26, 318, 322, 59, 11, [0, 5]], [[0, 22], 260, [323, 4], 244, 334, 244, 294, 246, 229, 122, 239, [221, 2], [227, 2], 335, [323, 3], 336, [323, 4], 302, 230, 246, 251, [246, 3], 260, [323, 4], 228, 229, 257, 246, 260, [323, 4], 0, 1, 7, 6, 6, 2, 8, 27, 10, 35, 5, 59, 40, 1, 6, 322, 337, 26, 59, 20, 14, 338, 14, 311, 59, 59, 14, 6, [0, 3]], [[0, 22], 260, [323, 4], 334, 187, 41, 316, 246, 257, 122, 137, 213, [221, 2], 339, [323, 4], 236, 336, [323, 3], 340, 229, [257, 2], [229, 2], 257, 260, [323, 4], 246, [251, 2], 6, 341, [323, 4], 0, 4, 7, [2, 3], 54, 9, 14, 58, 14, 9, 35, 1, 8, 312, 342, 343, 13, 58, 5, 8, [14, 3], 8, 321, 5, 344, 5, 2], [[0, 22], 260, [323, 4], [244, 2], 316, 257, 246, 345, [292, 2], 146, 238, 224, 260, [323, 3], 335, 238, 346, [323, 3], 324, 230, 228, [230, 3], 229, 260, [323, 4], 1, 1, 11, 11, 347, [323, 4], 1, 4, 4, [2, 3], 317, 311, 8, 13, 59, 10, 41, 2, 59, 322, 16, 10, 58, 58, 35, 35, 8, [311, 3], 59, 311, 14, 8, 14], [[0, 22], 260, [323, 11], 348, 292, 146, 234, 324, [323, 3], 253, 238, 122, 324, [323, 3], 263, [221, 2], 230, 231, 230, 260, [323, 4], 1, 6, 8, 14, 260, [323, 4], 1, 1, 2, 6, 1, 6, 54, 54, 13, 10, 311, 13, 251, 6, 343, 59, 13, 11, 58, 58, [233, 2], 5, 54, 322, 16, 311, 14, 315, 54, 59], [[0, 22], 260, [323, 11], 348, 146, 292, 349, [323, 3], 324, 284, 225, 147, 350, [323, 3], 260, [221, 2], [209, 3], 260, [323, 4], 109, 8, 34, 5, 260, [323, 4], 1, 1, 6, 2, 0, 320, 54, 54, 5, 319, 8, 11, 1, 5, 315, 13, 11, 40, 6, [233, 2], 6, 14, 343, 311, 20, 20, 54, [322, 2], 318], [[0, 20], 1, 2, 351, [323, 11], 352, 297, 146, 325, [323, 3], 335, [214, 3], 353, [323, 3], 324, 214, [213, 2], 221, 230, 260, [323, 4], 8, 5, 5, 1, 260, [323, 4], 1, 7, 22, 1, 1, 8, [315, 2], 20, 319, 29, 6, 2, 8, 10, 35, 5, 40, 6, [233, 2], 29, [8, 3], 311, 343, 318, 322, 16, 343], [[0, 15], 99, 2, 2, 22, 233, 109, 58, 341, [323, 4], 330, 313, 294, 175, 306, 122, [282, 2], 285, 271, 324, [323, 3], 340, [226, 4], 324, [323, 3], 273, 224, 221, 227, 228, 260, [323, 4], 14, 0, 1, 0, 260, [323, 4], 2, 7, 4, 0, 4, 14, 54, 54, 14, 13, 35, 251, 2, 11, 58, 11, 5, 40, [233, 2], 58, 29, 5, 5, 14, 315, 54, 59, 59, 34, 315], [[0, 12], 99, 22, 22, 6, [109, 3], [58, 3], 354, [323, 4], 293, 294, 355, 356, 210, 128, 357, [282, 2], 352, [323, 13], 335, [213, 3], 221, 260, [323, 4], 6, [0, 3], 260, [323, 4], 22, 2, 1, 0, 4, 327, 54, 54, 14, 358, 6, 1, 233, 58, 58, 5, 5, 58, [233, 2], 58, 58, 29, 8, 14, 14, 8, 20, 59, 311, 322], [[0, 9], 99, 7, 11, 5, 11, [109, 3], [58, 3], 359, 233, 260, [323, 4], 316, 294, 287, 360, 112, 145, [282, 3], 350, [323, 14], 236, 234, 214, 224, 260, [323, 4], [0, 4], 260, [323, 4], 22, 1, 0, 0, 7, 14, 59, 9, 8, 11, 2, 48, 6, 11, 11, 40, 13, 6, 233, 361, 58, 58, 5, 13, 8, 13, 13, 5, 5, 8, 322], [[0, 7], 4, 6, 36, 5, 5, 11, 58, [109, 2], 58, 11, 11, 29, 58, 251, 260, [323, 4], 251, 233, 114, 89, 112, 153, 289, 362, 363, [323, 15], 364, 234, 214, 224, 260, [323, 4], [0, 4], 260, [323, 4], 2, [0, 3], 21, 338, 8, 319, 5, 35, 48, 22, 11, 5, 11, 40, 40, [233, 2], 361, 58, 40, [5, 3], 29, 6, 6, 11, 14, 59], [[0, 6], 21, [5, 4], 36, 11, 58, 58, 11, 29, [58, 3], 48, 2, 260, [323, 4], 1, 279, 193, 105, 113, 162, 153, 145, 365, [323, 3], 366, 185, 153, 205, 145, [146, 2], 138, 367, [323, 3], 324, 234, 214, 221, 260, [323, 4], [0, 4], 260, [323, 4], 1, 0, 0, 1, 5, 8, 8, 5, 358, 6, 99, 6, 5, 319, 8, 5, [233, 2], 361, 58, 58, 29, 29, 11, 6, 233, 6, 11, 5, 20, 14], [[0, 4], 4, 11, 5, 8, 8, 5, 36, 5, 36, 11, 36, 29, 58, 58, 109, 48, 41, 41, 260, [323, 4], 233, 219, 368, 369, 137, [162, 2], 282, 370, [323, 3], 371, [153, 3], 145, 285, 146, 138, 329, [323, 4], 353, 213, 229, 354, [323, 4], [0, 4], 260, [323, 12], 372, 2, 48, 58, 13, 13, 319, 5, [233, 2], 58, 58, 29, 29, 11, 58, 22, 22, 11, 36, 5, 20, 14], [[0, 3], 2, 5, 63, 344, 5, 5, 36, 29, 63, 63, 29, 29, [58, 3], 233, 2, 48, 251, 260, [323, 4], 244, 290, 373, 124, 121, 162, 181, 185, [323, 4], 363, [282, 2], 145, 285, 146, 297, 271, 138, 370, [323, 3], 336, 230, 40, 351, [323, 4], [0, 4], 260, [323, 12], 258, 2, 233, 36, 8, 5, 5, 40, 233, 361, 58, 29, 29, 58, 11, 109, 22, 6, 36, 29, 8, 14, 8], [0, 0, 2, 29, 63, 344, 5, 5, 36, 36, [12, 3], 5, [58, 3], 6, [233, 2], 48, 251, 260, [323, 4], 187, 244, 72, 93, 207, [162, 2], 374, [323, 3], 370, [282, 2], [145, 3], [362, 2], 146, 271, 325, [323, 3], 324, 232, 58, 260, [323, 4], [0, 4], 260, [323, 12], 291, 1, 109, 5, 8, 13, 29, 58, 375, [58, 3], [22, 3], 2, 22, 11, 11, 36, 8, 8, 319], [0, 4, [5, 5], 29, 29, 12, 376, 12, 12, 11, 359, 36, 6, 109, 22, 233, 48, [251, 2], 233, 48, 1, 48, 293, 290, 106, 113, 153, 132, [181, 2], 163, 126, 153, 362, [282, 6], 145, 285, 146, 271, 377, 235, 284, 242, 58, 1, [0, 10], [1, 3], [0, 3], 22, 5, 5, 58, 5, 11, 2, 2, 58, 8, 8, 13, 29, 58, 58, 220, 35, 99, 4, 109, 6, 4, 6, 29, 29, 11, [5, 3]]]};

  // romejs/cli-diagnostics/DiagnosticsPrinter.ts

  const ___R$$priv$romejs$cli$diagnostics$DiagnosticsPrinter_ts$fs = require('fs');

  function ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal(filename) {
    if (!___R$$priv$romejs$cli$diagnostics$DiagnosticsPrinter_ts$fs.existsSync(filename)) {
      return;
    }

    const src = ___R$$priv$romejs$cli$diagnostics$DiagnosticsPrinter_ts$fs.readFileSync(filename, 'utf8');
    const mtime = ___R$$priv$romejs$cli$diagnostics$DiagnosticsPrinter_ts$fs.lstatSync(filename).mtimeMs;
    return {content: src, mtime: mtime};
  }

  function ___R$$priv$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(a, b) {
    if (a === undefined || b === undefined) {
      return false;
    }

    if (a.line !== b.line || a.column !== b.column) {
      return false;
    }

    return true;
  }

  const ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS = {
    grep: '',
    inverseGrep: false,
    focus: '',
    showAllDiagnostics: true,
    fieri: false,
    verboseDiagnostics: false,
    maxDiagnostics: 100};

  class ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default extends Error {
    constructor(opts) {
      super(
      'Diagnostics printer. If you\'re seeing this then it wasn\'t caught and printed correctly.');
      const {cwd: cwd, reporter: reporter, flags: flags = ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS} = opts;

      this.reporter = reporter;
      this.flags = flags;
      this.readFile =
      opts.readFile === undefined ? ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal : opts.readFile;
      this.cwd = cwd === undefined ? ___R$romejs$path$index_ts$createAbsoluteFilePath(process.cwd()) : cwd;
      this.processor = new ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default({
        origins: opts.origins});

      this.displayedCount = 0;
      this.problemCount = 0;
      this.filteredCount = 0;
      this.truncatedCount = 0;

      this.fileSources = new Map();
      this.fileMtimes = new Map();
      this.beforeFooterPrint = [];
    }

    throwIfAny() {
      if (this.hasDiagnostics()) {
        throw this;
      }
    }

    hasDiagnostics() {
      return this.processor.hasDiagnostics();
    }

    getDisplayedProblemsCount() {
      return this.problemCount - this.filteredCount;
    }

    shouldTruncate() {
      if (!this.flags.showAllDiagnostics &&
      this.displayedCount > this.flags.maxDiagnostics) {
        return true;
      } else {
        return false;
      }
    }

    getDiagnostics() {
      return this.processor.getCompleteSortedDiagnostics(
      this.reporter.markupOptions);
    }

    isFocused(diag) {
      const focusFlag = this.flags.focus;
      const focusEnabled = focusFlag !== undefined && focusFlag !== '';

      const {filename: filename, start: start, end: end} = diag;

      if (focusEnabled && (filename === undefined || start === undefined)) {
        return true;
      }

      if (filename !== undefined && start !== undefined && end !== undefined) {
        const niceFilename = ___R$romejs$string$markup$format_ts$humanizeMarkupFilename(
        [filename],
        this.reporter.markupOptions);
        const focusId = ___R$romejs$diagnostics$derive_ts$getDiagnosticHeader({
          filename: filename,
          start: start});
        if (focusEnabled && focusId !== focusFlag && focusId !== niceFilename) {
          return true;
        }
      }

      return false;
    }

    shouldIgnore(diag) {
      const {focus: focus, grep: grep, inverseGrep: inverseGrep} = this.flags;
      const focusEnabled = focus !== undefined && focus !== '';

      if (focusEnabled && this.isFocused(diag) === false) {
        return true;
      }

      if (grep === undefined || grep === '') {
        return false;
      }

      let ignored = diag.message.toLowerCase().includes(grep) === false;
      if (inverseGrep) {
        ignored = !ignored;
      }
      return ignored;
    }

    addFileSource(info, stats) {
      this.fileMtimes.set(info.filename, stats.mtime);

      if (info.type === 'reference') {
        this.fileSources.set(
        info.filename,
        ___R$romejs$cli$diagnostics$utils_ts$toLines({
          path: ___R$romejs$path$index_ts$createUnknownFilePath(info.filename),
          input: stats.content,
          sourceType: info.sourceType,
          language: info.language}));
      }
    }

    getDependenciesFromDiagnostics(diagnostics) {
      const deps = [];

      for (const {
        advice: advice,
        filename: filename,
        dependencies: dependencies,
        language: language,
        sourceType: sourceType,
        mtime: mtime} of diagnostics) {
        if (filename !== undefined) {
          deps.push({type: 'reference', filename: filename, mtime: mtime, language: language, sourceType: sourceType});
        }

        for (const {filename: filename, mtime: mtime} of dependencies) {
          deps.push({
            type: 'change',
            filename: filename,
            mtime: mtime});
        }

        for (const item of advice) {
          if (item.type === 'frame' &&
          item.filename !== undefined &&
          item.sourceText === undefined) {
            deps.push({
              type: 'reference',
              filename: item.filename,
              language: item.language,
              sourceType: item.sourceType,
              mtime: item.mtime});
          }
        }
      }

      const depsMap = new Map();

      for (const dep of deps) {
        const path = ___R$romejs$path$index_ts$createUnknownFilePath(dep.filename);
        if (!path.isAbsolute()) {
          continue;
        }

        const existing = depsMap.get(dep.filename);

        if (existing === undefined || existing.type === 'change') {
          depsMap.set(dep.filename, dep);
          continue;
        }

        if (dep.type === 'reference') {
          if (existing.sourceType !== dep.sourceType) {
            existing.sourceType = 'unknown';
          }

          if (existing.language !== dep.language) {
            existing.language = 'unknown';
          }
        }
      }

      return Array.from(depsMap.values());
    }

    fetchFileSources(diagnostics) {
      for (const info of this.getDependenciesFromDiagnostics(diagnostics)) {
        const stats = this.readFile(info.filename);
        if (stats !== undefined) {
          this.addFileSource(info, stats);
        }
      }
    }

    addDiagnostic(partialDiagnostic, origin) {
      this.addDiagnostics([partialDiagnostic], origin);
    }

    addDiagnostics(partials, origin) {
      if (partials.length === 0) {
        return undefined;
      }

      this.processor.addDiagnostics(partials, origin);
    }

    print() {
      const filteredDiagnostics = this.filterDiagnostics();
      this.fetchFileSources(filteredDiagnostics);
      this.displayDiagnostics(filteredDiagnostics);
    }

    displayDiagnostics(diagnostics) {
      this.reporter.redirectOutToErr(true);
      for (const diag of diagnostics) {
        this.displayDiagnostic(diag);
      }
      this.reporter.redirectOutToErr(false);
    }

    displayDiagnostic(diag) {
      const {reporter: reporter} = this;
      const {start: start, end: end, filename: filename} = diag;

      let skipFrame = false;
      if (start !== undefined && end !== undefined) {
        adviceLoop: for (const item of diag.advice) {
          if (item.type === 'frame' &&
          item.filename === filename &&
          ___R$$priv$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(item.start, start) &&
          ___R$$priv$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(item.end, end)) {
            skipFrame = true;
            break;
          }

          if (item.type === 'stacktrace') {
            for (const frame of item.frames) {
              if (frame.filename === filename && ___R$$priv$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(frame, start)) {
                skipFrame = true;
                break adviceLoop;
              }
            }
          }
        }
      }

      let outdatedFiles = [];
      for (const {
        filename: filename,
        mtime: expectedMtime} of this.getDependenciesFromDiagnostics([diag])) {
        const mtime = this.fileMtimes.get(filename);
        if (mtime !== undefined &&
        expectedMtime !== undefined &&
        mtime > expectedMtime) {
          outdatedFiles.push(filename);
        }
      }

      const outdatedAdvice = [];
      const isOutdated = outdatedFiles.length > 0;
      if (isOutdated) {
        if (outdatedFiles.length === 1 && outdatedFiles[0] === filename) {
          outdatedAdvice.push({
            type: 'log',
            category: 'warn',
            message: 'This file has been changed since the diagnostic was produced and may be out of date'});
        } else {
          outdatedAdvice.push({
            type: 'log',
            category: 'warn',
            message: 'This diagnostic may be out of date as it relies on the following files that have been changed since the diagnostic was generated'});

          outdatedAdvice.push({
            type: 'list',
            list: outdatedFiles});
        }
      }

      const derived = ___R$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(diag, {
        skipFrame: skipFrame,
        includeHeaderInAdvice: false,
        outdated: isOutdated});
      reporter.hr(derived.header);
      reporter.indent();

      const derivedAdvice = [...derived.advice, ...outdatedAdvice].map(item => ___R$romejs$diagnostics$normalize_ts$normalizeDiagnosticAdviceItem(diag, item, this.reporter.markupOptions));
      const advice = derivedAdvice.concat(diag.advice);

      for (const item of advice) {
        const noSpacer = ___R$romejs$cli$diagnostics$printAdvice_ts$default(item, {
          flags: this.flags,
          fileSources: this.fileSources,
          diagnostic: diag,
          reporter: reporter});
        if (!noSpacer) {
          reporter.optionalSpacer();
        }
      }

      if (this.flags.verboseDiagnostics) {
        const {origins: origins} = diag;

        if (origins.length > 0) {
          reporter.spacer();
          reporter.info('Why are you seeing this diagnostic?');
          reporter.spacer();
          reporter.list(
          origins.map(origin => {
            let res = '<emphasis>' + origin.category + '</emphasis>';
            if (origin.message !== undefined) {
              res += ': ' + origin.message;
            }
            return res;
          }),
          {ordered: true});
        }
      }

      reporter.dedent();
    }

    filterDiagnostics() {
      const diagnostics = this.getDiagnostics();
      const filteredDiagnostics = [];

      for (const diag of diagnostics) {
        this.problemCount++;

        if (this.shouldIgnore(diag)) {
          this.filteredCount++;
        } else if (this.shouldTruncate()) {
          this.truncatedCount++;
        } else {
          this.displayedCount++;
          filteredDiagnostics.push(diag);
        }
      }

      return filteredDiagnostics;
    }

    onBeforeFooterPrint(fn) {
      this.beforeFooterPrint.push(fn);
    }

    footer() {
      const {reporter: reporter, problemCount: problemCount} = this;

      for (const handler of this.beforeFooterPrint) {
        handler(reporter);
      }

      if (problemCount > 0) {
        this.footerError();
      } else {
        this.footerSuccess();
      }
    }

    showBanner(banner) {
      for (const stream of this.reporter.getStreams(false)) {
        for (const row of banner.rows) {
          for (const field of row) {
            let palleteIndex;
            let times = 1;
            if (Array.isArray(field)) {
              [palleteIndex, times] = field;
            } else {
              palleteIndex = field;
            }

            const pallete = banner.palettes[palleteIndex];
            stream.write(
            ___R$romejs$string$ansi$format_ts$formatAnsi.bgRgb(' ', {r: pallete[0], g: pallete[1], b: pallete[2]}).repeat(times));
          }
          stream.write('\n');
        }
      }
    }

    footerSuccess() {
      const {reporter: reporter} = this;

      if (this.flags.fieri) {
        this.showBanner(___R$romejs$cli$diagnostics$banners$success_json$default);
      }

      reporter.success('No known problems!');
    }

    footerError() {
      const {reporter: reporter, filteredCount: filteredCount} = this;

      reporter.hr();

      if (this.flags.fieri) {
        this.showBanner(___R$romejs$cli$diagnostics$banners$error_json$default);
      }

      const displayableProblems = this.getDisplayedProblemsCount();
      let str = 'Found <number emphasis>' + displayableProblems + '</number> problem';
      if (displayableProblems > 1 || displayableProblems == 0) {
        str += 's';
      }

      if (filteredCount > 0) {
        str += ___R$romejs$string$ansi$format_ts$formatAnsi.brightBlack(' (' + filteredCount + ' filtered)');
      }

      reporter.error(str);

      if (this.truncatedCount > 0) {
        const {maxDiagnostics: maxDiagnostics} = this.flags;
        reporter.warn('Only <number>' + maxDiagnostics + '</number> errors shown, add the <emphasis>--show-all-diagnostics</emphasis> flag to view the remaining <number>' + (displayableProblems -
        maxDiagnostics) + '</number> errors');
      }
    }
  }

  // romejs/cli-diagnostics/index.ts

  async function ___R$romejs$cli$diagnostics$index_ts$printDiagnostics(diagnostics, opts) {
    const printer = new ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default(opts);
    printer.addDiagnostics(diagnostics);
    await printer.print();
    return printer;
  }

  function ___R$romejs$cli$diagnostics$index_ts$printDiagnosticsSync(diagnostics, opts) {
    const printer = new ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default(opts);
    printer.addDiagnostics(diagnostics);
    printer.print();
    return printer;
  }

  function ___R$romejs$cli$diagnostics$index_ts$printDiagnosticsToString(diagnostics, opts = {}, format = 'none') {
    let buff = '';

    const reporter = new ___R$romejs$cli$reporter$Reporter_ts$default({
      streams: [{
        type: 'all',
        format: format,
        columns: 400,
        write(chunk) {
          buff += chunk;
        }}]});

    const printer = new ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default(Object.assign({}, opts, {
      reporter: reporter}));
    printer.addDiagnostics(diagnostics);
    printer.print();
    return buff;
  }

  // romejs/core/package.json

  const ___R$romejs$core$package_json$default = {'name': '@romejs/core', 'version': '0.0.52', 'type': 'module', 'private': true, 'main': 'index.ts'};

  // romejs/core/common/constants.ts

  const ___R$romejs$core$common$constants_ts = {
    get CHILD_ARGS() {
      return ___R$romejs$core$common$constants_ts$CHILD_ARGS;
    },
    get BIN() {
      return ___R$romejs$core$common$constants_ts$BIN;
    },
    get MAP() {
      return ___R$romejs$core$common$constants_ts$MAP;
    },
    get MAX_MASTER_BYTES_BEFORE_WORKERS() {
      return ___R$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS;
    },
    get MAX_WORKER_BYTES_BEFORE_ADD() {
      return ___R$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD;
    },
    get MAX_WORKER_COUNT() {
      return ___R$romejs$core$common$constants_ts$MAX_WORKER_COUNT;
    },
    get VERSION() {
      return ___R$romejs$core$common$constants_ts$VERSION;
    },
    get SOCKET_PATH() {
      return ___R$romejs$core$common$constants_ts$SOCKET_PATH;
    },
    get CLI_SOCKET_PATH() {
      return ___R$romejs$core$common$constants_ts$CLI_SOCKET_PATH;
    }};
  const ___R$$priv$romejs$core$common$constants_ts$os = require('os');
  const ___R$romejs$core$common$constants_ts$CHILD_ARGS = ['--max-old-space-size=8192'];

  const ___R$romejs$core$common$constants_ts$BIN = ___R$romejs$path$index_ts$createAbsoluteFilePath(process.mainModule.filename);
  const ___R$romejs$core$common$constants_ts$MAP = ___R$romejs$core$common$constants_ts$BIN.addExtension('.map');

  const ___R$$priv$romejs$core$common$constants_ts$MEGABYTE = 10000;

  const ___R$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS = 0.5 * ___R$$priv$romejs$core$common$constants_ts$MEGABYTE;

  const ___R$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD = 1 * ___R$$priv$romejs$core$common$constants_ts$MEGABYTE;

  const ___R$$priv$romejs$core$common$constants_ts$CPU_COUNT = ___R$$priv$romejs$core$common$constants_ts$os.cpus().length;
  const ___R$romejs$core$common$constants_ts$MAX_WORKER_COUNT = Math.min(___R$$priv$romejs$core$common$constants_ts$CPU_COUNT, 4);

  const ___R$romejs$core$common$constants_ts$VERSION = String(___R$romejs$core$package_json$default.version);

  const ___R$romejs$core$common$constants_ts$SOCKET_PATH = ___R$romejs$path$index_ts$TEMP_PATH.append('rome-' + ___R$romejs$core$common$constants_ts$VERSION + '.sock');

  const ___R$romejs$core$common$constants_ts$CLI_SOCKET_PATH = ___R$romejs$path$index_ts$TEMP_PATH.append('rome-wait-' + ___R$romejs$core$common$constants_ts$VERSION + '.sock');

  // romejs/core/common/types/client.ts

  const ___R$romejs$core$common$types$client_ts = {
    get DEFAULT_CLIENT_FLAGS() {
      return ___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS;
    },
    get DEFAULT_CLIENT_REQUEST_FLAGS() {
      return ___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS;
    }};
  const ___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS = {
    clientName: 'unknown',
    cwd: ___R$romejs$path$index_ts$CWD_PATH,
    silent: false,
    verbose: false};

  const ___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS = Object.assign({
    collectMarkers: false,

    benchmark: false,
    benchmarkIterations: 10,

    watch: false,
    resolverPlatform: undefined,
    resolverScale: undefined,
    resolverMocks: false}, ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS);

  // romejs/core/commands.ts


  function ___R$romejs$core$commands_ts$createMasterCommand(cmd) {
    return cmd;
  }

  const ___R$romejs$core$commands_ts$commandCategories = {
    PROCESS_MANAGEMENT: 'Process Management',
    CODE_QUALITY: 'Code Quality',
    SOURCE_CODE: 'Source Code',
    PROJECT_MANAGEMENT: 'Project Management',
    SOURCE_CONTROL: 'Source Control',
    INTERNAL: 'Internal'};

  // romejs/core/common/utils/executeMain.ts

  const ___R$$priv$romejs$core$common$utils$executeMain_ts$internalModule = require('module');
  const ___R$$priv$romejs$core$common$utils$executeMain_ts$vm = require('vm');

  async function ___R$romejs$core$common$utils$executeMain_ts$default(opts) {
    const {path: path, code: code, sourceMap: sourceMap, globals: globals} = opts;

    const filename = path.join();

    const sandbox = Object.assign({}, globals, {
      process: {
        argv: [process.argv[0], filename],
        __proto__: process},

      Buffer: Buffer,
      clearImmediate: clearImmediate,
      clearInterval: clearInterval,
      clearTimeout: clearTimeout,
      setImmediate: setImmediate,
      setInterval: setInterval,
      setTimeout: setTimeout,
      require: ___R$$priv$romejs$core$common$utils$executeMain_ts$internalModule.createRequireFromPath(filename),
      console: console,
      __dirname: path.getParent().join(),
      __filename: filename});
    sandbox.global = sandbox;
    const context = ___R$$priv$romejs$core$common$utils$executeMain_ts$vm.createContext(sandbox);

    let script;
    try {
      script = new ___R$$priv$romejs$core$common$utils$executeMain_ts$vm.Script(code, {
        filename: filename,
        displayErrors: true});
    } catch (err) {
      if (err instanceof SyntaxError && err.stack !== undefined) {
        const lineMatch = err.stack.match(/^(.*?):(\d+)/);
        if (lineMatch == null) {
          throw err;
        }

        const line = Number(lineMatch[2]);

        const pos = {
          index: ___R$romejs$ob1$index_ts$number0Neg1,
          column: ___R$romejs$ob1$index_ts$number0,
          line: ___R$romejs$ob1$index_ts$coerce1(line)};

        const syntaxError = {
          message: err.message,
          category: 'syntaxError',
          start: pos,
          end: pos,
          filename: filename,
          sourceText: ___R$romejs$diagnostics$helpers_ts$truncateSourceText(code, pos, pos),
          advice: [___R$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE]};
        return {syntaxError: syntaxError};
      }

      throw err;
    }

    ___R$romejs$v8$index_ts$sourceMapManager.addSourceMap(filename, sourceMap);
    await script.runInContext(context);
    return {syntaxError: undefined};
  }

  // romejs/core/client/commands.ts

  const ___R$romejs$core$client$commands_ts$localCommands = new Map();

  ___R$romejs$core$client$commands_ts$localCommands.set('start', {
    category: ___R$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'start daemon (if none running)',
    async callback(req) {
      const existingServer = await req.client.tryConnectToExistingDaemon();
      if (existingServer) {
        req.client.reporter.success('Already running server.');
        return true;
      }

      const bridge = await req.client.startDaemon();
      return bridge !== undefined;
    }});

  ___R$romejs$core$client$commands_ts$localCommands.set('web', {
    category: ___R$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: '',
    async callback(req) {
      const existingServer = await req.client.tryConnectToExistingDaemon();
      const hasExistingServer = existingServer !== undefined;

      if (!hasExistingServer) {
        await req.client.forceStartDaemon();
      }

      await req.client.query(Object.assign({}, req.query, {
        terminateWhenIdle: true}), 'master');

      return true;
    }});

  ___R$romejs$core$client$commands_ts$localCommands.set('stop', {
    category: ___R$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'stop a running daemon if one exists',
    async callback(req) {
      const {reporter: reporter} = req.client;
      const bridge = await req.client.tryConnectToExistingDaemon();
      if (bridge) {
        const stop = await req.client.query(
        {
          command: 'stop'},
        'master');
        if (stop.type === 'ERROR' && stop.fatal) {
          reporter.success('Stopped server.');
        } else {
          reporter.error('Failed to stop server.');
          return false;
        }
      } else {
        reporter.warn('No running server to stop.');
      }
      return true;
    }});

  ___R$romejs$core$client$commands_ts$localCommands.set('run', {
    category: ___R$romejs$core$commands_ts$commandCategories.PROJECT_MANAGEMENT,
    description: 'TODO',
    async callback(req) {
      const bridge = await req.client.findOrStartMaster();
      if (bridge === undefined) {
        return false;
      }

      process.on('unhandledRejection', error => {
        error;
      });

      const res = await req.client.query(
      {
        command: 'run',
        args: req.query.args},
      'master');

      if (res.type !== 'SUCCESS') {
        return false;
      }

      const data = ___R$romejs$consume$index_ts$consumeUnknown(res.data);

      if (data.exists()) {
        const type = data.get('type').asString();

        switch (type) {
          case 'executeCode':
            process.execArgv = [...process.execArgv, process.argv[1], 'run'];
            process.argv = [process.argv[0], String(data.filename), ...process.argv.slice(4)];
            const {syntaxError: syntaxError} = await ___R$romejs$core$common$utils$executeMain_ts$default({
              path: ___R$romejs$path$index_ts$createAbsoluteFilePath(data.get('filename').asString()),
              code: data.get('code').asString(),
              sourceMap: data.get('map').asAny()});
            if (syntaxError !== undefined) {
              throw new ___R$romejs$diagnostics$errors_ts$DiagnosticsError(syntaxError.message, [syntaxError]);
            }
            await new Promise(() => {});
            break;}
      }

      return true;
    }});

  ___R$romejs$core$client$commands_ts$localCommands.set('restart', {
    category: ___R$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'restart daemon',
    async callback(req) {
      const stopped = await req.client.query({
        command: 'stop'});

      if (stopped.type === 'SUCCESS' && stopped.data === true) {
        const started = await req.client.query({
          command: 'start'});
        return started.type === 'SUCCESS' && started.data === true;
      } else {
        return false;
      }
    }});

  ___R$romejs$core$client$commands_ts$localCommands.set('status', {
    description: 'get the current daemon status',
    category: ___R$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    async callback(req) {
      const {reporter: reporter} = req.client;
      const bridge = await req.client.tryConnectToExistingDaemon();
      if (bridge) {
        const status = await req.client.query(
        {
          command: 'status'},
        'master');
        if (status.type === 'SUCCESS') {
          reporter.inspect(status.data);
          return true;
        } else {
          return false;
        }
      } else {
        reporter.error('Server not running.');
        return false;
      }
    }});

  // romejs/core/client/ClientRequest.ts


  class ___R$romejs$core$client$ClientRequest_ts$default {
    constructor(client, type = 'local', query) {
      this.client = client;
      this.type = type;
      this.query = query;
    }

    async init() {
      try {
        return await this.initCommand();
      } catch (err) {
        return {
          type: 'ERROR',
          fatal: false,
          handled: false,
          name: err.name,
          message: err.message,
          stack: err.stack};
      }
    }

    async initCommand() {
      const localCommand = ___R$romejs$core$client$commands_ts$localCommands.get(this.query.command);

      if (this.type === 'master' || localCommand === undefined) {
        return this.initFromMaster();
      } else {
        return this.initFromLocal(localCommand);
      }
    }

    async initFromLocal(localCommand) {
      const {query: query, client: client} = this;
      if (client.flags.silent !== true) {
        this.client.reporter.banner(query.command);
      }

      const success = await localCommand.callback(
      this,
      ___R$romejs$consume$index_ts$consumeUnknown(query.commandFlags));
      if (success) {
        if (client.flags.silent !== true) {
          client.reporter.footer();
        }

        return {
          type: 'SUCCESS',
          data: undefined,
          hasData: false,
          markers: []};
      } else {
        return {
          type: 'ERROR',
          fatal: false,

          handled: true,
          name: 'Error',
          message: 'Command was not successful',
          stack: undefined};
      }
    }

    async initFromMaster() {
      const {client: client} = this;

      try {
        const bridge = await client.findOrStartMaster();
        return await bridge.query.call(this.query);
      } catch (err) {
        if (err instanceof ___R$romejs$events$BridgeError_ts$default) {
          return {
            type: 'ERROR',
            fatal: true,
            handled: false,
            name: 'Error',
            message: 'Server died while processing command. Results may be incomplete.',
            stack: undefined};
        } else {
          throw err;
        }
      }
    }
  }

  // romejs/codec-spdx-license/data.ts

  const ___R$romejs$codec$spdx$license$data_ts$default = {
    licenseListVersion: 'v3.4-22-g14c1a0e',
    licenses: [{
      reference: './0BSD.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/0BSD.json',
      referenceNumber: '311',
      name: 'BSD Zero Clause License',
      licenseId: '0BSD',
      seeAlso: ['http://landley.net/toybox/license.html'],
      isOsiApproved: true}, {
      reference: './AAL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AAL.json',
      referenceNumber: '20',
      name: 'Attribution Assurance License',
      licenseId: 'AAL',
      seeAlso: ['https://opensource.org/licenses/attribution'],
      isOsiApproved: true}, {
      reference: './ADSL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ADSL.json',
      referenceNumber: '18',
      name: 'Amazon Digital Services License',
      licenseId: 'ADSL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/AmazonDigitalServicesLicense'],
      isOsiApproved: false}, {
      reference: './AFL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AFL-1.1.json',
      referenceNumber: '112',
      name: 'Academic Free License v1.1',
      licenseId: 'AFL-1.1',
      seeAlso: ['http://opensource.linux-mirror.org/licenses/afl-1.1.txt', 'http://wayback.archive.org/web/20021004124254/http://www.opensource.org/licenses/academic.php'],
      isOsiApproved: true}, {
      reference: './AFL-1.2.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AFL-1.2.json',
      referenceNumber: '130',
      name: 'Academic Free License v1.2',
      licenseId: 'AFL-1.2',
      seeAlso: ['http://opensource.linux-mirror.org/licenses/afl-1.2.txt', 'http://wayback.archive.org/web/20021204204652/http://www.opensource.org/licenses/academic.php'],
      isOsiApproved: true}, {
      reference: './AFL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AFL-2.0.json',
      referenceNumber: '109',
      name: 'Academic Free License v2.0',
      licenseId: 'AFL-2.0',
      seeAlso: ['http://wayback.archive.org/web/20060924134533/http://www.opensource.org/licenses/afl-2.0.txt'],
      isOsiApproved: true}, {
      reference: './AFL-2.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AFL-2.1.json',
      referenceNumber: '245',
      name: 'Academic Free License v2.1',
      licenseId: 'AFL-2.1',
      seeAlso: ['http://opensource.linux-mirror.org/licenses/afl-2.1.txt'],
      isOsiApproved: true}, {
      reference: './AFL-3.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AFL-3.0.json',
      referenceNumber: '210',
      name: 'Academic Free License v3.0',
      licenseId: 'AFL-3.0',
      seeAlso: ['http://www.rosenlaw.com/AFL3.0.htm', 'https://opensource.org/licenses/afl-3.0'],
      isOsiApproved: true}, {
      reference: './AGPL-1.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AGPL-1.0.json',
      referenceNumber: '326',
      name: 'Affero General Public License v1.0',
      licenseId: 'AGPL-1.0',
      seeAlso: ['http://www.affero.org/oagpl.html'],
      isOsiApproved: false}, {
      reference: './AGPL-1.0-only.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AGPL-1.0-only.json',
      referenceNumber: '371',
      name: 'Affero General Public License v1.0 only',
      licenseId: 'AGPL-1.0-only',
      seeAlso: ['http://www.affero.org/oagpl.html'],
      isOsiApproved: false}, {
      reference: './AGPL-1.0-or-later.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AGPL-1.0-or-later.json',
      referenceNumber: '323',
      name: 'Affero General Public License v1.0 or later',
      licenseId: 'AGPL-1.0-or-later',
      seeAlso: ['http://www.affero.org/oagpl.html'],
      isOsiApproved: false}, {
      reference: './AGPL-3.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AGPL-3.0.json',
      referenceNumber: '223',
      name: 'GNU Affero General Public License v3.0',
      licenseId: 'AGPL-3.0',
      seeAlso: ['https://www.gnu.org/licenses/agpl.txt', 'https://opensource.org/licenses/AGPL-3.0'],
      isOsiApproved: true}, {
      reference: './AGPL-3.0-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AGPL-3.0-only.json',
      referenceNumber: '90',
      name: 'GNU Affero General Public License v3.0 only',
      licenseId: 'AGPL-3.0-only',
      seeAlso: ['https://www.gnu.org/licenses/agpl.txt', 'https://opensource.org/licenses/AGPL-3.0'],
      isOsiApproved: true}, {
      reference: './AGPL-3.0-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/AGPL-3.0-or-later.json',
      referenceNumber: '149',
      name: 'GNU Affero General Public License v3.0 or later',
      licenseId: 'AGPL-3.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/agpl.txt', 'https://opensource.org/licenses/AGPL-3.0'],
      isOsiApproved: true}, {
      reference: './AMDPLPA.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AMDPLPA.json',
      referenceNumber: '31',
      name: 'AMD\'s plpa_map.c License',
      licenseId: 'AMDPLPA',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/AMD_plpa_map_License'],
      isOsiApproved: false}, {
      reference: './AML.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AML.json',
      referenceNumber: '142',
      name: 'Apple MIT License',
      licenseId: 'AML',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Apple_MIT_License'],
      isOsiApproved: false}, {
      reference: './AMPAS.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/AMPAS.json',
      referenceNumber: '185',
      name: 'Academy of Motion Picture Arts and Sciences BSD',
      licenseId: 'AMPAS',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/BSD#AMPASBSD'],
      isOsiApproved: false}, {
      reference: './ANTLR-PD.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ANTLR-PD.json',
      referenceNumber: '382',
      name: 'ANTLR Software Rights Notice',
      licenseId: 'ANTLR-PD',
      seeAlso: ['http://www.antlr2.org/license.html'],
      isOsiApproved: false}, {
      reference: './APAFML.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/APAFML.json',
      referenceNumber: '189',
      name: 'Adobe Postscript AFM License',
      licenseId: 'APAFML',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/AdobePostscriptAFM'],
      isOsiApproved: false}, {
      reference: './APL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/APL-1.0.json',
      referenceNumber: '246',
      name: 'Adaptive Public License 1.0',
      licenseId: 'APL-1.0',
      seeAlso: ['https://opensource.org/licenses/APL-1.0'],
      isOsiApproved: true}, {
      reference: './APSL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/APSL-1.0.json',
      referenceNumber: '343',
      name: 'Apple Public Source License 1.0',
      licenseId: 'APSL-1.0',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Apple_Public_Source_License_1.0'],
      isOsiApproved: true}, {
      reference: './APSL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/APSL-1.1.json',
      referenceNumber: '316',
      name: 'Apple Public Source License 1.1',
      licenseId: 'APSL-1.1',
      seeAlso: ['http://www.opensource.apple.com/source/IOSerialFamily/IOSerialFamily-7/APPLE_LICENSE'],
      isOsiApproved: true}, {
      reference: './APSL-1.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/APSL-1.2.json',
      referenceNumber: '32',
      name: 'Apple Public Source License 1.2',
      licenseId: 'APSL-1.2',
      seeAlso: ['http://www.samurajdata.se/opensource/mirror/licenses/apsl.php'],
      isOsiApproved: true}, {
      reference: './APSL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/APSL-2.0.json',
      referenceNumber: '103',
      name: 'Apple Public Source License 2.0',
      licenseId: 'APSL-2.0',
      seeAlso: ['http://www.opensource.apple.com/license/apsl/'],
      isOsiApproved: true}, {
      reference: './Abstyles.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Abstyles.json',
      referenceNumber: '76',
      name: 'Abstyles License',
      licenseId: 'Abstyles',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Abstyles'],
      isOsiApproved: false}, {
      reference: './Adobe-2006.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Adobe-2006.json',
      referenceNumber: '278',
      name: 'Adobe Systems Incorporated Source Code License Agreement',
      licenseId: 'Adobe-2006',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/AdobeLicense'],
      isOsiApproved: false}, {
      reference: './Adobe-Glyph.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Adobe-Glyph.json',
      referenceNumber: '101',
      name: 'Adobe Glyph List License',
      licenseId: 'Adobe-Glyph',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT#AdobeGlyph'],
      isOsiApproved: false}, {
      reference: './Afmparse.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Afmparse.json',
      referenceNumber: '40',
      name: 'Afmparse License',
      licenseId: 'Afmparse',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Afmparse'],
      isOsiApproved: false}, {
      reference: './Aladdin.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Aladdin.json',
      referenceNumber: '252',
      name: 'Aladdin Free Public License',
      licenseId: 'Aladdin',
      seeAlso: ['http://pages.cs.wisc.edu/~ghost/doc/AFPL/6.01/Public.htm'],
      isOsiApproved: false}, {
      reference: './Apache-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Apache-1.0.json',
      referenceNumber: '231',
      name: 'Apache License 1.0',
      licenseId: 'Apache-1.0',
      seeAlso: ['http://www.apache.org/licenses/LICENSE-1.0'],
      isOsiApproved: false}, {
      reference: './Apache-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Apache-1.1.json',
      referenceNumber: '80',
      name: 'Apache License 1.1',
      licenseId: 'Apache-1.1',
      seeAlso: ['http://apache.org/licenses/LICENSE-1.1', 'https://opensource.org/licenses/Apache-1.1'],
      isOsiApproved: true}, {
      reference: './Apache-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Apache-2.0.json',
      referenceNumber: '24',
      name: 'Apache License 2.0',
      licenseId: 'Apache-2.0',
      seeAlso: ['http://www.apache.org/licenses/LICENSE-2.0', 'https://opensource.org/licenses/Apache-2.0'],
      isOsiApproved: true}, {
      reference: './Artistic-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Artistic-1.0.json',
      referenceNumber: '159',
      name: 'Artistic License 1.0',
      licenseId: 'Artistic-1.0',
      seeAlso: ['https://opensource.org/licenses/Artistic-1.0'],
      isOsiApproved: true}, {
      reference: './Artistic-1.0-Perl.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Artistic-1.0-Perl.json',
      referenceNumber: '364',
      name: 'Artistic License 1.0 (Perl)',
      licenseId: 'Artistic-1.0-Perl',
      seeAlso: ['http://dev.perl.org/licenses/artistic.html'],
      isOsiApproved: true}, {
      reference: './Artistic-1.0-cl8.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Artistic-1.0-cl8.json',
      referenceNumber: '12',
      name: 'Artistic License 1.0 w/clause 8',
      licenseId: 'Artistic-1.0-cl8',
      seeAlso: ['https://opensource.org/licenses/Artistic-1.0'],
      isOsiApproved: true}, {
      reference: './Artistic-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Artistic-2.0.json',
      referenceNumber: '183',
      name: 'Artistic License 2.0',
      licenseId: 'Artistic-2.0',
      seeAlso: ['http://www.perlfoundation.org/artistic_license_2_0', 'https://opensource.org/licenses/artistic-license-2.0'],
      isOsiApproved: true}, {
      reference: './BSD-1-Clause.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-1-Clause.json',
      referenceNumber: '346',
      name: 'BSD 1-Clause License',
      licenseId: 'BSD-1-Clause',
      seeAlso: ['https://svnweb.freebsd.org/base/head/include/ifaddrs.h?revision=326823'],
      isOsiApproved: false}, {
      reference: './BSD-2-Clause.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause.json',
      referenceNumber: '317',
      name: 'BSD 2-Clause "Simplified" License',
      licenseId: 'BSD-2-Clause',
      seeAlso: ['https://opensource.org/licenses/BSD-2-Clause'],
      isOsiApproved: true}, {
      reference: './BSD-2-Clause-FreeBSD.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause-FreeBSD.json',
      referenceNumber: '115',
      name: 'BSD 2-Clause FreeBSD License',
      licenseId: 'BSD-2-Clause-FreeBSD',
      seeAlso: ['http://www.freebsd.org/copyright/freebsd-license.html'],
      isOsiApproved: false}, {
      reference: './BSD-2-Clause-NetBSD.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause-NetBSD.json',
      referenceNumber: '368',
      name: 'BSD 2-Clause NetBSD License',
      licenseId: 'BSD-2-Clause-NetBSD',
      seeAlso: ['http://www.netbsd.org/about/redistribution.html#default'],
      isOsiApproved: false}, {
      reference: './BSD-2-Clause-Patent.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-2-Clause-Patent.json',
      referenceNumber: '163',
      name: 'BSD-2-Clause Plus Patent License',
      licenseId: 'BSD-2-Clause-Patent',
      seeAlso: ['https://opensource.org/licenses/BSDplusPatent'],
      isOsiApproved: true}, {
      reference: './BSD-3-Clause.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause.json',
      referenceNumber: '263',
      name: 'BSD 3-Clause "New" or "Revised" License',
      licenseId: 'BSD-3-Clause',
      seeAlso: ['https://opensource.org/licenses/BSD-3-Clause'],
      isOsiApproved: true}, {
      reference: './BSD-3-Clause-Attribution.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-Attribution.json',
      referenceNumber: '37',
      name: 'BSD with attribution',
      licenseId: 'BSD-3-Clause-Attribution',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/BSD_with_Attribution'],
      isOsiApproved: false}, {
      reference: './BSD-3-Clause-Clear.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-Clear.json',
      referenceNumber: '206',
      name: 'BSD 3-Clause Clear License',
      licenseId: 'BSD-3-Clause-Clear',
      seeAlso: ['http://labs.metacarta.com/license-explanation.html#license'],
      isOsiApproved: false}, {
      reference: './BSD-3-Clause-LBNL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-LBNL.json',
      referenceNumber: '328',
      name: 'Lawrence Berkeley National Labs BSD variant license',
      licenseId: 'BSD-3-Clause-LBNL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/LBNLBSD'],
      isOsiApproved: false}, {
      reference: './BSD-3-Clause-No-Nuclear-License.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-License.json',
      referenceNumber: '11',
      name: 'BSD 3-Clause No Nuclear License',
      licenseId: 'BSD-3-Clause-No-Nuclear-License',
      seeAlso: ['http://download.oracle.com/otn-pub/java/licenses/bsd.txt?AuthParam=1467140197_43d516ce1776bd08a58235a7785be1cc'],
      isOsiApproved: false}, {
      reference: './BSD-3-Clause-No-Nuclear-License-2014.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-License-2014.json',
      referenceNumber: '131',
      name: 'BSD 3-Clause No Nuclear License 2014',
      licenseId: 'BSD-3-Clause-No-Nuclear-License-2014',
      seeAlso: ['https://java.net/projects/javaeetutorial/pages/BerkeleyLicense'],
      isOsiApproved: false}, {
      reference: './BSD-3-Clause-No-Nuclear-Warranty.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-Warranty.json',
      referenceNumber: '42',
      name: 'BSD 3-Clause No Nuclear Warranty',
      licenseId: 'BSD-3-Clause-No-Nuclear-Warranty',
      seeAlso: ['https://jogamp.org/git/?p=gluegen.git;a=blob_plain;f=LICENSE.txt'],
      isOsiApproved: false}, {
      reference: './BSD-4-Clause.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BSD-4-Clause.json',
      referenceNumber: '156',
      name: 'BSD 4-Clause "Original" or "Old" License',
      licenseId: 'BSD-4-Clause',
      seeAlso: ['http://directory.fsf.org/wiki/License:BSD_4Clause'],
      isOsiApproved: false}, {
      reference: './BSD-4-Clause-UC.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-4-Clause-UC.json',
      referenceNumber: '197',
      name: 'BSD-4-Clause (University of California-Specific)',
      licenseId: 'BSD-4-Clause-UC',
      seeAlso: ['http://www.freebsd.org/copyright/license.html'],
      isOsiApproved: false}, {
      reference: './BSD-Protection.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-Protection.json',
      referenceNumber: '113',
      name: 'BSD Protection License',
      licenseId: 'BSD-Protection',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/BSD_Protection_License'],
      isOsiApproved: false}, {
      reference: './BSD-Source-Code.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BSD-Source-Code.json',
      referenceNumber: '301',
      name: 'BSD Source Code Attribution',
      licenseId: 'BSD-Source-Code',
      seeAlso: ['https://github.com/robbiehanson/CocoaHTTPServer/blob/master/LICENSE.txt'],
      isOsiApproved: false}, {
      reference: './BSL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BSL-1.0.json',
      referenceNumber: '218',
      name: 'Boost Software License 1.0',
      licenseId: 'BSL-1.0',
      seeAlso: ['http://www.boost.org/LICENSE_1_0.txt', 'https://opensource.org/licenses/BSL-1.0'],
      isOsiApproved: true}, {
      reference: './Bahyph.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Bahyph.json',
      referenceNumber: '354',
      name: 'Bahyph License',
      licenseId: 'Bahyph',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Bahyph'],
      isOsiApproved: false}, {
      reference: './Barr.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Barr.json',
      referenceNumber: '324',
      name: 'Barr License',
      licenseId: 'Barr',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Barr'],
      isOsiApproved: false}, {
      reference: './Beerware.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Beerware.json',
      referenceNumber: '16',
      name: 'Beerware License',
      licenseId: 'Beerware',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Beerware', 'https://people.freebsd.org/~phk/'],
      isOsiApproved: false}, {
      reference: './BitTorrent-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/BitTorrent-1.0.json',
      referenceNumber: '212',
      name: 'BitTorrent Open Source License v1.0',
      licenseId: 'BitTorrent-1.0',
      seeAlso: ['http://sources.gentoo.org/cgi-bin/viewvc.cgi/gentoo-x86/licenses/BitTorrent?r1=1.1&r2=1.1.1.1&diff_format=s'],
      isOsiApproved: false}, {
      reference: './BitTorrent-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/BitTorrent-1.1.json',
      referenceNumber: '173',
      name: 'BitTorrent Open Source License v1.1',
      licenseId: 'BitTorrent-1.1',
      seeAlso: ['http://directory.fsf.org/wiki/License:BitTorrentOSL1.1'],
      isOsiApproved: false}, {
      reference: './Borceux.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Borceux.json',
      referenceNumber: '304',
      name: 'Borceux license',
      licenseId: 'Borceux',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Borceux'],
      isOsiApproved: false}, {
      reference: './CATOSL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CATOSL-1.1.json',
      referenceNumber: '256',
      name: 'Computer Associates Trusted Open Source License 1.1',
      licenseId: 'CATOSL-1.1',
      seeAlso: ['https://opensource.org/licenses/CATOSL-1.1'],
      isOsiApproved: true}, {
      reference: './CC-BY-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-1.0.json',
      referenceNumber: '122',
      name: 'Creative Commons Attribution 1.0 Generic',
      licenseId: 'CC-BY-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-2.0.json',
      referenceNumber: '226',
      name: 'Creative Commons Attribution 2.0 Generic',
      licenseId: 'CC-BY-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-2.5.json',
      referenceNumber: '123',
      name: 'Creative Commons Attribution 2.5 Generic',
      licenseId: 'CC-BY-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-3.0.json',
      referenceNumber: '250',
      name: 'Creative Commons Attribution 3.0 Unported',
      licenseId: 'CC-BY-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-4.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-4.0.json',
      referenceNumber: '322',
      name: 'Creative Commons Attribution 4.0 International',
      licenseId: 'CC-BY-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-1.0.json',
      referenceNumber: '124',
      name: 'Creative Commons Attribution Non Commercial 1.0 Generic',
      licenseId: 'CC-BY-NC-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-2.0.json',
      referenceNumber: '238',
      name: 'Creative Commons Attribution Non Commercial 2.0 Generic',
      licenseId: 'CC-BY-NC-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-2.5.json',
      referenceNumber: '1',
      name: 'Creative Commons Attribution Non Commercial 2.5 Generic',
      licenseId: 'CC-BY-NC-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by-nc/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-3.0.json',
      referenceNumber: '249',
      name: 'Creative Commons Attribution Non Commercial 3.0 Unported',
      licenseId: 'CC-BY-NC-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-4.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-4.0.json',
      referenceNumber: '180',
      name: 'Creative Commons Attribution Non Commercial 4.0 International',
      licenseId: 'CC-BY-NC-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-ND-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-1.0.json',
      referenceNumber: '57',
      name: 'Creative Commons Attribution Non Commercial No Derivatives 1.0 Generic',
      licenseId: 'CC-BY-NC-ND-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nd-nc/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-ND-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-2.0.json',
      referenceNumber: '34',
      name: 'Creative Commons Attribution Non Commercial No Derivatives 2.0 Generic',
      licenseId: 'CC-BY-NC-ND-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-ND-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-2.5.json',
      referenceNumber: '152',
      name: 'Creative Commons Attribution Non Commercial No Derivatives 2.5 Generic',
      licenseId: 'CC-BY-NC-ND-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-ND-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-3.0.json',
      referenceNumber: '46',
      name: 'Creative Commons Attribution Non Commercial No Derivatives 3.0 Unported',
      licenseId: 'CC-BY-NC-ND-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-ND-4.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-ND-4.0.json',
      referenceNumber: '274',
      name: 'Creative Commons Attribution Non Commercial No Derivatives 4.0 International',
      licenseId: 'CC-BY-NC-ND-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-SA-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-1.0.json',
      referenceNumber: '172',
      name: 'Creative Commons Attribution Non Commercial Share Alike 1.0 Generic',
      licenseId: 'CC-BY-NC-SA-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-SA-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-2.0.json',
      referenceNumber: '77',
      name: 'Creative Commons Attribution Non Commercial Share Alike 2.0 Generic',
      licenseId: 'CC-BY-NC-SA-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-SA-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-2.5.json',
      referenceNumber: '60',
      name: 'Creative Commons Attribution Non Commercial Share Alike 2.5 Generic',
      licenseId: 'CC-BY-NC-SA-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-SA-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-3.0.json',
      referenceNumber: '21',
      name: 'Creative Commons Attribution Non Commercial Share Alike 3.0 Unported',
      licenseId: 'CC-BY-NC-SA-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-NC-SA-4.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-NC-SA-4.0.json',
      referenceNumber: '45',
      name: 'Creative Commons Attribution Non Commercial Share Alike 4.0 International',
      licenseId: 'CC-BY-NC-SA-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-ND-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-1.0.json',
      referenceNumber: '48',
      name: 'Creative Commons Attribution No Derivatives 1.0 Generic',
      licenseId: 'CC-BY-ND-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nd/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-ND-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-2.0.json',
      referenceNumber: '280',
      name: 'Creative Commons Attribution No Derivatives 2.0 Generic',
      licenseId: 'CC-BY-ND-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nd/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-ND-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-2.5.json',
      referenceNumber: '66',
      name: 'Creative Commons Attribution No Derivatives 2.5 Generic',
      licenseId: 'CC-BY-ND-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by-nd/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-ND-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-3.0.json',
      referenceNumber: '380',
      name: 'Creative Commons Attribution No Derivatives 3.0 Unported',
      licenseId: 'CC-BY-ND-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nd/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-ND-4.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-ND-4.0.json',
      referenceNumber: '126',
      name: 'Creative Commons Attribution No Derivatives 4.0 International',
      licenseId: 'CC-BY-ND-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by-nd/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-SA-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-1.0.json',
      referenceNumber: '314',
      name: 'Creative Commons Attribution Share Alike 1.0 Generic',
      licenseId: 'CC-BY-SA-1.0',
      seeAlso: ['https://creativecommons.org/licenses/by-sa/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-SA-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-2.0.json',
      referenceNumber: '136',
      name: 'Creative Commons Attribution Share Alike 2.0 Generic',
      licenseId: 'CC-BY-SA-2.0',
      seeAlso: ['https://creativecommons.org/licenses/by-sa/2.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-SA-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-2.5.json',
      referenceNumber: '299',
      name: 'Creative Commons Attribution Share Alike 2.5 Generic',
      licenseId: 'CC-BY-SA-2.5',
      seeAlso: ['https://creativecommons.org/licenses/by-sa/2.5/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-SA-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-3.0.json',
      referenceNumber: '381',
      name: 'Creative Commons Attribution Share Alike 3.0 Unported',
      licenseId: 'CC-BY-SA-3.0',
      seeAlso: ['https://creativecommons.org/licenses/by-sa/3.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC-BY-SA-4.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CC-BY-SA-4.0.json',
      referenceNumber: '30',
      name: 'Creative Commons Attribution Share Alike 4.0 International',
      licenseId: 'CC-BY-SA-4.0',
      seeAlso: ['https://creativecommons.org/licenses/by-sa/4.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CC0-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CC0-1.0.json',
      referenceNumber: '207',
      name: 'Creative Commons Zero v1.0 Universal',
      licenseId: 'CC0-1.0',
      seeAlso: ['https://creativecommons.org/publicdomain/zero/1.0/legalcode'],
      isOsiApproved: false}, {
      reference: './CDDL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CDDL-1.0.json',
      referenceNumber: '132',
      name: 'Common Development and Distribution License 1.0',
      licenseId: 'CDDL-1.0',
      seeAlso: ['https://opensource.org/licenses/cddl1'],
      isOsiApproved: true}, {
      reference: './CDDL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CDDL-1.1.json',
      referenceNumber: '363',
      name: 'Common Development and Distribution License 1.1',
      licenseId: 'CDDL-1.1',
      seeAlso: ['http://glassfish.java.net/public/CDDL+GPL_1_1.html', 'https://javaee.github.io/glassfish/LICENSE'],
      isOsiApproved: false}, {
      reference: './CDLA-Permissive-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CDLA-Permissive-1.0.json',
      referenceNumber: '244',
      name: 'Community Data License Agreement Permissive 1.0',
      licenseId: 'CDLA-Permissive-1.0',
      seeAlso: ['https://cdla.io/permissive-1-0'],
      isOsiApproved: false}, {
      reference: './CDLA-Sharing-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CDLA-Sharing-1.0.json',
      referenceNumber: '303',
      name: 'Community Data License Agreement Sharing 1.0',
      licenseId: 'CDLA-Sharing-1.0',
      seeAlso: ['https://cdla.io/sharing-1-0'],
      isOsiApproved: false}, {
      reference: './CECILL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CECILL-1.0.json',
      referenceNumber: '217',
      name: 'CeCILL Free Software License Agreement v1.0',
      licenseId: 'CECILL-1.0',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V1-fr.html'],
      isOsiApproved: false}, {
      reference: './CECILL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CECILL-1.1.json',
      referenceNumber: '293',
      name: 'CeCILL Free Software License Agreement v1.1',
      licenseId: 'CECILL-1.1',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V1.1-US.html'],
      isOsiApproved: false}, {
      reference: './CECILL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CECILL-2.0.json',
      referenceNumber: '341',
      name: 'CeCILL Free Software License Agreement v2.0',
      licenseId: 'CECILL-2.0',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V2-en.html'],
      isOsiApproved: false}, {
      reference: './CECILL-2.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CECILL-2.1.json',
      referenceNumber: '114',
      name: 'CeCILL Free Software License Agreement v2.1',
      licenseId: 'CECILL-2.1',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.html'],
      isOsiApproved: true}, {
      reference: './CECILL-B.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CECILL-B.json',
      referenceNumber: '331',
      name: 'CeCILL-B Free Software License Agreement',
      licenseId: 'CECILL-B',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html'],
      isOsiApproved: false}, {
      reference: './CECILL-C.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CECILL-C.json',
      referenceNumber: '73',
      name: 'CeCILL-C Free Software License Agreement',
      licenseId: 'CECILL-C',
      seeAlso: ['http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html\n    '],
      isOsiApproved: false}, {
      reference: './CNRI-Jython.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CNRI-Jython.json',
      referenceNumber: '89',
      name: 'CNRI Jython License',
      licenseId: 'CNRI-Jython',
      seeAlso: ['http://www.jython.org/license.html'],
      isOsiApproved: false}, {
      reference: './CNRI-Python.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CNRI-Python.json',
      referenceNumber: '43',
      name: 'CNRI Python License',
      licenseId: 'CNRI-Python',
      seeAlso: ['https://opensource.org/licenses/CNRI-Python'],
      isOsiApproved: true}, {
      reference: './CNRI-Python-GPL-Compatible.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CNRI-Python-GPL-Compatible.json',
      referenceNumber: '196',
      name: 'CNRI Python Open Source GPL Compatible License Agreement',
      licenseId: 'CNRI-Python-GPL-Compatible',
      seeAlso: ['http://www.python.org/download/releases/1.6.1/download_win/'],
      isOsiApproved: false}, {
      reference: './CPAL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CPAL-1.0.json',
      referenceNumber: '164',
      name: 'Common Public Attribution License 1.0',
      licenseId: 'CPAL-1.0',
      seeAlso: ['https://opensource.org/licenses/CPAL-1.0'],
      isOsiApproved: true}, {
      reference: './CPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/CPL-1.0.json',
      referenceNumber: '166',
      name: 'Common Public License 1.0',
      licenseId: 'CPL-1.0',
      seeAlso: ['https://opensource.org/licenses/CPL-1.0'],
      isOsiApproved: true}, {
      reference: './CPOL-1.02.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CPOL-1.02.json',
      referenceNumber: '26',
      name: 'Code Project Open License 1.02',
      licenseId: 'CPOL-1.02',
      seeAlso: ['http://www.codeproject.com/info/cpol10.aspx'],
      isOsiApproved: false}, {
      reference: './CUA-OPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CUA-OPL-1.0.json',
      referenceNumber: '353',
      name: 'CUA Office Public License v1.0',
      licenseId: 'CUA-OPL-1.0',
      seeAlso: ['https://opensource.org/licenses/CUA-OPL-1.0'],
      isOsiApproved: true}, {
      reference: './Caldera.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Caldera.json',
      referenceNumber: '102',
      name: 'Caldera License',
      licenseId: 'Caldera',
      seeAlso: ['http://www.lemis.com/grog/UNIX/ancient-source-all.pdf'],
      isOsiApproved: false}, {
      reference: './ClArtistic.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ClArtistic.json',
      referenceNumber: '264',
      name: 'Clarified Artistic License',
      licenseId: 'ClArtistic',
      seeAlso: ['http://gianluca.dellavedova.org/2011/01/03/clarified-artistic-license/', 'http://www.ncftp.com/ncftp/doc/LICENSE.txt'],
      isOsiApproved: false}, {
      reference: './Condor-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Condor-1.1.json',
      referenceNumber: '300',
      name: 'Condor Public License v1.1',
      licenseId: 'Condor-1.1',
      seeAlso: ['http://research.cs.wisc.edu/condor/license.html#condor', 'http://web.archive.org/web/20111123062036/http://research.cs.wisc.edu/condor/license.html#condor'],
      isOsiApproved: false}, {
      reference: './Crossword.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Crossword.json',
      referenceNumber: '351',
      name: 'Crossword License',
      licenseId: 'Crossword',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Crossword'],
      isOsiApproved: false}, {
      reference: './CrystalStacker.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/CrystalStacker.json',
      referenceNumber: '162',
      name: 'CrystalStacker License',
      licenseId: 'CrystalStacker',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing:CrystalStacker?rd=Licensing/CrystalStacker'],
      isOsiApproved: false}, {
      reference: './Cube.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Cube.json',
      referenceNumber: '358',
      name: 'Cube License',
      licenseId: 'Cube',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Cube'],
      isOsiApproved: false}, {
      reference: './D-FSL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/D-FSL-1.0.json',
      referenceNumber: '176',
      name: 'Deutsche Freie Software Lizenz',
      licenseId: 'D-FSL-1.0',
      seeAlso: ['http://www.dipp.nrw.de/d-fsl/lizenzen/', 'http://www.dipp.nrw.de/d-fsl/index_html/lizenzen/de/D-FSL-1_0_de.txt', 'http://www.dipp.nrw.de/d-fsl/index_html/lizenzen/en/D-FSL-1_0_en.txt', 'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl', 'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/deutsche-freie-software-lizenz', 'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/german-free-software-license', 'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/D-FSL-1_0_de.txt/at_download/file', 'https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/D-FSL-1_0_en.txt/at_download/file'],
      isOsiApproved: false}, {
      reference: './DOC.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/DOC.json',
      referenceNumber: '154',
      name: 'DOC License',
      licenseId: 'DOC',
      seeAlso: ['http://www.cs.wustl.edu/~schmidt/ACE-copying.html'],
      isOsiApproved: false}, {
      reference: './DSDP.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/DSDP.json',
      referenceNumber: '135',
      name: 'DSDP License',
      licenseId: 'DSDP',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/DSDP'],
      isOsiApproved: false}, {
      reference: './Dotseqn.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Dotseqn.json',
      referenceNumber: '377',
      name: 'Dotseqn License',
      licenseId: 'Dotseqn',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Dotseqn'],
      isOsiApproved: false}, {
      reference: './ECL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ECL-1.0.json',
      referenceNumber: '383',
      name: 'Educational Community License v1.0',
      licenseId: 'ECL-1.0',
      seeAlso: ['https://opensource.org/licenses/ECL-1.0'],
      isOsiApproved: true}, {
      reference: './ECL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ECL-2.0.json',
      referenceNumber: '291',
      name: 'Educational Community License v2.0',
      licenseId: 'ECL-2.0',
      seeAlso: ['https://opensource.org/licenses/ECL-2.0'],
      isOsiApproved: true}, {
      reference: './EFL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/EFL-1.0.json',
      referenceNumber: '144',
      name: 'Eiffel Forum License v1.0',
      licenseId: 'EFL-1.0',
      seeAlso: ['http://www.eiffel-nice.org/license/forum.txt', 'https://opensource.org/licenses/EFL-1.0'],
      isOsiApproved: true}, {
      reference: './EFL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EFL-2.0.json',
      referenceNumber: '155',
      name: 'Eiffel Forum License v2.0',
      licenseId: 'EFL-2.0',
      seeAlso: ['http://www.eiffel-nice.org/license/eiffel-forum-license-2.html', 'https://opensource.org/licenses/EFL-2.0'],
      isOsiApproved: true}, {
      reference: './EPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EPL-1.0.json',
      referenceNumber: '208',
      name: 'Eclipse Public License 1.0',
      licenseId: 'EPL-1.0',
      seeAlso: ['http://www.eclipse.org/legal/epl-v10.html', 'https://opensource.org/licenses/EPL-1.0'],
      isOsiApproved: true}, {
      reference: './EPL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EPL-2.0.json',
      referenceNumber: '128',
      name: 'Eclipse Public License 2.0',
      licenseId: 'EPL-2.0',
      seeAlso: ['https://www.eclipse.org/legal/epl-2.0', 'https://www.opensource.org/licenses/EPL-2.0'],
      isOsiApproved: true}, {
      reference: './EUDatagrid.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EUDatagrid.json',
      referenceNumber: '186',
      name: 'EU DataGrid Software License',
      licenseId: 'EUDatagrid',
      seeAlso: ['http://eu-datagrid.web.cern.ch/eu-datagrid/license.html', 'https://opensource.org/licenses/EUDatagrid'],
      isOsiApproved: true}, {
      reference: './EUPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/EUPL-1.0.json',
      referenceNumber: '167',
      name: 'European Union Public License 1.0',
      licenseId: 'EUPL-1.0',
      seeAlso: ['http://ec.europa.eu/idabc/en/document/7330.html', 'http://ec.europa.eu/idabc/servlets/Doc027f.pdf?id=31096'],
      isOsiApproved: false}, {
      reference: './EUPL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EUPL-1.1.json',
      referenceNumber: '87',
      name: 'European Union Public License 1.1',
      licenseId: 'EUPL-1.1',
      seeAlso: ['https://joinup.ec.europa.eu/software/page/eupl/licence-eupl', 'https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/eupl1.1.-licence-en_0.pdf', 'https://opensource.org/licenses/EUPL-1.1'],
      isOsiApproved: true}, {
      reference: './EUPL-1.2.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/EUPL-1.2.json',
      referenceNumber: '374',
      name: 'European Union Public License 1.2',
      licenseId: 'EUPL-1.2',
      seeAlso: ['https://joinup.ec.europa.eu/page/eupl-text-11-12', 'https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/eupl_v1.2_en.pdf', 'https://joinup.ec.europa.eu/sites/default/files/inline-files/EUPL%20v1_2%20EN(1).txt', 'http://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:32017D0863', 'https://opensource.org/licenses/EUPL-1.1'],
      isOsiApproved: true}, {
      reference: './Entessa.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Entessa.json',
      referenceNumber: '94',
      name: 'Entessa Public License v1.0',
      licenseId: 'Entessa',
      seeAlso: ['https://opensource.org/licenses/Entessa'],
      isOsiApproved: true}, {
      reference: './ErlPL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ErlPL-1.1.json',
      referenceNumber: '151',
      name: 'Erlang Public License v1.1',
      licenseId: 'ErlPL-1.1',
      seeAlso: ['http://www.erlang.org/EPLICENSE'],
      isOsiApproved: false}, {
      reference: './Eurosym.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Eurosym.json',
      referenceNumber: '107',
      name: 'Eurosym License',
      licenseId: 'Eurosym',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Eurosym'],
      isOsiApproved: false}, {
      reference: './FSFAP.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/FSFAP.json',
      referenceNumber: '108',
      name: 'FSF All Permissive License',
      licenseId: 'FSFAP',
      seeAlso: ['https://www.gnu.org/prep/maintain/html_node/License-Notices-for-Other-Files.html'],
      isOsiApproved: false}, {
      reference: './FSFUL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/FSFUL.json',
      referenceNumber: '187',
      name: 'FSF Unlimited License',
      licenseId: 'FSFUL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/FSF_Unlimited_License'],
      isOsiApproved: false}, {
      reference: './FSFULLR.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/FSFULLR.json',
      referenceNumber: '41',
      name: 'FSF Unlimited License (with License Retention)',
      licenseId: 'FSFULLR',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/FSF_Unlimited_License#License_Retention_Variant'],
      isOsiApproved: false}, {
      reference: './FTL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/FTL.json',
      referenceNumber: '234',
      name: 'Freetype Project License',
      licenseId: 'FTL',
      seeAlso: ['http://freetype.fis.uniroma2.it/FTL.TXT', 'http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/docs/FTL.TXT'],
      isOsiApproved: false}, {
      reference: './Fair.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Fair.json',
      referenceNumber: '290',
      name: 'Fair License',
      licenseId: 'Fair',
      seeAlso: ['http://fairlicense.org/', 'https://opensource.org/licenses/Fair'],
      isOsiApproved: true}, {
      reference: './Frameworx-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Frameworx-1.0.json',
      referenceNumber: '376',
      name: 'Frameworx Open License 1.0',
      licenseId: 'Frameworx-1.0',
      seeAlso: ['https://opensource.org/licenses/Frameworx-1.0'],
      isOsiApproved: true}, {
      reference: './FreeImage.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/FreeImage.json',
      referenceNumber: '270',
      name: 'FreeImage Public License v1.0',
      licenseId: 'FreeImage',
      seeAlso: ['http://freeimage.sourceforge.net/freeimage-license.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.1.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.1.json',
      referenceNumber: '93',
      name: 'GNU Free Documentation License v1.1',
      licenseId: 'GFDL-1.1',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.1-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.1-only.json',
      referenceNumber: '97',
      name: 'GNU Free Documentation License v1.1 only',
      licenseId: 'GFDL-1.1-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.1-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.1-or-later.json',
      referenceNumber: '338',
      name: 'GNU Free Documentation License v1.1 or later',
      licenseId: 'GFDL-1.1-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.2.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.2.json',
      referenceNumber: '191',
      name: 'GNU Free Documentation License v1.2',
      licenseId: 'GFDL-1.2',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.2-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.2-only.json',
      referenceNumber: '230',
      name: 'GNU Free Documentation License v1.2 only',
      licenseId: 'GFDL-1.2-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.2-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.2-or-later.json',
      referenceNumber: '209',
      name: 'GNU Free Documentation License v1.2 or later',
      licenseId: 'GFDL-1.2-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.3.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.3.json',
      referenceNumber: '106',
      name: 'GNU Free Documentation License v1.3',
      licenseId: 'GFDL-1.3',
      seeAlso: ['https://www.gnu.org/licenses/fdl-1.3.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.3-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.3-only.json',
      referenceNumber: '67',
      name: 'GNU Free Documentation License v1.3 only',
      licenseId: 'GFDL-1.3-only',
      seeAlso: ['https://www.gnu.org/licenses/fdl-1.3.txt'],
      isOsiApproved: false}, {
      reference: './GFDL-1.3-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GFDL-1.3-or-later.json',
      referenceNumber: '3',
      name: 'GNU Free Documentation License v1.3 or later',
      licenseId: 'GFDL-1.3-or-later',
      seeAlso: ['https://www.gnu.org/licenses/fdl-1.3.txt'],
      isOsiApproved: false}, {
      reference: './GL2PS.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/GL2PS.json',
      referenceNumber: '118',
      name: 'GL2PS License',
      licenseId: 'GL2PS',
      seeAlso: ['http://www.geuz.org/gl2ps/COPYING.GL2PS'],
      isOsiApproved: false}, {
      reference: './GPL-1.0.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-1.0.json',
      referenceNumber: '75',
      name: 'GNU General Public License v1.0 only',
      licenseId: 'GPL-1.0',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html'],
      isOsiApproved: false}, {
      reference: './GPL-1.0+.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-1.0+.json',
      referenceNumber: '169',
      name: 'GNU General Public License v1.0 or later',
      licenseId: 'GPL-1.0+',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html'],
      isOsiApproved: false}, {
      reference: './GPL-1.0-only.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/GPL-1.0-only.json',
      referenceNumber: '14',
      name: 'GNU General Public License v1.0 only',
      licenseId: 'GPL-1.0-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html'],
      isOsiApproved: false}, {
      reference: './GPL-1.0-or-later.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/GPL-1.0-or-later.json',
      referenceNumber: '345',
      name: 'GNU General Public License v1.0 or later',
      licenseId: 'GPL-1.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html'],
      isOsiApproved: false}, {
      reference: './GPL-2.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0.json',
      referenceNumber: '141',
      name: 'GNU General Public License v2.0 only',
      licenseId: 'GPL-2.0',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html', 'https://opensource.org/licenses/GPL-2.0'],
      isOsiApproved: true}, {
      reference: './GPL-2.0+.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0+.json',
      referenceNumber: '72',
      name: 'GNU General Public License v2.0 or later',
      licenseId: 'GPL-2.0+',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html', 'https://opensource.org/licenses/GPL-2.0'],
      isOsiApproved: true}, {
      reference: './GPL-2.0-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-only.json',
      referenceNumber: '227',
      name: 'GNU General Public License v2.0 only',
      licenseId: 'GPL-2.0-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html', 'https://opensource.org/licenses/GPL-2.0'],
      isOsiApproved: true}, {
      reference: './GPL-2.0-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-or-later.json',
      referenceNumber: '54',
      name: 'GNU General Public License v2.0 or later',
      licenseId: 'GPL-2.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html', 'https://opensource.org/licenses/GPL-2.0'],
      isOsiApproved: true}, {
      reference: './GPL-2.0-with-GCC-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-GCC-exception.json',
      referenceNumber: '111',
      name: 'GNU General Public License v2.0 w/GCC Runtime Library exception',
      licenseId: 'GPL-2.0-with-GCC-exception',
      seeAlso: ['https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/libgcc1.c;h=762f5143fc6eed57b6797c82710f3538aa52b40b;hb=cb143a3ce4fb417c68f5fa2691a1b1b1053dfba9#l10'],
      isOsiApproved: false}, {
      reference: './GPL-2.0-with-autoconf-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-autoconf-exception.json',
      referenceNumber: '344',
      name: 'GNU General Public License v2.0 w/Autoconf exception',
      licenseId: 'GPL-2.0-with-autoconf-exception',
      seeAlso: ['http://ac-archive.sourceforge.net/doc/copyright.html'],
      isOsiApproved: false}, {
      reference: './GPL-2.0-with-bison-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-bison-exception.json',
      referenceNumber: '365',
      name: 'GNU General Public License v2.0 w/Bison exception',
      licenseId: 'GPL-2.0-with-bison-exception',
      seeAlso: ['http://git.savannah.gnu.org/cgit/bison.git/tree/data/yacc.c?id=193d7c7054ba7197b0789e14965b739162319b5e#n141'],
      isOsiApproved: false}, {
      reference: './GPL-2.0-with-classpath-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-classpath-exception.json',
      referenceNumber: '58',
      name: 'GNU General Public License v2.0 w/Classpath exception',
      licenseId: 'GPL-2.0-with-classpath-exception',
      seeAlso: ['https://www.gnu.org/software/classpath/license.html'],
      isOsiApproved: false}, {
      reference: './GPL-2.0-with-font-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-2.0-with-font-exception.json',
      referenceNumber: '362',
      name: 'GNU General Public License v2.0 w/Font exception',
      licenseId: 'GPL-2.0-with-font-exception',
      seeAlso: ['https://www.gnu.org/licenses/gpl-faq.html#FontException'],
      isOsiApproved: false}, {
      reference: './GPL-3.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0.json',
      referenceNumber: '236',
      name: 'GNU General Public License v3.0 only',
      licenseId: 'GPL-3.0',
      seeAlso: ['https://www.gnu.org/licenses/gpl-3.0-standalone.html', 'https://opensource.org/licenses/GPL-3.0'],
      isOsiApproved: true}, {
      reference: './GPL-3.0+.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0+.json',
      referenceNumber: '70',
      name: 'GNU General Public License v3.0 or later',
      licenseId: 'GPL-3.0+',
      seeAlso: ['https://www.gnu.org/licenses/gpl-3.0-standalone.html', 'https://opensource.org/licenses/GPL-3.0'],
      isOsiApproved: true}, {
      reference: './GPL-3.0-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0-only.json',
      referenceNumber: '200',
      name: 'GNU General Public License v3.0 only',
      licenseId: 'GPL-3.0-only',
      seeAlso: ['https://www.gnu.org/licenses/gpl-3.0-standalone.html', 'https://opensource.org/licenses/GPL-3.0'],
      isOsiApproved: true}, {
      reference: './GPL-3.0-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0-or-later.json',
      referenceNumber: '190',
      name: 'GNU General Public License v3.0 or later',
      licenseId: 'GPL-3.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/gpl-3.0-standalone.html', 'https://opensource.org/licenses/GPL-3.0'],
      isOsiApproved: true}, {
      reference: './GPL-3.0-with-GCC-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0-with-GCC-exception.json',
      referenceNumber: '215',
      name: 'GNU General Public License v3.0 w/GCC Runtime Library exception',
      licenseId: 'GPL-3.0-with-GCC-exception',
      seeAlso: ['https://www.gnu.org/licenses/gcc-exception-3.1.html'],
      isOsiApproved: true}, {
      reference: './GPL-3.0-with-autoconf-exception.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/GPL-3.0-with-autoconf-exception.json',
      referenceNumber: '229',
      name: 'GNU General Public License v3.0 w/Autoconf exception',
      licenseId: 'GPL-3.0-with-autoconf-exception',
      seeAlso: ['https://www.gnu.org/licenses/autoconf-exception-3.0.html'],
      isOsiApproved: false}, {
      reference: './Giftware.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Giftware.json',
      referenceNumber: '357',
      name: 'Giftware License',
      licenseId: 'Giftware',
      seeAlso: ['http://liballeg.org/license.html#allegro-4-the-giftware-license'],
      isOsiApproved: false}, {
      reference: './Glide.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Glide.json',
      referenceNumber: '361',
      name: '3dfx Glide License',
      licenseId: 'Glide',
      seeAlso: ['http://www.users.on.net/~triforce/glidexp/COPYING.txt'],
      isOsiApproved: false}, {
      reference: './Glulxe.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Glulxe.json',
      referenceNumber: '88',
      name: 'Glulxe License',
      licenseId: 'Glulxe',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Glulxe'],
      isOsiApproved: false}, {
      reference: './HPND.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/HPND.json',
      referenceNumber: '258',
      name: 'Historical Permission Notice and Disclaimer',
      licenseId: 'HPND',
      seeAlso: ['https://opensource.org/licenses/HPND'],
      isOsiApproved: true}, {
      reference: './HPND-sell-variant.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/HPND-sell-variant.json',
      referenceNumber: '139',
      name: 'Historical Permission Notice and Disclaimer - sell variant',
      licenseId: 'HPND-sell-variant',
      seeAlso: ['https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/auth_gss/gss_generic_token.c?h=v4.19'],
      isOsiApproved: false}, {
      reference: './HaskellReport.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/HaskellReport.json',
      referenceNumber: '116',
      name: 'Haskell Language Report License',
      licenseId: 'HaskellReport',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Haskell_Language_Report_License'],
      isOsiApproved: false}, {
      reference: './IBM-pibs.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/IBM-pibs.json',
      referenceNumber: '201',
      name: 'IBM PowerPC Initialization and Boot Software',
      licenseId: 'IBM-pibs',
      seeAlso: ['http://git.denx.de/?p=u-boot.git;a=blob;f=arch/powerpc/cpu/ppc4xx/miiphy.c;h=297155fdafa064b955e53e9832de93bfb0cfb85b;hb=9fab4bf4cc077c21e43941866f3f2c196f28670d'],
      isOsiApproved: false}, {
      reference: './ICU.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ICU.json',
      referenceNumber: '188',
      name: 'ICU License',
      licenseId: 'ICU',
      seeAlso: ['http://source.icu-project.org/repos/icu/icu/trunk/license.html'],
      isOsiApproved: false}, {
      reference: './IJG.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/IJG.json',
      referenceNumber: '53',
      name: 'Independent JPEG Group License',
      licenseId: 'IJG',
      seeAlso: ['http://dev.w3.org/cvsweb/Amaya/libjpeg/Attic/README?rev=1.2'],
      isOsiApproved: false}, {
      reference: './IPA.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/IPA.json',
      referenceNumber: '305',
      name: 'IPA Font License',
      licenseId: 'IPA',
      seeAlso: ['https://opensource.org/licenses/IPA'],
      isOsiApproved: true}, {
      reference: './IPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/IPL-1.0.json',
      referenceNumber: '29',
      name: 'IBM Public License v1.0',
      licenseId: 'IPL-1.0',
      seeAlso: ['https://opensource.org/licenses/IPL-1.0'],
      isOsiApproved: true}, {
      reference: './ISC.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ISC.json',
      referenceNumber: '104',
      name: 'ISC License',
      licenseId: 'ISC',
      seeAlso: ['https://www.isc.org/downloads/software-support-policy/isc-license/', 'https://opensource.org/licenses/ISC'],
      isOsiApproved: true}, {
      reference: './ImageMagick.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ImageMagick.json',
      referenceNumber: '225',
      name: 'ImageMagick License',
      licenseId: 'ImageMagick',
      seeAlso: ['http://www.imagemagick.org/script/license.php'],
      isOsiApproved: false}, {
      reference: './Imlib2.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Imlib2.json',
      referenceNumber: '251',
      name: 'Imlib2 License',
      licenseId: 'Imlib2',
      seeAlso: ['http://trac.enlightenment.org/e/browser/trunk/imlib2/COPYING', 'https://git.enlightenment.org/legacy/imlib2.git/tree/COPYING'],
      isOsiApproved: false}, {
      reference: './Info-ZIP.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Info-ZIP.json',
      referenceNumber: '99',
      name: 'Info-ZIP License',
      licenseId: 'Info-ZIP',
      seeAlso: ['http://www.info-zip.org/license.html'],
      isOsiApproved: false}, {
      reference: './Intel.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Intel.json',
      referenceNumber: '161',
      name: 'Intel Open Source License',
      licenseId: 'Intel',
      seeAlso: ['https://opensource.org/licenses/Intel'],
      isOsiApproved: true}, {
      reference: './Intel-ACPI.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Intel-ACPI.json',
      referenceNumber: '84',
      name: 'Intel ACPI Software License Agreement',
      licenseId: 'Intel-ACPI',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Intel_ACPI_Software_License_Agreement'],
      isOsiApproved: false}, {
      reference: './Interbase-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Interbase-1.0.json',
      referenceNumber: '79',
      name: 'Interbase Public License v1.0',
      licenseId: 'Interbase-1.0',
      seeAlso: ['https://web.archive.org/web/20060319014854/http://info.borland.com/devsupport/interbase/opensource/IPL.html'],
      isOsiApproved: false}, {
      reference: './JSON.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/JSON.json',
      referenceNumber: '359',
      name: 'JSON License',
      licenseId: 'JSON',
      seeAlso: ['http://www.json.org/license.html'],
      isOsiApproved: false}, {
      reference: './JasPer-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/JasPer-2.0.json',
      referenceNumber: '233',
      name: 'JasPer License',
      licenseId: 'JasPer-2.0',
      seeAlso: ['http://www.ece.uvic.ca/~mdadams/jasper/LICENSE'],
      isOsiApproved: false}, {
      reference: './LAL-1.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LAL-1.2.json',
      referenceNumber: '367',
      name: 'Licence Art Libre 1.2',
      licenseId: 'LAL-1.2',
      seeAlso: ['http://artlibre.org/licence/lal/licence-art-libre-12/'],
      isOsiApproved: false}, {
      reference: './LAL-1.3.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LAL-1.3.json',
      referenceNumber: '150',
      name: 'Licence Art Libre 1.3',
      licenseId: 'LAL-1.3',
      seeAlso: ['http://artlibre.org/'],
      isOsiApproved: false}, {
      reference: './LGPL-2.0.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.0.json',
      referenceNumber: '261',
      name: 'GNU Library General Public License v2 only',
      licenseId: 'LGPL-2.0',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html'],
      isOsiApproved: true}, {
      reference: './LGPL-2.0+.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.0+.json',
      referenceNumber: '50',
      name: 'GNU Library General Public License v2 or later',
      licenseId: 'LGPL-2.0+',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html'],
      isOsiApproved: true}, {
      reference: './LGPL-2.0-only.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.0-only.json',
      referenceNumber: '269',
      name: 'GNU Library General Public License v2 only',
      licenseId: 'LGPL-2.0-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html'],
      isOsiApproved: true}, {
      reference: './LGPL-2.0-or-later.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.0-or-later.json',
      referenceNumber: '211',
      name: 'GNU Library General Public License v2 or later',
      licenseId: 'LGPL-2.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html'],
      isOsiApproved: true}, {
      reference: './LGPL-2.1.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.1.json',
      referenceNumber: '160',
      name: 'GNU Lesser General Public License v2.1 only',
      licenseId: 'LGPL-2.1',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html', 'https://opensource.org/licenses/LGPL-2.1'],
      isOsiApproved: true}, {
      reference: './LGPL-2.1+.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.1+.json',
      referenceNumber: '62',
      name: 'GNU Library General Public License v2.1 or later',
      licenseId: 'LGPL-2.1+',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html', 'https://opensource.org/licenses/LGPL-2.1'],
      isOsiApproved: true}, {
      reference: './LGPL-2.1-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.1-only.json',
      referenceNumber: '2',
      name: 'GNU Lesser General Public License v2.1 only',
      licenseId: 'LGPL-2.1-only',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html', 'https://opensource.org/licenses/LGPL-2.1'],
      isOsiApproved: true}, {
      reference: './LGPL-2.1-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-2.1-or-later.json',
      referenceNumber: '329',
      name: 'GNU Lesser General Public License v2.1 or later',
      licenseId: 'LGPL-2.1-or-later',
      seeAlso: ['https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html', 'https://opensource.org/licenses/LGPL-2.1'],
      isOsiApproved: true}, {
      reference: './LGPL-3.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-3.0.json',
      referenceNumber: '204',
      name: 'GNU Lesser General Public License v3.0 only',
      licenseId: 'LGPL-3.0',
      seeAlso: ['https://www.gnu.org/licenses/lgpl-3.0-standalone.html', 'https://opensource.org/licenses/LGPL-3.0'],
      isOsiApproved: true}, {
      reference: './LGPL-3.0+.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-3.0+.json',
      referenceNumber: '146',
      name: 'GNU Lesser General Public License v3.0 or later',
      licenseId: 'LGPL-3.0+',
      seeAlso: ['https://www.gnu.org/licenses/lgpl-3.0-standalone.html', 'https://opensource.org/licenses/LGPL-3.0'],
      isOsiApproved: true}, {
      reference: './LGPL-3.0-only.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-3.0-only.json',
      referenceNumber: '248',
      name: 'GNU Lesser General Public License v3.0 only',
      licenseId: 'LGPL-3.0-only',
      seeAlso: ['https://www.gnu.org/licenses/lgpl-3.0-standalone.html', 'https://opensource.org/licenses/LGPL-3.0'],
      isOsiApproved: true}, {
      reference: './LGPL-3.0-or-later.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LGPL-3.0-or-later.json',
      referenceNumber: '294',
      name: 'GNU Lesser General Public License v3.0 or later',
      licenseId: 'LGPL-3.0-or-later',
      seeAlso: ['https://www.gnu.org/licenses/lgpl-3.0-standalone.html', 'https://opensource.org/licenses/LGPL-3.0'],
      isOsiApproved: true}, {
      reference: './LGPLLR.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LGPLLR.json',
      referenceNumber: '98',
      name: 'Lesser General Public License For Linguistic Resources',
      licenseId: 'LGPLLR',
      seeAlso: ['http://www-igm.univ-mlv.fr/~unitex/lgpllr.html'],
      isOsiApproved: false}, {
      reference: './LPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LPL-1.0.json',
      referenceNumber: '85',
      name: 'Lucent Public License Version 1.0',
      licenseId: 'LPL-1.0',
      seeAlso: ['https://opensource.org/licenses/LPL-1.0'],
      isOsiApproved: true}, {
      reference: './LPL-1.02.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LPL-1.02.json',
      referenceNumber: '125',
      name: 'Lucent Public License v1.02',
      licenseId: 'LPL-1.02',
      seeAlso: ['http://plan9.bell-labs.com/plan9/license.html', 'https://opensource.org/licenses/LPL-1.02'],
      isOsiApproved: true}, {
      reference: './LPPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LPPL-1.0.json',
      referenceNumber: '253',
      name: 'LaTeX Project Public License v1.0',
      licenseId: 'LPPL-1.0',
      seeAlso: ['http://www.latex-project.org/lppl/lppl-1-0.txt'],
      isOsiApproved: false}, {
      reference: './LPPL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LPPL-1.1.json',
      referenceNumber: '302',
      name: 'LaTeX Project Public License v1.1',
      licenseId: 'LPPL-1.1',
      seeAlso: ['http://www.latex-project.org/lppl/lppl-1-1.txt'],
      isOsiApproved: false}, {
      reference: './LPPL-1.2.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LPPL-1.2.json',
      referenceNumber: '379',
      name: 'LaTeX Project Public License v1.2',
      licenseId: 'LPPL-1.2',
      seeAlso: ['http://www.latex-project.org/lppl/lppl-1-2.txt'],
      isOsiApproved: false}, {
      reference: './LPPL-1.3a.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/LPPL-1.3a.json',
      referenceNumber: '298',
      name: 'LaTeX Project Public License v1.3a',
      licenseId: 'LPPL-1.3a',
      seeAlso: ['http://www.latex-project.org/lppl/lppl-1-3a.txt'],
      isOsiApproved: false}, {
      reference: './LPPL-1.3c.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LPPL-1.3c.json',
      referenceNumber: '318',
      name: 'LaTeX Project Public License v1.3c',
      licenseId: 'LPPL-1.3c',
      seeAlso: ['http://www.latex-project.org/lppl/lppl-1-3c.txt', 'https://opensource.org/licenses/LPPL-1.3c'],
      isOsiApproved: true}, {
      reference: './Latex2e.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Latex2e.json',
      referenceNumber: '276',
      name: 'Latex2e License',
      licenseId: 'Latex2e',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Latex2e'],
      isOsiApproved: false}, {
      reference: './Leptonica.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Leptonica.json',
      referenceNumber: '153',
      name: 'Leptonica License',
      licenseId: 'Leptonica',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Leptonica'],
      isOsiApproved: false}, {
      reference: './LiLiQ-P-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LiLiQ-P-1.1.json',
      referenceNumber: '366',
      name: 'Licence Libre du Qu\xe9bec \u2013 Permissive version 1.1',
      licenseId: 'LiLiQ-P-1.1',
      seeAlso: ['https://forge.gouv.qc.ca/licence/fr/liliq-v1-1/', 'http://opensource.org/licenses/LiLiQ-P-1.1'],
      isOsiApproved: true}, {
      reference: './LiLiQ-R-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LiLiQ-R-1.1.json',
      referenceNumber: '279',
      name: 'Licence Libre du Qu\xe9bec \u2013 R\xe9ciprocit\xe9 version 1.1',
      licenseId: 'LiLiQ-R-1.1',
      seeAlso: ['https://www.forge.gouv.qc.ca/participez/licence-logicielle/licence-libre-du-quebec-liliq-en-francais/licence-libre-du-quebec-reciprocite-liliq-r-v1-1/', 'http://opensource.org/licenses/LiLiQ-R-1.1'],
      isOsiApproved: true}, {
      reference: './LiLiQ-Rplus-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/LiLiQ-Rplus-1.1.json',
      referenceNumber: '133',
      name: 'Licence Libre du Qu\xe9bec \u2013 R\xe9ciprocit\xe9 forte version 1.1',
      licenseId: 'LiLiQ-Rplus-1.1',
      seeAlso: ['https://www.forge.gouv.qc.ca/participez/licence-logicielle/licence-libre-du-quebec-liliq-en-francais/licence-libre-du-quebec-reciprocite-forte-liliq-r-v1-1/', 'http://opensource.org/licenses/LiLiQ-Rplus-1.1'],
      isOsiApproved: true}, {
      reference: './Libpng.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Libpng.json',
      referenceNumber: '96',
      name: 'libpng License',
      licenseId: 'Libpng',
      seeAlso: ['http://www.libpng.org/pub/png/src/libpng-LICENSE.txt'],
      isOsiApproved: false}, {
      reference: './Linux-OpenIB.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Linux-OpenIB.json',
      referenceNumber: '4',
      name: 'Linux Kernel Variant of OpenIB.org license',
      licenseId: 'Linux-OpenIB',
      seeAlso: ['https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/infiniband/core/sa.h'],
      isOsiApproved: false}, {
      reference: './MIT.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/MIT.json',
      referenceNumber: '195',
      name: 'MIT License',
      licenseId: 'MIT',
      seeAlso: ['https://opensource.org/licenses/MIT'],
      isOsiApproved: true}, {
      reference: './MIT-0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MIT-0.json',
      referenceNumber: '5',
      name: 'MIT No Attribution',
      licenseId: 'MIT-0',
      seeAlso: ['https://github.com/aws/mit-0', 'https://romanrm.net/mit-zero', 'https://github.com/awsdocs/aws-cloud9-user-guide/blob/master/LICENSE-SAMPLECODE'],
      isOsiApproved: true}, {
      reference: './MIT-CMU.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MIT-CMU.json',
      referenceNumber: '8',
      name: 'CMU License',
      licenseId: 'MIT-CMU',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing:MIT?rd=Licensing/MIT#CMU_Style'],
      isOsiApproved: false}, {
      reference: './MIT-advertising.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MIT-advertising.json',
      referenceNumber: '7',
      name: 'Enlightenment License (e16)',
      licenseId: 'MIT-advertising',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT_With_Advertising'],
      isOsiApproved: false}, {
      reference: './MIT-enna.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MIT-enna.json',
      referenceNumber: '23',
      name: 'enna License',
      licenseId: 'MIT-enna',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT#enna'],
      isOsiApproved: false}, {
      reference: './MIT-feh.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MIT-feh.json',
      referenceNumber: '36',
      name: 'feh License',
      licenseId: 'MIT-feh',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT#feh'],
      isOsiApproved: false}, {
      reference: './MITNFA.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MITNFA.json',
      referenceNumber: '287',
      name: 'MIT +no-false-attribs license',
      licenseId: 'MITNFA',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MITNFA'],
      isOsiApproved: false}, {
      reference: './MPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MPL-1.0.json',
      referenceNumber: '47',
      name: 'Mozilla Public License 1.0',
      licenseId: 'MPL-1.0',
      seeAlso: ['http://www.mozilla.org/MPL/MPL-1.0.html', 'https://opensource.org/licenses/MPL-1.0'],
      isOsiApproved: true}, {
      reference: './MPL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/MPL-1.1.json',
      referenceNumber: '297',
      name: 'Mozilla Public License 1.1',
      licenseId: 'MPL-1.1',
      seeAlso: ['http://www.mozilla.org/MPL/MPL-1.1.html', 'https://opensource.org/licenses/MPL-1.1'],
      isOsiApproved: true}, {
      reference: './MPL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/MPL-2.0.json',
      referenceNumber: '228',
      name: 'Mozilla Public License 2.0',
      licenseId: 'MPL-2.0',
      seeAlso: ['http://www.mozilla.org/MPL/2.0/', 'https://opensource.org/licenses/MPL-2.0'],
      isOsiApproved: true}, {
      reference: './MPL-2.0-no-copyleft-exception.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MPL-2.0-no-copyleft-exception.json',
      referenceNumber: '296',
      name: 'Mozilla Public License 2.0 (no copyleft exception)',
      licenseId: 'MPL-2.0-no-copyleft-exception',
      seeAlso: ['http://www.mozilla.org/MPL/2.0/', 'https://opensource.org/licenses/MPL-2.0'],
      isOsiApproved: true}, {
      reference: './MS-PL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/MS-PL.json',
      referenceNumber: '327',
      name: 'Microsoft Public License',
      licenseId: 'MS-PL',
      seeAlso: ['http://www.microsoft.com/opensource/licenses.mspx', 'https://opensource.org/licenses/MS-PL'],
      isOsiApproved: true}, {
      reference: './MS-RL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/MS-RL.json',
      referenceNumber: '273',
      name: 'Microsoft Reciprocal License',
      licenseId: 'MS-RL',
      seeAlso: ['http://www.microsoft.com/opensource/licenses.mspx', 'https://opensource.org/licenses/MS-RL'],
      isOsiApproved: true}, {
      reference: './MTLL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MTLL.json',
      referenceNumber: '175',
      name: 'Matrix Template Library License',
      licenseId: 'MTLL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Matrix_Template_Library_License'],
      isOsiApproved: false}, {
      reference: './MakeIndex.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MakeIndex.json',
      referenceNumber: '181',
      name: 'MakeIndex License',
      licenseId: 'MakeIndex',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MakeIndex'],
      isOsiApproved: false}, {
      reference: './MirOS.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/MirOS.json',
      referenceNumber: '292',
      name: 'MirOS License',
      licenseId: 'MirOS',
      seeAlso: ['https://opensource.org/licenses/MirOS'],
      isOsiApproved: true}, {
      reference: './Motosoto.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Motosoto.json',
      referenceNumber: '309',
      name: 'Motosoto License',
      licenseId: 'Motosoto',
      seeAlso: ['https://opensource.org/licenses/Motosoto'],
      isOsiApproved: true}, {
      reference: './Multics.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Multics.json',
      referenceNumber: '61',
      name: 'Multics License',
      licenseId: 'Multics',
      seeAlso: ['https://opensource.org/licenses/Multics'],
      isOsiApproved: true}, {
      reference: './Mup.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Mup.json',
      referenceNumber: '342',
      name: 'Mup License',
      licenseId: 'Mup',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Mup'],
      isOsiApproved: false}, {
      reference: './NASA-1.3.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NASA-1.3.json',
      referenceNumber: '83',
      name: 'NASA Open Source Agreement 1.3',
      licenseId: 'NASA-1.3',
      seeAlso: ['http://ti.arc.nasa.gov/opensource/nosa/', 'https://opensource.org/licenses/NASA-1.3'],
      isOsiApproved: true}, {
      reference: './NBPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NBPL-1.0.json',
      referenceNumber: '349',
      name: 'Net Boolean Public License v1',
      licenseId: 'NBPL-1.0',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=37b4b3f6cc4bf34e1d3dec61e69914b9819d8894'],
      isOsiApproved: false}, {
      reference: './NCSA.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/NCSA.json',
      referenceNumber: '56',
      name: 'University of Illinois/NCSA Open Source License',
      licenseId: 'NCSA',
      seeAlso: ['http://otm.illinois.edu/uiuc_openSource', 'https://opensource.org/licenses/NCSA'],
      isOsiApproved: true}, {
      reference: './NGPL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NGPL.json',
      referenceNumber: '69',
      name: 'Nethack General Public License',
      licenseId: 'NGPL',
      seeAlso: ['https://opensource.org/licenses/NGPL'],
      isOsiApproved: true}, {
      reference: './NLOD-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NLOD-1.0.json',
      referenceNumber: '203',
      name: 'Norwegian Licence for Open Government Data',
      licenseId: 'NLOD-1.0',
      seeAlso: ['http://data.norge.no/nlod/en/1.0'],
      isOsiApproved: false}, {
      reference: './NLPL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NLPL.json',
      referenceNumber: '334',
      name: 'No Limit Public License',
      licenseId: 'NLPL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/NLPL'],
      isOsiApproved: false}, {
      reference: './NOSL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/NOSL.json',
      referenceNumber: '370',
      name: 'Netizen Open Source License',
      licenseId: 'NOSL',
      seeAlso: ['http://bits.netizen.com.au/licenses/NOSL/nosl.txt'],
      isOsiApproved: false}, {
      reference: './NPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/NPL-1.0.json',
      referenceNumber: '320',
      name: 'Netscape Public License v1.0',
      licenseId: 'NPL-1.0',
      seeAlso: ['http://www.mozilla.org/MPL/NPL/1.0/'],
      isOsiApproved: false}, {
      reference: './NPL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/NPL-1.1.json',
      referenceNumber: '179',
      name: 'Netscape Public License v1.1',
      licenseId: 'NPL-1.1',
      seeAlso: ['http://www.mozilla.org/MPL/NPL/1.1/'],
      isOsiApproved: false}, {
      reference: './NPOSL-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NPOSL-3.0.json',
      referenceNumber: '216',
      name: 'Non-Profit Open Software License 3.0',
      licenseId: 'NPOSL-3.0',
      seeAlso: ['https://opensource.org/licenses/NOSL3.0'],
      isOsiApproved: true}, {
      reference: './NRL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NRL.json',
      referenceNumber: '51',
      name: 'NRL License',
      licenseId: 'NRL',
      seeAlso: ['http://web.mit.edu/network/isakmp/nrllicense.html'],
      isOsiApproved: false}, {
      reference: './NTP.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NTP.json',
      referenceNumber: '255',
      name: 'NTP License',
      licenseId: 'NTP',
      seeAlso: ['https://opensource.org/licenses/NTP'],
      isOsiApproved: true}, {
      reference: './Naumen.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Naumen.json',
      referenceNumber: '271',
      name: 'Naumen Public License',
      licenseId: 'Naumen',
      seeAlso: ['https://opensource.org/licenses/Naumen'],
      isOsiApproved: true}, {
      reference: './Net-SNMP.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Net-SNMP.json',
      referenceNumber: '277',
      name: 'Net-SNMP License',
      licenseId: 'Net-SNMP',
      seeAlso: ['http://net-snmp.sourceforge.net/about/license.html'],
      isOsiApproved: false}, {
      reference: './NetCDF.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/NetCDF.json',
      referenceNumber: '44',
      name: 'NetCDF license',
      licenseId: 'NetCDF',
      seeAlso: ['http://www.unidata.ucar.edu/software/netcdf/copyright.html'],
      isOsiApproved: false}, {
      reference: './Newsletr.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Newsletr.json',
      referenceNumber: '272',
      name: 'Newsletr License',
      licenseId: 'Newsletr',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Newsletr'],
      isOsiApproved: false}, {
      reference: './Nokia.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Nokia.json',
      referenceNumber: '319',
      name: 'Nokia Open Source License',
      licenseId: 'Nokia',
      seeAlso: ['https://opensource.org/licenses/nokia'],
      isOsiApproved: true}, {
      reference: './Noweb.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Noweb.json',
      referenceNumber: '352',
      name: 'Noweb License',
      licenseId: 'Noweb',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Noweb'],
      isOsiApproved: false}, {
      reference: './Nunit.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Nunit.json',
      referenceNumber: '281',
      name: 'Nunit License',
      licenseId: 'Nunit',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Nunit'],
      isOsiApproved: false}, {
      reference: './OCCT-PL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OCCT-PL.json',
      referenceNumber: '275',
      name: 'Open CASCADE Technology Public License',
      licenseId: 'OCCT-PL',
      seeAlso: ['http://www.opencascade.com/content/occt-public-license'],
      isOsiApproved: false}, {
      reference: './OCLC-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OCLC-2.0.json',
      referenceNumber: '105',
      name: 'OCLC Research Public License 2.0',
      licenseId: 'OCLC-2.0',
      seeAlso: ['http://www.oclc.org/research/activities/software/license/v2final.htm', 'https://opensource.org/licenses/OCLC-2.0'],
      isOsiApproved: true}, {
      reference: './ODC-By-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ODC-By-1.0.json',
      referenceNumber: '138',
      name: 'Open Data Commons Attribution License v1.0',
      licenseId: 'ODC-By-1.0',
      seeAlso: ['https://opendatacommons.org/licenses/by/1.0/'],
      isOsiApproved: false}, {
      reference: './ODbL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ODbL-1.0.json',
      referenceNumber: '240',
      name: 'ODC Open Database License v1.0',
      licenseId: 'ODbL-1.0',
      seeAlso: ['http://www.opendatacommons.org/licenses/odbl/1.0/'],
      isOsiApproved: false}, {
      reference: './OFL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OFL-1.0.json',
      referenceNumber: '147',
      name: 'SIL Open Font License 1.0',
      licenseId: 'OFL-1.0',
      seeAlso: ['http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web'],
      isOsiApproved: false}, {
      reference: './OFL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OFL-1.1.json',
      referenceNumber: '307',
      name: 'SIL Open Font License 1.1',
      licenseId: 'OFL-1.1',
      seeAlso: ['http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web', 'https://opensource.org/licenses/OFL-1.1'],
      isOsiApproved: true}, {
      reference: './OGL-UK-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OGL-UK-1.0.json',
      referenceNumber: '110',
      name: 'Open Government Licence v1.0',
      licenseId: 'OGL-UK-1.0',
      seeAlso: ['http://www.nationalarchives.gov.uk/doc/open-government-licence/version/1/'],
      isOsiApproved: false}, {
      reference: './OGL-UK-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OGL-UK-2.0.json',
      referenceNumber: '282',
      name: 'Open Government Licence v2.0',
      licenseId: 'OGL-UK-2.0',
      seeAlso: ['http://www.nationalarchives.gov.uk/doc/open-government-licence/version/2/'],
      isOsiApproved: false}, {
      reference: './OGL-UK-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OGL-UK-3.0.json',
      referenceNumber: '220',
      name: 'Open Government Licence v3.0',
      licenseId: 'OGL-UK-3.0',
      seeAlso: ['http://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/'],
      isOsiApproved: false}, {
      reference: './OGTSL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OGTSL.json',
      referenceNumber: '119',
      name: 'Open Group Test Suite License',
      licenseId: 'OGTSL',
      seeAlso: ['http://www.opengroup.org/testing/downloads/The_Open_Group_TSL.txt', 'https://opensource.org/licenses/OGTSL'],
      isOsiApproved: true}, {
      reference: './OLDAP-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-1.1.json',
      referenceNumber: '92',
      name: 'Open LDAP Public License v1.1',
      licenseId: 'OLDAP-1.1',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=806557a5ad59804ef3a44d5abfbe91d706b0791f'],
      isOsiApproved: false}, {
      reference: './OLDAP-1.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-1.2.json',
      referenceNumber: '184',
      name: 'Open LDAP Public License v1.2',
      licenseId: 'OLDAP-1.2',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=42b0383c50c299977b5893ee695cf4e486fb0dc7'],
      isOsiApproved: false}, {
      reference: './OLDAP-1.3.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-1.3.json',
      referenceNumber: '100',
      name: 'Open LDAP Public License v1.3',
      licenseId: 'OLDAP-1.3',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=e5f8117f0ce088d0bd7a8e18ddf37eaa40eb09b1'],
      isOsiApproved: false}, {
      reference: './OLDAP-1.4.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-1.4.json',
      referenceNumber: '28',
      name: 'Open LDAP Public License v1.4',
      licenseId: 'OLDAP-1.4',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=c9f95c2f3f2ffb5e0ae55fe7388af75547660941'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.0.json',
      referenceNumber: '260',
      name: 'Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B)',
      licenseId: 'OLDAP-2.0',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=cbf50f4e1185a21abd4c0a54d3f4341fe28f36ea'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.0.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.0.1.json',
      referenceNumber: '339',
      name: 'Open LDAP Public License v2.0.1',
      licenseId: 'OLDAP-2.0.1',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=b6d68acd14e51ca3aab4428bf26522aa74873f0e'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.1.json',
      referenceNumber: '148',
      name: 'Open LDAP Public License v2.1',
      licenseId: 'OLDAP-2.1',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=b0d176738e96a0d3b9f85cb51e140a86f21be715'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.2.json',
      referenceNumber: '350',
      name: 'Open LDAP Public License v2.2',
      licenseId: 'OLDAP-2.2',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=470b0c18ec67621c85881b2733057fecf4a1acc3'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.2.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.2.1.json',
      referenceNumber: '330',
      name: 'Open LDAP Public License v2.2.1',
      licenseId: 'OLDAP-2.2.1',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=4bc786f34b50aa301be6f5600f58a980070f481e'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.2.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.2.2.json',
      referenceNumber: '193',
      name: 'Open LDAP Public License 2.2.2',
      licenseId: 'OLDAP-2.2.2',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=df2cc1e21eb7c160695f5b7cffd6296c151ba188'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.3.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.3.json',
      referenceNumber: '158',
      name: 'Open LDAP Public License v2.3',
      licenseId: 'OLDAP-2.3',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=d32cf54a32d581ab475d23c810b0a7fbaf8d63c3'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.4.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.4.json',
      referenceNumber: '64',
      name: 'Open LDAP Public License v2.4',
      licenseId: 'OLDAP-2.4',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=cd1284c4a91a8a380d904eee68d1583f989ed386'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.5.json',
      referenceNumber: '177',
      name: 'Open LDAP Public License v2.5',
      licenseId: 'OLDAP-2.5',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=6852b9d90022e8593c98205413380536b1b5a7cf'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.6.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.6.json',
      referenceNumber: '59',
      name: 'Open LDAP Public License v2.6',
      licenseId: 'OLDAP-2.6',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=1cae062821881f41b73012ba816434897abf4205'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.7.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.7.json',
      referenceNumber: '117',
      name: 'Open LDAP Public License v2.7',
      licenseId: 'OLDAP-2.7',
      seeAlso: ['http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=47c2415c1df81556eeb39be6cad458ef87c534a2'],
      isOsiApproved: false}, {
      reference: './OLDAP-2.8.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OLDAP-2.8.json',
      referenceNumber: '35',
      name: 'Open LDAP Public License v2.8',
      licenseId: 'OLDAP-2.8',
      seeAlso: ['http://www.openldap.org/software/release/license.html'],
      isOsiApproved: false}, {
      reference: './OML.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OML.json',
      referenceNumber: '63',
      name: 'Open Market License',
      licenseId: 'OML',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Open_Market_License'],
      isOsiApproved: false}, {
      reference: './OPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OPL-1.0.json',
      referenceNumber: '333',
      name: 'Open Public License v1.0',
      licenseId: 'OPL-1.0',
      seeAlso: ['http://old.koalateam.com/jackaroo/OPL_1_0.TXT', 'https://fedoraproject.org/wiki/Licensing/Open_Public_License'],
      isOsiApproved: false}, {
      reference: './OSET-PL-2.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/OSET-PL-2.1.json',
      referenceNumber: '284',
      name: 'OSET Public License version 2.1',
      licenseId: 'OSET-PL-2.1',
      seeAlso: ['http://www.osetfoundation.org/public-license', 'https://opensource.org/licenses/OPL-2.1'],
      isOsiApproved: true}, {
      reference: './OSL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OSL-1.0.json',
      referenceNumber: '81',
      name: 'Open Software License 1.0',
      licenseId: 'OSL-1.0',
      seeAlso: ['https://opensource.org/licenses/OSL-1.0'],
      isOsiApproved: true}, {
      reference: './OSL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OSL-1.1.json',
      referenceNumber: '325',
      name: 'Open Software License 1.1',
      licenseId: 'OSL-1.1',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/OSL1.1'],
      isOsiApproved: false}, {
      reference: './OSL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OSL-2.0.json',
      referenceNumber: '19',
      name: 'Open Software License 2.0',
      licenseId: 'OSL-2.0',
      seeAlso: ['http://web.archive.org/web/20041020171434/http://www.rosenlaw.com/osl2.0.html'],
      isOsiApproved: true}, {
      reference: './OSL-2.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OSL-2.1.json',
      referenceNumber: '22',
      name: 'Open Software License 2.1',
      licenseId: 'OSL-2.1',
      seeAlso: ['http://web.archive.org/web/20050212003940/http://www.rosenlaw.com/osl21.htm', 'https://opensource.org/licenses/OSL-2.1'],
      isOsiApproved: true}, {
      reference: './OSL-3.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OSL-3.0.json',
      referenceNumber: '95',
      name: 'Open Software License 3.0',
      licenseId: 'OSL-3.0',
      seeAlso: ['https://web.archive.org/web/20120101081418/http://rosenlaw.com:80/OSL3.0.htm', 'https://opensource.org/licenses/OSL-3.0'],
      isOsiApproved: true}, {
      reference: './OpenSSL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/OpenSSL.json',
      referenceNumber: '243',
      name: 'OpenSSL License',
      licenseId: 'OpenSSL',
      seeAlso: ['http://www.openssl.org/source/license.html'],
      isOsiApproved: false}, {
      reference: './PDDL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/PDDL-1.0.json',
      referenceNumber: '13',
      name: 'ODC Public Domain Dedication & License 1.0',
      licenseId: 'PDDL-1.0',
      seeAlso: ['http://opendatacommons.org/licenses/pddl/1.0/'],
      isOsiApproved: false}, {
      reference: './PHP-3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/PHP-3.0.json',
      referenceNumber: '372',
      name: 'PHP License v3.0',
      licenseId: 'PHP-3.0',
      seeAlso: ['http://www.php.net/license/3_0.txt', 'https://opensource.org/licenses/PHP-3.0'],
      isOsiApproved: true}, {
      reference: './PHP-3.01.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/PHP-3.01.json',
      referenceNumber: '308',
      name: 'PHP License v3.01',
      licenseId: 'PHP-3.01',
      seeAlso: ['http://www.php.net/license/3_01.txt'],
      isOsiApproved: false}, {
      reference: './Plexus.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Plexus.json',
      referenceNumber: '219',
      name: 'Plexus Classworlds License',
      licenseId: 'Plexus',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Plexus_Classworlds_License'],
      isOsiApproved: false}, {
      reference: './PostgreSQL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/PostgreSQL.json',
      referenceNumber: '241',
      name: 'PostgreSQL License',
      licenseId: 'PostgreSQL',
      seeAlso: ['http://www.postgresql.org/about/licence', 'https://opensource.org/licenses/PostgreSQL'],
      isOsiApproved: true}, {
      reference: './Python-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Python-2.0.json',
      referenceNumber: '33',
      name: 'Python License 2.0',
      licenseId: 'Python-2.0',
      seeAlso: ['https://opensource.org/licenses/Python-2.0'],
      isOsiApproved: true}, {
      reference: './QPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/QPL-1.0.json',
      referenceNumber: '25',
      name: 'Q Public License 1.0',
      licenseId: 'QPL-1.0',
      seeAlso: ['http://doc.qt.nokia.com/3.3/license.html', 'https://opensource.org/licenses/QPL-1.0'],
      isOsiApproved: true}, {
      reference: './Qhull.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Qhull.json',
      referenceNumber: '65',
      name: 'Qhull License',
      licenseId: 'Qhull',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Qhull'],
      isOsiApproved: false}, {
      reference: './RHeCos-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/RHeCos-1.1.json',
      referenceNumber: '143',
      name: 'Red Hat eCos Public License v1.1',
      licenseId: 'RHeCos-1.1',
      seeAlso: ['http://ecos.sourceware.org/old-license.html'],
      isOsiApproved: false}, {
      reference: './RPL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/RPL-1.1.json',
      referenceNumber: '262',
      name: 'Reciprocal Public License 1.1',
      licenseId: 'RPL-1.1',
      seeAlso: ['https://opensource.org/licenses/RPL-1.1'],
      isOsiApproved: true}, {
      reference: './RPL-1.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/RPL-1.5.json',
      referenceNumber: '221',
      name: 'Reciprocal Public License 1.5',
      licenseId: 'RPL-1.5',
      seeAlso: ['https://opensource.org/licenses/RPL-1.5'],
      isOsiApproved: true}, {
      reference: './RPSL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/RPSL-1.0.json',
      referenceNumber: '266',
      name: 'RealNetworks Public Source License v1.0',
      licenseId: 'RPSL-1.0',
      seeAlso: ['https://helixcommunity.org/content/rpsl', 'https://opensource.org/licenses/RPSL-1.0'],
      isOsiApproved: true}, {
      reference: './RSA-MD.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/RSA-MD.json',
      referenceNumber: '78',
      name: 'RSA Message-Digest License ',
      licenseId: 'RSA-MD',
      seeAlso: ['http://www.faqs.org/rfcs/rfc1321.html'],
      isOsiApproved: false}, {
      reference: './RSCPL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/RSCPL.json',
      referenceNumber: '205',
      name: 'Ricoh Source Code Public License',
      licenseId: 'RSCPL',
      seeAlso: ['http://wayback.archive.org/web/20060715140826/http://www.risource.org/RPL/RPL-1.0A.shtml', 'https://opensource.org/licenses/RSCPL'],
      isOsiApproved: true}, {
      reference: './Rdisc.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Rdisc.json',
      referenceNumber: '288',
      name: 'Rdisc License',
      licenseId: 'Rdisc',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Rdisc_License'],
      isOsiApproved: false}, {
      reference: './Ruby.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Ruby.json',
      referenceNumber: '257',
      name: 'Ruby License',
      licenseId: 'Ruby',
      seeAlso: ['http://www.ruby-lang.org/en/LICENSE.txt'],
      isOsiApproved: false}, {
      reference: './SAX-PD.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SAX-PD.json',
      referenceNumber: '134',
      name: 'Sax Public Domain Notice',
      licenseId: 'SAX-PD',
      seeAlso: ['http://www.saxproject.org/copying.html'],
      isOsiApproved: false}, {
      reference: './SCEA.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SCEA.json',
      referenceNumber: '15',
      name: 'SCEA Shared Source License',
      licenseId: 'SCEA',
      seeAlso: ['http://research.scea.com/scea_shared_source_license.html'],
      isOsiApproved: false}, {
      reference: './SGI-B-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SGI-B-1.0.json',
      referenceNumber: '86',
      name: 'SGI Free Software License B v1.0',
      licenseId: 'SGI-B-1.0',
      seeAlso: ['http://oss.sgi.com/projects/FreeB/SGIFreeSWLicB.1.0.html'],
      isOsiApproved: false}, {
      reference: './SGI-B-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SGI-B-1.1.json',
      referenceNumber: '235',
      name: 'SGI Free Software License B v1.1',
      licenseId: 'SGI-B-1.1',
      seeAlso: ['http://oss.sgi.com/projects/FreeB/'],
      isOsiApproved: false}, {
      reference: './SGI-B-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/SGI-B-2.0.json',
      referenceNumber: '265',
      name: 'SGI Free Software License B v2.0',
      licenseId: 'SGI-B-2.0',
      seeAlso: ['http://oss.sgi.com/projects/FreeB/SGIFreeSWLicB.2.0.pdf'],
      isOsiApproved: false}, {
      reference: './SISSL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/SISSL.json',
      referenceNumber: '71',
      name: 'Sun Industry Standards Source License v1.1',
      licenseId: 'SISSL',
      seeAlso: ['http://www.openoffice.org/licenses/sissl_license.html', 'https://opensource.org/licenses/SISSL'],
      isOsiApproved: true}, {
      reference: './SISSL-1.2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SISSL-1.2.json',
      referenceNumber: '6',
      name: 'Sun Industry Standards Source License v1.2',
      licenseId: 'SISSL-1.2',
      seeAlso: ['http://gridscheduler.sourceforge.net/Gridengine_SISSL_license.html'],
      isOsiApproved: false}, {
      reference: './SMLNJ.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/SMLNJ.json',
      referenceNumber: '289',
      name: 'Standard ML of New Jersey License',
      licenseId: 'SMLNJ',
      seeAlso: ['https://www.smlnj.org/license.html'],
      isOsiApproved: false}, {
      reference: './SMPPL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SMPPL.json',
      referenceNumber: '121',
      name: 'Secure Messaging Protocol Public License',
      licenseId: 'SMPPL',
      seeAlso: ['https://github.com/dcblake/SMP/blob/master/Documentation/License.txt'],
      isOsiApproved: false}, {
      reference: './SNIA.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SNIA.json',
      referenceNumber: '224',
      name: 'SNIA Public License 1.1',
      licenseId: 'SNIA',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/SNIA_Public_License'],
      isOsiApproved: false}, {
      reference: './SPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/SPL-1.0.json',
      referenceNumber: '52',
      name: 'Sun Public License v1.0',
      licenseId: 'SPL-1.0',
      seeAlso: ['https://opensource.org/licenses/SPL-1.0'],
      isOsiApproved: true}, {
      reference: './SWL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SWL.json',
      referenceNumber: '202',
      name: 'Scheme Widget Library (SWL) Software License Agreement',
      licenseId: 'SWL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/SWL'],
      isOsiApproved: false}, {
      reference: './Saxpath.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Saxpath.json',
      referenceNumber: '17',
      name: 'Saxpath License',
      licenseId: 'Saxpath',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Saxpath_License'],
      isOsiApproved: false}, {
      reference: './Sendmail.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Sendmail.json',
      referenceNumber: '145',
      name: 'Sendmail License',
      licenseId: 'Sendmail',
      seeAlso: ['http://www.sendmail.com/pdfs/open_source/sendmail_license.pdf', 'https://web.archive.org/web/20160322142305/https://www.sendmail.com/pdfs/open_source/sendmail_license.pdf'],
      isOsiApproved: false}, {
      reference: './Sendmail-8.23.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Sendmail-8.23.json',
      referenceNumber: '39',
      name: 'Sendmail License 8.23',
      licenseId: 'Sendmail-8.23',
      seeAlso: ['https://www.proofpoint.com/sites/default/files/sendmail-license.pdf', 'https://web.archive.org/web/20181003101040/https://www.proofpoint.com/sites/default/files/sendmail-license.pdf'],
      isOsiApproved: false}, {
      reference: './SimPL-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SimPL-2.0.json',
      referenceNumber: '178',
      name: 'Simple Public License 2.0',
      licenseId: 'SimPL-2.0',
      seeAlso: ['https://opensource.org/licenses/SimPL-2.0'],
      isOsiApproved: true}, {
      reference: './Sleepycat.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Sleepycat.json',
      referenceNumber: '283',
      name: 'Sleepycat License',
      licenseId: 'Sleepycat',
      seeAlso: ['https://opensource.org/licenses/Sleepycat'],
      isOsiApproved: true}, {
      reference: './Spencer-86.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Spencer-86.json',
      referenceNumber: '306',
      name: 'Spencer License 86',
      licenseId: 'Spencer-86',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Henry_Spencer_Reg-Ex_Library_License'],
      isOsiApproved: false}, {
      reference: './Spencer-94.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Spencer-94.json',
      referenceNumber: '27',
      name: 'Spencer License 94',
      licenseId: 'Spencer-94',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Henry_Spencer_Reg-Ex_Library_License'],
      isOsiApproved: false}, {
      reference: './Spencer-99.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Spencer-99.json',
      referenceNumber: '373',
      name: 'Spencer License 99',
      licenseId: 'Spencer-99',
      seeAlso: ['http://www.opensource.apple.com/source/tcl/tcl-5/tcl/generic/regfronts.c'],
      isOsiApproved: false}, {
      reference: './StandardML-NJ.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/StandardML-NJ.json',
      referenceNumber: '213',
      name: 'Standard ML of New Jersey License',
      licenseId: 'StandardML-NJ',
      seeAlso: ['http://www.smlnj.org//license.html'],
      isOsiApproved: false}, {
      reference: './SugarCRM-1.1.3.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/SugarCRM-1.1.3.json',
      referenceNumber: '285',
      name: 'SugarCRM Public License v1.1.3',
      licenseId: 'SugarCRM-1.1.3',
      seeAlso: ['http://www.sugarcrm.com/crm/SPL'],
      isOsiApproved: false}, {
      reference: './TCL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TCL.json',
      referenceNumber: '259',
      name: 'TCL/TK License',
      licenseId: 'TCL',
      seeAlso: ['http://www.tcl.tk/software/tcltk/license.html', 'https://fedoraproject.org/wiki/Licensing/TCL'],
      isOsiApproved: false}, {
      reference: './TCP-wrappers.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TCP-wrappers.json',
      referenceNumber: '267',
      name: 'TCP Wrappers License',
      licenseId: 'TCP-wrappers',
      seeAlso: ['http://rc.quest.com/topics/openssh/license.php#tcpwrappers'],
      isOsiApproved: false}, {
      reference: './TMate.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TMate.json',
      referenceNumber: '247',
      name: 'TMate Open Source License',
      licenseId: 'TMate',
      seeAlso: ['http://svnkit.com/license.html'],
      isOsiApproved: false}, {
      reference: './TORQUE-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TORQUE-1.1.json',
      referenceNumber: '165',
      name: 'TORQUE v2.5+ Software License v1.1',
      licenseId: 'TORQUE-1.1',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/TORQUEv1.1'],
      isOsiApproved: false}, {
      reference: './TOSL.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TOSL.json',
      referenceNumber: '348',
      name: 'Trusster Open Source License',
      licenseId: 'TOSL',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/TOSL'],
      isOsiApproved: false}, {
      reference: './TU-Berlin-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TU-Berlin-1.0.json',
      referenceNumber: '360',
      name: 'Technische Universitaet Berlin License 1.0',
      licenseId: 'TU-Berlin-1.0',
      seeAlso: ['https://github.com/swh/ladspa/blob/7bf6f3799fdba70fda297c2d8fd9f526803d9680/gsm/COPYRIGHT'],
      isOsiApproved: false}, {
      reference: './TU-Berlin-2.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/TU-Berlin-2.0.json',
      referenceNumber: '378',
      name: 'Technische Universitaet Berlin License 2.0',
      licenseId: 'TU-Berlin-2.0',
      seeAlso: ['https://github.com/CorsixTH/deps/blob/fd339a9f526d1d9c9f01ccf39e438a015da50035/licences/libgsm.txt'],
      isOsiApproved: false}, {
      reference: './UPL-1.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/UPL-1.0.json',
      referenceNumber: '199',
      name: 'Universal Permissive License v1.0',
      licenseId: 'UPL-1.0',
      seeAlso: ['https://opensource.org/licenses/UPL'],
      isOsiApproved: true}, {
      reference: './Unicode-DFS-2015.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Unicode-DFS-2015.json',
      referenceNumber: '10',
      name: 'Unicode License Agreement - Data Files and Software (2015)',
      licenseId: 'Unicode-DFS-2015',
      seeAlso: ['https://web.archive.org/web/20151224134844/http://unicode.org/copyright.html'],
      isOsiApproved: false}, {
      reference: './Unicode-DFS-2016.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Unicode-DFS-2016.json',
      referenceNumber: '369',
      name: 'Unicode License Agreement - Data Files and Software (2016)',
      licenseId: 'Unicode-DFS-2016',
      seeAlso: ['http://www.unicode.org/copyright.html'],
      isOsiApproved: false}, {
      reference: './Unicode-TOU.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Unicode-TOU.json',
      referenceNumber: '68',
      name: 'Unicode Terms of Use',
      licenseId: 'Unicode-TOU',
      seeAlso: ['http://www.unicode.org/copyright.html'],
      isOsiApproved: false}, {
      reference: './Unlicense.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Unlicense.json',
      referenceNumber: '286',
      name: 'The Unlicense',
      licenseId: 'Unlicense',
      seeAlso: ['http://unlicense.org/'],
      isOsiApproved: false}, {
      reference: './VOSTROM.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/VOSTROM.json',
      referenceNumber: '222',
      name: 'VOSTROM Public License for Open Source',
      licenseId: 'VOSTROM',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/VOSTROM'],
      isOsiApproved: false}, {
      reference: './VSL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/VSL-1.0.json',
      referenceNumber: '174',
      name: 'Vovida Software License v1.0',
      licenseId: 'VSL-1.0',
      seeAlso: ['https://opensource.org/licenses/VSL-1.0'],
      isOsiApproved: true}, {
      reference: './Vim.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Vim.json',
      referenceNumber: '127',
      name: 'Vim License',
      licenseId: 'Vim',
      seeAlso: ['http://vimdoc.sourceforge.net/htmldoc/uganda.html'],
      isOsiApproved: false}, {
      reference: './W3C.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/W3C.json',
      referenceNumber: '340',
      name: 'W3C Software Notice and License (2002-12-31)',
      licenseId: 'W3C',
      seeAlso: ['http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231.html', 'https://opensource.org/licenses/W3C'],
      isOsiApproved: true}, {
      reference: './W3C-19980720.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/W3C-19980720.json',
      referenceNumber: '315',
      name: 'W3C Software Notice and License (1998-07-20)',
      licenseId: 'W3C-19980720',
      seeAlso: ['http://www.w3.org/Consortium/Legal/copyright-software-19980720.html'],
      isOsiApproved: false}, {
      reference: './W3C-20150513.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/W3C-20150513.json',
      referenceNumber: '49',
      name: 'W3C Software Notice and Document License (2015-05-13)',
      licenseId: 'W3C-20150513',
      seeAlso: ['https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document'],
      isOsiApproved: false}, {
      reference: './WTFPL.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/WTFPL.json',
      referenceNumber: '356',
      name: 'Do What The F*ck You Want To Public License',
      licenseId: 'WTFPL',
      seeAlso: ['http://sam.zoy.org/wtfpl/COPYING'],
      isOsiApproved: false}, {
      reference: './Watcom-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Watcom-1.0.json',
      referenceNumber: '171',
      name: 'Sybase Open Watcom Public License 1.0',
      licenseId: 'Watcom-1.0',
      seeAlso: ['https://opensource.org/licenses/Watcom-1.0'],
      isOsiApproved: true}, {
      reference: './Wsuipa.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Wsuipa.json',
      referenceNumber: '129',
      name: 'Wsuipa License',
      licenseId: 'Wsuipa',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Wsuipa'],
      isOsiApproved: false}, {
      reference: './X11.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/X11.json',
      referenceNumber: '182',
      name: 'X11 License',
      licenseId: 'X11',
      seeAlso: ['http://www.xfree86.org/3.3.6/COPYRIGHT2.html#3'],
      isOsiApproved: false}, {
      reference: './XFree86-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/XFree86-1.1.json',
      referenceNumber: '237',
      name: 'XFree86 License 1.1',
      licenseId: 'XFree86-1.1',
      seeAlso: ['http://www.xfree86.org/current/LICENSE4.html'],
      isOsiApproved: false}, {
      reference: './XSkat.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/XSkat.json',
      referenceNumber: '91',
      name: 'XSkat License',
      licenseId: 'XSkat',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/XSkat_License'],
      isOsiApproved: false}, {
      reference: './Xerox.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Xerox.json',
      referenceNumber: '157',
      name: 'Xerox License',
      licenseId: 'Xerox',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Xerox'],
      isOsiApproved: false}, {
      reference: './Xnet.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Xnet.json',
      referenceNumber: '375',
      name: 'X.Net License',
      licenseId: 'Xnet',
      seeAlso: ['https://opensource.org/licenses/Xnet'],
      isOsiApproved: true}, {
      reference: './YPL-1.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/YPL-1.0.json',
      referenceNumber: '168',
      name: 'Yahoo! Public License v1.0',
      licenseId: 'YPL-1.0',
      seeAlso: ['http://www.zimbra.com/license/yahoo_public_license_1.0.html'],
      isOsiApproved: false}, {
      reference: './YPL-1.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/YPL-1.1.json',
      referenceNumber: '55',
      name: 'Yahoo! Public License v1.1',
      licenseId: 'YPL-1.1',
      seeAlso: ['http://www.zimbra.com/license/yahoo_public_license_1.1.html'],
      isOsiApproved: false}, {
      reference: './ZPL-1.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/ZPL-1.1.json',
      referenceNumber: '347',
      name: 'Zope Public License 1.1',
      licenseId: 'ZPL-1.1',
      seeAlso: ['http://old.zope.org/Resources/License/ZPL-1.1'],
      isOsiApproved: false}, {
      reference: './ZPL-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ZPL-2.0.json',
      referenceNumber: '74',
      name: 'Zope Public License 2.0',
      licenseId: 'ZPL-2.0',
      seeAlso: ['http://old.zope.org/Resources/License/ZPL-2.0', 'https://opensource.org/licenses/ZPL-2.0'],
      isOsiApproved: true}, {
      reference: './ZPL-2.1.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/ZPL-2.1.json',
      referenceNumber: '335',
      name: 'Zope Public License 2.1',
      licenseId: 'ZPL-2.1',
      seeAlso: ['http://old.zope.org/Resources/ZPL/'],
      isOsiApproved: false}, {
      reference: './Zed.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Zed.json',
      referenceNumber: '242',
      name: 'Zed License',
      licenseId: 'Zed',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Zed'],
      isOsiApproved: false}, {
      reference: './Zend-2.0.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Zend-2.0.json',
      referenceNumber: '192',
      name: 'Zend License v2.0',
      licenseId: 'Zend-2.0',
      seeAlso: ['https://web.archive.org/web/20130517195954/http://www.zend.com/license/2_00.txt'],
      isOsiApproved: false}, {
      reference: './Zimbra-1.3.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Zimbra-1.3.json',
      referenceNumber: '38',
      name: 'Zimbra Public License v1.3',
      licenseId: 'Zimbra-1.3',
      seeAlso: ['http://web.archive.org/web/20100302225219/http://www.zimbra.com/license/zimbra-public-license-1-3.html'],
      isOsiApproved: false}, {
      reference: './Zimbra-1.4.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/Zimbra-1.4.json',
      referenceNumber: '232',
      name: 'Zimbra Public License v1.4',
      licenseId: 'Zimbra-1.4',
      seeAlso: ['http://www.zimbra.com/legal/zimbra-public-license-1-4'],
      isOsiApproved: false}, {
      reference: './Zlib.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/Zlib.json',
      referenceNumber: '312',
      name: 'zlib License',
      licenseId: 'Zlib',
      seeAlso: ['http://www.zlib.net/zlib_license.html', 'https://opensource.org/licenses/Zlib'],
      isOsiApproved: true}, {
      reference: './bzip2-1.0.5.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/bzip2-1.0.5.json',
      referenceNumber: '194',
      name: 'bzip2 and libbzip2 License v1.0.5',
      licenseId: 'bzip2-1.0.5',
      seeAlso: ['http://bzip.org/1.0.5/bzip2-manual-1.0.5.html'],
      isOsiApproved: false}, {
      reference: './bzip2-1.0.6.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/bzip2-1.0.6.json',
      referenceNumber: '295',
      name: 'bzip2 and libbzip2 License v1.0.6',
      licenseId: 'bzip2-1.0.6',
      seeAlso: ['https://github.com/asimonov-im/bzip2/blob/master/LICENSE'],
      isOsiApproved: false}, {
      reference: './copyleft-next-0.3.0.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/copyleft-next-0.3.0.json',
      referenceNumber: '170',
      name: 'copyleft-next 0.3.0',
      licenseId: 'copyleft-next-0.3.0',
      seeAlso: ['https://github.com/copyleft-next/copyleft-next/blob/master/Releases/copyleft-next-0.3.0'],
      isOsiApproved: false}, {
      reference: './copyleft-next-0.3.1.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/copyleft-next-0.3.1.json',
      referenceNumber: '337',
      name: 'copyleft-next 0.3.1',
      licenseId: 'copyleft-next-0.3.1',
      seeAlso: ['https://github.com/copyleft-next/copyleft-next/blob/master/Releases/copyleft-next-0.3.1'],
      isOsiApproved: false}, {
      reference: './curl.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/curl.json',
      referenceNumber: '254',
      name: 'curl License',
      licenseId: 'curl',
      seeAlso: ['https://github.com/bagder/curl/blob/master/COPYING'],
      isOsiApproved: false}, {
      reference: './diffmark.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/diffmark.json',
      referenceNumber: '355',
      name: 'diffmark license',
      licenseId: 'diffmark',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/diffmark'],
      isOsiApproved: false}, {
      reference: './dvipdfm.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/dvipdfm.json',
      referenceNumber: '137',
      name: 'dvipdfm License',
      licenseId: 'dvipdfm',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/dvipdfm'],
      isOsiApproved: false}, {
      reference: './eCos-2.0.html',
      isDeprecatedLicenseId: true,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/eCos-2.0.json',
      referenceNumber: '321',
      name: 'eCos license version 2.0',
      licenseId: 'eCos-2.0',
      seeAlso: ['https://www.gnu.org/licenses/ecos-license.html'],
      isOsiApproved: false}, {
      reference: './eGenix.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/eGenix.json',
      referenceNumber: '198',
      name: 'eGenix.com Public License 1.1.0',
      licenseId: 'eGenix',
      seeAlso: ['http://www.egenix.com/products/eGenix.com-Public-License-1.1.0.pdf', 'https://fedoraproject.org/wiki/Licensing/eGenix.com_Public_License_1.1.0'],
      isOsiApproved: false}, {
      reference: './gSOAP-1.3b.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/gSOAP-1.3b.json',
      referenceNumber: '336',
      name: 'gSOAP Public License v1.3b',
      licenseId: 'gSOAP-1.3b',
      seeAlso: ['http://www.cs.fsu.edu/~engelen/license.html'],
      isOsiApproved: false}, {
      reference: './gnuplot.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/gnuplot.json',
      referenceNumber: '9',
      name: 'gnuplot License',
      licenseId: 'gnuplot',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Gnuplot'],
      isOsiApproved: false}, {
      reference: './iMatix.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/iMatix.json',
      referenceNumber: '332',
      name: 'iMatix Standard Function Library Agreement',
      licenseId: 'iMatix',
      seeAlso: ['http://legacy.imatix.com/html/sfl/sfl4.htm#license'],
      isOsiApproved: false}, {
      reference: './libtiff.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/libtiff.json',
      referenceNumber: '214',
      name: 'libtiff License',
      licenseId: 'libtiff',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/libtiff'],
      isOsiApproved: false}, {
      reference: './mpich2.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/mpich2.json',
      referenceNumber: '310',
      name: 'mpich2 License',
      licenseId: 'mpich2',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/MIT'],
      isOsiApproved: false}, {
      reference: './psfrag.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/psfrag.json',
      referenceNumber: '239',
      name: 'psfrag License',
      licenseId: 'psfrag',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/psfrag'],
      isOsiApproved: false}, {
      reference: './psutils.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/psutils.json',
      referenceNumber: '120',
      name: 'psutils License',
      licenseId: 'psutils',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/psutils'],
      isOsiApproved: false}, {
      reference: './wxWindows.html',
      isDeprecatedLicenseId: true,
      detailsUrl: 'http://spdx.org/licenses/wxWindows.json',
      referenceNumber: '82',
      name: 'wxWindows Library License',
      licenseId: 'wxWindows',
      seeAlso: ['https://opensource.org/licenses/WXwindows'],
      isOsiApproved: false}, {
      reference: './xinetd.html',
      isDeprecatedLicenseId: false,
      isFsfLibre: true,
      detailsUrl: 'http://spdx.org/licenses/xinetd.json',
      referenceNumber: '140',
      name: 'xinetd License',
      licenseId: 'xinetd',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/Xinetd_License'],
      isOsiApproved: false}, {
      reference: './xpp.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/xpp.json',
      referenceNumber: '268',
      name: 'XPP License',
      licenseId: 'xpp',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/xpp'],
      isOsiApproved: false}, {
      reference: './zlib-acknowledgement.html',
      isDeprecatedLicenseId: false,
      detailsUrl: 'http://spdx.org/licenses/zlib-acknowledgement.json',
      referenceNumber: '313',
      name: 'zlib/libpng License with Acknowledgement',
      licenseId: 'zlib-acknowledgement',
      seeAlso: ['https://fedoraproject.org/wiki/Licensing/ZlibWithAcknowledgement'],
      isOsiApproved: false}],
    releaseDate: '2019-03-11'};

  // romejs/codec-spdx-license/parse.ts


  function ___R$$priv$romejs$codec$spdx$license$parse_ts$isWordChar(char) {
    return ___R$romejs$parser$core$index_ts$isAlpha(char) || ___R$romejs$parser$core$index_ts$isDigit(char) || char === '-' || char === '.';
  }

  const ___R$$priv$romejs$codec$spdx$license$parse_ts$createSPDXLicenseParser = ___R$romejs$parser$core$index_ts$createParser(
  ParserCore => class SPDXLicenseParser extends ParserCore {
    constructor(opts) {
      super(opts, 'spdx-license');
    }

    tokenize(index, input) {
      const char = input[___R$romejs$ob1$index_ts$get0(index)];

      if (char === '+') {
        return this.finishToken('Plus');
      }

      if (char === '(') {
        return this.finishToken('ParenOpen');
      }

      if (char === ')') {
        return this.finishToken('ParenClose');
      }

      if (char === ' ') {
        return this.lookaheadToken(___R$romejs$ob1$index_ts$inc(index));
      }

      if (___R$romejs$parser$core$index_ts$isAlpha(char)) {
        const value = this.readInputFrom(index, ___R$$priv$romejs$codec$spdx$license$parse_ts$isWordChar);
        const end = ___R$romejs$ob1$index_ts$add(index, value.length);

        if (value === 'AND') {
          return this.finishToken('And', end);
        } else if (value === 'OR') {
          return this.finishToken('Or', end);
        } else if (value === 'WITH') {
          return this.finishToken('With', end);
        } else {
          return this.finishValueToken('Word', value, end);
        }
      }

      return undefined;
    }

    parseLicense(token) {
      const startPos = this.getPosition();

      const id = token.value;
      const licenseInfo = ___R$romejs$codec$spdx$license$index_ts$getSPDXLicense(id);
      if (licenseInfo === undefined) {
        throw this.unexpected({
          message: 'Unknown SPDX license <emphasis>' + id + '</emphasis>',
          start: this.getPositionFromIndex(token.start),
          end: this.getPositionFromIndex(token.end),
          advice: ___R$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(id, ___R$romejs$codec$spdx$license$index_ts$licenseNames)});
      }

      this.nextToken();

      const plus = this.eatToken('Plus') !== undefined;

      let exception;
      if (this.eatToken('With')) {
        const token = this.getToken();
        if (token.type === 'Word') {
          exception = token.value;
          this.nextToken();
        } else {
          throw this.unexpected({
            message: 'Only a license id can be on the right side of a WITH'});
        }
      }

      return {
        type: 'License',
        loc: this.finishLoc(startPos),
        id: id,
        exception: exception,
        plus: plus};
    }

    parseExpression() {
      const startPos = this.getPosition();
      const startToken = this.getToken();

      let value;

      switch (startToken.type) {
        case 'ParenOpen':
          this.nextToken();
          value = this.parseExpression();
          this.expectToken('ParenClose');
          break;

        case 'Word':
          value = this.parseLicense(startToken);
          break;

        case 'Or':
        case 'And':
          throw this.unexpected({
            message: 'Can only use AND/OR in between an expression'});

        case 'Plus':
          throw this.unexpected({
            message: 'A plus can only come after a license id'});

        case 'ParenClose':
          throw this.unexpected({message: 'Nothing open to close'});

        case 'EOF':
          throw this.unexpected({message: 'Unexpected end of file'});

        default:
          throw this.unexpected();}

      const nextToken = this.getToken();
      switch (nextToken.type) {
        case 'Or':
          this.nextToken();
          return {
            type: 'Or',
            loc: this.finishLoc(startPos),
            left: value,
            right: this.parseExpression()};

        case 'And':
          this.nextToken();
          return {
            type: 'And',
            loc: this.finishLoc(startPos),
            left: value,
            right: this.parseExpression()};

        default:
          return value;}
    }

    parse() {
      const expr = this.parseExpression();
      this.finalize();
      return expr;
    }
  });

  function ___R$romejs$codec$spdx$license$parse_ts$default(opts) {
    return ___R$$priv$romejs$codec$spdx$license$parse_ts$createSPDXLicenseParser(opts).parse();
  }

  // romejs/codec-spdx-license/stringify.ts

  function ___R$romejs$codec$spdx$license$stringify_ts$default(node) {
    switch (node.type) {
      case 'Or':
        return ___R$romejs$codec$spdx$license$stringify_ts$default(node.left) + ' OR ' + ___R$romejs$codec$spdx$license$stringify_ts$default(node.right);

      case 'And':
        return ___R$romejs$codec$spdx$license$stringify_ts$default(node.left) + ' AND ' + ___R$romejs$codec$spdx$license$stringify_ts$default(node.right);

      case 'License':
        {
          let str = node.id;
          if (node.plus) {
            str += '+';
          }
          if (node.exception !== undefined) {
            str += ' WITH ' + node.exception;
          }
          return str;
        }}
  }

  // romejs/codec-spdx-license/index.ts


  const ___R$$priv$romejs$codec$spdx$license$index_ts$idToLicense = new Map();
  const ___R$romejs$codec$spdx$license$index_ts$licenseNames = [];
  for (const license of ___R$romejs$codec$spdx$license$data_ts$default.licenses) {
    ___R$romejs$codec$spdx$license$index_ts$licenseNames.push(license.licenseId);
    ___R$$priv$romejs$codec$spdx$license$index_ts$idToLicense.set(license.licenseId, license);
  }

  function ___R$romejs$codec$spdx$license$index_ts$getSPDXLicense(licenseId) {
    return ___R$$priv$romejs$codec$spdx$license$index_ts$idToLicense.get(licenseId);
  }

  // romejs/codec-js-manifest/name.ts


  function ___R$$priv$romejs$codec$js$manifest$name_ts$validateNamePart({loose: loose, unexpected: unexpected}, {name: name, isOrg: isOrg, isOrgPart: isOrgPart, offset: offset}) {
    let normalizedName = '';

    for (let i = 0; i < name.length; i++) {
      const char = name[i];

      if (isOrg && char === '@' && i === 0) {
        unexpected({
          message: 'Redundant <emphasis>@</emphasis> in org name',
          start: ___R$romejs$ob1$index_ts$add(offset, i)});
      } else if (!isOrgPart && char === '/') {
        normalizedName = '@' + normalizedName + '/';
      } else if (!loose && char.match(/[A-Z]/)) {
        normalizedName += char.toLowerCase();
      } else if (char.match(/[A-Za-z0-9\-_\.]/)) {
        normalizedName += char;
      } else {
        unexpected({
          message: 'The character <emphasis>' + ___R$romejs$string$markup$escape_ts$escapeMarkup(
          char) + '</emphasis> isn\'t allowed',
          start: ___R$romejs$ob1$index_ts$add(offset, i)});
      }
    }

    return normalizedName;
  }

  function ___R$romejs$codec$js$manifest$name_ts$normalizeName(opts) {
    const {unexpected: unexpected} = opts;
    let {name: name} = opts;

    if (name.length > 214) {
      unexpected({
        at: 'prefix',
        message: 'cannot exceed 214 characters'});
      name = name.slice(0, 214);
    }

    if (name[0] === '.' || name[0] === '_') {
      unexpected({
        at: 'prefix',
        message: 'cannot start with a dot or underscore',
        start: ___R$romejs$ob1$index_ts$number0});
      name = name.slice(1);
    }

    if (name[0] === '@') {
      const [org, packageName, ...other] = name.slice(1).split('/');

      let offset = ___R$romejs$ob1$index_ts$coerce0(1);

      const sanitizedOrg = ___R$$priv$romejs$codec$js$manifest$name_ts$validateNamePart(opts, {
        isOrg: true,
        isOrgPart: true,
        name: org,
        offset: offset});
      offset = ___R$romejs$ob1$index_ts$add(offset, org.length);

      if (packageName === undefined) {
        name = '@' + sanitizedOrg + '/unknown';
      } else {
        offset = ___R$romejs$ob1$index_ts$inc(offset);

        const sanitizedPackageName = ___R$$priv$romejs$codec$js$manifest$name_ts$validateNamePart(opts, {
          isOrg: false,
          isOrgPart: true,
          name: packageName,
          offset: offset});
        offset = ___R$romejs$ob1$index_ts$add(offset, packageName.length);

        if (other.length > 0) {
          unexpected({
            at: 'prefix',
            message: 'contains too many name separators',
            start: offset});
        }

        name = '@' + sanitizedOrg + '/' + sanitizedPackageName;
      }
    } else {
      name = ___R$$priv$romejs$codec$js$manifest$name_ts$validateNamePart(opts, {
        name: name,
        offset: ___R$romejs$ob1$index_ts$number0,
        isOrg: false,
        isOrgPart: false});
    }

    return name;
  }

  // romejs/codec-js-manifest/dependencies.ts


  function ___R$romejs$codec$js$manifest$dependencies_ts$stringifyDependencyPattern(pattern) {
    switch (pattern.type) {
      case 'hosted-git':
        {
          let str = pattern.host + ':' + pattern.user + '/' + pattern.repo;
          if (pattern.commitish !== undefined) {
            str += '#' + pattern.commitish;
          }
          return str;
        }

      case 'file':
        return 'file:' + pattern.path;

      case 'semver':
        return ___R$romejs$codec$semver$stringify_ts$default(pattern.range);

      case 'tag':
        return pattern.tag;

      case 'git':
      case 'http-tarball':
        if (pattern.hash === undefined) {
          return pattern.url;
        } else {
          return pattern.url + '#' + pattern.hash;
        }}
  }

  function ___R$$priv$romejs$codec$js$manifest$dependencies_ts$explodeHashUrl(pattern, consumer) {
    const parts = pattern.split('#');

    if (parts.length > 2) {
      throw consumer.unexpected('Too many hashes');
    }

    return {
      hash: parts[1],
      url: parts[0]};
  }

  function ___R$$priv$romejs$codec$js$manifest$dependencies_ts$removePrefix(prefix, value) {
    if (value.startsWith(prefix)) {
      return value.slice(prefix.length);
    } else {
      return value;
    }
  }

  const ___R$$priv$romejs$codec$js$manifest$dependencies_ts$GITHUB_SHORTHAND = /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/;

  const ___R$$priv$romejs$codec$js$manifest$dependencies_ts$HOSTED_GIT_PREFIXES = ['bitbucket', 'github', 'gist', 'gitlab'];

  function ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseHostedGit(host, pattern, consumer) {
    let commitish;
    if (pattern.includes('#')) {
      const hashIndex = pattern.indexOf('#');
      commitish = pattern.slice(hashIndex + 1);
      pattern = pattern.slice(0, hashIndex - 1);
    }

    const parts = pattern.split('/');
    if (parts.length > 2) {
      throw consumer.unexpected('Expected only 2 parts');
    }

    const user = parts[0];
    if (user === undefined) {
      throw consumer.unexpected('We are missing a user!');
    }

    const repo = parts[1];
    if (repo === undefined) {
      throw consumer.unexpected('We are missing a repo!');
    }

    const incomplete = {
      type: 'hosted-git',
      host: host,
      user: user,
      repo: repo,
      commitish: commitish};

    return Object.assign({}, incomplete, {
      url: ___R$romejs$codec$js$manifest$dependencies_ts$getHostedGitURL(incomplete)});
  }

  function ___R$romejs$codec$js$manifest$dependencies_ts$getHostedGitURL(pattern) {
    switch (pattern.host) {
      case 'bitbucket':
        return '';

      case 'gitlab':
      case 'gist':
        return '';

      case 'github':
        return '';}
  }

  const ___R$$priv$romejs$codec$js$manifest$dependencies_ts$GIT_PATTERN_MATCHERS = [/^git:/, /^git\+.+:/, /^ssh:/, /^https?:.+\.git$/, /^https?:.+\.git#.+/];

  function ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseGit(pattern, consumer) {
    return Object.assign({
      type: 'git'}, ___R$$priv$romejs$codec$js$manifest$dependencies_ts$explodeHashUrl(pattern, consumer));
  }

  function ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseHttpTarball(pattern, consumer) {
    return Object.assign({
      type: 'http-tarball'}, ___R$$priv$romejs$codec$js$manifest$dependencies_ts$explodeHashUrl(pattern, consumer));
  }

  function ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseSemver(pattern, consumer, loose) {
    const ast = ___R$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
    {
      loose: loose,
      path: consumer.path,
      input: pattern},
    {
      getOffsetPosition: () => consumer.getLocation('inner-value').start,
      parse: opts => ___R$romejs$codec$semver$parse_ts$parseSemverRange(opts)});

    return {
      type: 'semver',
      range: ast};
  }

  const ___R$$priv$romejs$codec$js$manifest$dependencies_ts$FILE_PREFIX_REGEX = /^\.{1,2}\//;

  function ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseFile(pattern) {
    return {
      type: 'file',
      path: ___R$$priv$romejs$codec$js$manifest$dependencies_ts$removePrefix('file:', pattern)};
  }

  const ___R$$priv$romejs$codec$js$manifest$dependencies_ts$TAG_REGEX = /^[a-z]+$/g;

  function ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseTag(pattern) {
    return {
      type: 'tag',
      tag: pattern};
  }

  function ___R$romejs$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(consumer) {
    const pattern = consumer.asString();

    for (const host of ___R$$priv$romejs$codec$js$manifest$dependencies_ts$HOSTED_GIT_PREFIXES) {
      const prefix = host + ':';
      if (pattern.startsWith(prefix)) {
        return ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseHostedGit(host, ___R$$priv$romejs$codec$js$manifest$dependencies_ts$removePrefix(prefix, pattern), consumer);
      }
    }

    for (const matcher of ___R$$priv$romejs$codec$js$manifest$dependencies_ts$GIT_PATTERN_MATCHERS) {
      if (matcher.test(pattern)) {
        return ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseGit(pattern, consumer);
      }
    }

    if (___R$$priv$romejs$codec$js$manifest$dependencies_ts$GITHUB_SHORTHAND.test(pattern)) {
      return ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseHostedGit('github', pattern, consumer);
    }
  }

  function ___R$romejs$codec$js$manifest$dependencies_ts$parseDependencyPattern(consumer, loose) {
    const pattern = consumer.asString();

    const gitPattern = ___R$romejs$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(consumer);
    if (gitPattern !== undefined) {
      return gitPattern;
    }

    if (pattern.startsWith('http://') || pattern.startsWith('https://')) {
      return ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseHttpTarball(pattern, consumer);
    }

    if (___R$$priv$romejs$codec$js$manifest$dependencies_ts$FILE_PREFIX_REGEX.test(pattern) ||
    ___R$romejs$path$index_ts$createUnknownFilePath(pattern).isAbsolute() ||
    pattern.startsWith('file:')) {
      return ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseFile(pattern);
    }

    if (pattern.match(___R$$priv$romejs$codec$js$manifest$dependencies_ts$TAG_REGEX)) {
      return ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseTag(pattern);
    }

    return ___R$$priv$romejs$codec$js$manifest$dependencies_ts$parseSemver(pattern, consumer, loose);
  }

  function ___R$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(root, key, loose) {
    const map = new Map();

    if (!root.has(key)) {
      return map;
    }

    const consumer = root.get(key);

    if (Array.isArray(consumer.asUnknown()) && loose) {
      return map;
    }

    for (const [name, value] of consumer.asMap()) {
      ___R$romejs$codec$js$manifest$name_ts$normalizeName({
        name: name,
        loose: loose,
        unexpected: ({message: message, at: at, advice: advice}) => {
          value.unexpected(message, {
            at: at,
            advice: advice,
            target: 'key'});
        }});

      map.set(name, ___R$romejs$codec$js$manifest$dependencies_ts$parseDependencyPattern(value, loose));
    }

    return map;
  }

  // romejs/codec-js-manifest/types.ts

  const ___R$romejs$codec$js$manifest$types_ts = {};

  // romejs/codec-js-manifest/convert.ts

  const ___R$romejs$codec$js$manifest$convert_ts = {
    convertManifestToJSON: ___R$romejs$codec$js$manifest$convert_ts$convertManifestToJSON};
  function ___R$romejs$codec$js$manifest$convert_ts$convertManifestToJSON(manifest) {
    return Object.assign({}, manifest.raw, {
      name: manifest.name,
      description: manifest.description,
      private: manifest.private,
      type: manifest.type,

      homepage: manifest.homepage,
      repository: manifest.repository,
      bugs: manifest.bugs,

      browser: manifest.browser,
      main: manifest.main,
      'rome:main': manifest['rome:main'],
      'jsnext:main': manifest['jsnext:main'],

      author: manifest.author,
      contributors: manifest.contributors,
      maintainers: manifest.maintainers,

      version: manifest.version === undefined ? undefined : ___R$romejs$codec$semver$stringify_ts$default(manifest.version),
      license: manifest.license === undefined ? undefined : ___R$romejs$codec$spdx$license$stringify_ts$default(manifest.license),

      files: ___R$$priv$romejs$codec$js$manifest$convert_ts$maybeArray(manifest.files),
      keywords: ___R$$priv$romejs$codec$js$manifest$convert_ts$maybeArray(manifest.keywords),
      cpu: ___R$$priv$romejs$codec$js$manifest$convert_ts$maybeArray(manifest.cpu),
      os: ___R$$priv$romejs$codec$js$manifest$convert_ts$maybeArray(manifest.os),

      bin: ___R$$priv$romejs$codec$js$manifest$convert_ts$mapToObject(manifest.bin),
      scripts: ___R$$priv$romejs$codec$js$manifest$convert_ts$mapToObject(manifest.scripts),
      engines: ___R$$priv$romejs$codec$js$manifest$convert_ts$mapToObject(manifest.engines),

      dependencies: ___R$$priv$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(manifest.dependencies),
      devDependencies: ___R$$priv$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(manifest.devDependencies),
      optionalDependencies: ___R$$priv$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(manifest.optionalDependencies),
      peerDependencies: ___R$$priv$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(manifest.peerDependencies),

      bundleDependencies: undefined,
      bundledDependencies: ___R$$priv$romejs$codec$js$manifest$convert_ts$maybeArray(manifest.bundledDependencies)});
  }

  function ___R$$priv$romejs$codec$js$manifest$convert_ts$maybeArray(items) {
    if (items.length === 0) {
      return undefined;
    } else {
      return items;
    }
  }

  function ___R$$priv$romejs$codec$js$manifest$convert_ts$mapToObject(map) {
    if (map.size === 0) {
      return;
    }

    const obj = {};
    for (const [key, value] of map) {
      obj[key] = value;
    }
    return obj;
  }

  function ___R$$priv$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(map) {
    if (map.size === 0) {
      return;
    }

    const obj = {};
    for (const [key, pattern] of map) {
      obj[key] = ___R$romejs$codec$js$manifest$dependencies_ts$stringifyDependencyPattern(pattern);
    }
    return obj;
  }

  // romejs/codec-js-manifest/index.ts

  const ___R$$priv$romejs$codec$js$manifest$index_ts$TYPO_KEYS = new Map([['autohr', 'author'], ['autor', 'author'], ['contributers', 'contributors'], ['depends', 'dependencies'], ['hampage', 'homepage'], ['hompage', 'homepage'], ['prefereGlobal', 'preferGlobal'], ['publicationConfig', 'publishConfig'], ['repo', 'repository'], ['repostitory', 'repository'], ['script', 'scripts']]);

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeBoolean(consumer, key) {
    if (consumer.has(key)) {
      return consumer.get(key).asBoolean();
    } else {
      return undefined;
    }
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeString(consumer, key) {
    if (consumer.has(key)) {
      return consumer.get(key).asString();
    } else {
      return undefined;
    }
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer, key, loose) {
    const prop = consumer.get(key);
    if (prop.exists()) {
      if (loose) {
        const val = prop.asUnknown();

        if (typeof val === 'string') {
          return [prop.asString()];
        }

        if (val === false) {
          return [];
        }
      }

      return prop.asArray().map(item => item.asString());
    } else {
      return [];
    }
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringMap(root, key, loose) {
    const map = new Map();

    if (!root.has(key)) {
      return map;
    }

    const consumer = root.get(key);

    if (Array.isArray(consumer.asUnknown()) && loose) {
      return map;
    }

    for (const [name, value] of consumer.asMap()) {
      map.set(name, value.asString());
    }

    return map;
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeBin(consumer, name, loose) {
    const map = new Map();
    if (!consumer.has('bin')) {
      return map;
    }

    const obj = consumer.get('bin');
    if (typeof obj.asUnknown() === 'string') {
      if (name === undefined) {
        obj.unexpected(
        'A string bin is only allowed if the manifest has a name property');
      } else {
        map.set(name, obj.asString());
        return map;
      }
    }

    return ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringMap(consumer, 'bin', loose);
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(consumer) {
    const prop = consumer.get('type');
    const value = prop.asString();
    return [value, prop];
  }

  const ___R$$priv$romejs$codec$js$manifest$index_ts$INVALID_IGNORE_LICENSES = ['UNLICENSED', 'none', 'Facebook Platform License', 'BSD', 'MIT/X11', 'Public Domain', 'MIT License', 'BSD-like'];

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeLicense(consumer, loose) {
    if (!consumer.has('license')) {
      return undefined;
    }

    let licenseProp = consumer.get('license');

    let licenseId;

    const raw = licenseProp.asUnknown();
    if (loose && Array.isArray(raw)) {
      const licenseIds = licenseProp.asArray().map(consumer => ___R$$priv$romejs$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(consumer)[0]);
      licenseId = '(' + licenseIds.join(' OR ') + ')';
    } else if (loose && typeof raw === 'object') {
      [licenseId, licenseProp] = ___R$$priv$romejs$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(licenseProp);
    } else {
      licenseId = licenseProp.asString();
    }

    if (licenseId.startsWith('SEE LICENSE IN ')) {
      return undefined;
    }

    if (___R$$priv$romejs$codec$js$manifest$index_ts$INVALID_IGNORE_LICENSES.includes(licenseId)) {
      return undefined;
    }

    return ___R$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
    {
      path: consumer.path,
      input: licenseId},
    {
      getOffsetPosition: () => licenseProp.getLocation('inner-value').start,
      parse: opts => ___R$romejs$codec$spdx$license$parse_ts$default(opts)});
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeVersion(consumer, loose) {
    if (!consumer.has('version')) {
      return undefined;
    }

    const prop = consumer.get('version');
    const rawVersion = prop.asString();

    if (rawVersion === 'VERSION_STRING') {
      return undefined;
    }

    const ast = ___R$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
    {
      path: consumer.path,
      input: rawVersion,

      loose: loose},
    {
      getOffsetPosition: () => prop.getLocation('inner-value').start,
      parse: opts => ___R$romejs$codec$semver$parse_ts$parseSemverVersion(opts)});
    return ast;
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizePerson(consumer, loose) {
    if (typeof consumer.asUnknown() === 'string') {
      const str = consumer.asString();

      const nameMatch = str.match(/^([^\(<]+)/);
      let name;
      if (nameMatch) {
        name = nameMatch[0].trim();
      }

      const person = {
        name: name,
        url: undefined,
        email: undefined,
        twitter: undefined,
        github: undefined};

      const emailMatch = str.match(/<([^>]+)>/);
      if (emailMatch) {
        person.email = emailMatch[1];
      }

      const urlMatch = str.match(/\(([^\)]+)\)/);
      if (urlMatch) {
        person.url = urlMatch[1];
      }

      return person;
    } else {
      let url = consumer.get('url').asStringOrVoid();

      if (loose) {
        if (url === undefined) {
          url = consumer.get('web').asStringOrVoid();
        }

        if (url === undefined) {
          url = consumer.get('website').asStringOrVoid();
        }
      }

      let github = consumer.get('github').asStringOrVoid();

      if (loose && github === undefined) {
        github = consumer.get('githubUsername').asStringOrVoid();
      }

      const person = {
        name: consumer.get('name').asString(),
        email: consumer.get('email').asStringOrVoid(),
        twitter: consumer.get('twitter').asStringOrVoid(),
        github: github,
        url: url};
      consumer.enforceUsedProperties();
      return person;
    }
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizePeople(consumer, loose) {
    if (!consumer.exists()) {
      return;
    }

    if (loose && consumer.isObject()) {
      return [___R$$priv$romejs$codec$js$manifest$index_ts$normalizePerson(consumer, loose)];
    }

    const people = [];

    for (const item of consumer.asArray()) {
      people.push(___R$$priv$romejs$codec$js$manifest$index_ts$normalizePerson(item, loose));
    }

    return people;
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeRepo(consumer, loose) {
    if (!consumer.exists()) {
      return;
    }

    if (typeof consumer.asUnknown() === 'string') {
      let url = consumer.asString();

      const parsed = ___R$romejs$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(consumer);
      if (parsed !== undefined && parsed.type === 'hosted-git') {
        url = parsed.url;
      }

      return {
        type: 'git',
        url: url,
        directory: undefined};
    } else {
      let url;
      let type;

      if (loose) {
        type = consumer.get('type').asString('git');

        consumer.markUsedProperty('web');
        consumer.markUsedProperty('git');
        consumer.markUsedProperty('dist');

        let looseUrl = consumer.get('url').asStringOrVoid();

        if (looseUrl === undefined) {
          looseUrl = consumer.get('repository').asStringOrVoid();
        }

        if (looseUrl === undefined) {
          consumer.unexpected('No url found');
          url = '';
        } else {
          url = looseUrl;
        }
      } else {
        url = consumer.get('url').asString();
        type = consumer.get('type').asString();
      }

      const repo = {
        type: type,
        url: url,
        directory: consumer.get('directory').asStringOrVoid()};
      consumer.enforceUsedProperties();
      return repo;
    }
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeBugs(consumer, loose) {
    if (!consumer.exists()) {
      return;
    }

    if (typeof consumer.asUnknown() === 'string') {
      return {
        email: undefined,
        url: consumer.asString()};
    } else {
      let email = consumer.get('email').asStringOrVoid();

      if (loose && email === undefined) {
        email = consumer.get('mail').asStringOrVoid();
      }

      consumer.markUsedProperty('type');

      const bugs = {
        email: email,
        url: consumer.get('url').asStringOrVoid()};
      consumer.enforceUsedProperties();
      return bugs;
    }
  }

  function ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeRootName(consumer, loose) {
    if (!consumer.has('name')) {
      return;
    }

    const prop = consumer.get('name');

    return ___R$romejs$codec$js$manifest$name_ts$normalizeName({
      name: prop.asString(),
      loose: loose,
      unexpected: ({message: message, at: at, start: start, end: end, advice: advice}) => {
        prop.unexpected(message, {
          advice: advice,
          at: at,
          loc: start === undefined ? undefined : prop.getLocationRange(start, end, 'inner-value')});
      }});
  }

  const ___R$$priv$romejs$codec$js$manifest$index_ts$DEPENDENCIES_KEYS = ['', 'dev', 'peer', 'optional'];

  const ___R$$priv$romejs$codec$js$manifest$index_ts$INCORRECT_DEPENDENCIES_SUFFIXES = ['depdenencies', 'dependancies', 'dependecies'];

  function ___R$$priv$romejs$codec$js$manifest$index_ts$checkDependencyKeyTypo(key, prop) {
    for (const depPrefixKey of ___R$$priv$romejs$codec$js$manifest$index_ts$DEPENDENCIES_KEYS) {
      const depKey = depPrefixKey === '' ? 'dependencies' : depPrefixKey + 'Dependencies';
      if (key === depKey) {
        return;
      }

      const lowerKey = key.toLowerCase();
      if (lowerKey === depKey) {
        prop.unexpected(key + ' has incorrect casing, should be ' + depKey);
      }

      for (const suffix of ___R$$priv$romejs$codec$js$manifest$index_ts$INCORRECT_DEPENDENCIES_SUFFIXES) {
        if (lowerKey === '' + depPrefixKey + suffix) {
          prop.unexpected(key + ' has a typo, should be ' + depKey);
        }
      }

      if (___R$romejs$string$utils$toCamelCase_ts$toCamelCase(depKey) === lowerKey) {
        prop.unexpected(key + ' isn\'t correctly camel cased when it should be ' + depKey);
      }
    }
  }

  async function ___R$romejs$codec$js$manifest$index_ts$normalizeManifest(path, consumer) {
    const loose = path.getSegments().includes('node_modules');

    const {result: manifest, diagnostics: diagnostics} = await consumer.capture(consumer => {
      if (path.join().includes('resolve/test/resolver/invalid_main')) {
        consumer.setValue({});
      }

      if (!loose) {
        for (const [key, prop] of consumer.asMap()) {
          ___R$$priv$romejs$codec$js$manifest$index_ts$checkDependencyKeyTypo(key, prop);

          const correctKey = ___R$$priv$romejs$codec$js$manifest$index_ts$TYPO_KEYS.get(key);
          if (correctKey !== undefined) {
            prop.unexpected(key + ' is a typo of ' + correctKey);
          }
        }
      }

      const name = ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeRootName(consumer, loose);

      const manifest = {
        name: name,
        version: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeVersion(consumer, loose),
        private: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeBoolean(consumer, 'private') === true,
        description: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeString(consumer, 'description'),
        license: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeLicense(consumer, loose),
        type: consumer.get('type').asStringSetOrVoid(['module', 'commonjs']),

        bin: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeBin(consumer, name, loose),
        scripts: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringMap(consumer, 'scripts', loose),
        homepage: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeString(consumer, 'homepage'),
        repository: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeRepo(consumer.get('repository'), loose),
        bugs: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeBugs(consumer.get('bugs'), loose),
        engines: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringMap(consumer, 'engines', loose),

        files: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer, 'files', loose),
        keywords: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer, 'keywords', loose),
        cpu: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer, 'cpu', loose),
        os: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer, 'os', loose),

        browser: undefined,
        main: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeString(consumer, 'main'),
        'rome:main': ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeString(consumer, 'rome:main'),
        'jsnext:main': ___R$$priv$romejs$codec$js$manifest$index_ts$normalizeString(consumer, 'jsnext:main'),

        dependencies: ___R$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(consumer, 'dependencies', loose),
        devDependencies: ___R$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
        consumer,
        'devDependencies',
        loose),
        optionalDependencies: ___R$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
        consumer,
        'optionalDependencies',
        loose),
        peerDependencies: ___R$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
        consumer,
        'peerDependencies',
        loose),
        bundledDependencies: [...___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer, 'bundledDependencies', loose), ...___R$$priv$romejs$codec$js$manifest$index_ts$normalizeStringArray(consumer, 'bundleDependencies', loose)],

        author: consumer.has('author') ? ___R$$priv$romejs$codec$js$manifest$index_ts$normalizePerson(consumer.get('author'), loose) : undefined,
        contributors: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizePeople(consumer.get('contributors'), loose),
        maintainers: ___R$$priv$romejs$codec$js$manifest$index_ts$normalizePeople(consumer.get('maintainers'), loose),

        raw: consumer.asJSONObject()};

      return manifest;
    });

    return {
      manifest: manifest,
      diagnostics: diagnostics};
  }

  // romejs/codec-watchman/bser.ts

  const ___R$$priv$romejs$codec$watchman$bser_ts$os = require('os');
  const ___R$$priv$romejs$codec$watchman$bser_ts$isBigEndian = ___R$$priv$romejs$codec$watchman$bser_ts$os.endianness() == 'BE';

  function ___R$$priv$romejs$codec$watchman$bser_ts$nextPow2(size) {
    return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));
  }

  class ___R$romejs$codec$watchman$bser_ts$Accumulator {
    constructor(initsize = 8192) {
      this.buffer = Buffer.alloc(___R$$priv$romejs$codec$watchman$bser_ts$nextPow2(initsize));
      this.readOffset = 0;
      this.writeOffset = 0;
    }

    canRead(size) {
      return this.readAvail() > size;
    }

    writeAvail() {
      return this.buffer.length - this.writeOffset;
    }

    readAvail() {
      return this.writeOffset - this.readOffset;
    }

    reserve(size) {
      if (size < this.writeAvail()) {
        return;
      }

      if (this.readOffset > 0) {
        this.buffer.copy(this.buffer, 0, this.readOffset, this.writeOffset);
        this.writeOffset -= this.readOffset;
        this.readOffset = 0;
      }

      if (size < this.writeAvail()) {
        return;
      }

      const buf = Buffer.alloc(
      ___R$$priv$romejs$codec$watchman$bser_ts$nextPow2(this.buffer.length + size - this.writeAvail()));
      this.buffer.copy(buf);
      this.buffer = buf;
    }

    append(buf) {
      if (Buffer.isBuffer(buf)) {
        this.reserve(buf.length);
        buf.copy(this.buffer, this.writeOffset, 0, buf.length);
        this.writeOffset += buf.length;
      } else {
        const size = Buffer.byteLength(buf);
        this.reserve(size);
        this.buffer.write(buf, this.writeOffset);
        this.writeOffset += size;
      }
    }

    assertReadableSize(size) {
      if (this.readAvail() < size) {
        throw new Error('wanted to read ' + size + ' bytes but only have ' + this.readAvail());
      }
    }

    peekString(size) {
      this.assertReadableSize(size);
      return this.buffer.toString(
      'utf-8',
      this.readOffset,
      this.readOffset + size);
    }

    readString(size) {
      const str = this.peekString(size);
      this.readOffset += size;
      return str;
    }

    peekInt(size) {
      this.assertReadableSize(size);

      switch (size) {
        case 1:
          return this.buffer.readInt8(this.readOffset);

        case 2:
          return ___R$$priv$romejs$codec$watchman$bser_ts$isBigEndian ? this.buffer.readInt16BE(this.readOffset) : this.buffer.readInt16LE(this.readOffset);

        case 4:
          return ___R$$priv$romejs$codec$watchman$bser_ts$isBigEndian ? this.buffer.readInt32BE(this.readOffset) : this.buffer.readInt32LE(this.readOffset);

        case 8:
          throw new Error('64-bit numbers aren\'t supported');

        default:
          throw new Error('invalid integer size ' + size);}
    }

    readInt(bytes) {
      const ival = this.peekInt(bytes);
      this.readOffset += bytes;
      return ival;
    }

    peekDouble() {
      this.assertReadableSize(8);
      return ___R$$priv$romejs$codec$watchman$bser_ts$isBigEndian ? this.buffer.readDoubleBE(this.readOffset) : this.buffer.readDoubleLE(this.readOffset);
    }

    readDouble() {
      const dval = this.peekDouble();
      this.readOffset += 8;
      return dval;
    }

    readAdvance(size) {
      if (size > 0) {
        this.assertReadableSize(size);
      } else if (size < 0 && this.readOffset + size < 0) {
        throw new Error('advance with negative offset ' +
        size +
        ' would seek off the start of the buffer');
      }
      this.readOffset += size;
    }

    writeByte(value) {
      this.reserve(1);
      this.buffer.writeInt8(value, this.writeOffset);
      ++this.writeOffset;
    }

    writeInt(value, size) {
      this.reserve(size);
      switch (size) {
        case 1:
          this.buffer.writeInt8(value, this.writeOffset);
          break;

        case 2:
          if (___R$$priv$romejs$codec$watchman$bser_ts$isBigEndian) {
            this.buffer.writeInt16BE(value, this.writeOffset);
          } else {
            this.buffer.writeInt16LE(value, this.writeOffset);
          }
          break;

        case 4:
          if (___R$$priv$romejs$codec$watchman$bser_ts$isBigEndian) {
            this.buffer.writeInt32BE(value, this.writeOffset);
          } else {
            this.buffer.writeInt32LE(value, this.writeOffset);
          }
          break;

        default:
          throw new Error('unsupported integer size ' + size);}
      this.writeOffset += size;
    }

    writeDouble(value) {
      this.reserve(8);
      if (___R$$priv$romejs$codec$watchman$bser_ts$isBigEndian) {
        this.buffer.writeDoubleBE(value, this.writeOffset);
      } else {
        this.buffer.writeDoubleLE(value, this.writeOffset);
      }
      this.writeOffset += 8;
    }
  }

  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_ARRAY = 0;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_OBJECT = 1;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_STRING = 2;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT8 = 3;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT16 = 4;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT32 = 5;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT64 = 6;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_REAL = 7;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_TRUE = 8;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_FALSE = 9;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_NULL = 10;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_TEMPLATE = 11;
  const ___R$$priv$romejs$codec$watchman$bser_ts$BSER_SKIP = 12;

  const ___R$$priv$romejs$codec$watchman$bser_ts$ST_NEED_PDU = 0;
  const ___R$$priv$romejs$codec$watchman$bser_ts$ST_FILL_PDU = 1;

  const ___R$$priv$romejs$codec$watchman$bser_ts$MAX_INT8 = 127;
  const ___R$$priv$romejs$codec$watchman$bser_ts$MAX_INT16 = 32767;
  const ___R$$priv$romejs$codec$watchman$bser_ts$MAX_INT32 = 2147483647;

  class ___R$romejs$codec$watchman$bser_ts$BunserBuf {
    constructor() {
      this.acc = new ___R$romejs$codec$watchman$bser_ts$Accumulator();
      this.state = ___R$$priv$romejs$codec$watchman$bser_ts$ST_NEED_PDU;

      this.errorEvent = new ___R$romejs$events$Event_ts$default({
        name: 'BunserBuf.error'});

      this.valueEvent = new ___R$romejs$events$Event_ts$default({
        name: 'BunserBuf.value'});

      this.pduLen = false;
    }

    append(buf, synchronous = false) {
      if (synchronous) {
        this.acc.append(buf);
        return this.process(synchronous);
      }

      try {
        this.acc.append(buf);
      } catch (err) {
        this.errorEvent.send(err);
        return;
      }

      this.processLater();
    }

    processLater() {
      process.nextTick(() => {
        try {
          this.process(false);
        } catch (err) {
          this.errorEvent.send(err);
        }
      });
    }

    process(synchronous) {
      if (this.state == ___R$$priv$romejs$codec$watchman$bser_ts$ST_NEED_PDU) {
        if (this.acc.readAvail() < 2) {
          return;
        }

        this.expectCode(0);
        this.expectCode(1);
        this.pduLen = this.decodePDUInt();
        if (this.pduLen === false) {
          this.acc.readAdvance(-2);
          return;
        }

        this.acc.reserve(this.pduLen);
        this.state = ___R$$priv$romejs$codec$watchman$bser_ts$ST_FILL_PDU;
      }

      if (this.state == ___R$$priv$romejs$codec$watchman$bser_ts$ST_FILL_PDU) {
        if (this.acc.readAvail() < this.pduLen) {
          return;
        }

        const val = this.decodeAny();
        if (synchronous) {
          return val;
        }
        this.valueEvent.send(val);
        this.state = ___R$$priv$romejs$codec$watchman$bser_ts$ST_NEED_PDU;
      }

      if (!synchronous && this.acc.readAvail() > 0) {
        this.processLater();
      }
    }

    raise(reason) {
      const bufferLength = this.acc.buffer.length;
      const readableLength = this.acc.readAvail();
      const readOffset = this.acc.readOffset;
      const buffer = JSON.stringify(
      this.acc.buffer.slice(this.acc.readOffset, this.acc.readOffset + 32).toJSON());

      throw new Error(reason + ' in Buffer of length ' + bufferLength + ', ' + readableLength + ' readable at offset ' + readOffset + ' buffer: ' + buffer);
    }

    expectCode(expected) {
      const code = this.acc.readInt(1);
      if (code != expected) {
        this.raise('Expected bser opcode ' + expected + ' but got ' + code);
      }
    }

    decodeAny() {
      const code = this.acc.peekInt(1);
      switch (code) {
        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT8:
        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT16:
        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT32:
        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT64:
          return this.decodeInt();

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_REAL:
          this.acc.readAdvance(1);
          return this.acc.readDouble();

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_TRUE:
          this.acc.readAdvance(1);
          return true;

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_FALSE:
          this.acc.readAdvance(1);
          return false;

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_NULL:
          this.acc.readAdvance(1);
          return null;

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_STRING:
          return this.decodeString();

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_ARRAY:
          return this.decodeArray();

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_OBJECT:
          return this.decodeObject();

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_TEMPLATE:
          return this.decodeTemplate();

        default:
          this.raise('Unhandled bser opcode ' + code);}
    }

    decodeArray() {
      this.expectCode(___R$$priv$romejs$codec$watchman$bser_ts$BSER_ARRAY);
      const nitems = this.decodeInt();
      const arr = [];
      for (let i = 0; i < nitems; ++i) {
        arr.push(this.decodeAny());
      }
      return arr;
    }

    decodeObject() {
      this.expectCode(___R$$priv$romejs$codec$watchman$bser_ts$BSER_OBJECT);
      const nitems = this.decodeInt();
      const res = {};
      for (let i = 0; i < nitems; ++i) {
        const key = this.decodeString();
        const val = this.decodeAny();
        res[key] = val;
      }
      return res;
    }

    decodeTemplate() {
      this.expectCode(___R$$priv$romejs$codec$watchman$bser_ts$BSER_TEMPLATE);
      const keys = this.decodeArray();
      const nitems = this.decodeInt();
      const arr = [];
      for (let i = 0; i < nitems; ++i) {
        const obj = {};
        for (let keyidx = 0; keyidx < keys.length; ++keyidx) {
          if (this.acc.peekInt(1) == ___R$$priv$romejs$codec$watchman$bser_ts$BSER_SKIP) {
            this.acc.readAdvance(1);
            continue;
          }
          const val = this.decodeAny();
          obj[String(keys[keyidx])] = val;
        }
        arr.push(obj);
      }
      return arr;
    }

    decodeString() {
      this.expectCode(___R$$priv$romejs$codec$watchman$bser_ts$BSER_STRING);
      const len = this.decodeInt();
      return this.acc.readString(len);
    }

    decodePDUInt() {
      if (this.acc.canRead(1)) {
        const size = this.getDecodeIntSize();
        if (this.acc.canRead(1 + size)) {
          return this.decodeInt();
        }
      }

      return false;
    }

    getDecodeIntSize() {
      let size = 0;

      const code = this.acc.peekInt(1);
      switch (code) {
        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT8:
          size = 1;
          break;

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT16:
          size = 2;
          break;

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT32:
          size = 4;
          break;

        case ___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT64:
          size = 8;
          break;

        default:
          throw this.raise('invalid bser int encoding ' + code);}

      return size;
    }

    decodeInt() {
      this.acc.assertReadableSize(1);
      const size = this.getDecodeIntSize();
      this.acc.readAdvance(1);
      return this.acc.readInt(size);
    }
  }

  function ___R$romejs$codec$watchman$bser_ts$loadFromBuffer(input) {
    const buf = new ___R$romejs$codec$watchman$bser_ts$BunserBuf();
    const result = buf.append(input, true);

    if (buf.acc.readAvail()) {
      throw Error('Excess data found after input buffer, use BunserBuf instead');
    }

    if (typeof result === 'undefined') {
      throw Error('No bser found in string and no error raised!?');
    }

    return result;
  }

  function ___R$$priv$romejs$codec$watchman$bser_ts$dumpInt(buf, val) {
    const abs = Math.abs(val);
    if (abs <= ___R$$priv$romejs$codec$watchman$bser_ts$MAX_INT8) {
      buf.writeByte(___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT8);
      buf.writeInt(val, 1);
    } else if (abs <= ___R$$priv$romejs$codec$watchman$bser_ts$MAX_INT16) {
      buf.writeByte(___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT16);
      buf.writeInt(val, 2);
    } else if (abs <= ___R$$priv$romejs$codec$watchman$bser_ts$MAX_INT32) {
      buf.writeByte(___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT32);
      buf.writeInt(val, 4);
    } else {
      throw new Error('???');
    }
  }

  function ___R$$priv$romejs$codec$watchman$bser_ts$dumpArray(buf, val) {
    buf.writeByte(___R$$priv$romejs$codec$watchman$bser_ts$BSER_ARRAY);
    ___R$$priv$romejs$codec$watchman$bser_ts$dumpInt(buf, val.length);
    for (let i = 0; i < val.length; ++i) {
      ___R$$priv$romejs$codec$watchman$bser_ts$dumpUnknown(buf, val[i]);
    }
  }

  function ___R$$priv$romejs$codec$watchman$bser_ts$dumpObject(buf, val) {
    if (val === null) {
      buf.writeByte(___R$$priv$romejs$codec$watchman$bser_ts$BSER_NULL);
      return;
    }

    if (Array.isArray(val)) {
      ___R$$priv$romejs$codec$watchman$bser_ts$dumpArray(buf, val);
      return;
    }

    if (!___R$romejs$typescript$helpers$index_ts$isPlainObject(val)) {
      throw new Error('Expected a plain object');
    }

    buf.writeByte(___R$$priv$romejs$codec$watchman$bser_ts$BSER_OBJECT);

    const keys = Object.keys(val);

    let num_keys = keys.length;
    for (let i = 0; i < keys.length; ++i) {
      const key = keys[i];
      const v = val[key];
      if (typeof v === 'undefined') {
        num_keys--;
      }
    }

    ___R$$priv$romejs$codec$watchman$bser_ts$dumpInt(buf, num_keys);

    for (let i = 0; i < keys.length; ++i) {
      const key = keys[i];
      const v = val[key];
      if (typeof v === 'undefined') {
        continue;
      }

      ___R$$priv$romejs$codec$watchman$bser_ts$dumpUnknown(buf, key);
      try {
        ___R$$priv$romejs$codec$watchman$bser_ts$dumpUnknown(buf, v);
      } catch (err) {
        throw new Error(err.message + '  (while serializing object property with name ' + key);
      }
    }
  }

  function ___R$$priv$romejs$codec$watchman$bser_ts$dumpUnknown(buf, val) {
    switch (typeof val) {
      case 'number':
        if (isFinite(val) && Math.floor(val) === val) {
          ___R$$priv$romejs$codec$watchman$bser_ts$dumpInt(buf, val);
        } else {
          buf.writeByte(___R$$priv$romejs$codec$watchman$bser_ts$BSER_REAL);
          buf.writeDouble(val);
        }
        return;

      case 'bigint':
        throw new Error('bigint isn\'t supported yet');

      case 'string':
        buf.writeByte(___R$$priv$romejs$codec$watchman$bser_ts$BSER_STRING);
        ___R$$priv$romejs$codec$watchman$bser_ts$dumpInt(buf, Buffer.byteLength(val));
        buf.append(val);
        return;

      case 'boolean':
        buf.writeByte(val ? ___R$$priv$romejs$codec$watchman$bser_ts$BSER_TRUE : ___R$$priv$romejs$codec$watchman$bser_ts$BSER_FALSE);
        return;

      case 'object':
        ___R$$priv$romejs$codec$watchman$bser_ts$dumpObject(buf, val);
        return;

      default:
        throw new Error('Cannot serialize type ' + typeof val + ' to BSER');}
  }

  function ___R$romejs$codec$watchman$bser_ts$dumpToBuffer(val) {
    const buf = new ___R$romejs$codec$watchman$bser_ts$Accumulator();

    buf.writeByte(0);
    buf.writeByte(1);

    buf.writeByte(___R$$priv$romejs$codec$watchman$bser_ts$BSER_INT32);
    buf.writeInt(0, 4);

    ___R$$priv$romejs$codec$watchman$bser_ts$dumpUnknown(buf, val);

    const off = buf.writeOffset;
    const len = off - 7;
    buf.writeOffset = 3;
    buf.writeInt(len, 4);
    buf.writeOffset = off;

    return buf.buffer.slice(0, off);
  }

  // romejs/codec-watchman/index.ts

  const ___R$$priv$romejs$codec$watchman$index_ts$child_process = require('child_process');
  const ___R$$priv$romejs$codec$watchman$index_ts$util = require('util');
  const ___R$$priv$romejs$codec$watchman$index_ts$net = require('net');
  const ___R$$priv$romejs$codec$watchman$index_ts$exec = ___R$$priv$romejs$codec$watchman$index_ts$util.promisify(___R$$priv$romejs$codec$watchman$index_ts$child_process.exec);

  function ___R$$priv$romejs$codec$watchman$index_ts$normalizeWatchmanSubscription(res) {
    return {
      'state-enter': res.get('state-enter').asStringOrVoid(),
      'state-leave': res.get('state-leave').asStringOrVoid(),
      unilateral: res.get('unilateral').asBoolean(),
      subscription: res.get('subscription').asString(),
      root: res.get('root').asString(),

      files: res.get('files').asAny(),

      is_fresh_instance: res.get('is_fresh_instance').asBoolean(),
      version: res.get('version').asString(),
      since: res.get('since').asString(),
      clock: res.get('clock').asString()};
  }

  class ___R$romejs$codec$watchman$index_ts$WatchmanClient {
    constructor(socket, reporter) {
      this.reporter = reporter;
      this.socket = socket;

      this.subscriptionCounter = 0;
      this.subscriptions = new Map();

      this.logEvent = new ___R$romejs$events$Event_ts$default({name: 'WatchmanClient.log'});

      this.callbacks = [];
      this.listen();
    }

    listen() {
      const {socket: socket} = this;

      socket.on('error', function() {});

      const bunser = new ___R$romejs$codec$watchman$bser_ts$BunserBuf();

      bunser.valueEvent.subscribe(obj => {
        this.processResponse(___R$romejs$consume$index_ts$consumeUnknown(obj));
      });

      socket.on('data', chunk => {
        bunser.append(chunk);
      });

      socket.on('end', () => {
        this.end();
      });
    }

    processResponse(res) {
      if (res.has('warn')) {
        this.reporter.warn(res.get('warn').asString());
      }

      if (res.has('subscription')) {
        const name = res.get('subscription').asString();
        const event = this.subscriptions.get(name);
        if (event === undefined) {
          this.reporter.warn(
          'Received a watchman subscription event for %s that we aren\'t listening for',
          name);
        } else {
          event.send(___R$$priv$romejs$codec$watchman$index_ts$normalizeWatchmanSubscription(res));
        }
        return;
      }

      if (res.has('log')) {
        return;
      }

      if (res.get('unilateral').asBooleanOrVoid() === true) {
        this.reporter.warn(
        'Received a watchman unilateral event that we don\'t support',
        res.asUnknown());
        return;
      }

      const callback = this.callbacks.shift();
      if (callback === undefined) {
        throw new Error('Received message but no callback');
      }

      if (res.has('error')) {
        callback.reject(new Error(res.get('error').asString()));
      } else {
        callback.resolve(res);
      }
    }

    async createSubscription(dir, opts) {
      const name = 'rome-' + process.pid + '.' + String(this.subscriptionCounter++);
      const event = new ___R$romejs$events$Event_ts$default({
        name: name});
      this.subscriptions.set(name, event);

      const consumer = await this.command(['watch-project', dir]);

      if (consumer.has('relative_path')) {
        opts = Object.assign({}, opts, {
          relative_root: consumer.get('relative_path').asString()});
      }

      const root = consumer.get('watch').asString();
      await this.command(['subscribe', root, name, opts]);
      return event;
    }

    async command(args) {
      return new Promise((resolve, reject) => {
        this.callbacks.push({resolve: resolve, reject: reject});
        this.socket.write(___R$romejs$codec$watchman$bser_ts$dumpToBuffer(args));
      });
    }

    end() {
      for (const {reject: reject} of this.callbacks) {
        reject(new Error('The watchman connection was closed'));
      }
      this.socket.end();
    }
  }

  async function ___R$romejs$codec$watchman$index_ts$getWatchmanSocketLocation() {
    if (typeof process.env.WATCHMAN_SOCK === 'string') {
      return process.env.WATCHMAN_SOCK;
    }

    try {
      const {stdout: stdout, stderr: stderr} = await ___R$$priv$romejs$codec$watchman$index_ts$exec('watchman --no-pretty get-sockname');

      try {
        const data = JSON.parse(stdout);

        if (typeof data !== 'object' ||
        data == null ||
        typeof data.sockname !== 'string') {
          throw new Error('Watchman returned JSON payload that wasnt an object with a sockname property');
        }

        return data.sockname;
      } catch (err) {
        if (err instanceof SyntaxError) {
          err = new Error('Watchman returned malformed JSON payload');
        }

        err.message += ' ' + JSON.stringify({stdout: stdout, stderr: stderr});
        throw err;
      }
    } catch (err) {
      if (err.code === 127) {
        throw new Error('No watchman binary command found');
      } else {
        throw err;
      }
    }
  }

  async function ___R$romejs$codec$watchman$index_ts$createWatchmanClient(reporter) {
    const sockname = await ___R$romejs$codec$watchman$index_ts$getWatchmanSocketLocation();
    const socket = ___R$$priv$romejs$codec$watchman$index_ts$net.createConnection(sockname);

    return new Promise((resolve, reject) => {
      socket.on('error', err => {
        reject(err);
      });

      socket.on('connect', () => {
        resolve(new ___R$romejs$codec$watchman$index_ts$WatchmanClient(socket, reporter));
      });
    });
  }

  // romejs/core/master/fs/MemoryFileSystem.ts

  const ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$crypto = require('crypto');
  const ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$fs = require('fs');
  const ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$DEFAULT_DENYLIST = ['.hg', '.git'];

  const ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$PACKAGE_JSON = 'package.json';

  const ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$PRIORITY_FILES = new Set(___R$romejs$project$constants_ts$ROME_CONFIG_FILENAMES);

  async function ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$createRegularWatcher(memoryFs, diagnostics, projectFolderPath) {
    const projectFolder = projectFolderPath.join();
    const {logger: logger} = memoryFs.master;

    const activity = memoryFs.master.connectedReporters.progress({
      initDelay: 1000});
    activity.setTitle('Adding project ' + projectFolder);

    const watchers = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();

    try {
      function onFoundDirectory(folderPath) {
        if (watchers.has(folderPath)) {
          return;
        }

        if (process.platform !== 'linux' && folderPath.equal(projectFolderPath)) {
          return;
        }

        const watcher = ___R$romejs$fs$index_ts$watch(
        folderPath,
        {recursive: true, persistent: false},
        (eventType, filename) => {
          const path = folderPath.resolve(filename);

          memoryFs.stat(path).then(newStats => {
            const diagnostics = memoryFs.master.createDisconnectedDiagnosticsProcessor(
            [{
              category: 'memory-fs',
              message: 'Processing fs.watch changes'}]);

            if (newStats.type === 'file') {
              memoryFs.handleFileChange(path, newStats, {
                diagnostics: diagnostics,
                crawl: true});
            } else if (newStats.type === 'directory') {
              memoryFs.addDirectory(path, newStats, {
                crawl: true,
                diagnostics: diagnostics,
                onFoundDirectory: onFoundDirectory});
            }
          }).catch(err => {
            if (err.code === 'ENOENT') {
              memoryFs.handleDeletion(path);
            } else {
              throw err;
            }
          });
        });
        watchers.set(folderPath, watcher);
      }

      const stats = await memoryFs.stat(projectFolderPath);
      await memoryFs.addDirectory(projectFolderPath, stats, {
        crawl: true,
        diagnostics: diagnostics,
        onFoundDirectory: onFoundDirectory});
      logger.info('[MemoryFileSystem] Finished initial crawl for ' + projectFolder + ' - added ' + ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
      memoryFs.countFiles(projectFolderPath)) + ' files');
    } finally {
      activity.end();
    }

    return () => {
      for (const watcher of watchers.values()) {
        watcher.close();
      }
    };
  }

  async function ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$createWatchmanWatcher(memoryFs, diagnostics, projectFolderPath, projectConfig) {
    const projectFolder = projectFolderPath.join();
    const {connectedReporters: connectedReporters} = memoryFs.master;

    const activity = connectedReporters.progress();
    activity.setTitle('Adding project ' + projectFolder + ' with watchman');

    let timeout;

    function queueCallout() {
      timeout = setTimeout(
      memoryFs.master.wrapFatal(() => {
        connectedReporters.warn(
        'Watchman is taking a while to respond. Watchman may have just started and is still crawling the disk.');

        queueCallout();
      }),
      5000);
    }

    queueCallout();

    try {
      const client = await ___R$romejs$codec$watchman$index_ts$createWatchmanClient(___R$romejs$cli$reporter$Reporter_ts$default.fromProcess());

      const event = await client.createSubscription(projectFolder, {
        fields: ['mtime', 'name', 'size', 'type', 'exists'],
        expression: ['anyof', ['type', 'd'], ['suffix', ___R$romejs$core$common$fileHandlers_ts$getFileHandlerExtensions(projectConfig)]]});

      const initial = await event.wait();
      if (initial.is_fresh_instance !== true) {
        throw new Error('Expected this to be a fresh instance');
      }
      clearTimeout(timeout);

      const processChanges = async (data, diagnostics) => {
        if (data['state-enter'] || data['state-leave']) {
          return;
        }

        const dirs = [];
        const files = [];

        for (const file of data.files) {
          const path = projectFolderPath.append(file.name);

          if (file.exists === false) {
            memoryFs.handleDeletion(path);
            continue;
          }

          if (file.type === 'f') {
            const basename = path.getBasename();

            if (___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$PRIORITY_FILES.has(basename)) {
              files.unshift([path, file]);
            } else {
              files.push([path, file]);
            }
          } else if (file.type === 'd') {
            dirs.push([path, file]);
          }
        }

        await Promise.all(
        dirs.map(async ([path, info]) => {
          await memoryFs.addDirectory(
          path,
          {
            size: info.size,
            mtime: info.mtime,
            type: 'directory'},
          {diagnostics: diagnostics, crawl: false});
        }));

        await Promise.all(
        files.map(async ([path, info]) => {
          const stats = {
            size: info.size,
            mtime: info.mtime,
            type: 'file'};

          if (memoryFs.files.has(path)) {
            await memoryFs.handleFileChange(path, stats, {
              diagnostics: diagnostics,
              crawl: false});
          } else {
            await memoryFs.addFile(path, stats, {
              diagnostics: diagnostics,
              crawl: false});
          }
        }));
      };

      activity.setText('Processing results');
      await processChanges(initial, diagnostics);

      event.subscribe(data => {
        processChanges(
        data,
        memoryFs.master.createDisconnectedDiagnosticsProcessor([{
          category: 'memory-fs',
          message: 'Processing watchman changes'}]));
      });

      activity.end();

      return () => {};
    } catch (err) {
      activity.end();

      if (err.message.includes('RootResolveError')) {
        memoryFs.master.connectedReporters.error('Failed to use watchman: ' + err.message);
        return ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$createRegularWatcher(memoryFs, diagnostics, projectFolderPath);
      } else {
        throw err;
      }
    } finally {
      clearTimeout(timeout);
    }
  }

  class ___R$romejs$core$master$fs$MemoryFileSystem_ts$default {
    constructor(master) {
      this.master = master;

      this.watchPromises = new Map();
      this.directoryListings = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.directories = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.files = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.manifests = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.watchers = new Map();
      this.manifestCounter = 0;

      this.changedFileEvent = new ___R$romejs$events$Event_ts$default({
        name: 'MemoryFileSystem.changedFile',
        onError: master.onFatalErrorBound});
      this.deletedFileEvent = new ___R$romejs$events$Event_ts$default({
        name: 'MemoryFileSystem.deletedFile',
        onError: master.onFatalErrorBound});
    }

    init() {}

    unwatch(dirPath) {
      const dir = dirPath.join();
      const watcher = this.watchers.get(dir);
      if (watcher === undefined) {
        return;
      }

      this.watchers.delete(dir);
      watcher.close();

      let queue = [dirPath];
      while (queue.length > 0) {
        const path = queue.pop();
        if (path === undefined) {
          throw new Error('Unknown path');
        }

        this.directories.delete(path);
        this.manifests.delete(path);
        this.files.delete(path);

        const listing = this.directoryListings.get(path);
        if (listing !== undefined) {
          this.directoryListings.delete(path);
          queue = queue.concat(Array.from(listing.values()));
        }
      }
    }

    unwatchAll() {
      for (const {close: close} of this.watchers.values()) {
        close();
      }
    }

    readdir(path) {
      const listing = this.directoryListings.get(path);
      if (listing === undefined) {
        return [];
      } else {
        return listing.values();
      }
    }

    isDirectory(filename) {
      return this.directories.has(filename);
    }

    isFile(filename) {
      return this.files.has(filename);
    }

    getFiles() {
      return Array.from(this.files.values());
    }

    getManifestDefinition(dirname) {
      return this.manifests.get(dirname);
    }

    getManifest(dirname) {
      const def = this.getManifestDefinition(dirname);
      if (def === undefined) {
        return undefined;
      } else {
        return def.manifest;
      }
    }

    getOwnedManifest(path) {
      for (const dir of path.getChain()) {
        const def = this.master.memoryFs.getManifestDefinition(dir);
        if (def !== undefined) {
          return def;
        }
      }
    }

    getPartialManifest(def) {
      return {
        type: def.manifest.type};
    }

    addFileToDirectoryListing(path) {
      const dirname = path.getParent();
      let listing = this.directoryListings.get(dirname);
      if (listing === undefined) {
        listing = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
        this.directoryListings.set(dirname, listing);
      }
      listing.set(path, path);
    }

    handleDeletion(path) {
      const folderInfo = this.directories.get(path);
      if (folderInfo !== undefined) {
        this.directories.delete(path);

        const listing = this.directoryListings.get(path);
        if (listing !== undefined) {
          this.directoryListings.delete(path);
          for (const path of listing.values()) {
            this.handleDeletion(path);
          }
        }
      }

      this.files.delete(path);

      this.handleDeletedHaste(path);

      const basename = path.getBasename();
      if (basename === 'package.json') {
        this.handleDeletedManifest(path);
      }

      const dirname = path.getParent();
      const parentListing = this.directoryListings.get(dirname);
      if (parentListing !== undefined) {
        parentListing.delete(path);
      }

      this.deletedFileEvent.send(path);
    }

    handleDeletedHaste(path) {
      const hasteName = this.getHasteName(path);
      if (hasteName === undefined) {
        return undefined;
      }

      const projects = this.master.projectManager.getHierarchyFromFilename(path);
      for (const {hasteMap: hasteMap} of projects) {
        const existing = hasteMap.get(hasteName);
        if (existing !== undefined && existing.equal(path)) {
          hasteMap.delete(hasteName);
        }
      }
    }

    handleDeletedManifest(path) {
      const folder = path.getParent();
      const def = this.manifests.get(folder);
      if (def !== undefined) {
        this.manifests.delete(folder);
      }
    }

    async handleFileChange(path, stats, opts) {
      const oldStats = this.getFileStats(path);
      const changed = await this.addFile(path, stats, opts);
      if (changed) {
        const newStats = this.getFileStatsAssert(path);
        this.changedFileEvent.send({path: path, oldStats: oldStats, newStats: newStats});
      }
      return changed;
    }

    async watch(projectFolderPath, projectConfig) {
      const {logger: logger} = this.master;
      const projectFolder = projectFolderPath.join();

      const cached = this.watchPromises.get(projectFolder);
      if (cached !== undefined) {
        await cached;
        return undefined;
      }

      if (this.watchers.has(projectFolder)) {
        return undefined;
      }

      for (const {path: path} of this.watchers.values()) {
        if (projectFolderPath.isRelativeTo(path)) {
          logger.info('[MemoryFileSystem] Skipped crawl for ' + projectFolder + ' because we\'re already watching the parent directory ' + path.join());
          return undefined;
        }
      }

      for (const {promise: promise, path: path} of this.watchPromises.values()) {
        if (projectFolderPath.isRelativeTo(path)) {
          await promise;
          return undefined;
        }
      }

      for (const {path: path, promise: promise} of this.watchPromises.values()) {
        if (path.isRelativeTo(projectFolderPath)) {
          await promise;
        }
      }

      logger.info('[MemoryFileSystem] Adding new project folder ' + projectFolder);

      for (const [loc, {close: close, path: path}] of this.watchers) {
        if (path.isRelativeTo(projectFolderPath)) {
          this.watchers.delete(loc);
          close();
        }
      }

      const diagnostics = new ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default({
        origins: [{
          category: 'memory-fs',
          message: 'Crawling project folder'}]});

      let promise;
      if (projectConfig.files.watchman) {
        logger.info('[MemoryFileSystem] Watching ' + projectFolder + ' with watchman');
        promise = ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$createWatchmanWatcher(
        this,
        diagnostics,
        projectFolderPath,
        projectConfig);
      } else {
        logger.info('[MemoryFileSystem] Watching ' + projectFolder + ' with fs.watch');
        promise = ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$createRegularWatcher(this, diagnostics, projectFolderPath);
      }
      this.watchPromises.set(projectFolder, {
        path: projectFolderPath,
        promise: promise});

      const watcherClose = await promise;
      this.watchers.set(projectFolder, {
        path: projectFolderPath,
        close: watcherClose});
      this.watchPromises.delete(projectFolder);

      diagnostics.maybeThrowDiagnosticsError();
    }

    async stat(path) {
      const stats = await ___R$romejs$fs$index_ts$lstat(path);

      let type = 'unknown';
      if (stats.isDirectory()) {
        type = 'directory';
      } else if (stats.isFile()) {
        type = 'file';
      }

      return {
        type: type,
        size: stats.size,
        mtime: stats.mtimeMs};
    }

    getMtime(filename) {
      const stats = this.getFileStats(filename);
      if (stats === undefined) {
        throw new Error('File ' + filename.join() + ' not in database, cannot get mtime');
      } else {
        return stats.mtime;
      }
    }

    getFileStats(filename) {
      return this.files.get(filename);
    }

    getFileStatsAssert(filename) {
      const stats = this.getFileStats(filename);
      if (stats === undefined) {
        throw new Error('Expected file stats for ' + filename);
      }
      return stats;
    }

    isIgnored(path, type) {
      const project = this.master.projectManager.findProjectExisting(path);
      if (project === undefined) {
        return false;
      }

      if (type === 'file' && ___R$romejs$core$common$fileHandlers_ts$getFileHandler(path, project.config) === undefined) {
        return true;
      }

      const basename = path.getBasename();
      if (___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$DEFAULT_DENYLIST.includes(basename)) {
        return true;
      }

      return false;
    }

    isInsideProject(path) {
      return path.getSegments().includes('node_modules') === false;
    }

    isInsideHaste(path) {
      const parts = path.getSegments();

      if (!this.isInsideProject(path)) {
        return false;
      }

      const project = this.master.projectManager.findProjectExisting(path);
      if (project !== undefined) {
        if (parts.includes(project.config.tests.folderName) ||
        parts.includes(project.config.tests.mocksFolderName)) {
          return false;
        }
      }

      for (const dir of path.getChain()) {
        const packagePath = dir.append(___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$PACKAGE_JSON);
        if (path.equal(packagePath)) {
          continue;
        }

        const manifest = this.getManifest(packagePath);
        if (manifest !== undefined && manifest.raw.haste_commonjs === true) {
          return false;
        }
      }

      return true;
    }

    getHasteName(path) {
      const filename = path.join();

      let {handler: handler, ext: ext} = this.master.projectManager.getHandlerWithProject(path);
      if (handler === undefined || handler.hasteMode === undefined) {
        return undefined;
      }

      const basename = path.getBasename();

      if (handler.hasteMode === 'ext') {
        ext = '.' + ext;

        if (!filename.endsWith(ext)) {
          throw new Error('Expected ' + filename + ' to end with ' + ext + ' as it was returned as the extension name');
        }

        return basename.slice(0, -ext.length);
      } else if (handler.hasteMode === 'noext') {
        return basename;
      }

      return undefined;
    }

    async declareManifest(opts) {
      try {
        return await this._declareManifest(opts);
      } catch (err) {
        const diagnostics = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);

        if (diagnostics === undefined) {
          throw err;
        } else {
          opts.diagnostics.addDiagnostics(diagnostics);
        }
        return undefined;
      }
    }

    async _declareManifest({
      path: path,
      hasteName: hasteName,
      diagnostics: diagnostics}) {
      const manifestRaw = await ___R$romejs$fs$index_ts$readFileText(path);
      const hash = ___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$crypto.createHash('sha256').update(manifestRaw).digest('hex');

      const consumer = ___R$romejs$codec$json$index_ts$consumeJSON({
        path: path,
        input: manifestRaw,
        consumeCategory: 'manifest'});

      const {
        manifest: manifest,
        diagnostics: normalizedDiagnostics} = await ___R$romejs$codec$js$manifest$index_ts$normalizeManifest(path, consumer);

      if (normalizedDiagnostics.length > 0) {
        diagnostics.addDiagnostics(normalizedDiagnostics);
        return;
      }

      const folder = path.getParent();
      const manifestId = this.manifestCounter++;
      const def = {
        id: manifestId,
        filename: path,
        folder: folder,
        consumer: consumer,
        manifest: manifest,
        hash: hash};

      this.manifests.set(folder, def);

      if (manifest.name !== undefined) {
        hasteName = manifest.name;
      }

      const isProjectPackage = this.isInsideProject(path);
      const {projectManager: projectManager} = this.master;
      const project = projectManager.findProjectExisting(path);
      if (project !== undefined) {
        projectManager.declareManifest(
        project,
        isProjectPackage,
        def,
        diagnostics);
      }

      for (const worker of this.master.workerManager.getWorkers()) {
        worker.bridge.updateManifests.call({
          manifests: [{id: def.id, manifest: this.getPartialManifest(def)}]});
      }

      return hasteName;
    }

    glob(cwd, opts = {}) {
      const {extensions: extensions, ignore: ignore} = opts;

      const files = [];
      const ignoreParsed = ignore === undefined ? [] : ignore;

      let crawl = [cwd];

      while (crawl.length > 0) {
        const path = crawl.pop();
        if (path === undefined) {
          throw new Error('crawl.length already validated');
        }

        if (___R$romejs$path$match$index_ts$matchPathPatterns(path, ignoreParsed, cwd)) {
          continue;
        }

        if (this.files.has(path)) {
          const ext = path.getExtensions().slice(1);
          if (extensions === undefined || extensions.includes(ext)) {
            files.push(path);
          }
          continue;
        }

        const listing = this.directoryListings.get(path);
        if (listing !== undefined) {
          crawl = crawl.concat(Array.from(listing.values()));
          continue;
        }
      }

      return files;
    }

    getAllFilesInFolder(folder) {
      let files = [];

      const listing = this.directoryListings.get(folder);
      if (listing !== undefined) {
        for (const file of listing.keys()) {
          if (this.files.has(file)) {
            files.push(file);
          } else {
            files = files.concat(this.getAllFilesInFolder(file));
          }
        }
      }

      return files;
    }

    countFiles(folder) {
      let count = 0;

      const listing = this.directoryListings.get(folder);
      if (listing !== undefined) {
        for (const file of listing.keys()) {
          count++;
          count += this.countFiles(file);
        }
      }

      return count;
    }

    hasStatsChanged(filename, newStats) {
      const oldStats = this.directories.get(filename) || this.files.get(filename);
      return oldStats === undefined || newStats.mtime !== oldStats.mtime;
    }

    async addDirectory(folderPath, stats, opts) {
      if (!this.hasStatsChanged(folderPath, stats)) {
        return false;
      }

      if (this.isIgnored(folderPath, 'directory')) {
        return false;
      }

      if (opts.tick !== undefined) {
        opts.tick(folderPath);
      }

      this.addFileToDirectoryListing(folderPath);
      this.directories.set(folderPath, stats);

      if (opts.onFoundDirectory !== undefined) {
        opts.onFoundDirectory(folderPath);
      }

      if (opts.crawl) {
        const files = await ___R$romejs$fs$index_ts$readdir(folderPath);

        const declareItem = async path => {
          const stats = await this.stat(path);
          if (stats.type === 'file') {
            await this.addFile(path, stats, opts);
          } else if (stats.type === 'directory') {
            await this.addDirectory(path, stats, opts);
          }
        };

        for (const file of files) {
          if (___R$$priv$romejs$core$master$fs$MemoryFileSystem_ts$PRIORITY_FILES.has(file.getBasename())) {
            files.delete(file);
            await declareItem(file);
          }
        }

        await Promise.all(Array.from(files, declareItem));
      }

      return true;
    }

    exists(path) {
      if (this.files.has(path) || this.directories.has(path)) {
        return true;
      }

      for (const {path: projectFolder} of this.watchPromises.values()) {
        if (path.isRelativeTo(projectFolder)) {
          return undefined;
        }
      }

      const parent = path.getParent();
      if (this.directories.has(parent)) {
        return false;
      }

      return undefined;
    }

    async existsHard(path) {
      const resolvedExistence = this.exists(path);
      if (resolvedExistence === undefined) {
        return ___R$romejs$fs$index_ts$exists(path);
      } else {
        return resolvedExistence;
      }
    }

    async addFile(path, stats, opts) {
      if (!this.hasStatsChanged(path, stats)) {
        return false;
      }

      if (this.isIgnored(path, 'file')) {
        return false;
      }

      if (opts.tick !== undefined) {
        opts.tick(path);
      }

      this.files.set(path, stats);
      this.addFileToDirectoryListing(path);

      let hastePath = path;
      let hasteName = this.getHasteName(path);

      const basename = path.getBasename();
      const dirname = path.getParent();

      const {projectManager: projectManager} = this.master;
      projectManager.checkConfigFile(path, opts.diagnostics);

      if (___R$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.includes(basename)) {
        await projectManager.queueAddProject(dirname, path);
      }

      if (basename === 'package.json') {
        hasteName = await this.declareManifest({
          diagnostics: opts.diagnostics,
          dirname: dirname,
          path: path,
          hasteName: hasteName,
          hastePath: hastePath});
        hastePath = dirname;
      }

      if (hasteName !== undefined && this.isInsideHaste(path)) {
        projectManager.declareHaste(path, hasteName, hastePath, opts.diagnostics);
      }

      return true;
    }
  }

  // romejs/cli-flags/serializeCLIFlags.ts

  const ___R$romejs$cli$flags$serializeCLIFlags_ts = {
    serializeCLIFlags: ___R$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags};

  function ___R$$priv$romejs$cli$flags$serializeCLIFlags_ts$normalizeFlagValue(val) {
    if (val === 'true') {
      return true;
    } else if (typeof val === 'object' && val != null) {
      return String(val);
    } else {
      return val;
    }
  }

  function ___R$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(data, cliTarget) {
    const {args: args, flags: flags, defaultFlags: defaultFlags} = data;

    let code = '$ ';
    if (data.prefix !== undefined) {
      code += data.prefix + ' ';
    }
    let startColumn = ___R$romejs$ob1$index_ts$number0Neg1;
    let endColumn = ___R$romejs$ob1$index_ts$number0Neg1;

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];

      let isTarget = false;
      if (cliTarget.type === 'arg' && i === cliTarget.key) {
        isTarget = true;
      }
      if (cliTarget.type === 'arg-range' && cliTarget.from === i) {
        isTarget = true;
      }

      if (isTarget) {
        startColumn = ___R$romejs$ob1$index_ts$coerce0(code.length);
      }

      code += arg + ' ';

      let isEndTarget = isTarget;

      if (cliTarget.type === 'arg-range' &&
      i > cliTarget.from &&
      (cliTarget.to === undefined || cliTarget.to <= i)) {
        isEndTarget = true;
      }

      if (isEndTarget) {
        endColumn = ___R$romejs$ob1$index_ts$coerce0(code.length - 1);
      }
    }

    for (const key in flags) {
      const val = ___R$$priv$romejs$cli$flags$serializeCLIFlags_ts$normalizeFlagValue(flags[key]);

      if (val === ___R$$priv$romejs$cli$flags$serializeCLIFlags_ts$normalizeFlagValue(defaultFlags[key])) {
        continue;
      }

      const isTarget = cliTarget.type === 'flag' && key === cliTarget.key;

      if (isTarget) {
        startColumn = ___R$romejs$ob1$index_ts$coerce0(code.length);
      }

      const flagPrefix = data.shorthandFlags.has(key) ? '-' : '--';
      const kebabKey = ___R$romejs$string$utils$toKebabCase_ts$toKebabCase(key);
      if (val === false) {
        code += flagPrefix + 'no-' + kebabKey + ' ';
      } else {
        code += '' + flagPrefix + kebabKey + ' ';
      }

      if (typeof val !== 'boolean') {
        if (isTarget &&
        cliTarget.type === 'flag' &&
        (cliTarget.target === 'value' || cliTarget.target === 'inner-value')) {
          startColumn = ___R$romejs$ob1$index_ts$coerce0(code.length);
        }

        code += String(val) + ' ';
      }

      if (isTarget) {
        endColumn = ___R$romejs$ob1$index_ts$coerce0(code.length - 1);
      }
    }

    if (startColumn === ___R$romejs$ob1$index_ts$number0Neg1 || endColumn === ___R$romejs$ob1$index_ts$number0Neg1) {
      startColumn = ___R$romejs$ob1$index_ts$coerce0(code.length - 1);
      endColumn = startColumn;
    }

    return {
      language: 'shell',
      mtime: undefined,
      sourceText: code,
      filename: 'argv',
      start: {
        line: ___R$romejs$ob1$index_ts$number1,
        column: startColumn,
        index: startColumn},
      end: {
        line: ___R$romejs$ob1$index_ts$number1,
        column: endColumn,
        index: endColumn}};
  }

  // romejs/cli-flags/Parser.ts


  function ___R$$priv$romejs$cli$flags$Parser_ts$splitCommandName(cmd) {
    return cmd.split(' ');
  }

  class ___R$romejs$cli$flags$Parser_ts$default {
    constructor(reporter, opts, rawArgs) {
      this.reporter = reporter;
      this.opts = opts;

      this.shorthandFlags = new Set();
      this.declaredFlags = new Map();
      this.defaultFlags = new Map();
      this.flags = new Map();
      this.args = [];

      this.consumeRawArgs(rawArgs);

      this.commands = new Map();
      this.ranCommand = false;
      this.currentCommand = undefined;

      if (opts.version !== undefined) {
        this.declareArgument({
          command: undefined,
          name: 'version',
          definition: {
            type: 'boolean',
            objectPath: ['version'],
            default: false,
            required: false,
            metadata: {
              description: 'show the version'}}});
      }

      this.declareArgument({
        command: undefined,
        name: 'help',
        definition: {
          type: 'boolean',
          objectPath: ['help'],
          default: false,
          required: false,
          metadata: {
            description: 'show this help screen'}}});

      this.helpMode = this.flags.has('help');
    }

    looksLikeFlag(flag) {
      return flag !== undefined && flag[0] === '-';
    }

    setConsumedFlag(name, value) {
      if (this.flags.has(name)) {}

      this.flags.set(name, value);
    }

    consumeRawArgs(rawArgs) {
      while (rawArgs.length > 0) {
        const arg = String(rawArgs.shift());

        if (arg === '--') {
          this.args = this.args.concat(rawArgs);
          break;
        } else if (arg[0] === '-') {
          const name = arg[1] === '-' ? arg.slice(2) : arg.slice(1);

          if (name.startsWith('no-')) {
            this.flags.set(name.slice(3), false);
            continue;
          }

          if (rawArgs.length === 0 || this.looksLikeFlag(rawArgs[0])) {
            this.setConsumedFlag(name, true);
          } else {
            this.setConsumedFlag(name, String(rawArgs.shift()));
          }

          if (arg[0] === '-' && arg[1] !== '-') {
            this.shorthandFlags.add(name);
          }
        } else {
          this.args.push(arg);
        }
      }
    }

    setFlagAlias(key, alias) {
      const value = this.flags.get(key);
      if (value !== undefined) {
        this.flags.delete(key);
        this.flags.set(alias, value);
      }
    }

    getFlagsConsumer() {
      const defaultFlags = {};

      const flags = {};
      for (const [key, value] of this.flags) {
        flags[___R$romejs$string$utils$toCamelCase_ts$toCamelCase(key)] = value;
      }

      return ___R$romejs$consume$index_ts$consume({
        filePath: ___R$romejs$path$index_ts$createUnknownFilePath('argv'),
        value: flags,

        onDefinition: def => {
          const key = def.objectPath.join('.');

          if (key === '') {
            return;
          }

          this.declareArgument({
            name: key,
            command: this.currentCommand,
            definition: def});
          defaultFlags[key] = def.default;
        },

        context: {
          category: 'cli-flags',
          getOriginalValue: keys => {
            return flags[keys[0]];
          },
          getDiagnosticPointer: (keys, target) => {
            let prefixParts = [];

            const {programName: programName} = this.opts;
            if (programName !== undefined) {
              prefixParts.push(programName);
            }
            if (this.currentCommand !== undefined) {
              prefixParts.push(this.currentCommand);
            }

            return ___R$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
            {
              prefix: prefixParts.join(' '),
              args: this.args,
              defaultFlags: defaultFlags,
              flags: flags,
              shorthandFlags: this.shorthandFlags},
            {
              type: 'flag',
              key: String(keys[0]),
              target: target});
          }}});
    }

    hasArg(name) {
      return this.flags.has(name) && this.flags.get(name) !== undefined;
    }

    declareArgument(decl) {
      const key = decl.command === undefined || this.helpMode ? decl.name : decl.command + '.' + decl.name;

      if (this.declaredFlags.has(key)) {
        throw new Error('Already declared argument ' + key);
      }

      this.setFlagAlias(___R$romejs$string$utils$toKebabCase_ts$toKebabCase(key), key);
      this.declaredFlags.set(key, decl);
      this.defaultFlags.set(key, decl.definition.default);
    }

    getInterface() {
      return new ___R$romejs$cli$flags$Parser_ts$ParserInterface(this);
    }

    async shouldRunCommand(commandName, consumer) {
      const commandParts = ___R$$priv$romejs$cli$flags$Parser_ts$splitCommandName(commandName);
      for (let i = 0; i < commandParts.length; i++) {
        if (commandParts[i] !== this.args[i]) {
          return;
        }
      }

      this.args = this.args.slice(commandParts.length);
      return await this.defineCommandFlags(commandName, consumer);
    }

    async init() {
      if (this.helpMode) {
        await this.showHelp();
        process.exit(1);
      }

      if (this.flags.has('version')) {
        this.reporter.logAll(String(this.opts.version));
        process.exit(0);
      }

      for (const [key, value] of this.flags) {
        const declared = this.declaredFlags.get(key);

        if (declared !== undefined &&
        declared.definition.type === 'boolean' &&
        value !== true &&
        value !== false) {
          this.args.push(value);

          this.flags.set(key, true);
        }
      }

      const consumer = this.getFlagsConsumer();

      let definedCommand;

      const {diagnostics: diagnostics, result: result} = await consumer.capture(async consumer => {
        for (const shorthandName of this.shorthandFlags) {
          consumer.get(shorthandName).unexpected('Shorthand flags are not supported');
        }

        const result = this.opts.defineFlags(consumer);

        for (const key of this.commands.keys()) {
          const defined = await this.shouldRunCommand(key, consumer);
          if (defined) {
            this.currentCommand = key;
            definedCommand = defined;
            break;
          }
        }

        consumer.enforceUsedProperties('flag', false);
        this.currentCommand = undefined;

        return result;
      });

      if (result === undefined) {
        throw new ___R$romejs$diagnostics$errors_ts$DiagnosticsError('CLI flag parsing diagnostics', diagnostics);
      }

      if (definedCommand !== undefined) {
        this.ranCommand = true;
        await definedCommand.command.callback(definedCommand.flags);
      }

      return result;
    }

    buildOptionsHelp(keys) {
      const lines = [];

      const optionOutput = [];
      let argColumnLength = 0;

      for (const key of keys) {
        const decl = this.declaredFlags.get(key);
        if (decl === undefined) {
          throw new Error('Expected argument declaration');
        }

        const {definition: def} = decl;
        const {metadata: metadata} = def;
        let argName = decl.name;
        let argCol = ___R$romejs$string$utils$toKebabCase_ts$toKebabCase(decl.name);

        if (def.type === 'boolean' && def.default === true) {
          argCol = '--no-' + argCol;
          argName = 'no-' + argName;
        } else {
          argCol = '--' + argCol;
        }

        if (def.type !== 'boolean') {
          let inputName = undefined;

          if (inputName === undefined) {
            if (def.type === 'number' || def.type === 'number-range') {
              inputName = 'num';
            } else {
              inputName = 'input';
            }
          }

          argCol += ' <' + inputName + '>';
        }

        if (argColumnLength < argCol.length) {
          argColumnLength = argCol.length;
        }

        const descCol = metadata === undefined || metadata.description === undefined ? 'no description found' : metadata.description;

        optionOutput.push({
          argName: argName,
          arg: argCol,
          description: descCol});
      }

      optionOutput.sort((a, b) => ___R$romejs$string$utils$naturalCompare_ts$naturalCompare(a.argName, b.argName));

      for (const {arg: arg, description: description} of optionOutput) {
        lines.push('  <brightBlack>' + ___R$romejs$string$ansi$pad_ts$rightPad(
        arg,
        argColumnLength,
        ' ') + '</brightBlack>  ' + description);
      }

      return lines;
    }

    showCommandsHelp(heading, rawCommandNames) {
      if (rawCommandNames.length === 0) {
        return undefined;
      }

      const {reporter: reporter} = this;
      reporter.spacer();
      reporter.logAll('<emphasis>' + heading + '</emphasis>');
      reporter.spacer();

      const commandNames = rawCommandNames.sort();
      const cmdOutput = [];
      let nameColumnLength = 0;
      for (const cmd of commandNames) {
        const opts = this.commands.get(cmd);
        if (opts === undefined) {
          throw new Error('Expected command options');
        }

        if (cmd[0] === '_') {
          continue;
        }

        if (nameColumnLength < cmd.length) {
          nameColumnLength = cmd.length;
        }

        const argKeys = [];
        for (const [key, decl] of this.declaredFlags) {
          if (decl.command === cmd) {
            argKeys.push(key);
          }
        }

        const desc = opts.description === undefined ? 'no description available' : opts.description;
        const optLines = this.buildOptionsHelp(argKeys);
        cmdOutput.push([cmd, desc, optLines]);
      }

      for (const [nameCol, descCol, optLines] of cmdOutput) {
        reporter.logAllNoMarkup('  <brightBlack>' + ___R$romejs$string$ansi$pad_ts$rightPad(
        nameCol,
        nameColumnLength,
        ' ') + '</brightBlack>  ' + descCol);

        reporter.indent();
        for (const line of optLines) {
          reporter.logAllNoMarkup(line);
        }
        reporter.dedent();
      }
    }

    async showHelp() {
      const {description: description, usage: usage, programName: programName, examples: examples} = this.opts;

      const consumer = this.getFlagsConsumer();
      await this.opts.defineFlags(consumer);

      for (const key of this.commands.keys()) {
        await this.defineCommandFlags(key, consumer);
      }

      const {reporter: reporter} = this;
      reporter.indent();

      reporter.spacer();
      reporter.logAll('<emphasis>Usage:</emphasis> ' + programName + ' ' + (usage === undefined ? '[flags]' : usage));
      reporter.spacer();

      if (description !== undefined) {
        reporter.logAll(description);
        reporter.spacer();
      }

      reporter.logAll('<emphasis>Options</emphasis>');
      reporter.spacer();

      const lonerArgKeys = [];
      for (const [key, decl] of this.declaredFlags) {
        if (decl.command === undefined) {
          lonerArgKeys.push(key);
        }
      }
      for (const line of this.buildOptionsHelp(lonerArgKeys)) {
        reporter.logAllNoMarkup(line);
      }

      const commandNames = new Set(this.commands.keys());
      const commandsByCategory = new Map();
      for (const name of commandNames) {
        const command = this.commands.get(name);
        if (command === undefined) {
          throw new Error('Expected command');
        }

        const {category: category} = command;
        if (category === undefined) {
          continue;
        }

        let categoryNames = commandsByCategory.get(category);
        if (categoryNames === undefined) {
          categoryNames = [];
          commandsByCategory.set(category, categoryNames);
        }
        categoryNames.push(name);

        commandNames.delete(name);
      }

      const categoryNames = Array.from(commandsByCategory.keys()).sort();
      for (const category of categoryNames) {
        const commandNames = commandsByCategory.get(category);
        if (commandNames === undefined) {
          throw new Error('Expected command names');
        }
        this.showCommandsHelp(category + ' Commands', commandNames);
      }

      this.showCommandsHelp(
      commandsByCategory.size > 0 ? 'Other Commands' : 'Commands',
      Array.from(commandNames));

      if (examples !== undefined) {
        reporter.spacer();
        reporter.logAll('<emphasis>Examples:</emphasis>');
        reporter.spacer();

        reporter.indent();
        for (const cmd of examples) {
          reporter.command(cmd);
        }
        reporter.dedent();
      }

      reporter.spacer();
    }

    commandRequired() {
      if (this.ranCommand) {
        return;
      }

      if (this.args.length === 0) {
        this.reporter.error(
        'No command specified. Run --help to see available commands.');
      } else {
        this.reporter.error('Unknown command <emphasis>' + this.args.join(
        ' ') + '</emphasis>. Run --help to see available commands.');
      }

      process.exit(1);
    }

    addCommand(opts) {
      if (this.currentCommand !== undefined) {
        throw new Error('Nested commands aren\'t allowed');
      }

      this.commands.set(opts.name, opts);
    }

    async defineCommandFlags(cmd, consumer) {
      const opts = this.commands.get(cmd);
      if (opts === undefined) {
        throw new Error('Expected options');
      }

      this.currentCommand = cmd;

      let flags = {};
      if (opts.defineFlags !== undefined) {
        flags = opts.defineFlags(consumer);
      }

      this.currentCommand = undefined;

      return {flags: flags, command: opts};
    }
  }

  class ___R$romejs$cli$flags$Parser_ts$ParserInterface {
    constructor(parser) {
      this.parser = parser;
    }

    init() {
      return this.parser.init();
    }

    getArgs() {
      return this.parser.args;
    }

    commandRequired() {
      this.parser.commandRequired();
    }

    command(opts) {
      this.parser.addCommand(opts);
    }
  }

  // romejs/cli-flags/index.ts

  function ___R$romejs$cli$flags$index_ts$parseCLIFlags(reporter, args, opts) {
    const parser = new ___R$romejs$cli$flags$Parser_ts$default(reporter, opts, args);
    return parser.getInterface();
  }

  function ___R$romejs$cli$flags$index_ts$parseCLIFlagsFromProcess(opts) {
    return ___R$romejs$cli$flags$index_ts$parseCLIFlags(___R$romejs$cli$reporter$Reporter_ts$default.fromProcess(), process.argv.slice(2), Object.assign({}, opts, {
      programName: opts.programName === undefined ? process.argv[1] : opts.programName}));
  }

  // romejs/core/master/MasterRequest.ts

  const ___R$$priv$romejs$core$master$MasterRequest_ts$crypto = require('crypto');

  let ___R$$priv$romejs$core$master$MasterRequest_ts$requestIdCounter = 0;

  class ___R$romejs$core$master$MasterRequest_ts$default {
    constructor(opts) {
      this.query = opts.query;
      this.master = opts.master;
      this.bridge = opts.bridge;
      this.reporter = opts.reporter;
      this.markerEvent = new ___R$romejs$events$Event_ts$default({
        name: 'MasterRequest.marker',
        onError: this.master.onFatalErrorBound});
      this.endEvent = new ___R$romejs$events$Event_ts$default({
        name: 'MasterRequest.teardown',
        onError: this.master.onFatalErrorBound,
        serial: true});
      this.client = opts.client;
      this.id = ___R$$priv$romejs$core$master$MasterRequest_ts$requestIdCounter++;

      this.normalizedCommandFlags = {
        flags: {},
        defaultFlags: {}};
    }

    setNormalizedCommandFlags(normalized) {
      this.normalizedCommandFlags = normalized;
    }

    teardown(response) {
      this.reporter.teardown();
      this.endEvent.send(response);
    }

    async assertClientCwdProject() {
      return this.master.projectManager.assertProject(this.client.flags.cwd);
    }

    createDiagnosticsPrinter(origin) {
      return new ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default({
        origins: [{
          category: 'master',
          message: this.query.commandName + ' command was dispatched'}, origin],
        reporter: this.reporter,
        cwd: this.client.flags.cwd,
        flags: this.getDiagnosticsPrinterFlags(),
        readFile: this.master.readDiagnosticsPrinterFile.bind(this.master)});
    }

    getDiagnosticsPrinterFlags() {
      const {requestFlags: requestFlags} = this.query;
      return {
        grep: requestFlags.grep,
        inverseGrep: requestFlags.inverseGrep,
        focus: requestFlags.focus,
        showAllDiagnostics: requestFlags.showAllDiagnostics,
        verboseDiagnostics: requestFlags.verboseDiagnostics,
        maxDiagnostics: requestFlags.maxDiagnostics,
        fieri: requestFlags.fieri};
    }

    expectArgumentLength(min, max = min) {
      const {args: args} = this.query;
      let message;

      let excessive = false;

      if (min === max) {
        if (args.length !== min) {
          message = 'Expected exactly <number emphasis>' + min + '</number> arguments';
        }
      } else {
        if (args.length < min) {
          message = 'Expected at least <number emphasis>' + min + '</number> arguments';
        }

        if (args.length > max) {
          excessive = true;
          message = 'Expected no more than <number emphasis>' + min + '</number> arguments';
        }
      }

      if (message !== undefined) {
        this.throwDiagnosticFlagError(
        excessive ? 'Too many arguments' : 'Missing arguments',
        {
          type: 'arg-range',
          from: min,
          to: max},
        [{
          type: 'log',
          category: 'info',
          message: message}]);
      }
    }

    throwDiagnosticFlagError(message, target = {type: 'none'}, advice) {
      const pointer = this.getDiagnosticPointerFromFlags(target);
      throw new ___R$romejs$diagnostics$errors_ts$DiagnosticsError(message, [Object.assign({
        message: message,
        filename: 'argv',
        category: 'error'}, pointer, {
        advice: advice})]);
    }

    getDiagnosticPointerFromFlags(target) {
      const {query: query} = this;
      return ___R$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
      {
        prefix: 'rome ' + query.commandName,
        flags: Object.assign({}, this.client.flags, query.requestFlags, this.normalizedCommandFlags.flags),
        args: query.args,
        defaultFlags: Object.assign({}, ___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS, ___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS, this.normalizedCommandFlags.defaultFlags, {
          clientName: this.client.flags.clientName}),
        shorthandFlags: new Set()},
      target);
    }

    getResolverOptionsFromFlags() {
      const {requestFlags: requestFlags} = this.query;
      return {
        platform: requestFlags.resolverPlatform,
        scale: requestFlags.resolverScale,
        mocks: requestFlags.resolverMocks};
    }

    getBundlerConfigFromFlags(resolverOpts) {
      return {
        inlineSourceMap: false,
        cwd: this.client.flags.cwd,
        resolver: Object.assign({}, this.getResolverOptionsFromFlags(), resolverOpts)};
    }

    async getFilesFromArgs(getIgnoreForProject) {
      const {master: master} = this;
      const {flags: flags} = this.client;

      const rawArgs = [...this.query.args];
      const resolvedArgs = [];
      if (rawArgs.length === 0) {
        const project = await this.assertClientCwdProject();
        resolvedArgs.push(project.folder);
      } else {
        for (const arg of rawArgs) {
          resolvedArgs.push(flags.cwd.resolve(arg));
        }
      }

      let files = [];
      for (let arg of resolvedArgs) {
        const project = await master.projectManager.assertProject(arg);
        const projectIgnore = getIgnoreForProject(project);

        const matches = master.memoryFs.glob(arg, {ignore: projectIgnore});
        files = files.concat(matches);
      }
      return files;
    }

    normalizeCompileResult(res) {
      const {projectManager: projectManager} = this.master;

      return Object.assign({}, res, {
        cacheDependencies: res.cacheDependencies.map(filename => {
          return projectManager.getFileReference(___R$romejs$path$index_ts$createAbsoluteFilePath(filename)).uid;
        })});
    }

    startMarker(opts) {
      this.master.logger.info('Started marker %s', opts.label);
      return Object.assign({}, opts, {
        start: Date.now()});
    }

    endMarker(startMarker) {
      const endMarker = Object.assign({}, startMarker, {
        end: Date.now()});
      this.master.logger.info('Finished marker %s', startMarker.label);
      this.markerEvent.send(endMarker);
      return endMarker;
    }

    async wrapRequestDiagnostic(method, path, factory) {
      const {master: master} = this;
      const owner = await master.fileAllocator.getOrAssignOwner(path);
      const ref = master.projectManager.getTransportFileReference(path);

      const marker = this.startMarker({
        label: method + ': ' + ref.uid,
        facet: method,
        rowId: 'worker ' + owner.id});

      try {
        const res = await factory(owner.bridge, ref);
        this.endMarker(marker);
        return res;
      } catch (err) {
        let diagnostics = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);

        if (diagnostics === undefined) {
          const info = ___R$romejs$v8$errors_ts$getErrorStructure(err);

          throw ___R$romejs$v8$errors_ts$createErrorFromStructure(Object.assign({}, info, {
            advice: [...info.advice, {
              type: 'log',
              category: 'info',
              message: 'Error occurred while requesting ' + method + ' for <filelink emphasis target="' + ref.uid + '" />'}]}));
        } else {
          throw err;
        }
      }
    }

    async requestWorkerParse(filename, opts) {
      return this.wrapRequestDiagnostic('parse', filename, (bridge, file) => bridge.parseJS.call({file: file, opts: opts}));
    }

    async requestWorkerLint(filename, fix) {
      const {cache: cache} = this.master;
      const cacheEntry = await cache.get(filename);
      if (cacheEntry.lint !== undefined) {
        return cacheEntry.lint;
      }

      const prefetchedModuleSignatures = await this.maybePrefetchModuleSignatures(
      filename);

      const res = await this.wrapRequestDiagnostic(
      'lint',
      filename,
      (bridge, file) => bridge.lint.call({file: file, fix: fix, prefetchedModuleSignatures: prefetchedModuleSignatures}));

      await cache.update(filename, {
        lint: res});

      return res;
    }

    async requestWorkerCompile(filename, stage, options) {
      const {cache: cache} = this.master;

      const optionsHash = options === undefined ? 'none' : ___R$$priv$romejs$core$master$MasterRequest_ts$crypto.createHash('sha256').update(JSON.stringify(options)).digest('hex');
      const cacheKey = stage + ':' + optionsHash;

      const cacheEntry = await cache.get(filename);
      const cached = cacheEntry.compile[cacheKey];
      if (cached !== undefined) {
        return cached;
      }

      const compileRes = await this.wrapRequestDiagnostic(
      'compile',
      filename,
      (bridge, file) => {
        if (options === undefined) {
          options = {};
        }

        return bridge.compileJS.call({file: file, stage: stage, options: options});
      });

      const res = this.normalizeCompileResult(Object.assign({}, compileRes, {
        cached: false}));

      await cache.update(filename, cacheEntry => ({
        compile: Object.assign({}, cacheEntry.compile, {
          [cacheKey]: Object.assign({}, res, {
            cached: true})})}));

      return res;
    }

    async requestWorkerAnalyzeDependencies(path) {
      const {cache: cache} = this.master;

      const cacheEntry = await cache.get(path);
      if (cacheEntry.analyzeDependencies !== undefined) {
        return cacheEntry.analyzeDependencies;
      }

      const res = await this.wrapRequestDiagnostic(
      'analyzeDependencies',
      path,
      (bridge, file) => bridge.analyzeDependencies.call({file: file}));
      await cache.update(path, {
        analyzeDependencies: Object.assign({}, res, {
          cached: true})});

      return Object.assign({}, res, {
        cached: false});
    }

    async requestWorkerModuleSignature(filename) {
      const {cache: cache} = this.master;

      const cacheEntry = await cache.get(filename);
      if (cacheEntry.moduleSignature !== undefined) {
        return cacheEntry.moduleSignature;
      }

      const res = await this.wrapRequestDiagnostic(
      'moduleSignature',
      filename,
      (bridge, file) => bridge.moduleSignatureJS.call({file: file}));
      await cache.update(filename, {
        moduleSignature: res});
      return res;
    }

    async maybePrefetchModuleSignatures(filename) {
      const {projectManager: projectManager} = this.master;

      const prefetchedModuleSignatures = {};
      const project = await projectManager.assertProject(filename);
      if (project.config.typeCheck.enabled === false) {
        return prefetchedModuleSignatures;
      }

      return prefetchedModuleSignatures;
    }
  }

  // romejs/core/master/project/ProjectManager.ts

  function ___R$$priv$romejs$core$master$project$ProjectManager_ts$cleanName(name) {
    if (name[0] === '@') {
      return name.slice(1);
    } else {
      return name;
    }
  }

  function ___R$$priv$romejs$core$master$project$ProjectManager_ts$cleanRelativeUidPath(relative) {
    return relative.join();

    const segments = relative.getSegments();

    if (!segments[segments.length - 1].startsWith('index.')) {
      return relative.join();
    }

    const basename = relative.getBasename();
    for (const ext of ___R$romejs$core$common$fileHandlers_ts$IMPLICIT_JS_EXTENSIONS) {
      if (basename === 'index.' + ext) {
        if (segments.length === 1) {
          return undefined;
        } else {
          return relative.getParent().join();
        }
      }
    }

    return relative.join();
  }

  class ___R$romejs$core$master$project$ProjectManager_ts$default {
    constructor(master) {
      this.master = master;

      this.isAddingProject = false;
      this.pendingAddProjects = [];

      this.projectIdCounter = 0;
      this.projectFolderToId = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.projectConfigDependenciesToIds = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.fileToProject = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.projects = new Map();

      this.uidToFilename = new Map();
      this.filenameToUid = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.remoteToLocalPath = new Map();
      this.localPathToRemote = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
    }

    async init() {
      this.master.memoryFs.deletedFileEvent.subscribe(path => {
        this.handleDeleted(path);
      });

      const vendorProjectConfig = Object.assign({}, ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG, {
        name: 'rome-internal-remote'});
      const defaultVendorPath = vendorProjectConfig.files.vendorPath;
      await ___R$romejs$fs$index_ts$createDirectory(defaultVendorPath, {recursive: true});
      await this.addProjectWithConfig({
        projectFolder: defaultVendorPath,
        meta: ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG_META,
        config: vendorProjectConfig});
      await this.master.memoryFs.watch(defaultVendorPath, vendorProjectConfig);
    }

    handleDeleted(path) {
      const filename = path.join();

      this.projectConfigDependenciesToIds.delete(path);
      this.fileToProject.delete(path);

      const uid = this.filenameToUid.get(path);
      this.filenameToUid.delete(path);
      if (uid !== undefined) {
        this.uidToFilename.delete(filename);
      }
    }

    getRemoteFromLocalPath(path) {
      return this.localPathToRemote.get(path);
    }

    getFilePathFromUid(uid) {
      return this.uidToFilename.get(uid);
    }

    setUid(path, uid) {
      const filename = path.join();

      const collided = this.uidToFilename.get(uid);
      if (collided !== undefined && !collided.equal(path)) {
        throw new Error('UID collision between ' + filename + ' and ' + collided + ': ' + uid);
      }

      this.uidToFilename.set(uid, path);
      this.filenameToUid.set(path, uid);
    }

    getUid(path) {
      const filename = path.join();
      if (this.uidToFilename.has(filename)) {
        return filename;
      }

      const existing = this.filenameToUid.get(path);
      if (existing !== undefined) {
        return existing;
      }

      const project = this.assertProjectExisting(path);

      if (this.isHasteDeclared(path, project)) {
        const hasteName = this.master.memoryFs.getHasteName(path);
        if (hasteName === undefined) {
          throw new Error('isHasteDeclared returned true so this should always return a valid name');
        }
        this.setUid(path, hasteName);
        return hasteName;
      }

      const parts = [];
      parts.push(project.config.name);

      let root = project.folder;
      const pkg = this.master.memoryFs.getOwnedManifest(path);
      if (pkg !== undefined && pkg.manifest.name !== undefined) {
        parts.push(pkg.manifest.name);
        root = pkg.folder;

        if (___R$$priv$romejs$core$master$project$ProjectManager_ts$cleanName(parts[1]).startsWith(___R$$priv$romejs$core$master$project$ProjectManager_ts$cleanName(parts[0]))) {
          parts.shift();
        }
      }

      const relative = ___R$$priv$romejs$core$master$project$ProjectManager_ts$cleanRelativeUidPath(root.relative(path));
      if (relative !== undefined) {
        parts.push(relative);
      }

      const uid = ___R$$priv$romejs$core$master$project$ProjectManager_ts$cleanName(parts.join('/'));
      this.setUid(path, uid);
      return uid;
    }

    getFileReference(path) {
      const project = this.assertProjectExisting(path);
      const uid = this.getUid(path);
      const pkg = this.master.memoryFs.getOwnedManifest(path);
      return {
        uid: uid,
        project: project.id,
        real: path,
        manifest: pkg === undefined ? undefined : pkg.id,
        remote: this.localPathToRemote.has(path)};
    }

    getURLFileReference(local, url) {
      const uid = url.join();

      if (!this.remoteToLocalPath.has(uid)) {
        this.remoteToLocalPath.set(uid, local);
        this.localPathToRemote.set(local, url);
      }

      return this.getFileReference(local);
    }

    getTransportFileReference(path) {
      return Object.assign({}, this.getFileReference(path), {
        real: path.join()});
    }

    async maybeEvictPossibleConfig(path) {
      const projectIds = this.projectConfigDependenciesToIds.get(path);
      if (projectIds === undefined) {
        return false;
      }

      const projectsToEvict = new Set();

      function getAllProjects(project) {
        let children = [];
        for (const child of project.children) {
          children = children.concat(getAllProjects(child));
        }
        return [project, ...children];
      }

      for (const evictProjectId of projectIds) {
        const project = this.projects.get(evictProjectId);
        if (project === undefined) {
          throw new Error('Expected project of id ' + evictProjectId + ' since it was declared in projectConfigLocsToId');
        }

        let topProject = project;
        while (topProject.parent !== undefined) {
          topProject = topProject.parent;
        }
        for (const project of getAllProjects(topProject)) {
          projectsToEvict.add(project);
        }
      }

      for (const project of projectsToEvict) {
        await this.evictProject(project);
      }

      return true;
    }

    async evictProject(project) {
      const evictProjectId = project.id;

      for (const [configLoc, projectIds] of this.projectConfigDependenciesToIds) {
        if (projectIds.has(evictProjectId)) {
          projectIds.delete(evictProjectId);
        }

        if (projectIds.size === 0) {
          this.projectConfigDependenciesToIds.delete(configLoc);
        }
      }

      for (const {bridge: bridge} of this.master.workerManager.getWorkers()) {
        bridge.updateProjects.send({
          projects: [{
            id: evictProjectId,
            folder: project.folder.join(),
            config: undefined}]});

        bridge.updateManifests.send({
          manifests: Array.from(project.manifests.values(), def => ({
            id: def.id,
            manifest: undefined}))});
      }

      this.projects.delete(evictProjectId);
      this.projectFolderToId.delete(project.folder);

      const ownedFiles = [];
      for (const {projectId: projectId, path: path} of this.fileToProject.values()) {
        if (evictProjectId === projectId) {
          this.handleDeleted(path);
          ownedFiles.push(path);
        }
      }
      await Promise.all(
      ownedFiles.map(path => this.master.fileAllocator.evict(path)));

      this.master.memoryFs.unwatch(project.folder);
    }

    getProjects() {
      return Array.from(this.projects.values());
    }

    async queueAddProject(projectFolder, configPath) {
      const maybeProject = this.findProjectExisting(projectFolder);
      if (maybeProject !== undefined) {
        return maybeProject;
      }

      if (this.isAddingProject) {
        return new Promise(resolve => {
          this.pendingAddProjects.push({projectFolder: projectFolder, configPath: configPath, resolve: resolve});
        });
      }

      this.isAddingProject = true;

      const mainProject = await this.addProject(projectFolder, configPath);
      const resolvedProjectsByDir = new Map();
      resolvedProjectsByDir.set(projectFolder.join(), mainProject);

      const resolvedProjects = [];
      for (const {projectFolder: projectFolder, configPath: configPath, resolve: resolve} of this.pendingAddProjects) {
        const existing = resolvedProjectsByDir.get(projectFolder.join());
        if (existing !== undefined) {
          resolvedProjects.push({project: existing, resolve: resolve});
        } else {
          const project = await this.addProject(projectFolder, configPath);
          resolvedProjects.push({project: project, resolve: resolve});
        }
      }

      for (const {project: project, resolve: resolve} of resolvedProjects) {
        resolve(project);
      }

      this.pendingAddProjects = [];
      this.isAddingProject = false;

      return mainProject;
    }

    addDependencyToProjectId(path, projectId) {
      const ids = this.projectConfigDependenciesToIds.get(path);

      if (ids === undefined) {
        this.projectConfigDependenciesToIds.set(path, new Set([projectId]));
      } else {
        ids.add(projectId);
      }
    }

    warnProjectInteropOption(projectFolder, optionPath, externalName, ourComponentName) {
      this.master.connectedReporters.warn('Project <filelink emphasis target="' + projectFolder.join() + '" /> uses the <emphasis>' + optionPath + '</emphasis> option. This adds ' + externalName + ' integration to the Rome ' + ourComponentName + '. This is intended to be migratory, and not a long-term solution. Please port your configuration.');
    }

    findProjectConfigConsumer(def, test) {
      const meta = ___R$romejs$project$utils_ts$assertHardMeta(def.meta);

      for (const consumer of meta.consumersChain) {
        const value = test(consumer);
        if (value !== undefined && value.exists()) {
          return {value: value, consumer: meta.consumer};
        }
      }

      return {value: undefined, consumer: meta.consumer};
    }

    async addProject(projectFolder, configPath) {
      const {config: config, meta: meta} = ___R$romejs$project$load_ts$loadCompleteProjectConfig(projectFolder, configPath);

      return this.addProjectWithConfig({
        projectFolder: projectFolder,
        meta: meta,
        config: config});
    }

    async addProjectWithConfig({
      projectFolder: projectFolder,
      meta: meta,
      config: config}) {
      if (config.compiler.legacyBabelInterop) {
        this.warnProjectInteropOption(
        projectFolder,
        'compiler.legacyBabelInterop',
        'Babel',
        'compiler');
      }
      if (config.lint.legacyEslintInterop) {
        this.warnProjectInteropOption(
        projectFolder,
        'lint.legacyEslintInterop',
        'ESLint',
        'linter');
      }

      for (const project of this.projects.values()) {
        if (project.config.name === config.name) {
          throw new Error('Conflicting project names. ' + projectFolder + ' and ' + project.folder);
        }
      }

      const parentProject = this.findProjectExisting(projectFolder.getParent());
      const project = {
        config: config,
        meta: meta,
        folder: projectFolder,
        id: this.projectIdCounter++,
        packages: new Map(),
        manifests: new Map(),
        hasteMap: new Map(),
        parent: parentProject,
        children: new Set()};

      this.projects.set(project.id, project);
      this.fileToProject.set(projectFolder, {
        path: projectFolder,
        projectId: project.id});
      this.projectFolderToId.set(projectFolder, project.id);

      if (parentProject !== undefined) {
        parentProject.children.add(project);
      }

      if (meta.configPath !== undefined) {
        this.addDependencyToProjectId(meta.configPath, project.id);
      }
      for (const loc of meta.configDependencies) {
        this.addDependencyToProjectId(loc, project.id);
      }

      this.master.workerManager.onNewProject(project);

      await this.master.memoryFs.watch(projectFolder, config);

      return project;
    }

    declareManifest(project, isProjectPackage, def, diagnostics) {
      const {name: name} = def.manifest;

      const projects = this.getHierarchyFromProject(project);

      if (isProjectPackage && name !== undefined) {
        for (const project of projects) {
          const existingPackage = project.packages.get(name);
          if (existingPackage === undefined) {
            continue;
          }

          diagnostics.addDiagnostic({
            category: 'projectManager',
            filename: def.filename.join(),
            message: 'Duplicate package name <emphasis>' + name + '</emphasis>',
            advice: [{
              type: 'log',
              category: 'info',
              message: 'Defined already by <filelink target="' + existingPackage.filename + '" />'}]});
          return;
        }
      }

      for (const project of projects) {
        this.addDependencyToProjectId(def.filename, project.id);
        project.manifests.set(def.id, def);

        if (isProjectPackage && name !== undefined) {
          project.packages.set(name, def);
        }
      }
    }

    isHasteIgnored(path, config) {
      return ___R$romejs$path$match$index_ts$matchPathPatterns(path, config.haste.ignore);
    }

    isHasteDeclared(path, project) {
      if (project.config.haste.enabled === false) {
        return false;
      }

      const hasteName = this.master.memoryFs.getHasteName(path);
      if (hasteName === undefined) {
        return false;
      }

      const existing = project.hasteMap.get(hasteName);
      if (existing === undefined) {
        return false;
      }

      return existing.equal(path);
    }

    declareHaste(path, hasteName, hastePath, diagnostics) {
      for (const project of this.getHierarchyFromFilename(path)) {
        const {hasteMap: hasteMap, config: config} = project;

        if (config.haste.enabled === false) {
          break;
        }

        if (this.isHasteIgnored(path, config)) {
          continue;
        }

        let existing = hasteMap.get(hasteName);
        if (existing !== undefined && !existing.equal(hastePath)) {
          const existingResolved = this.master.resolver.resolvePath({
            origin: existing,
            source: existing});

          if (existingResolved.type === 'FOUND' &&
          hastePath.equal(existingResolved.ref.real)) {
            continue;
          }

          diagnostics.addDiagnostic({
            category: 'projectManager',
            filename: hastePath.join(),
            message: 'Found a haste collision for <emphasis>' + hasteName + '</emphasis>',
            advice: [{
              type: 'log',
              category: 'info',
              message: 'Defined already by <filelink target="' + existing + '" />'}]});
          continue;
        }

        hasteMap.set(hasteName, hastePath);
      }
    }

    async notifyWorkersOfProjects(workers, projects) {
      if (projects === undefined) {
        projects = Array.from(this.projects.values());
      }

      const manifestsSerial = [];
      const projectsSerial = [];
      for (const project of projects) {
        projectsSerial.push({
          config: ___R$romejs$project$transport_ts$serializeJSONProjectConfig(project.config),
          id: project.id,
          folder: project.folder.join()});

        for (const def of project.manifests.values()) {
          manifestsSerial.push({
            id: def.id,
            manifest: this.master.memoryFs.getPartialManifest(def)});
        }
      }

      const promises = [];

      for (const worker of workers) {
        promises.push(
        worker.bridge.updateProjects.call({projects: projectsSerial}));
        promises.push(
        worker.bridge.updateManifests.call({manifests: manifestsSerial}));
      }

      await Promise.all(promises);
    }

    async assertProject(loc) {
      const syncProject = this.findProjectExisting(loc);
      const project = syncProject || (await this.findProject(loc));

      if (project) {
        if (project.config.isolated === false && syncProject === undefined) {
          await this.findProject(project.folder.getParent());
        }

        return project;
      } else {
        throw new Error('Couldn\'t find a ' + ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.join(' or ') + ' for ' + loc);
      }
    }

    getHandlerWithProject(path) {
      const project = this.findProjectExisting(path);
      if (project === undefined) {
        return {ext: '', handler: undefined};
      } else {
        return ___R$romejs$core$common$fileHandlers_ts$getFileHandler(path, project.config);
      }
    }

    getHierarchyFromFilename(filename) {
      const project = this.findProjectExisting(filename);
      if (project === undefined) {
        return [];
      } else {
        return this.getHierarchyFromProject(project);
      }
    }

    getHierarchyFromProject(project) {
      const projects = [];

      let currProject = project;
      while (currProject !== undefined) {
        projects.push(currProject);

        if (currProject.config.isolated) {
          break;
        }

        currProject = project.parent;
      }

      return projects;
    }

    assertProjectExisting(path) {
      const project = this.findProjectExisting(path);
      if (project === undefined) {
        throw new Error('Expected existing project for ' + path.join());
      }
      return project;
    }

    findProjectExisting(cwd) {
      const tried = [];

      for (const dir of cwd.getChain()) {
        const cached = this.fileToProject.get(dir);
        if (cached === undefined) {
          tried.push(dir);
        } else {
          for (const dir of tried) {
            this.fileToProject.set(dir, cached);
          }

          const project = this.projects.get(cached.projectId);
          if (project === undefined) {
            throw new Error('Expected project from project id found in fileToProject');
          }
          return project;
        }
      }

      return undefined;
    }

    async findProject(cwd) {
      const syncProject = this.findProjectExisting(cwd);
      if (syncProject !== undefined) {
        return syncProject;
      }

      const parentDirectories = cwd.getChain();

      for (const dir of parentDirectories) {
        for (const configFilename of ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAMES) {
          const configPath = dir.append(configFilename);
          const hasProject = await this.master.memoryFs.existsHard(configPath);
          if (hasProject) {
            return this.queueAddProject(dir, configPath);
          }
        }

        const packagePath = dir.append('package.json');
        if (await this.master.memoryFs.existsHard(packagePath)) {
          const input = await ___R$romejs$fs$index_ts$readFileText(packagePath);
          const json = await ___R$romejs$codec$json$index_ts$consumeJSON({input: input, path: packagePath});
          if (json.has(___R$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD)) {
            return this.queueAddProject(dir, packagePath);
          }
        }
      }

      for (const dir of parentDirectories) {
        for (const basename of ___R$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES) {
          const path = dir.append(basename);

          if (await this.master.memoryFs.existsHard(path)) {
            this.warnIncorrectConfigFile(
            path,
            ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default.createImmediateThrower([{
              category: 'project-manager',
              message: 'Find project'}]));
          }
        }
      }

      return undefined;
    }

    checkConfigFile(path, diagnostics) {
      if (___R$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES.includes(path.getBasename())) {
        this.warnIncorrectConfigFile(path, diagnostics);
      }
    }

    warnIncorrectConfigFile(path, diagnostics) {
      diagnostics.addDiagnostic({
        category: 'projectManager',
        filename: path.join(),
        message: 'Invalid rome config filename, <emphasis>' + ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.join(
        ' or ') + '</emphasis> are the only valid filename'});
    }
  }

  // romejs/core/common/utils/fork.ts

  const ___R$$priv$romejs$core$common$utils$fork_ts$child = require('child_process');
  function ___R$romejs$core$common$utils$fork_ts$default(processType, opts) {
    return ___R$$priv$romejs$core$common$utils$fork_ts$child.fork(___R$romejs$core$common$constants_ts$BIN.join(), ___R$romejs$core$common$constants_ts$CHILD_ARGS, Object.assign({
      stdio: 'inherit'}, opts, {
      env: Object.assign({}, process.env, {
        ROME_PROCESS_VERSION: ___R$romejs$core$common$constants_ts$VERSION,
        ROME_PROCESS_TYPE: processType})}));
  }

  // romejs/core/common/utils/Locker.ts


  class ___R$$priv$romejs$core$common$utils$Locker_ts$Lock {
    constructor(locker, key) {
      this.locker = locker;
      this.resolves = [];
      this.key = key;
    }

    addResolve(resolve) {
      this.resolves.push(resolve);
    }

    release() {
      const {resolves: resolves} = this;

      if (resolves.length === 0) {
        this.locker.locks.delete(this.key);
      } else {
        const resolve = resolves.shift();
        if (resolve === undefined) {
          throw new Error('Already validated resolved.length aboved');
        }
        resolve(this);
      }
    }
  }

  class ___R$romejs$core$common$utils$Locker_ts$default {
    constructor() {
      this.locks = new Map();
    }

    hasLock(id) {
      return this.locks.has(id);
    }

    getNewLock(key) {
      if (this.locks.has(key)) {
        throw new Error('Expected no lock to exist');
      }

      const lock = new ___R$$priv$romejs$core$common$utils$Locker_ts$Lock(this, key);
      this.locks.set(key, lock);
      return lock;
    }

    async getLock(key) {
      const existingLock = this.locks.get(key);

      if (existingLock === undefined) {
        return this.getNewLock(key);
      } else {
        return new Promise(resolve => {
          existingLock.addResolve(resolve);
        });
      }
    }

    async waitLock(key) {
      if (this.hasLock(key)) {
        const lock = await this.getLock(key);
        lock.release();
      }
    }
  }

  // romejs/core/master/WorkerManager.ts

  const ___R$$priv$romejs$core$master$WorkerManager_ts$child = require('child_process');

  class ___R$romejs$core$master$WorkerManager_ts$default {
    constructor(master) {
      this.master = master;

      this.workerStartEvent = new ___R$romejs$events$Event_ts$default({
        name: 'WorkerManager.workerStart',
        onError: master.onFatalErrorBound});
      this.selfWorker = true;
      this.locker = new ___R$romejs$core$common$utils$Locker_ts$default();
      this.workers = new Map();
      this.idCounter = 0;
    }

    getNextWorkerId() {
      return this.idCounter++;
    }

    getWorkerAssert(id) {
      const worker = this.workers.get(id);
      if (worker === undefined) {
        throw new Error('Expected worker');
      }
      return worker;
    }

    getWorkers() {
      return Array.from(this.workers.values());
    }

    getWorkerCount() {
      let count = 0;
      for (const worker of this.workers.values()) {
        if (worker.ghost === false) {
          count++;
        }
      }
      return count;
    }

    getExternalWorkers() {
      return this.getWorkers().filter(worker => worker.process !== undefined);
    }

    end() {
      for (const {bridge: bridge} of this.workers.values()) {
        bridge.end();
      }
    }

    getLowestByteCountWorker() {
      let smallestWorker;
      let byteCount;
      for (const worker of this.workers.values()) {
        if (!worker.ghost &&
        (byteCount === undefined || byteCount > worker.byteCount)) {
          smallestWorker = worker;
          byteCount = worker.byteCount;
        }
      }

      if (smallestWorker === undefined) {
        throw new Error('No worker found');
      } else {
        return smallestWorker;
      }
    }

    async init() {
      const bridge = ___R$romejs$events$bridgeCreators_ts$createBridgeFromLocal(___R$romejs$core$common$bridges$WorkerBridge_ts$default, {});
      const worker = new ___R$romejs$core$worker$Worker_ts$default({
        bridge: bridge,
        globalErrorHandlers: false});

      const id = this.getNextWorkerId();
      if (id !== 0) {
        throw new Error('Expected master worker id to be 0');
      }

      const container = {
        id: 0,
        fileCount: 0,
        byteCount: 0,
        process: undefined,
        bridge: bridge,
        ghost: false,
        ready: false};
      this.workers.set(0, container);
      await worker.init();

      await Promise.all([this.workerHandshake(container), bridge.handshake()]);

      this.workerStartEvent.send(bridge);
    }

    async replaceOwnWorker() {
      const lock = this.locker.getNewLock(0);

      try {
        const masterWorker = this.getWorkerAssert(0);
        this.master.logger.info('[WorkerManager] Spawning first worker outside of master after exceeding ' + ___R$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS + ' bytes');
        this.selfWorker = false;

        const newWorker = await this.spawnWorker(this.getNextWorkerId(), true);

        masterWorker.bridge.end();

        this.workers.set(0, {
          id: 0,
          fileCount: masterWorker.fileCount,
          byteCount: masterWorker.byteCount,
          bridge: newWorker.bridge,
          process: newWorker.process,
          ghost: false,
          ready: true});
        this.workers.delete(newWorker.id);
      } finally {
        lock.release();
      }
    }

    onNewProject(newProject) {
      this.master.projectManager.notifyWorkersOfProjects(this.getWorkers(), [newProject]);
    }

    async workerHandshake(worker) {
      const {bridge: bridge} = worker;
      await bridge.handshake({timeout: 3000});
      await this.master.projectManager.notifyWorkersOfProjects([worker]);
      worker.ready = true;
    }

    async spawnWorker(workerId, isGhost = false) {
      const lock = this.locker.getNewLock(workerId);
      try {
        return await this._spawnWorker(workerId, isGhost);
      } finally {
        lock.release();
      }
    }

    async _spawnWorker(workerId, isGhost) {
      const start = Date.now();

      const process = ___R$romejs$core$common$utils$fork_ts$default('worker');

      const bridge = ___R$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess(___R$romejs$core$common$bridges$WorkerBridge_ts$default, process, {
        type: 'client',
        onSendMessage: data => {
          this.master.logger.info('[WorkerManager] Sending worker request to %s:', workerId, data);
        }});

      const worker = {
        id: workerId,
        fileCount: 0,
        byteCount: 0,
        process: process,
        bridge: bridge,
        ghost: isGhost,
        ready: false};
      this.workers.set(workerId, worker);

      process.once('error', err => {
        this.master.onFatalError(err);
        process.kill();
      });

      process.once('exit', () => {
        this.master.onFatalError(new Error('Worker ' + String(workerId) + ' died'));
      });

      await this.workerHandshake(worker);

      if (this.master.profiling !== undefined) {
        await bridge.profilingStart.call(this.master.profiling);
      }

      this.workerStartEvent.send(bridge);

      this.master.logger.info('[WorkerManager] Worker %s started after %sms', workerId, Date.now() - start);

      return worker;
    }

    own(workerId, stats) {
      const worker = this.getWorkerAssert(workerId);
      worker.byteCount += stats.size;
      worker.fileCount++;
    }

    disown(workerId, stats) {
      const worker = this.getWorkerAssert(workerId);
      worker.byteCount -= stats.size;
      worker.fileCount--;
    }

    async getNextWorker(path) {
      const {logger: logger, memoryFs: memoryFs, fileAllocator: fileAllocator} = this.master;

      const stats = memoryFs.getFileStats(path);
      if (stats === undefined) {
        throw new Error('The file ' + path.join() + ' doesn\'t exist');
      }

      fileAllocator.verifySize(path, stats);

      await this.locker.waitLock(0);

      if (this.selfWorker) {
        const worker = this.getWorkerAssert(0);
        if (worker.byteCount > ___R$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS) {
          await this.replaceOwnWorker();
        }
      }

      const smallestWorker = this.getLowestByteCountWorker();
      let workerId = smallestWorker.id;

      if (smallestWorker.byteCount > ___R$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD &&
      this.getWorkerCount() < ___R$romejs$core$common$constants_ts$MAX_WORKER_COUNT) {
        logger.info('[WorkerManager] Spawning a new worker as we\'ve exceeded ' + ___R$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD + ' bytes across each worker');
        workerId = this.getNextWorkerId();
        await this.spawnWorker(workerId);
      }

      this.own(workerId, stats);

      await this.locker.waitLock(workerId);

      return this.getWorkerAssert(workerId);
    }
  }

  // romejs/core/common/types/platform.ts

  const ___R$romejs$core$common$types$platform_ts = {
    get PLATFORMS() {
      return ___R$romejs$core$common$types$platform_ts$PLATFORMS;
    },
    get PLATFORM_ALIASES() {
      return ___R$romejs$core$common$types$platform_ts$PLATFORM_ALIASES;
    }};

  const ___R$romejs$core$common$types$platform_ts$PLATFORMS = ['ios', 'android', 'mobile', 'electron', 'web', 'node'];

  const ___R$romejs$core$common$types$platform_ts$PLATFORM_ALIASES = {
    ios: ['mobile'],
    android: ['mobile'],
    electron: ['web'],
    mobile: [],
    node: [],
    web: []};

  // romejs/core/master/fs/resolverSuggest.ts

  function ___R$romejs$core$master$fs$resolverSuggest_ts$default(resolver, query, resolved, origQuerySource) {
    let errMsg = '';
    if (resolved.type === 'UNSUPPORTED') {
      errMsg = 'Unsupported path format';
    } else if (resolved.type === 'MISSING') {
      errMsg = 'Cannot find';
    } else if (resolved.type === 'FETCH_ERROR') {
      errMsg = 'Failed to fetch';
    }
    errMsg += ' "' + query.source.join() + '" from "' + query.origin.join() + '"';

    const querySource = resolved.source === undefined ? origQuerySource : resolved.source;
    if (querySource === undefined || querySource.pointer === undefined) {
      throw new Error(errMsg);
    }

    const {pointer: pointer} = querySource;

    let advice = [];

    if (query.origin.isAbsolute()) {
      const localQuery = Object.assign({}, query, {
        origin: query.origin.assertAbsolute()});

      if (query.strict) {
        const nonStrictResolved = resolver.resolveLocal(Object.assign({}, localQuery, {
          strict: false}));

        if (nonStrictResolved.type === 'FOUND') {
          if (nonStrictResolved.types.includes('implicitIndex')) {
            advice.push({
              type: 'log',
              category: 'info',
              message: 'This successfully resolves as an implicit index file. Trying adding <emphasis>/index' + nonStrictResolved.path.getExtensions() + '</emphasis> to the end of the import source'});
          } else if (nonStrictResolved.types.includes('implicitExtension')) {
            advice.push({
              type: 'log',
              category: 'info',
              message: 'This successfully resolves as an implicit extension. Try adding the extension <emphasis>' + nonStrictResolved.path.getExtensions() + '</emphasis>'});
          }
        }
      }

      let skipSimilaritySuggestions = false;

      const validPlatforms = [];
      for (const PLATFORM of ___R$romejs$core$common$types$platform_ts$PLATFORMS) {
        if (PLATFORM === query.platform) {
          continue;
        }

        const resolved = resolver.resolveLocal(Object.assign({}, localQuery, {
          platform: PLATFORM}));

        if (resolved.type === 'FOUND') {
          validPlatforms.push('<emphasis>' + PLATFORM + '</emphasis> at <filelink emphasis target="' + resolved.ref.uid + '" />');
        }
      }
      if (validPlatforms.length > 0) {
        if (query.platform === undefined) {
          advice.push({
            type: 'log',
            category: 'info',
            message: 'No platform was specified but we found modules for the following platforms'});
        } else {
          advice.push({
            type: 'log',
            category: 'info',
            message: 'No module found for the platform <emphasis>' + query.platform + '</emphasis> but we found these others'});
        }

        skipSimilaritySuggestions = true;

        advice.push({
          type: 'list',
          list: validPlatforms});
      }

      if (origQuerySource !== undefined &&
      origQuerySource.pointer !== undefined &&
      resolved.source !== undefined) {
        advice.push({
          type: 'log',
          category: 'info',
          message: 'Found while resolving <emphasis>' + query.source + '</emphasis> from <filelink emphasis target="' + query.origin + '" />'});

        const origPointer = origQuerySource.pointer;

        advice.push(Object.assign({
          type: 'frame'}, origPointer));
      }

      if (!skipSimilaritySuggestions) {
        const suggestions = ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$getSuggestions(resolver, localQuery);
        if (suggestions.size > 0) {
          const originFolder = resolver.getOriginFolder(localQuery);

          const relativeToAbsolute = new Map();

          const relativeSuggestions = Array.from(
          suggestions,
          ([human, absolute]) => {
            if (human !== absolute) {
              relativeToAbsolute.set(human, absolute);
              return human;
            }

            let relativePath = originFolder.relative(absolute);

            if (!query.source.hasExtensions()) {
              relativePath = relativePath.changeBasename(
              relativePath.getExtensionlessBasename());
            }

            const relativeStr = relativePath.toExplicitRelative().join();
            relativeToAbsolute.set(relativeStr, absolute);
            return relativeStr;
          });

          advice = [...advice, ...___R$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
          query.source.join(),
          relativeSuggestions,
          0,
          relative => {
            const absolute = relativeToAbsolute.get(relative);
            if (absolute === undefined) {
              throw new Error('Should be valid');
            }

            return '<filelink target="' + absolute + '">' + relative + '</filelink>';
          })];
        }
      }

      if (query.entry === true &&
      resolver.master.projectManager.findProjectExisting(localQuery.origin) ===
      undefined) {
        advice.push({
          type: 'log',
          category: 'warn',
          message: 'You aren\'t in a Rome project'});
      }
    }

    const source = querySource.source === undefined ? query.source.join() : querySource.source;
    let message = '';

    if (resolved.type === 'UNSUPPORTED') {
      message = 'Unsupported';
    } else if (resolved.type === 'MISSING') {
      message = 'Cannot find';
    } else if (resolved.type === 'FETCH_ERROR') {
      message = 'Failed to fetch';
    }

    if (resolved.advice !== undefined) {
      advice = advice.concat(resolved.advice);
    }

    message += ' <emphasis>' + source + '</emphasis> from <filelink emphasis target="' + pointer.filename + '" />';

    throw new ___R$romejs$diagnostics$errors_ts$DiagnosticsError(errMsg, [{
      category: 'resolver',
      filename: pointer.filename,
      start: pointer.start,
      end: pointer.end,
      sourceText: querySource.pointer.sourceText,
      language: querySource.pointer.language,
      mtime: querySource.pointer.mtime,
      message: message,
      advice: advice}]);
  }

  function ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$getPathSuggestions(resolver, query) {
    const {source: source} = query;
    const originFolder = resolver.getOriginFolder(query);
    const suggestions = new Map();

    ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(resolver, suggestions, originFolder.resolve(source));

    const sourceParts = [...source.getSegments()];
    while (sourceParts[0] === '.' || sourceParts[0] === '..') {
      sourceParts.shift();
    }

    for (const path of originFolder.getChain()) {
      ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(resolver, suggestions, path.append(sourceParts));
    }

    return suggestions;
  }

  const ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$MIN_SIMILARITY = 0.8;

  function ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(resolver, suggestions, path) {
    const {memoryFs: memoryFs} = resolver.master;

    const segments = path.getSegments();
    const chain = path.getChain();

    for (let i = chain.length - 1; i >= 0; i--) {
      const path = chain[i];

      if (memoryFs.exists(path)) {
        if (i === chain.length) {
          const filename = path.join();
          suggestions.set(filename, filename);
        }

        break;
      }

      const parentPath = path.getParent();

      if (!memoryFs.exists(path) && memoryFs.exists(parentPath)) {
        const entries = Array.from(memoryFs.readdir(parentPath), path => path.join());
        if (entries.length === 0) {
          continue;
        }

        const ratings = ___R$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
        path.getExtensionlessBasename(),
        entries,
        ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$MIN_SIMILARITY,
        target => {
          return ___R$romejs$path$index_ts$createUnknownFilePath(target).getExtensionlessBasename();
        });

        for (const rating of ratings) {
          ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(
          resolver,
          suggestions,
          ___R$romejs$path$index_ts$createUnknownFilePath(rating.target).append(segments.slice(1)).assertAbsolute());
        }
      }
    }
  }

  function ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$getPackageSuggestions(resolver, query) {
    const possibleGlobalPackages = new Map();

    const mainProject = resolver.master.projectManager.findProjectExisting(
    query.origin);
    if (mainProject !== undefined) {
      const projects = resolver.master.projectManager.getHierarchyFromProject(
      mainProject);

      for (const project of projects) {
        for (const [name, value] of project.hasteMap) {
          possibleGlobalPackages.set(name, value.join());
        }

        for (const [name, value] of project.packages) {
          possibleGlobalPackages.set(name, value.folder.join());
        }
      }
    }

    const matches = ___R$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
    query.source.join(),
    Array.from(possibleGlobalPackages.keys()),
    ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$MIN_SIMILARITY).map(item => {
      const name = item.target;

      const absolute = possibleGlobalPackages.get(name);
      if (absolute === undefined) {
        throw new Error('Should exist');
      }

      return [name, absolute];
    });
    return new Map(matches);
  }

  function ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$getSuggestions(resolver, query) {
    if (query.entry === true) {
      return new Map([...___R$$priv$romejs$core$master$fs$resolverSuggest_ts$getPathSuggestions(resolver, query), ...___R$$priv$romejs$core$master$fs$resolverSuggest_ts$getPackageSuggestions(resolver, query)]);
    } else if (___R$romejs$core$master$fs$Resolver_ts$isPathLike(query.source)) {
      return ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$getPathSuggestions(resolver, query);
    } else {
      return ___R$$priv$romejs$core$master$fs$resolverSuggest_ts$getPackageSuggestions(resolver, query);
    }
  }

  // romejs/core/master/fs/Resolver.ts

  const ___R$$priv$romejs$core$master$fs$Resolver_ts$https = require('https');
  function ___R$$priv$romejs$core$master$fs$Resolver_ts$request(url) {
    return new Promise((resolve, reject) => {
      const req = ___R$$priv$romejs$core$master$fs$Resolver_ts$https.get(url, res => {
        if (res.statusCode !== 200) {
          console.log('non-200 return');
          resolve({
            type: 'FETCH_ERROR',
            source: undefined,
            advice: [{
              type: 'log',
              category: 'info',
              message: '<hyperlink target="' + url + '" /> returned a ' + res.statusCode + ' status code'}]});
          return;
        }

        let data = '';

        res.on('data', chunk => {
          data += chunk;
        });

        res.on('end', () => {
          resolve({type: 'DOWNLOADED', content: data});
        });
      });

      req.on('error', err => {
        resolve({
          type: 'FETCH_ERROR',
          source: undefined,
          advice: [{
            type: 'log',
            category: 'info',
            message: '<hyperlink target="' + url + '" /> resulted in the error "' + err.message + '"'}]});
      });
    });
  }

  const ___R$$priv$romejs$core$master$fs$Resolver_ts$NODE_MODULES = 'node_modules';

  const ___R$$priv$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING = {
    type: 'MISSING',
    source: undefined};

  function ___R$$priv$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(res) {
    return res.type === 'FOUND' || res.source !== undefined;
  }

  function ___R$romejs$core$master$fs$Resolver_ts$isPathLike(source) {
    return source.isAbsolute() || source.isExplicitRelative();
  }

  function ___R$$priv$romejs$core$master$fs$Resolver_ts$appendTypeQueryResponse(res, types) {
    if (res.type === 'FOUND') {
      return Object.assign({}, res, {
        types: [...res.types, ...types]});
    } else {
      return res;
    }
  }

  function ___R$$priv$romejs$core$master$fs$Resolver_ts$getPreferredMainKey(manifest) {
    if (manifest['jsnext:main'] !== undefined) {
      return {key: 'jsnext:main', value: manifest['jsnext:main']};
    }

    if (manifest.main !== undefined) {
      return {key: 'main', value: manifest.main};
    }
  }

  class ___R$romejs$core$master$fs$Resolver_ts$default {
    constructor(master) {
      this.master = master;
    }

    init() {}

    async findProjectFromQuery(query) {
      if (query.source.isAbsolute()) {
        await this.master.projectManager.findProject(
        query.source.assertAbsolute());
      } else if (query.origin.isAbsolute()) {
        const origin = query.origin.assertAbsolute();
        await this.master.projectManager.findProject(origin);
        await this.master.projectManager.findProject(
        origin.append(query.source.assertRelative()));
      }
    }

    async resolveEntryAssert(query, querySource) {
      await this.findProjectFromQuery(query);
      return this.resolveAssert(Object.assign({}, query, {
        entry: true}), querySource);
    }

    async resolveEntryAssertPath(query, querySource) {
      const res = await this.resolveEntryAssert(query, querySource);
      return res.path;
    }

    async resolveEntry(query) {
      await this.findProjectFromQuery(query);
      return this.resolveRemote(Object.assign({}, query, {
        entry: true}));
    }

    async resolveAssert(query, origQuerySource) {
      const resolved = await this.resolveRemote(query);
      if (resolved.type === 'FOUND') {
        return resolved;
      } else {
        throw ___R$romejs$core$master$fs$resolverSuggest_ts$default(this, query, resolved, origQuerySource);
      }
    }

    async resolveRemote(query) {
      const {origin: origin, source: source} = query;

      if (source.isURL()) {
        const sourceURL = source.assertURL();
        const protocol = sourceURL.getProtocol();

        switch (protocol) {
          case 'http':
          case 'https':
            {
              let projectConfig = ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG;

              if (origin.isAbsolute()) {
                const project = this.master.projectManager.findProjectExisting(
                query.origin.assertAbsolute());
                if (project !== undefined) {
                  projectConfig = project.config;
                }
              }

              const remotePath = projectConfig.files.vendorPath.append(
              source.join().replace(/[\/:]/g, '$').replace(/\$+/g, '$'));

              if (!this.master.memoryFs.exists(remotePath)) {
                const result = await ___R$$priv$romejs$core$master$fs$Resolver_ts$request(source.join());
                if (result.type === 'DOWNLOADED') {
                  await ___R$romejs$fs$index_ts$writeFile(remotePath, result.content);
                } else {
                  return result;
                }
              }

              return {
                type: 'FOUND',
                types: [],
                ref: this.master.projectManager.getURLFileReference(
                remotePath,
                sourceURL),
                path: remotePath};
            }

          default:
            return {
              type: 'UNSUPPORTED',
              source: undefined,
              advice: [{
                type: 'log',
                category: 'info',
                message: '<emphasis>' + protocol + '</emphasis> is not a supported remote protocol'}]};}
      }

      if (origin.isURL()) {
        if (source.isAbsolute() || source.isExplicitRelative()) {
          return this.resolveRemote(Object.assign({}, query, {
            source: origin.resolve(source)}));
        } else {
          return {
            type: 'MISSING',
            source: undefined};
        }
      }

      return this.resolveLocal(Object.assign({}, query, {
        origin: query.origin.assertAbsolute()}));
    }

    resolveLocal(query) {
      if (___R$romejs$core$master$fs$Resolver_ts$isPathLike(query.source)) {
        return this.resolvePath(query);
      }

      const resolved = this.resolveModule(query);

      if (resolved.type === 'MISSING' && query.entry === true) {
        return this.resolvePath(query);
      }

      return resolved;
    }

    *getFilenameVariants(query, path) {
      const seen = new Set();
      for (const variant of this._getFilenameVariants(query, path, [])) {
        const filename = variant.path.join();
        if (seen.has(filename)) {
          continue;
        }

        seen.add(filename);
        yield variant;
      }
    }

    *_getFilenameVariants(query, path, callees) {
      const {platform: platform} = query;

      yield {path: path, types: callees};

      const {handler: handler} = this.master.projectManager.getHandlerWithProject(
      path.isAbsolute() ? path.assertAbsolute() : query.origin);
      const usesUnknownExtension = !query.strict && handler === undefined;

      if (platform !== undefined && !callees.includes('implicitPlatform')) {
        yield* this._getFilenameVariants(
        query,
        path.addExtension('.' + platform),
        [...callees, 'implicitPlatform']);

        const platformAliases = ___R$romejs$core$common$types$platform_ts$PLATFORM_ALIASES[platform];
        if (platformAliases !== undefined) {
          for (const platform of platformAliases) {
            yield* this._getFilenameVariants(
            query,
            path.addExtension('.' + platform, true),
            [...callees, 'implicitPlatform']);
          }
        }
      }

      if (usesUnknownExtension && !callees.includes('implicitExtension')) {
        for (const ext of ___R$romejs$core$common$fileHandlers_ts$IMPLICIT_JS_EXTENSIONS) {
          yield* this._getFilenameVariants(query, path.addExtension('.' + ext), [...callees, 'implicitExtension']);
        }
      }

      if (handler !== undefined &&
      handler.canHaveScale === true &&
      !callees.includes('implicitScale')) {
        const scale = query.scale === undefined ? 3 : query.scale;
        for (let i = scale; i >= 1; i--) {
          yield* this._getFilenameVariants(
          query,
          path.changeBasename(path.getExtensionlessBasename() + '@' + String(i) + 'x' + path.memoizedExtension),
          [...callees, 'implicitScale']);
        }
      }
    }

    finishResolverQueryResponse(path, types) {
      return {
        type: 'FOUND',
        types: types === undefined ? [] : types,
        ref: this.master.projectManager.getFileReference(path),
        path: path};
    }

    getOriginFolder(query) {
      const {memoryFs: memoryFs} = this.master;
      const {origin: origin} = query;

      if (memoryFs.isFile(origin)) {
        return origin.getParent();
      } else {
        return origin;
      }
    }

    resolvePath(query, checkVariants = true, types) {
      const {memoryFs: memoryFs} = this.master;

      const originFolder = this.getOriginFolder(query);
      const resolvedOrigin = originFolder.resolve(query.source);

      if (memoryFs.isFile(resolvedOrigin)) {
        if (query.requestedType === 'package') {
          return ___R$$priv$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
        }

        return this.finishResolverQueryResponse(resolvedOrigin, types);
      }

      if (checkVariants) {
        for (const variant of this.getFilenameVariants(query, resolvedOrigin)) {
          if (variant.path.equal(resolvedOrigin)) {
            continue;
          }

          const resolved = this.resolvePath(Object.assign({}, query, {
            source: variant.path}), false, variant.types);

          if (___R$$priv$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(resolved)) {
            return ___R$$priv$romejs$core$master$fs$Resolver_ts$appendTypeQueryResponse(resolved, variant.types);
          }
        }
      }

      if (memoryFs.isDirectory(resolvedOrigin)) {
        if (query.requestedType === 'folder') {
          return this.finishResolverQueryResponse(resolvedOrigin, types);
        }

        const manifestDef = memoryFs.getManifestDefinition(resolvedOrigin);
        if (manifestDef !== undefined) {
          if (query.requestedType === 'package') {
            return this.finishResolverQueryResponse(resolvedOrigin, types);
          }

          const main = ___R$$priv$romejs$core$master$fs$Resolver_ts$getPreferredMainKey(manifestDef.manifest);
          if (main !== undefined) {
            const resolved = this.resolvePath(Object.assign({}, query, {
              origin: resolvedOrigin,
              source: ___R$romejs$path$index_ts$createUnknownFilePath(main.value)}), true, ['package']);

            if (resolved.type === 'FOUND') {
              return resolved;
            } else {
              const pointer = manifestDef.consumer.get(main.key).getDiagnosticPointer('value');

              return Object.assign({}, resolved, {
                source: pointer === undefined ? undefined : {
                  pointer: pointer,
                  source: main.value}});
            }
          }
        }

        if (!query.strict) {
          for (const ext of ___R$romejs$core$common$fileHandlers_ts$IMPLICIT_JS_EXTENSIONS) {
            const indexResolved = this.resolvePath(Object.assign({}, query, {
              source: resolvedOrigin.append('index.' + ext)}), true, ['implicitIndex']);

            if (___R$$priv$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(indexResolved)) {
              return indexResolved;
            }
          }
        }
      }

      return ___R$$priv$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
    }

    resolvePackageFolder(query, moduleName) {
      const project = this.master.projectManager.findProjectExisting(
      query.origin);
      if (project === undefined) {
        return;
      }

      const projects = this.master.projectManager.getHierarchyFromProject(
      project);

      for (const project of projects) {
        const pkg = project.packages.get(moduleName);
        if (pkg !== undefined) {
          return pkg.folder;
        }
      }
    }

    resolvePackage(query, moduleName, moduleNameParts) {
      const packageDir = this.resolvePackageFolder(query, moduleName);

      if (packageDir === undefined) {
        return ___R$$priv$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
      } else {
        return this.resolvePath(Object.assign({}, query, {
          source: packageDir.append(moduleNameParts)}), true, ['package']);
      }
    }

    resolveMock(query, project, parentDirectories) {
      if (project === undefined) {
        return ___R$$priv$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
      }

      const moduleName = query.source.assertRelative();

      for (const dir of parentDirectories) {
        const mocksDir = dir.append(project.config.tests.mocksFolderName);

        if (!this.master.memoryFs.exists(mocksDir)) {
          continue;
        }

        const resolved = this.resolveLocal(Object.assign({}, query, {
          source: mocksDir.append(moduleName)}));

        if (___R$$priv$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(resolved)) {
          return ___R$$priv$romejs$core$master$fs$Resolver_ts$appendTypeQueryResponse(resolved, ['mock']);
        }
      }

      return ___R$$priv$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
    }

    resolveHaste(query, mainProject, moduleName, moduleNameParts) {
      const projects = this.master.projectManager.getHierarchyFromProject(
      mainProject);

      for (const project of projects) {
        const resolved = project.hasteMap.get(moduleName);
        if (resolved !== undefined) {
          if (moduleNameParts.length === 0) {
            return this.finishResolverQueryResponse(resolved, ['haste']);
          } else {
            return this.resolvePath(Object.assign({}, query, {
              source: resolved.append(moduleNameParts)}), true, ['haste']);
          }
        }

        for (const {path: path} of this.getFilenameVariants(query, query.source)) {
          const resolved = project.hasteMap.get(path.join());
          if (resolved !== undefined) {
            return this.finishResolverQueryResponse(resolved, ['haste']);
          }
        }
      }

      return ___R$$priv$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
    }

    splitModuleName(path) {
      const [moduleName, ...moduleNameParts] = path.getSegments();

      if (moduleName[0] === '@' && moduleNameParts.length > 0) {
        return [moduleName + '/' + moduleNameParts.shift(), moduleNameParts];
      }

      return [moduleName, moduleNameParts];
    }

    resolveModule(query) {
      const {origin: origin, source: source} = query;

      const project = this.master.projectManager.findProjectExisting(origin);

      const parentDirectories = this.getOriginFolder(query).getChain();

      if (query.mocks === true) {
        const mockResolved = this.resolveMock(query, project, parentDirectories);
        if (___R$$priv$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(mockResolved)) {
          return mockResolved;
        }
      }

      const [moduleName, moduleNameParts] = this.splitModuleName(source);

      if (project !== undefined && project.hasteMap.size > 0) {
        const hasteResolved = this.resolveHaste(
        query,
        project,
        moduleName,
        moduleNameParts);
        if (___R$$priv$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(hasteResolved)) {
          return hasteResolved;
        }
      }

      const packageResolved = this.resolvePackage(
      query,
      moduleName,
      moduleNameParts);
      if (___R$$priv$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(packageResolved)) {
        return packageResolved;
      }

      for (const dir of parentDirectories) {
        const nodeModulesLoc = dir.append([___R$$priv$romejs$core$master$fs$Resolver_ts$NODE_MODULES, source.assertRelative()]);
        const nodeModulesResolved = this.resolvePath(Object.assign({}, query, {
          source: nodeModulesLoc}), true, ['package']);
        if (___R$$priv$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(nodeModulesResolved)) {
          return nodeModulesResolved;
        }
      }

      return ___R$$priv$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
    }
  }

  // romejs/core/master/fs/FileAllocator.ts

  class ___R$romejs$core$master$fs$FileAllocator_ts$default {
    constructor(master) {
      this.master = master;
      this.fileToWorker = new Map();
      this.locker = new ___R$romejs$core$common$utils$Locker_ts$default();
    }

    init() {
      this.master.memoryFs.deletedFileEvent.subscribe(path => {
        return this.handleDeleted(path);
      });

      this.master.memoryFs.changedFileEvent.subscribe(
      ({path: path, oldStats: oldStats, newStats: newStats}) => {
        return this.handleChange(path, oldStats, newStats);
      });
    }

    getAllOwnedFilenames() {
      return Array.from(this.fileToWorker.keys());
    }

    hasOwner(path) {
      return this.getOwnerId(path) !== undefined;
    }

    getOwnerId(path) {
      return this.fileToWorker.get(path.join());
    }

    verifySize(path, stats) {
      const project = this.master.projectManager.assertProjectExisting(path);
      const maxSize = project.config.files.maxSize;

      if (stats.size > maxSize) {
        throw new Error('The file ' + path.join() + ' exceeds the project config max size of ' + maxSize + ' bytes');
      }
    }

    getOwnerAssert(path) {
      const {workerManager: workerManager} = this.master;
      const workerId = this.getOwnerId(path);
      if (workerId === undefined) {
        throw new Error('No worker found for ' + path);
      }

      const worker = workerManager.getWorkerAssert(workerId);
      if (!worker.ready) {
        throw new Error('Worker ' + workerId + ' isn\'t ready');
      }
      return worker;
    }

    async getOrAssignOwner(path) {
      const {workerManager: workerManager} = this.master;

      const workerId = this.getOwnerId(path);
      if (workerId === undefined) {
        return this.assignOwner(path);
      } else {
        await workerManager.locker.waitLock(workerId);
        return workerManager.getWorkerAssert(workerId);
      }
    }

    async groupFilesByWorker(files) {
      const filesByWorker = new Map();

      await Promise.all(
      files.map(async path => {
        const worker = await this.getOrAssignOwner(path);

        let queue = filesByWorker.get(worker.id);
        if (queue === undefined) {
          queue = [];
          filesByWorker.set(worker.id, queue);
        }
        queue.push(path);
      }));

      return Array.from(filesByWorker.values());
    }

    async evict(path) {
      const workerId = this.getOwnerId(path);
      if (workerId === undefined) {
        return;
      }

      const filename = path.join();
      const worker = this.master.workerManager.getWorkerAssert(workerId);
      await worker.bridge.evict.call({
        filename: filename});

      this.master.logger.info('[FileAllocator] Evicted %s', filename);
    }

    async handleDeleted(path) {
      const workerId = this.getOwnerId(path);
      if (workerId === undefined) {
        return;
      }

      await this.evict(path);

      this.fileToWorker.delete(path.join());

      const stats = this.master.memoryFs.getFileStatsAssert(path);
      this.master.workerManager.disown(workerId, stats);
    }

    async handleChange(path, oldStats, newStats) {
      const filename = path.join();
      const {logger: logger, workerManager: workerManager} = this.master;

      if (this.hasOwner(path)) {
        const workerId = this.getOwnerId(path);
        if (workerId === undefined) {
          throw new Error('Expected worker id for ' + filename);
        }

        await this.evict(path);

        this.verifySize(path, newStats);

        if (oldStats === undefined) {
          throw new Error('File already has an owner so expected to have old stats but had none');
        }
        workerManager.disown(workerId, oldStats);
        workerManager.own(workerId, newStats);
      } else if (await this.master.projectManager.maybeEvictPossibleConfig(path)) {
        logger.info('[FileAllocator] Evicted the project belonging to config %s', filename);
      } else {
        logger.info('[FileAllocator] No owner for eviction %s', filename);
      }
    }

    async assignOwner(path) {
      const {workerManager: workerManager, logger: logger} = this.master;

      const filename = path.join();
      const lock = await this.locker.getLock(filename);

      if (this.hasOwner(path)) {
        lock.release();
        return this.getOwnerAssert(path);
      }

      const worker = await workerManager.getNextWorker(path);

      logger.info('[FileAllocator] File %s assigned to worker %s', filename, worker.id);
      this.fileToWorker.set(filename, worker.id);

      lock.release();

      return worker;
    }
  }

  // romejs/core/common/utils/Logger.ts

  class ___R$romejs$core$common$utils$Logger_ts$default extends ___R$romejs$cli$reporter$Reporter_ts$default {
    constructor(name, event, opts) {
      super(Object.assign({
        verbose: true}, opts));
      this._loggerName = name;
      this.event = event;
    }

    isEnabled() {
      return this.event.hasSubscribers();
    }

    getMessagePrefix(stream) {
      if (stream.format === 'none') {
        return '[' + this._loggerName + ' ' + process.pid + '] ';
      } else {
        return '<dim>[' + this._loggerName + ' ' + process.pid + ']</dim> ';
      }
    }
  }

  // romejs/core/master/Cache.ts


  function ___R$$priv$romejs$core$master$Cache_ts$areEntriesEqual(a, b) {
    if (a.version !== b.version) {
      return false;
    }

    if (a.configHash !== b.configHash) {
      return false;
    }

    if (a.mtime !== b.mtime) {
      return false;
    }

    return true;
  }

  class ___R$romejs$core$master$Cache_ts$default {
    constructor(master) {
      this.master = master;
      this.loadedEntries = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.disabled = process.env.ROME_CACHE === '0';
      this.cachePath = master.userConfig.cachePath;
    }

    async init() {
      this.master.memoryFs.deletedFileEvent.subscribe(filename => {
        return this.master.cache.handleDeleted(filename);
      });

      const {memoryFs: memoryFs} = this.master;
      await ___R$romejs$fs$index_ts$createDirectory(this.cachePath, {recursive: true});
      await memoryFs.watch(this.cachePath, ___R$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG);
    }

    async createEmptyEntry(filename) {
      const {projectManager: projectManager, memoryFs: memoryFs} = this.master;

      const project = await projectManager.assertProject(
      filename);

      const configHashes = [...project.meta.configHashes];
      const pkg = this.master.memoryFs.getOwnedManifest(filename);
      if (pkg !== undefined) {
        configHashes.push(pkg.hash);
      }

      const entry = {
        version: ___R$romejs$core$common$constants_ts$VERSION,
        projectDir: project.folder.join(),
        configHash: configHashes.join(';'),
        mtime: memoryFs.getMtime(filename),
        compile: {},
        analyzeDependencies: undefined,
        moduleSignature: undefined,
        lint: undefined};

      return entry;
    }

    getCacheFilename(filename) {
      const uid = this.master.projectManager.getUid(filename);
      return this.cachePath.append(uid);
    }

    async handleDeleted(filename) {
      const cacheFilename = this.getCacheFilename(filename);
      await ___R$romejs$fs$index_ts$unlink(cacheFilename);
      this.loadedEntries.delete(filename);
    }

    async get(filename) {
      const emptyEntry = await this.createEmptyEntry(filename);

      let loaded = this.loadedEntries.get(filename);
      if (loaded !== undefined && ___R$$priv$romejs$core$master$Cache_ts$areEntriesEqual(loaded, emptyEntry)) {
        return emptyEntry;
      }

      if (this.disabled) {
        return emptyEntry;
      }

      const cacheFilename = this.getCacheFilename(filename);
      const entry = await this.checkPossibleDiskCacheEntry(
      cacheFilename,
      emptyEntry);
      this.loadedEntries.set(filename, entry);
      return entry;
    }

    async checkPossibleDiskCacheEntry(cacheFilename, emptyEntry) {
      const {memoryFs: memoryFs} = this.master;

      if (!memoryFs.exists(cacheFilename)) {
        return emptyEntry;
      }

      try {
        const json = await ___R$romejs$fs$index_ts$readFileText(cacheFilename);
        const obj = JSON.parse(json);

        if (___R$$priv$romejs$core$master$Cache_ts$areEntriesEqual(emptyEntry, obj)) {
          return Object.assign({}, emptyEntry, obj);
        } else {
          await this.handleDeleted(cacheFilename);
          return emptyEntry;
        }
      } catch (err) {
        return emptyEntry;
      }
    }

    async update(filename, partialEntryCallback) {
      const currEntry = await this.get(filename);
      const partialEntry = typeof partialEntryCallback === 'function' ? partialEntryCallback(currEntry) : partialEntryCallback;

      const entry = Object.assign({}, currEntry, partialEntry);

      const cacheFilename = this.getCacheFilename(filename);
      this.loadedEntries.set(filename, entry);

      if (this.disabled) {
        return;
      }

      await ___R$romejs$fs$index_ts$createDirectory(cacheFilename.getParent(), {
        recursive: true});
      await ___R$romejs$fs$index_ts$writeFile(cacheFilename, JSON.stringify(entry, null, '  '));
    }
  }

  // romejs/core/master/WorkerQueue.ts


  class ___R$romejs$core$master$WorkerQueue_ts$default {
    constructor(master) {
      this.master = master;
      this.queue = [];
      this.callbacks = [];
      this.promises = [];
      this.workers = new Map();
      this.open = true;
    }

    pushQueue(filename, metadata) {
      if (!this.open) {
        throw new Error('WorkerQueue has already closed');
      }

      this.queue.push([filename, metadata]);
    }

    addCallback(callback) {
      this.callbacks.push(callback);
    }

    async updateWorkerQueues() {
      const {queue: queue} = this;

      while (queue.length > 0) {
        const item = queue.shift();
        if (item === undefined) {
          throw new Error('Already validated queue.length above');
        }

        const path = item[0];
        const workerContainer = await this.master.fileAllocator.getOrAssignOwner(
        path);

        let worker = this.workers.get(workerContainer);
        if (worker === undefined) {
          worker = {
            running: false,
            queue: []};
          this.workers.set(workerContainer, worker);
        }
        worker.queue.push(item);

        if (worker.running === false) {
          const promise = this.processWorker(worker);

          promise.catch(() => {});
          this.promises.push(promise);
        }
      }
    }

    async processWorker(item) {
      item.running = true;

      const {queue: queue} = item;

      while (queue.length > 0) {
        const item = queue.shift();
        if (item === undefined) {
          throw new Error('Already validated queue.length above');
        }

        const [filename, metadata] = item;
        for (const callback of this.callbacks) {
          await callback(filename, metadata);
        }
        await this.updateWorkerQueues();
      }

      item.running = false;
    }

    async spin() {
      const {queue: queue} = this;

      await this.updateWorkerQueues();

      while (this.promises.length > 0) {
        const {promises: promises} = this;
        this.promises = [];
        await Promise.all(promises);
      }

      this.open = false;

      if (queue.length > 0) {
        throw new Error('Expected no queue items to remain');
      }

      for (const [worker, {queue: queue}] of this.workers) {
        if (queue.length > 0) {
          throw new Error('Expected no queue items to remain for worker ' + worker.id);
        }
      }
    }
  }

  // romejs/core/master/dependencies/DependencyOrderer.ts


  class ___R$romejs$core$master$dependencies$DependencyOrderer_ts$default {
    constructor(graph) {
      this.graph = graph;
      this.orderedNodes = new Set();
      this.visitedNodes = new Set();
      this.possibleCyclePaths = new Map();
      this.diagnostics = [];
      this.firstTopAwaitLocations = [];
    }

    handleAlreadyVisitedFile(node, path, ancestry) {
      const filename = path.join();

      const isPossibleCycle = this.orderedNodes.has(node) === false && ancestry.includes(filename);
      if (isPossibleCycle) {
        const ourCyclePath = ancestry.concat([filename]);
        const existingCycle = this.possibleCyclePaths.get(node);

        const isShortestCycle = existingCycle === undefined ||
        existingCycle.length > ourCyclePath.length;
        if (isShortestCycle) {
          this.possibleCyclePaths.set(node, ourCyclePath);
        }
      }
    }

    addFile(path, ancestry) {
      const node = this.graph.getNode(path);

      if (this.visitedNodes.has(node)) {
        this.handleAlreadyVisitedFile(node, path, ancestry);
        return undefined;
      }

      this.visitedNodes.add(node);

      const {firstTopAwaitLocation: firstTopAwaitLocation} = node.analyze;
      if (firstTopAwaitLocation !== undefined) {
        this.firstTopAwaitLocations.push({
          mtime: node.getMtime(),
          loc: firstTopAwaitLocation});
      }

      const subAncestry = ancestry.concat([path.join()]);
      for (const depPath of node.getAbsoluteDependencies()) {
        const dep = node.getDependencyInfoFromAbsolute(depPath).analyze;
        if (dep.kind === 'value') {
          this.addFile(depPath, subAncestry);
        }
      }

      this.orderedNodes.add(node);
    }

    detectCycles() {
      const flatOrder = Array.from(this.orderedNodes);

      for (let i = 0; i < flatOrder.length; i++) {
        const node = flatOrder[i];

        for (const imp of node.analyze.importFirstUsage) {
          const resolved = node.getNodeFromRelativeDependency(imp.source).resolveImport(imp.imported, imp.loc);
          if (resolved.type !== 'FOUND') {
            continue;
          }

          if (resolved.record.valueType === 'function') {
            continue;
          }

          const dep = resolved.node;

          const isBefore = flatOrder.indexOf(dep) > i;
          if (isBefore) {
            this.flagCycle(node, dep, imp);
          }
        }
      }
    }

    flagCycle(node, dep, imp) {
      const path = this.possibleCyclePaths.get(dep);
      if (!path) {
        return undefined;
      }

      const target = path[path.length - 1];
      const culprit = String(
      path.find((value, index) => path[index - 1] === target));

      function formatPart(part, index) {
        const tagged = '<filelink target="' + part + '" />';
        if (part === culprit) {
          return '<magenta>' + tagged + '</magenta><dim>[1]</dim>';
        } else if (part === target) {
          return '<cyan>' + tagged + '</cyan><dim>[2]</dim>';
        } else if (index === 0) {
          return tagged + ' <inverse>ENTRY</inverse>';
        } else {
          return tagged;
        }
      }

      this.diagnostics.push({
        category: 'bundler/moduleCycle',
        filename: node.path.join(),
        mtime: node.getMtime(),
        start: imp.loc === undefined ? undefined : imp.loc.start,
        end: imp.loc === undefined ? undefined : imp.loc.end,
        message: 'The variable <emphasis>' + imp.local + '</emphasis> won\'t be initialized yet',
        advice: [{
          type: 'log',
          category: 'info',
          message: 'This is because the module it belongs to wont be executed yet. This is due to a circular dependency creating a module cycle.'}, {
          type: 'log',
          category: 'info',
          message: 'The likely cause is the file ' + formatPart(
          culprit) + ' that was required by ' + formatPart(
          target) + ' which created a circular dependency:'}, {
          type: 'list',
          reverse: true,
          ordered: true,
          list: path.map(formatPart)}]});
    }

    order(path) {
      this.addFile(path, []);

      return {
        firstTopAwaitLocations: this.firstTopAwaitLocations,
        diagnostics: this.diagnostics,
        files: Array.from(this.orderedNodes, node => node.path)};
    }
  }

  // romejs/core/master/dependencies/DependencyNode.ts


  function ___R$$priv$romejs$core$master$dependencies$DependencyNode_ts$equalKind(producer, consumerKind) {
    if ((producer.valueType === 'class' || producer.valueType === 'function') &&
    (consumerKind === 'type' || consumerKind === 'typeof')) {
      return true;
    }

    if (producer.kind === 'type') {
      return consumerKind === 'type';
    }

    if (producer.kind === 'value') {
      return consumerKind === 'typeof' || consumerKind === 'value';
    }

    return false;
  }

  class ___R$romejs$core$master$dependencies$DependencyNode_ts$default {
    constructor(graph, id, path, res) {
      this.graph = graph;

      this.project = graph.master.projectManager.assertProjectExisting(path);
      this.path = path;
      this.id = id;
      this.type = res.moduleType;

      this.usedAsync = false;
      this.all = false;
      this.relativeToAbsolutePath = new Map();
      this.absoluteToAnalyzeDependency = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();

      this.analyze = res;

      const {handler: handler} = ___R$romejs$core$common$fileHandlers_ts$getFileHandler(path, this.project.config);
      this.handler = handler;
    }

    getMtime() {
      return this.graph.master.memoryFs.getMtime(this.path);
    }

    setUsedAsync(usedAsync) {
      this.usedAsync = usedAsync;
    }

    setAll(all) {
      this.all = all;
    }

    hasEscapedExports() {
      for (const exp of this.analyze.exports) {
        if (exp.type === 'local' && exp.name === '*') {
          return true;
        }
      }
      return false;
    }

    getDependents() {
      const dependents = [];
      for (const node of this.graph.nodes.values()) {
        if (node.absoluteToAnalyzeDependency.has(this.path)) {
          dependents.push(node);
        }
      }
      return dependents;
    }

    addDependency(relative, absolute, dep) {
      this.relativeToAbsolutePath.set(relative, absolute);
      this.absoluteToAnalyzeDependency.set(absolute, {
        analyze: dep,
        path: absolute});
    }

    getDependencyInfoFromAbsolute(path) {
      const dep = this.absoluteToAnalyzeDependency.get(path);
      if (dep === undefined) {
        throw new Error('Expected dependency');
      }
      return dep;
    }

    getNodeFromRelativeDependency(relative) {
      const absolute = this.relativeToAbsolutePath.get(relative);
      if (absolute === undefined) {
        throw new Error('Expected dependency ' + relative + ' in ' + this.path);
      }
      return this.graph.getNode(absolute);
    }

    getAbsoluteDependencies() {
      return Array.from(this.relativeToAbsolutePath.values());
    }

    getTransitiveDependencies() {
      let queue = [this];

      const nodes = new Set();

      while (queue.length > 0) {
        const node = queue.shift();
        if (node === undefined) {
          throw new Error('Already validated queue.length');
        }

        nodes.add(node);

        for (const absolute of node.getAbsoluteDependencies()) {
          const node = this.graph.getNode(absolute);

          if (!nodes.has(node)) {
            queue.push(node);
          }
        }
      }

      return Array.from(nodes);
    }

    getDependencyOrder() {
      const orderer = new ___R$romejs$core$master$dependencies$DependencyOrderer_ts$default(this.graph);
      return orderer.order(this.path);
    }

    getExportedNames(kind, seen = new Set()) {
      if (seen.has(this)) {
        return new Set();
      } else {
        seen.add(this);
      }

      let names = new Set();

      for (const exp of this.analyze.exports) {
        if (exp.type === 'local' && ___R$$priv$romejs$core$master$dependencies$DependencyNode_ts$equalKind(exp, kind)) {
          names.add(exp.name);
        }

        if (exp.type === 'external') {
          const resolved = this.getNodeFromRelativeDependency(
          exp.source).resolveImport(exp.imported, exp.loc);
          if (resolved.type === 'FOUND' && ___R$$priv$romejs$core$master$dependencies$DependencyNode_ts$equalKind(resolved.record, kind)) {
            names.add(exp.exported);
          }
        }

        if (exp.type === 'externalAll') {
          names = new Set([...names, ...this.getNodeFromRelativeDependency(exp.source).getExportedNames(
          kind,
          seen)]);
        }
      }

      return names;
    }

    buildDiagnosticForUnknownExport(kind, resolved) {
      const resolvedFileLink = '<filelink emphasis target="' + resolved.node.id + '" />';

      const message = 'Couldn\'t find export <emphasis>' + resolved.name + '</emphasis> in ' + resolvedFileLink;
      let advice = [];

      if (resolved.node.analyze.exports.length === 0) {
        advice.push({
          type: 'log',
          category: 'info',
          message: 'This file doesn\'t have any exports'});
      } else {
        const exportedNames = resolved.node.getExportedNames(kind);

        advice = advice.concat(
        ___R$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
        resolved.name,
        Array.from(exportedNames),
        0,
        name => {
          const exportInfo = resolved.node.resolveImport(name, undefined);

          if (exportInfo.type === 'NOT_FOUND') {
            throw new Error('mod.resolveImport returned NOT_FOUND for an export ' + name + ' in ' + exportInfo.node.path + ' despite being returned by getExportedNames');
          }

          const {record: record} = exportInfo;

          const {loc: loc} = record;
          if (loc !== undefined) {
            name = '<filelink target="' + loc.filename + '" line="' + loc.start.line + '" column="' + loc.start.column + '">' + name + '</filelink>';

            if (exportInfo.node !== resolved.node) {
              name += ' <dim>(from <filelink target="' + exportInfo.node.path.join() + '" />)</dim>';
            }
          }

          return name;
        }));
      }

      return Object.assign({
        category: 'bundler'}, resolved.loc, {
        message: message,
        advice: advice,
        mtime: this.getMtime()});
    }

    buildDiagnosticForTypeMismatch(resolved, node, nameInfo) {
      const {name: name, kind: kind, loc: loc} = nameInfo;
      const advice = [];

      const {record: record} = resolved;

      if (record.loc !== undefined) {
        advice.push({
          type: 'log',
          category: 'info',
          message: 'Export was defined here in <filelink emphasis target="' + record.loc.filename + '" />'});

        advice.push(Object.assign({
          type: 'frame'}, record.loc));
      }

      return Object.assign({
        category: 'bundler'}, loc, {
        message: 'The export <emphasis>' + name + '</emphasis> in <filelink emphasis target="' + node.id + '" /> was incorrectly imported as a <emphasis>' + kind + '</emphasis> when it\'s actually a <emphasis>' + record.kind + '</emphasis>',
        advice: advice,
        mtime: this.getMtime()});
    }

    resolveImports() {
      const {graph: graph} = this;
      const deps = this.relativeToAbsolutePath;

      const resolvedImports = {};

      const diagnostics = [];

      const allowTypeImportsAsValue = this.analyze.syntax.includes('ts');
      for (const absolute of deps.values()) {
        const mod = graph.getNode(absolute);

        if (mod.type === 'cjs') {
          continue;
        }

        const usedNames = this.getDependencyInfoFromAbsolute(absolute).analyze.names;

        for (const nameInfo of usedNames) {
          const {name: name, kind: kind, loc: loc} = nameInfo;
          if (kind === 'type' || kind === 'typeof') {
            continue;
          }

          const resolved = mod.resolveImport(name, loc);

          if (resolved.type === 'NOT_FOUND') {
            diagnostics.push(
            this.buildDiagnosticForUnknownExport(kind, resolved));
            continue;
          }

          if (!allowTypeImportsAsValue && !___R$$priv$romejs$core$master$dependencies$DependencyNode_ts$equalKind(resolved.record, kind)) {
            diagnostics.push(
            this.buildDiagnosticForTypeMismatch(resolved, mod, nameInfo));
            continue;
          }

          if (resolved.node.id !== mod.id) {
            resolvedImports[mod.id + ':' + name] = {
              id: resolved.node.id,
              name: resolved.record.name};
          }
        }
      }

      return {
        resolved: resolvedImports,
        diagnostics: diagnostics};
    }

    resolveImport(name, loc, ignoreDefault = false, ancestry = []) {
      if (ancestry.includes(this)) {
        return {
          type: 'NOT_FOUND',
          loc: loc,
          node: this,
          name: name};
      }

      const subAncestry = [...ancestry, this];

      const exports = this.analyze.exports.reverse();

      for (const record of exports) {
        if (record.type === 'local' &&
        record.name === 'default' &&
        ignoreDefault) {
          continue;
        }

        if (record.type === 'local' &&
        (record.name === name || record.name === '*')) {
          return {
            type: 'FOUND',
            node: this,
            record: record};
        }

        if (record.type === 'external' && record.exported === name) {
          return this.getNodeFromRelativeDependency(record.source).resolveImport(
          record.imported,
          record.loc,
          false,
          subAncestry);
        }

        if (record.type === 'externalAll') {
          const resolved = this.getNodeFromRelativeDependency(
          record.source).resolveImport(name, record.loc, true, subAncestry);

          if (resolved.type === 'FOUND') {
            return resolved;
          }
        }
      }

      return {
        type: 'NOT_FOUND',
        loc: loc,
        node: this,
        name: name};
    }
  }

  // romejs/core/master/dependencies/DependencyGraph.ts


  const ___R$$priv$romejs$core$master$dependencies$DependencyGraph_ts$BUILTINS = ['electron', 'buffer', 'child_process', 'crypto', 'dgram', 'dns', 'fs', 'http', 'https', 'net', 'os', 'readline', 'stream', 'string_decoder', 'tls', 'tty', 'zlib', 'constants', 'events', 'url', 'assert', 'util', 'path', 'punycode', 'querystring', 'cluster', 'console', 'module', 'process', 'vm', 'domain', 'v8', 'repl', 'timers', 'inspector'];

  class ___R$romejs$core$master$dependencies$DependencyGraph_ts$default {
    constructor(request, resolverOpts) {
      this.request = request;
      this.master = request.master;
      this.nodes = new ___R$romejs$path$collections_ts$AbsoluteFilePathMap();
      this.resolverOpts = resolverOpts;

      this.locker = new ___R$romejs$core$common$utils$Locker_ts$default();
      this.closeEvent = new ___R$romejs$events$Event_ts$default({name: 'DependencyGraph.closeEvent'});
    }

    watch(callback) {
      const watchSubscription = this.master.fileChangeEvent.subscribe(
      async path => {
        if (this.nodes.has(path)) {
          this.nodes.delete(path);
        } else {
          return;
        }

        const processor = new ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default({origins: []});
        await this.seed([path], processor);
        processor.maybeThrowDiagnosticsError();

        if (callback !== undefined) {
          callback({path: path});
        }
      });

      this.closeEvent.subscribe(() => {
        watchSubscription.unsubscribe();
      });
    }

    close() {
      this.closeEvent.send();
    }

    isExternal(source) {
      return ___R$$priv$romejs$core$master$dependencies$DependencyGraph_ts$BUILTINS.includes(source);
    }

    getBundleBuddyStats(entries) {
      const stats = [];

      for (const node of this.nodes.values()) {
        const source = node.id;

        for (const absoluteTarget of node.relativeToAbsolutePath.values()) {
          const target = this.getNode(absoluteTarget).id;
          stats.push({
            target: target,
            source: source});
        }
      }

      for (const absoluteEntry of entries) {
        const source = this.getNode(absoluteEntry).id;
        stats.push({
          source: source,
          target: undefined});
      }

      return stats;
    }

    addNode(filename, res) {
      const module = new ___R$romejs$core$master$dependencies$DependencyNode_ts$default(this, this.master.projectManager.getUid(filename), filename, res);
      this.nodes.set(filename, module);
      return module;
    }

    getNode(path) {
      const mod = this.nodes.get(path);
      if (mod === undefined) {
        throw new Error('No module found for ' + path.join());
      }
      return mod;
    }

    async seed(filenames, diagnosticsProcessor, analyzeProgress) {
      const workerQueue = new ___R$romejs$core$master$WorkerQueue_ts$default(this.master);

      workerQueue.addCallback(async (path, item) => {
        await this.resolve(
        path,
        {
          workerQueue: workerQueue,
          all: item.all,
          async: item.async,
          ancestry: item.ancestry},
        diagnosticsProcessor,
        analyzeProgress);
      });

      const roots = await Promise.all(
      filenames.map(path => this.resolve(
      path,
      {
        workerQueue: workerQueue,
        all: true,
        async: false,
        ancestry: []},
      diagnosticsProcessor,
      analyzeProgress)));

      await workerQueue.spin();

      if (diagnosticsProcessor.hasDiagnostics()) {
        return;
      }

      for (const root of roots) {
        const order = root.getDependencyOrder();
        diagnosticsProcessor.addDiagnostics(order.diagnostics);

        for (const file of order.files) {
          const resolvedImports = this.getNode(file).resolveImports();
          diagnosticsProcessor.addDiagnostics(resolvedImports.diagnostics);
        }
      }
    }

    async resolve(path, opts, diagnosticsProcessor, analyzeProgress) {
      const filename = path.join();
      const {async: async, all: all, ancestry: ancestry} = opts;
      const {master: master} = this;

      const lock = await this.locker.getLock(filename);

      if (this.nodes.has(path)) {
        const node = this.getNode(path);

        if (all) {
          node.setAll(true);
        }

        if (async) {
          node.setUsedAsync(true);
        }

        lock.release();

        return node;
      }

      const progressText = '<filelink target="' + filename + '" />';

      if (analyzeProgress !== undefined) {
        analyzeProgress.pushText(progressText);
      }

      const res = await this.request.requestWorkerAnalyzeDependencies(
      path);

      const node = this.addNode(path, res);
      node.setAll(all);
      node.setUsedAsync(async);
      lock.release();

      const {dependencies: dependencies, diagnostics: diagnostics} = res;

      if (diagnostics.length > 0) {
        diagnosticsProcessor.addDiagnostics(diagnostics);
      }

      const remote = this.master.projectManager.getRemoteFromLocalPath(path);
      const origin = remote === undefined ? path : remote.getParent();

      await Promise.all(
      dependencies.map(async dep => {
        const {source: source, optional: optional} = dep;
        if (this.isExternal(source)) {
          return;
        }

        const {diagnostics: diagnostics} = await ___R$romejs$diagnostics$wrap_ts$catchDiagnostics(
        {
          category: 'DependencyGraph',
          message: 'Caught by resolve'},
        async () => {
          const resolved = await master.resolver.resolveAssert(Object.assign({
            origin: origin}, this.resolverOpts, {
            source: ___R$romejs$path$index_ts$createUnknownFilePath(source)}), dep.loc === undefined ? undefined : {
            pointer: Object.assign({
              sourceText: undefined}, dep.loc, {
              language: 'js',
              mtime: undefined})});

          node.addDependency(source, resolved.path, dep);
        });

        if (diagnostics !== undefined && !optional) {
          diagnosticsProcessor.addDiagnostics(diagnostics);
        }
      }));

      const subAncestry = [...ancestry, filename];
      for (const path of node.getAbsoluteDependencies()) {
        const dep = node.getDependencyInfoFromAbsolute(path).analyze;
        opts.workerQueue.pushQueue(path, {
          all: dep.all,
          async: dep.async,
          type: dep.type,
          loc: dep.loc,
          ancestry: subAncestry});
      }

      if (analyzeProgress !== undefined) {
        analyzeProgress.popText(progressText);
        analyzeProgress.tick();
      }

      return node;
    }
  }

  // romejs/core/master/bundler/BundleRequest.ts

  const ___R$$priv$romejs$core$master$bundler$BundleRequest_ts$crypto = require('crypto');
  class ___R$romejs$core$master$bundler$BundleRequest_ts$default {
    constructor(bundler, mode, resolvedEntry) {
      this.bundler = bundler;
      this.cached = true;
      this.mode = mode;

      this.resolvedEntry = resolvedEntry;
      this.resolvedEntryUid = bundler.master.projectManager.getUid(resolvedEntry);

      this.diagnostics = new ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default({
        origins: [{
          category: 'bundler',
          message: 'Requested bundle for <filelink target="' + this.resolvedEntryUid + '" />'}]});
      this.compiles = new Map();
      this.assets = new Map();

      this.sourceMap = new ___R$romejs$codec$source$map$SourceMapGenerator_ts$default({
        file: 'TODO-something'});

      this.inMemorySourceMap = [];
    }

    async stepAnalyze() {
      const {reporter: reporter, graph: graph} = this.bundler;

      const analyzeProgress = reporter.progress({
        name: 'bundler:analyze:' + this.resolvedEntryUid});
      analyzeProgress.setTitle('Analyzing');
      this.diagnostics.setThrowAfter(100);
      try {
        await graph.seed([this.resolvedEntry], this.diagnostics, analyzeProgress);
      } finally {
        analyzeProgress.end();
      }

      return this.bundler.graph.getNode(this.resolvedEntry).getDependencyOrder();
    }

    async stepCompile(files) {
      const {reporter: reporter, master: master} = this.bundler;
      this.diagnostics.setThrowAfter(undefined);

      const compilingSpinner = reporter.progress({
        name: 'bundler:compile:' + this.resolvedEntryUid});
      compilingSpinner.setTotal(files.length);
      compilingSpinner.setTitle('Compiling');

      const groupedFiles = await master.fileAllocator.groupFilesByWorker(files);
      await Promise.all(
      groupedFiles.map(async files => {
        for (const filename of files) {
          const progressText = '<filelink target="' + filename.join() + '" />';
          compilingSpinner.pushText(progressText);
          await this.compileJS(filename, false);
          compilingSpinner.tick();
          compilingSpinner.popText(progressText);
        }
      }));
      compilingSpinner.end();
    }

    async compileJS(path, hmr) {
      const {graph: graph} = this.bundler;

      const source = path.join();
      const mod = graph.getNode(path);

      const relativeSourcesToModuleId = {};
      for (const [relative, absolute] of mod.relativeToAbsolutePath) {
        const moduleId = graph.getNode(absolute).id;
        relativeSourcesToModuleId[relative] = moduleId;
      }

      const resolvedImports = mod.resolveImports().resolved;

      let assetPath;
      if (mod.handler !== undefined && mod.handler.isAsset) {
        const buffer = await ___R$romejs$fs$index_ts$readFile(mod.path);

        const hash = ___R$$priv$romejs$core$master$bundler$BundleRequest_ts$crypto.createHash('sha1').update(buffer).digest('hex');
        const basename = mod.path.getExtensionlessBasename();
        const exts = mod.path.getExtensions();

        assetPath = basename + '-' + hash + exts;
        this.assets.set(assetPath, buffer);
      }

      const opts = {
        mode: this.mode,
        moduleAll: mod.all,
        moduleId: mod.id,
        relativeSourcesToModuleId: relativeSourcesToModuleId,
        resolvedImports: resolvedImports,
        assetPath: assetPath};

      const res = await this.bundler.request.requestWorkerCompile(
      path,
      'compileForBundle',
      {bundle: opts});

      if (!res.cached) {
        this.cached = false;
      }

      if (res.diagnostics.length > 0) {
        this.diagnostics.addDiagnostics(res.diagnostics);
      }

      this.compiles.set(source, res);
      return res;
    }

    async stepCombine(order) {
      const {files: files} = order;
      const {inlineSourceMap: inlineSourceMap} = this.bundler.config;
      const {graph: graph} = this.bundler;
      const {resolvedEntry: resolvedEntry, mode: mode, sourceMap: sourceMap, inMemorySourceMap: inMemorySourceMap} = this;

      let content = '';
      let lineOffset = 0;

      function push(str) {
        str += '\n';
        content += str;
        for (let cha of str) {
          if (cha === '\n') {
            lineOffset++;
          }
        }
      }

      function addMappings(filename, sourceContent, mappings) {
        inMemorySourceMap.push({
          path: filename,
          firstLine: ___R$romejs$ob1$index_ts$coerce1(lineOffset + 1),
          map: mappings});
        return;

        sourceMap.setSourceContent(filename, sourceContent);
        for (const mapping of mappings) {
          sourceMap.addMapping(Object.assign({}, mapping, {
            generated: Object.assign({}, mapping.generated, {
              line: ___R$romejs$ob1$index_ts$add(lineOffset, mapping.generated.line)})}));
        }
      }

      if (order.firstTopAwaitLocations.length > 0) {
        if (mode === 'legacy') {
          for (const {loc: loc, mtime: mtime} of order.firstTopAwaitLocations) {
            this.diagnostics.addDiagnostic({
              category: 'bundler/topLevelAwait',
              filename: loc.filename,
              start: loc.start,
              end: loc.end,
              message: 'This module contains a top level await which isn\'t supported in wrapper mode',
              mtime: mtime});
          }
        }

        push('(async function(global) {');
      } else {
        push('(function(global) {');
      }

      if (mode === 'modern') {
        push('  \'use strict\';');
      }

      const declaredCJS = new Set();
      const declareCJS = module => {
        if (mode !== 'modern' ||
        module.type !== 'cjs' ||
        declaredCJS.has(module)) {
          return;
        }

        declaredCJS.add(module);

        push('  var ' + ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(module.id) + ' = {};');
      };

      for (const source of files) {
        const module = graph.getNode(source);

        for (const path of module.getAbsoluteDependencies()) {
          declareCJS(graph.getNode(path));
        }

        const compileResult = this.compiles.get(source.join());
        if (compileResult === undefined) {
          continue;
          throw new Error('Expected compile result');
        }

        if (mode === 'modern') {
          push('  // ' + module.id);
        }

        declareCJS(module);

        addMappings(module.id, compileResult.src, compileResult.mappings);
        push(compileResult.code);
        push('');
      }

      const entryModule = graph.getNode(resolvedEntry);
      if (mode === 'modern') {
        push('  return ' + ___R$romejs$js$compiler$plugins$compileForBundle$_utils_ts$getPrefixedNamespace(entryModule.id) + ';');
      } else {
        push('  return Rome.requireNamespace("' + entryModule.id + '");');
      }

      push(
      '})(typeof global !== \'undefined\' ? global : typeof window !== \'undefined\' ? window : this);');

      if (inlineSourceMap === true) {
        const sourceMapComment = sourceMap.toComment();
        content += sourceMapComment;
      }

      return {
        diagnostics: this.diagnostics.getPartialDiagnostics(),
        content: content,
        map: sourceMap.toJSON(),
        inMemorySourceMap: inMemorySourceMap,
        cached: this.cached,
        assets: this.assets};
    }

    shouldAbort() {
      return this.diagnostics.hasDiagnostics();
    }

    abort() {
      return {
        map: this.sourceMap.toJSON(),
        inMemorySourceMap: [],
        content: '',
        diagnostics: this.diagnostics.getPartialDiagnostics(),
        cached: false,
        assets: this.assets};
    }

    async bundle() {
      const order = await this.stepAnalyze();
      if (this.shouldAbort()) {
        return this.abort();
      }

      await this.stepCompile(order.files);
      if (this.shouldAbort()) {
        return this.abort();
      }

      return await this.stepCombine(order);
    }
  }

  // romejs/core/master/bundler/Bundler.ts


  class ___R$romejs$core$master$bundler$Bundler_ts$default {
    constructor(req, reporter, config) {
      this.config = config;
      this.master = req.master;
      this.reporter = reporter;
      this.request = req;

      this.entries = [];

      this.graph = new ___R$romejs$core$master$dependencies$DependencyGraph_ts$default(req, config.resolver);
    }

    static createFromMasterRequest(req) {
      return new ___R$romejs$core$master$bundler$Bundler_ts$default(req, req.reporter, req.getBundlerConfigFromFlags());
    }

    async getResolvedEntry(unresolvedEntry) {
      const {cwd: cwd} = this.config;

      const res = await this.master.resolver.resolveEntryAssert(Object.assign({}, this.config.resolver, {
        origin: cwd,
        source: ___R$romejs$path$index_ts$createUnknownFilePath(unresolvedEntry)}));

      const {master: master} = this;
      const resolvedEntry = res.path;

      const manifestRootResolved = master.resolver.resolveLocal(Object.assign({}, this.config.resolver, {
        origin: cwd,
        requestedType: 'package',
        source: ___R$romejs$path$index_ts$createUnknownFilePath(unresolvedEntry)}));
      const manifestRoot = manifestRootResolved.type === 'FOUND' ? manifestRootResolved.path : undefined;
      let manifestDef;
      if (manifestRoot !== undefined) {
        const def = master.memoryFs.getManifestDefinition(manifestRoot);
        if (def !== undefined) {
          manifestDef = def;
        }
      }

      return {manifestDef: manifestDef, resolvedEntry: resolvedEntry};
    }

    createBundleRequest(resolvedEntry) {
      const project = this.master.projectManager.assertProjectExisting(
      resolvedEntry);
      const mode = project.config.bundler.mode;

      this.entries.push(resolvedEntry);
      return new ___R$romejs$core$master$bundler$BundleRequest_ts$default(this, mode, resolvedEntry);
    }

    async compile(path, hmr = false) {
      const bundleRequest = this.createBundleRequest(path);
      await bundleRequest.stepAnalyze();
      bundleRequest.diagnostics.maybeThrowDiagnosticsError();
      return await bundleRequest.compileJS(path, hmr);
    }

    async bundleMultiple(entries) {
      const processor = new ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default({
        origins: [{
          category: 'Bundler',
          message: 'Analyzing dependencies for bundleMultiple'}]});
      const entryUids = entries.map(entry => this.master.projectManager.getUid(entry));
      const analyzeProgress = this.reporter.progress({
        name: 'bundler:analyze:' + entryUids.join(',')});
      analyzeProgress.setTitle('Analyzing');
      processor.setThrowAfter(100);
      await this.graph.seed(entries, processor, analyzeProgress);
      processor.maybeThrowDiagnosticsError();

      const map = new Map();

      for (const resolvedEntry of entries) {
        map.set(resolvedEntry, (await this.bundle(resolvedEntry)));
      }

      return map;
    }

    async bundleManifest({resolvedEntry: resolvedEntry, manifestDef: manifestDef}) {
      let bundles = [];
      const files = new Map();

      const createBundle = async (resolvedSegment, prefix) => {
        const bundle = await this.bundle(resolvedSegment, prefix);
        for (const [path, content] of bundle.files) {
          files.set(path, content);
        }
        bundles = bundles.concat(bundle.bundles);
        return bundle.entry;
      };

      const entryBundle = await createBundle(resolvedEntry);

      const bundleBuddyStats = this.graph.getBundleBuddyStats(this.entries);
      files.set('bundlebuddy.json', {
        kind: 'stats',
        content: JSON.stringify(bundleBuddyStats, null, '  ')});

      if (manifestDef !== undefined) {
        const newManifest = await this.deriveManifest(
        manifestDef,
        entryBundle,
        createBundle);

        files.set('package.json', {
          kind: 'manifest',
          content: JSON.stringify(newManifest, undefined, '  ')});
      }

      return {
        files: files,
        bundles: bundles,
        entry: entryBundle};
    }

    async deriveManifest(manifestDef, entryBundle, createBundle) {
      const manifest = manifestDef.manifest;

      const newManifest = Object.assign({}, ___R$romejs$codec$js$manifest$convert_ts$convertManifestToJSON(manifest), {
        main: entryBundle.js.path});

      const project = this.master.projectManager.findProjectExisting(
      manifestDef.folder);
      if (project !== undefined) {
        if (newManifest.name === undefined) {
          newManifest.name = project.config.name;
        }
      }

      if (manifest.files !== undefined) {}

      const bin = manifest.bin;
      if (bin !== undefined) {
        const newBin = {};
        newManifest.bin = newBin;

        const binConsumer = manifestDef.consumer.get('bin');
        const isBinShorthand = typeof binConsumer.asUnknown() === 'string';

        for (const [binName, relative] of manifest.bin) {
          const pointer = (isBinShorthand ? binConsumer : binConsumer.get(binName)).getDiagnosticPointer('inner-value');

          const absolute = await this.master.resolver.resolveAssert(Object.assign({
            origin: manifestDef.folder,
            source: ___R$romejs$path$index_ts$createUnknownFilePath(relative).toExplicitRelative()}, this.config.resolver), {
            pointer: pointer});

          const res = await createBundle(absolute.path, 'bin/' + binName);
          newBin[binName] = res.js.path;
        }
      }

      delete newManifest.type;

      return newManifest;
    }

    async bundle(resolvedEntry, rawPrefix) {
      const {reporter: reporter} = this;

      reporter.info('Bundling <filelink emphasis target="' + resolvedEntry.join() + '" />');

      const req = this.createBundleRequest(resolvedEntry);
      const res = await req.bundle();

      const processor = new ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default({origins: []});
      processor.addDiagnostics(res.diagnostics);
      processor.maybeThrowDiagnosticsError();

      if (res.cached) {
        reporter.warn('Bundle was built completely from cache');
      }

      const serialMap = JSON.stringify(res.map);

      const prefix = rawPrefix === undefined ? '' : rawPrefix + '/';
      const jsPath = prefix + 'index.js';
      const mapPath = jsPath + '.map';

      const files = new Map();
      files.set(jsPath, {
        kind: 'entry',
        content: res.content});
      files.set(mapPath, {
        kind: 'sourcemap',
        content: serialMap});

      for (const [relative, buffer] of res.assets) {
        files.set(relative, {
          kind: 'asset',
          content: buffer});
      }

      const bundle = {
        js: {
          path: jsPath,
          content: res.content},
        sourceMap: {
          path: mapPath,
          map: res.map,
          content: serialMap}};
      return {
        entry: bundle,
        bundles: [bundle],
        files: files};
    }

    async symbolicate(resolvedEntry, frame) {
      if (frame.lineNumber === undefined) {
        return undefined;
      }

      const {reporter: reporter} = this;

      reporter.info('Bundling <filelink emphasis target="' + resolvedEntry.join() + '" /> for symbolication');

      const req = this.createBundleRequest(resolvedEntry);
      const res = await req.bundle();

      if (res.cached) {
        reporter.warn('In-memory source map was built completely from cache');
      }

      const map = res.inMemorySourceMap;

      const moduleIndex = ___R$$priv$romejs$core$master$bundler$Bundler_ts$greatestLowerBound(
      map,
      ___R$romejs$ob1$index_ts$get1(frame.lineNumber),
      (target, candidate) => target - ___R$romejs$ob1$index_ts$get1(candidate.firstLine));
      if (moduleIndex == null) {
        return undefined;
      }
      const module = map[moduleIndex];

      const pos = ___R$$priv$romejs$core$master$bundler$Bundler_ts$findOriginalPos(frame, module);
      if (!pos) {
        return undefined;
      }

      return {
        file: module.path,
        lineNumber: pos.line,
        column: pos.column};
    }
  }

  function ___R$$priv$romejs$core$master$bundler$Bundler_ts$findOriginalPos(frame, module) {
    if (module.map === undefined ||
    frame.lineNumber === undefined ||
    frame.column === undefined) {
      return undefined;
    }

    const generatedPosInModule = {
      line: ___R$romejs$ob1$index_ts$add(___R$romejs$ob1$index_ts$sub(frame.lineNumber, module.firstLine), 1),
      column: frame.column};
    const mappingIndex = ___R$$priv$romejs$core$master$bundler$Bundler_ts$greatestLowerBound(
    module.map,
    generatedPosInModule,
    (target, candidate) => {
      if (target.line === candidate.generated.line) {
        return ___R$romejs$ob1$index_ts$get0(___R$romejs$ob1$index_ts$sub(target.column, candidate.generated.column));
      } else {
        return ___R$romejs$ob1$index_ts$get1(___R$romejs$ob1$index_ts$sub(target.line, candidate.generated.line));
      }
    });
    if (mappingIndex === undefined) {
      return undefined;
    }

    const mapping = module.map[mappingIndex];
    if (!mapping.original) {
      return undefined;
    }

    return {
      line: mapping.original.line,
      column: mapping.original.column};
  }

  function ___R$$priv$romejs$core$master$bundler$Bundler_ts$greatestLowerBound(elements, target, comparator) {
    let first = 0;
    let it = 0;
    let count = elements.length;
    let step;
    while (count > 0) {
      it = first;
      step = Math.floor(count / 2);
      it = it + step;
      if (comparator(target, elements[it]) >= 0) {
        first = ++it;
        count = count - (step + 1);
      } else {
        count = step;
      }
    }
    if (first > 0) {
      return first - 1;
    }
  }

  // romejs/core/master/commands/run.ts


  const ___R$romejs$core$master$commands$run_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.PROJECT_MANAGEMENT,
    description: 'TODO',

    async default(req) {
      const {args: args} = req.query;
      const {flags: flags} = req.client;
      const {master: master} = req;
      req.expectArgumentLength(1);

      async function executeCode(path) {
        const bundler = ___R$romejs$core$master$bundler$Bundler_ts$default.createFromMasterRequest(req);
        const {entry: entry} = await bundler.bundle(path);
        return {
          type: 'executeCode',
          filename: path.join(),
          code: entry.js.content,
          map: entry.sourceMap.map};
      }

      const project = await master.projectManager.findProject(flags.cwd);

      const target = args[0];
      const resolved = await master.resolver.resolveEntry(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: flags.cwd,
        source: ___R$romejs$path$index_ts$createRelativeFilePath(target)}));
      if (resolved.type === 'FOUND') {
        return executeCode(resolved.path);
      }

      if (project !== undefined) {
        for (const {manifest: manifest, folder: folder} of project.packages.values()) {
          const relative = manifest.bin.get(target);
          if (relative === undefined) {
            continue;
          }

          const resolved = await master.resolver.resolveEntryAssertPath(Object.assign({}, req.getResolverOptionsFromFlags(), {
            origin: folder,
            platform: 'node',
            source: ___R$romejs$path$index_ts$createRelativeFilePath(relative)}));

          return executeCode(resolved);
        }
      }

      throw new Error('Failed to find "' + target + '"');
    }});

  // romejs/core/master/commands/publish.ts

  const ___R$romejs$core$master$commands$publish_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.PROJECT_MANAGEMENT,
    description: 'TODO',

    async default(req) {
      req.expectArgumentLength(1);
    }});

  // romejs/core/master/commands/status.ts


  const ___R$romejs$core$master$commands$status_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'dump memory and process info of master and workers',

    async default({master: master}) {
      const workers = await Promise.all(
      master.workerManager.getWorkers().map(
      async worker => {
        const workerStatus = await worker.bridge.status.call();

        return {
          astCacheSize: workerStatus.astCacheSize,
          heapTotal: workerStatus.memoryUsage.heapTotal,
          pid: workerStatus.pid,
          uptime: workerStatus.uptime,
          ownedBytes: worker.byteCount,
          ownedFileCount: worker.fileCount};
      }));

      const {heapTotal: heapTotal} = process.memoryUsage();
      return {
        master: {
          heapTotal: heapTotal,
          pid: process.pid,
          uptime: process.uptime()},
        workers: workers,
        projects: master.projectManager.getProjects().map(project => {
          return {
            id: project.id};
        })};
    }});

  // romejs/core/master/commands/stop.ts

  const ___R$romejs$core$master$commands$stop_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.PROCESS_MANAGEMENT,
    description: 'stop daemon',

    async default({master: master}) {
      master.end();
    }});

  // romejs/codec-websocket/types.ts


  const ___R$romejs$codec$websocket$types_ts$OPCODES = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    TERMINATE: 8,
    PING: 9,
    PONG: 10};

  const ___R$romejs$codec$websocket$types_ts$GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';

  // romejs/codec-websocket/frame.ts

  const ___R$$priv$romejs$codec$websocket$frame_ts$crypto = require('crypto');
  function ___R$romejs$codec$websocket$frame_ts$isCompleteFrame(frame) {
    return Buffer.byteLength(frame.payload) >= frame.payloadLength;
  }

  function ___R$romejs$codec$websocket$frame_ts$unmaskPayload(payload, mask, offset) {
    if (mask === undefined) {
      return payload;
    }

    for (let i = 0; i < payload.length; i++) {
      payload[i] ^= mask[offset + i & 3];
    }

    return payload;
  }

  function ___R$romejs$codec$websocket$frame_ts$buildFrame(opts, shouldMask) {
    const {opcode: opcode, fin: fin, data: data} = opts;

    let offset = shouldMask ? 6 : 2;
    let dataLength = data.length;

    if (dataLength >= 65536) {
      offset += 8;
      dataLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      dataLength = 126;
    }

    const head = Buffer.allocUnsafe(offset);

    head[0] = fin ? opcode | 128 : opcode;
    head[1] = dataLength;

    if (dataLength === 126) {
      head.writeUInt16BE(data.length, 2);
    } else if (dataLength === 127) {
      head.writeUInt32BE(0, 2);
      head.writeUInt32BE(data.length, 6);
    }

    if (shouldMask) {
      const mask = ___R$$priv$romejs$codec$websocket$frame_ts$crypto.randomBytes(4);
      head[1] |= 128;
      head[offset - 4] = mask[0];
      head[offset - 3] = mask[1];
      head[offset - 2] = mask[2];
      head[offset - 1] = mask[3];

      const masked = Buffer.alloc(dataLength);
      for (let i = 0; i < dataLength; ++i) {
        masked[i] = data[i] ^ mask[i & 3];
      }

      return Buffer.concat([head, masked]);
    } else {
      return Buffer.concat([head, data]);
    }
  }

  function ___R$romejs$codec$websocket$frame_ts$parseFrame(buffer) {
    const firstByte = buffer.readUInt8(0);
    const isFinalFrame = Boolean(firstByte >>> 7 & 1);
    const opcode = firstByte & 15;

    const [reserved1, reserved2, reserved3] = [(firstByte >>> 6 & 1) === 1, (firstByte >>> 5 & 1) === 1, (firstByte >>> 4 & 1) === 1];
    reserved1;
    reserved2;
    reserved3;

    const secondByte = buffer.readUInt8(1);
    const isMasked = Boolean(secondByte >>> 7 & 1);

    let currentOffset = 2;
    let payloadLength = secondByte & 127;
    if (payloadLength > 125) {
      if (payloadLength === 126) {
        payloadLength = buffer.readUInt16BE(currentOffset);
        currentOffset += 2;
      } else if (payloadLength === 127) {
        const leftPart = buffer.readUInt32BE(currentOffset);
        currentOffset += 4;

        if (leftPart >= Number.MAX_SAFE_INTEGER) {
          throw new Error('Unsupported WebSocket frame: payload length > 2^53 - 1');
        }

        const rightPart = buffer.readUInt32BE(currentOffset);
        currentOffset += 4;

        payloadLength = leftPart * Math.pow(2, 32) + rightPart;
      } else {
        throw new Error('Unknown payload length');
      }
    }

    let mask;
    if (isMasked) {
      mask = buffer.slice(currentOffset, currentOffset + 4);
      currentOffset += 4;
    }

    let payload = ___R$romejs$codec$websocket$frame_ts$unmaskPayload(buffer.slice(currentOffset), mask, 0);

    return {
      fin: isFinalFrame,
      opcode: opcode,
      mask: mask,
      payload: payload,
      payloadLength: payloadLength};
  }

  // romejs/codec-websocket/index.ts

  const ___R$$priv$romejs$codec$websocket$index_ts$crypto = require('crypto');
  const ___R$$priv$romejs$codec$websocket$index_ts$url = require('url');
  const ___R$$priv$romejs$codec$websocket$index_ts$http = require('http');
  const ___R$$priv$romejs$codec$websocket$index_ts$net = require('net');
  function ___R$romejs$codec$websocket$index_ts$createKey(key) {
    return ___R$$priv$romejs$codec$websocket$index_ts$crypto.createHash('sha1').update('' + key + ___R$romejs$codec$websocket$types_ts$GUID).digest('base64');
  }

  class ___R$romejs$codec$websocket$index_ts$WebSocketInterface {
    constructor(type, socket, reporter) {
      this.unfinishedFrame = undefined;

      this.incompleteFrame = undefined;

      this.reporter = reporter;
      this.socket = socket;
      this.alive = true;
      this.type = type;

      this.completeFrameEvent = new ___R$romejs$events$Event_ts$default({name: 'WebSocketInterface.message'});
      this.errorEvent = new ___R$romejs$events$Event_ts$default({name: 'WebSocketInterface.error'});
      this.endEvent = new ___R$romejs$events$Event_ts$default({name: 'WebSocketInterface.end', serial: true});

      socket.on('data', buff => {
        this.addBuffer(buff);
      });

      socket.on('error', err => {
        if (err.code === 'ECONNRESET') {
          this.endEvent.send();
        } else {
          this.errorEvent.send(err);
        }
      });

      socket.on('close', () => {
        this.end();
      });
    }

    end() {
      if (!this.alive) {
        return;
      }

      this.alive = false;
      this.endEvent.send();
      this.socket.end();
    }

    send(buff) {
      if (typeof buff === 'string') {
        this.sendFrame({
          opcode: ___R$romejs$codec$websocket$types_ts$OPCODES.TEXT,
          fin: true,
          data: Buffer.from(buff)});
      } else if (buff instanceof Buffer) {
        this.sendFrame({
          opcode: ___R$romejs$codec$websocket$types_ts$OPCODES.BINARY,
          fin: true,
          data: buff});
      } else {
        throw new Error('Don\'t know how to send this');
      }
    }

    sendJSON(val) {
      this.send(String(JSON.stringify(val)));
    }

    sendFrame(frameOpts) {
      if (this.reporter !== undefined) {
        this.reporter.info('Sending frame', {
          fin: frameOpts.fin,
          opcode: frameOpts.opcode,
          msg: frameOpts.data});
      }
      this.socket.write(___R$romejs$codec$websocket$frame_ts$buildFrame(frameOpts, this.type === 'client'));
    }

    completeFrame(frame) {
      const {unfinishedFrame: unfinishedFrame} = this;
      if (unfinishedFrame !== undefined) {
        if (frame.opcode === ___R$romejs$codec$websocket$types_ts$OPCODES.CONTINUATION) {
          unfinishedFrame.payload = Buffer.concat([unfinishedFrame.payload, ___R$romejs$codec$websocket$frame_ts$unmaskPayload(
          frame.payload,
          unfinishedFrame.mask,
          unfinishedFrame.payload.length)]);

          if (frame.fin) {
            this.unfinishedFrame = undefined;
            this.completeFrame(unfinishedFrame);
          }
          return undefined;
        } else {
          this.unfinishedFrame = undefined;
        }
      }

      if (frame.fin) {
        if (frame.opcode === ___R$romejs$codec$websocket$types_ts$OPCODES.PING) {
          this.sendFrame({
            opcode: ___R$romejs$codec$websocket$types_ts$OPCODES.PONG,
            fin: true,
            data: frame.payload});
        } else {
          let excess;
          if (frame.payload.length > frame.payloadLength) {
            excess = frame.payload.slice(frame.payloadLength);
            frame.payload = frame.payload.slice(0, frame.payloadLength);
          }

          if (this.reporter !== undefined) {
            this.reporter.info('Received complete frame', {
              opcode: frame.opcode,
              length: frame.payloadLength,
              msg: frame.payload});
          }

          this.completeFrameEvent.send(frame);

          if (excess !== undefined) {
            this.addBuffer(excess);
          }
        }
      } else {
        this.unfinishedFrame = frame;
      }
    }

    addBufferToIncompleteFrame(incompleteFrame, buff) {
      incompleteFrame.payload = Buffer.concat([incompleteFrame.payload, ___R$romejs$codec$websocket$frame_ts$unmaskPayload(buff, incompleteFrame.mask, incompleteFrame.payload.length)]);

      if (___R$romejs$codec$websocket$frame_ts$isCompleteFrame(incompleteFrame)) {
        this.incompleteFrame = undefined;
        this.completeFrame(incompleteFrame);
      }
    }

    addBuffer(buff) {
      const {incompleteFrame: incompleteFrame} = this;
      if (incompleteFrame !== undefined) {
        this.addBufferToIncompleteFrame(incompleteFrame, buff);
        return undefined;
      }

      const frame = ___R$romejs$codec$websocket$frame_ts$parseFrame(buff);

      if (___R$romejs$codec$websocket$frame_ts$isCompleteFrame(frame)) {
        this.completeFrame(frame);
      } else {
        this.incompleteFrame = frame;
      }
    }
  }

  async function ___R$romejs$codec$websocket$index_ts$createClient(rawUrl) {
    const parts = ___R$$priv$romejs$codec$websocket$index_ts$url.parse(rawUrl);

    return new Promise((resolve, reject) => {
      const key = ___R$$priv$romejs$codec$websocket$index_ts$crypto.randomBytes(16).toString('base64');
      const digest = ___R$romejs$codec$websocket$index_ts$createKey(key);

      const req = ___R$$priv$romejs$codec$websocket$index_ts$http.request({
        hostname: parts.hostname,
        port: parts.port,
        path: parts.path,
        method: 'GET',
        headers: {
          Connection: 'Upgrade',
          Upgrade: 'websocket',
          'Sec-WebSocket-Key': key,
          'Sec-WebSocket-Version': '13'}});

      req.on('response', res => {
        if (res.statusCode >= 400) {
          process.stderr.write('Unexpected HTTP code: ' + res.statusCode + '\n');
          res.pipe(process.stderr);
        } else {
          res.pipe(process.stderr);
        }
      });

      req.on('upgrade', (res, socket, head) => {
        if (res.headers['sec-websocket-accept'] !== digest) {
          res.end();
          socket.end();
          reject(
          new Error('Digest mismatch ' + digest + ' !== ' + res.headers['sec-websocket-accept']));
          return undefined;
        }

        const client = new ___R$romejs$codec$websocket$index_ts$WebSocketInterface('client', socket);

        head;
        resolve(client);
      });

      req.on('error', err => {
        reject(err);
      });

      req.end();
    });
  }

  // romejs/codec-url/index.ts

  const ___R$$priv$romejs$codec$url$index_ts$url = require('url');

  function ___R$romejs$codec$url$index_ts$consumeUrl(rawUrl) {
    const parts = ___R$$priv$romejs$codec$url$index_ts$url.parse(rawUrl, true);

    const query = ___R$romejs$consume$index_ts$consumeUnknown(Object.assign({}, parts.query));

    const path = ___R$romejs$consume$index_ts$consume({
      value: parts.pathname,
      context: {
        getDiagnosticPointer() {
          return {
            language: 'url',
            mtime: undefined,
            sourceText: rawUrl,
            filename: 'url',
            start: {
              index: ___R$romejs$ob1$index_ts$number0,
              line: ___R$romejs$ob1$index_ts$number1,
              column: ___R$romejs$ob1$index_ts$number0},
            end: {
              index: ___R$romejs$ob1$index_ts$coerce0(rawUrl.length - 1),
              line: ___R$romejs$ob1$index_ts$number1,
              column: ___R$romejs$ob1$index_ts$coerce0(rawUrl.length - 1)}};
        }}});

    return {query: query, path: path};
  }

  // romejs/core/master/web/WebRequest.ts

  const ___R$$priv$romejs$core$master$web$WebRequest_ts$http = require('http');
  const ___R$$priv$romejs$core$master$web$WebRequest_ts$waitForever = new Promise(() => {});

  const ___R$$priv$romejs$core$master$web$WebRequest_ts$CACHED = ___R$romejs$path$index_ts$TEMP_PATH.append('fb4a-rome-test/index.js');

  function ___R$romejs$core$master$web$WebRequest_ts$stripBundleSuffix(pathname) {
    return ___R$romejs$string$utils$removePrefix_ts$removePrefix(___R$romejs$string$utils$removeSuffix_ts$removeSuffix(pathname, '.bundle'), '/');
  }

  class ___R$romejs$core$master$web$WebRequest_ts$default {
    constructor(server, req, res) {
      this.req = req;
      this.res = res;
      this.server = server;
      this.reporter = server.reporter;
      this.masterRequest = server.masterRequest;
      this.master = server.master;

      const reqUrl = req.url;
      if (reqUrl === undefined) {
        throw new Error('req.url should not be undefined');
      }
      this.url = ___R$romejs$codec$url$index_ts$consumeUrl(reqUrl);
    }

    loadRawBody() {
      const {req: req} = this;

      req.setEncoding('utf8');
      let rawBody = '';

      return new Promise(resolve => {
        req.on('data', chunk => {
          rawBody += chunk;
        });

        req.on('end', () => {
          resolve(rawBody);
        });
      });
    }

    async dispatch() {
      const {res: res} = this;

      try {
        const rawBody = await this.loadRawBody();
        await this.dispatchWithBody(rawBody);
        res.end();
      } catch (err) {
        res.writeHead(500, {'Content-Type': 'text/plain'});

        let diagnostics = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
        if (diagnostics === undefined) {
          diagnostics = [___R$romejs$diagnostics$derive_ts$deriveDiagnosticFromError({category: 'http-server', error: err})];
        }

        try {
          const printer = this.masterRequest.createDiagnosticsPrinter({
            category: 'WebRequest'});
          printer.addDiagnostics(diagnostics);
          await printer.print();
        } catch (err) {
          this.reporter.warn('Failed trying to print diagnostics');
          this.reporter.error(err.stack);
        }

        res.end('Diagnostics available, see console');
      }
    }

    async dispatchWithBody(body) {
      const {res: res} = this;
      const pathname = this.url.path.asString();

      switch (pathname) {
        case '/favicon.ico':
          res.end('');
          break;

        case '/__rome__/websocket':
          return this.handleFrontendWebsocket();

        case '/__rome__/script.js':
          return this.handleFrontendScript();

        case '/__rome__':
          res.writeHead(200, {'Content-Type': 'text/html'});
          res.end('\n          <!doctype html>\n          <html>\n            <head>\n              <meta charset="utf-8"/>\n              <title>Rome</title>\n              <link rel="stylesheet" href="https://meyerweb.com/eric/tools/css/reset/reset.css">\n            </head>\n            <body>\n              <div id="app"></div>\n              <script src="/__rome__/script.js"></script>\n            </body>\n          </html>\n        ');
          break;

        case '/hot':
          return this.handleDeviceWebsocket();

        default:
          return this.handleWildcard(pathname);}
    }

    async handleWildcard(pathname) {
      const {req: req, res: res} = this;

      if (pathname.endsWith('.bundle')) {
        const handled = await this.handleBundleRequest();
        if (handled) {
          return;
        }
      }

      const project = await this.masterRequest.assertClientCwdProject();
      if (project.config.develop.serveStatic) {
        const handled = await this.handlePossibleStatic(pathname, project);
        if (handled) {
          return;
        }
      }

      this.reporter.error('Unknown request for', req.url);
      res.writeHead(404);
      res.end('Not found');
    }

    async handlePossibleStatic(pathname, project) {
      const possibleStaticPath = await this.server.pathnameToAbsolutePath(
      pathname);

      if (possibleStaticPath !== undefined &&
      (await this.master.memoryFs.existsHard(possibleStaticPath))) {
        return true;
      }

      return false;
    }

    async handleFrontendScript() {
      const {res: res} = this;
      res.writeHead(200, {'Content-Type': 'application/javascript'});

      const bundler = new ___R$romejs$core$master$bundler$Bundler_ts$default(this.masterRequest, this.masterRequest.reporter, {
        inlineSourceMap: false,
        cwd: this.masterRequest.client.flags.cwd,
        resolver: {
          platform: 'web'}});
      const resolved = await this.master.resolver.resolveEntryAssertPath({
        origin: this.masterRequest.client.flags.cwd,
        source: ___R$romejs$path$index_ts$createUnknownFilePath('@romejs-web/frontend')});
      const bundle = await bundler.bundle(resolved);
      res.end(bundle.entry.js);
    }

    negotiateWebsocket() {
      const {req: req} = this;

      const digest = ___R$romejs$codec$websocket$index_ts$createKey(String(req.headers['sec-websocket-key']));

      const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', 'Sec-WebSocket-Protocol: rome', 'Sec-WebSocket-Accept: ' + digest, '', ''];

      req.socket.write(headers.join('\r\n'));
    }

    async handleDeviceWebsocketMessage(socket, data) {
      switch (data.type) {
        case 'log':
          return this.server.printConsoleLog(data);

        case 'log-opt-in':
          return;

        case 'register-entrypoints':
          return;

        default:
          console.log('UNKNOWN MESSAGE', data);}
    }

    async handleDeviceWebsocket() {
      const {req: req} = this;
      this.negotiateWebsocket();

      const socket = new ___R$romejs$codec$websocket$index_ts$WebSocketInterface('server', req.socket);
      this.server.deviceWebsockets.add(socket);

      req.socket.on('error', err => {
        console.log(err.stack);
      });

      this.reporter.success('Device websocket client connected');

      socket.completeFrameEvent.subscribe(frame => {
        const text = frame.payload.toString();
        try {
          const json = JSON.parse(text);
          this.handleDeviceWebsocketMessage(socket, json);
        } catch (err) {
          if (err instanceof SyntaxError) {
            console.log('UNKNOWN FRAME', text);
            return;
          } else {
            throw err;
          }
        }
      });

      socket.errorEvent.subscribe(err => {
        console.log(err);
      });

      socket.endEvent.subscribe(() => {
        console.log('END');
        this.server.deviceWebsockets.delete(socket);
      });

      await ___R$$priv$romejs$core$master$web$WebRequest_ts$waitForever;
    }

    async handleFrontendWebsocket() {
      const {req: req} = this;
      this.negotiateWebsocket();

      const socket = new ___R$romejs$codec$websocket$index_ts$WebSocketInterface('server', req.socket);
      const bridge = ___R$romejs$events$bridgeCreators_ts$createBridgeFromWebSocketInterface(___R$romejs$core$common$bridges$WebBridge_ts$default, socket, {
        type: 'client'});
      this.server.frontendWebsocketBridges.add(bridge);

      req.socket.on('close', () => {
        this.server.frontendWebsocketBridges.delete(bridge);
      });

      await bridge.handshake();

      this.reporter.success('Frontend websocket client connected');

      this.server.sendRequests(bridge);

      await ___R$$priv$romejs$core$master$web$WebRequest_ts$waitForever;
    }

    async handleBundleRequest() {
      const {res: res} = this;

      let content;
      if (false) {
        content = await ___R$romejs$fs$index_ts$readFileText(___R$$priv$romejs$core$master$web$WebRequest_ts$CACHED);
      } else {
        const {bundler: bundler, path: path} = await this.server.getBundler(this.url);
        const bundle = await bundler.bundle(path);
        content = bundle.entry.js.content;

        await ___R$romejs$fs$index_ts$writeFile(___R$$priv$romejs$core$master$web$WebRequest_ts$CACHED, content);
        this.reporter.logAll('Cached to <filelink target="' + ___R$$priv$romejs$core$master$web$WebRequest_ts$CACHED.join() + '"/>');
      }

      res.writeHead(200, {'Content-Type': 'application/javascript'});
      res.end(content);
      return true;
    }
  }

  // romejs/core/master/web/index.ts

  const ___R$$priv$romejs$core$master$web$index_ts$http = require('http');

  class ___R$romejs$core$master$web$index_ts$WebServer {
    constructor(req) {
      const {master: master} = req;

      this.masterRequest = req;
      this.reporter = req.reporter;
      this.master = master;

      this.bundlerCache = new Map();

      this.savingRequests = false;
      this.clientRequestHistory = new Map();
      this.clientHistory = new Map();

      this.deviceWebsockets = new Set();
      this.frontendWebsocketBridges = new Set();

      this.server = ___R$$priv$romejs$core$master$web$index_ts$http.createServer((req, res) => {
        const webRequest = new ___R$romejs$core$master$web$WebRequest_ts$default(this, req, res);
        webRequest.dispatch();
      });

      master.clientStartEvent.subscribe(client => {
        if (!this.savingRequests) {
          return;
        }

        const data = {
          id: client.id,
          flags: client.flags,
          startTime: Date.now(),
          endTime: undefined,
          stdout: ''};
        this.clientHistory.set(client.id, data);
        this.refreshRequests();

        const reporterStream = {
          type: 'all',
          format: 'ansi',
          columns: 100,
          write(chunk) {
            data.stdout += chunk;
          }};

        client.reporter.addStream(reporterStream);
        master.connectedReporters.addStream(reporterStream);

        client.bridge.endEvent.subscribe(() => {
          master.connectedReporters.removeStream(reporterStream);

          data.endTime = Date.now();
          this.refreshRequests();
        });
      });

      master.requestStartEvent.subscribe(request => {
        if (!this.savingRequests) {
          return;
        }

        const data = {
          id: request.id,
          client: request.client.id,
          query: request.query,
          markers: [],
          response: undefined,
          startTime: Date.now(),
          endTime: undefined};
        this.clientRequestHistory.set(request.id, data);
        this.refreshRequests();

        request.markerEvent.subscribe(marker => {
          data.markers.push(marker);
          this.refreshRequests();
        });

        request.endEvent.subscribe(response => {
          data.response = response;
          data.endTime = Date.now();
          this.refreshRequests();
        });
      });
    }

    sendRequests(bridge) {
      bridge.requests.send({
        requests: Array.from(this.clientRequestHistory.values()),
        clients: Array.from(this.clientHistory.values())});
    }

    refreshRequests() {
      for (const bridge of this.frontendWebsocketBridges) {
        this.sendRequests(bridge);
      }
    }

    close() {
      this.server.close();
    }

    listen(port) {
      this.server.listen(port);

      const url = 'http://localhost:' + String(port);
      this.reporter.success('Listening on <hyperlink emphasis>' + url + '</hyperlink>');
      this.reporter.info('Web console available at <hyperlink emphasis>' + url + '/__rome__</hyperlink>');
    }

    printConsoleLog(msg) {
      const {reporter: reporter} = this.masterRequest;

      let buf = msg.data.map(arg => {
        if (typeof arg === 'string') {
          return ___R$romejs$string$markup$escape_ts$escapeMarkup(arg);
        } else {
          return ___R$romejs$pretty$format$index_ts$default(arg, {escapeMarkup: true, color: true});
        }
      }).join(' ');

      switch (msg.level) {
        case 'info':
          reporter.info(buf);
          break;

        case 'warn':
          reporter.warn(buf);
          break;

        case 'log':
        case 'trace':
          reporter.verboseForce(buf);
          break;

        case 'group':
        case 'groupCollapsed':
        case 'groupEnd':
          reporter.logAll('TODO');}
    }

    async pathnameToAbsolutePath(pathname) {
      const project = await this.masterRequest.assertClientCwdProject();
      const possibleStaticPath = project.folder.append(pathname);

      if (possibleStaticPath.isRelativeTo(project.folder)) {
        return possibleStaticPath;
      }
    }

    sendToAllDeviceWebsockets(msg) {
      const text = JSON.stringify(msg);
      for (const socket of this.deviceWebsockets) {
        socket.send(text);
      }
    }

    async getBundler(url) {
      const pathname = ___R$romejs$core$master$web$WebRequest_ts$stripBundleSuffix(String(url.path.asString()));

      const absolute = await this.pathnameToAbsolutePath(pathname);
      if (absolute === undefined) {
        throw new Error('Pathname is attempting to escalate out of cwd');
      }

      const pathPointer = url.path.getDiagnosticPointer();
      const path = await this.master.resolver.resolveEntryAssertPath(
      {
        origin: this.masterRequest.client.flags.cwd,
        source: absolute},
      pathPointer === undefined ? undefined : {pointer: pathPointer});

      const platform = url.query.get('platform').asStringSetOrVoid(___R$romejs$core$common$types$platform_ts$PLATFORMS);
      const cacheKey = JSON.stringify({
        platform: platform});

      const cached = this.bundlerCache.get(cacheKey);
      if (cached !== undefined) {
        return {bundler: cached, path: path};
      }

      const bundlerConfig = this.masterRequest.getBundlerConfigFromFlags(
      {
        platform: platform});

      const bundler = new ___R$romejs$core$master$bundler$Bundler_ts$default(this.masterRequest, this.masterRequest.reporter, bundlerConfig);

      bundler.graph.watch(async ({path: path}) => {
        this.sendToAllDeviceWebsockets({
          type: 'update-start',
          body: {
            isInitialUpdate: false}});

        const {code: code} = await bundler.compile(path, true);

        this.sendToAllDeviceWebsockets({
          type: 'update',
          body: {
            isInitialUpdate: false,
            revisionId: '',
            added: [],
            modified: [{
              module: [0, code],
              sourceMappingURL: '',
              sourceURL: ''}],
            deleted: []}});

        this.sendToAllDeviceWebsockets({
          type: 'update-done'});
      });

      this.bundlerCache.set(cacheKey, bundler);

      return {bundler: bundler, path: path};
    }
  }

  // romejs/core/master/commands/develop.ts


  const ___R$$priv$romejs$core$master$commands$develop_ts$DEFAULT_PORT = 8081;
  const ___R$romejs$core$master$commands$develop_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
    description: 'start a web server',

    defineFlags(c) {
      return {
        port: c.get('port').asNumber(___R$$priv$romejs$core$master$commands$develop_ts$DEFAULT_PORT)};
    },

    async default(req, flags) {
      await req.master.projectManager.findProject(req.client.flags.cwd);

      const web = new ___R$romejs$core$master$web$index_ts$WebServer(req);
      web.listen(flags.port);

      req.endEvent.subscribe(() => {
        web.close();
      });

      await new Promise(() => {});
    }});

  // romejs/core/master/commands/config.ts

  const ___R$romejs$core$master$commands$config_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.PROJECT_MANAGEMENT,
    description: '',

    async default(req) {
      const {reporter: reporter} = req;
      req.expectArgumentLength(2, 3);

      const project = await req.assertClientCwdProject();

      let keyParts;
      let value;

      const [action] = req.query.args;
      switch (action) {
        case 'enable':
          {
            req.expectArgumentLength(2);
            keyParts = req.query.args[1];
            value = true;
            break;
          }

        case 'disable':
          {
            req.expectArgumentLength(2);
            keyParts = req.query.args[1];
            value = false;
            break;
          }

        case 'enable-category':
          {
            req.expectArgumentLength(2);
            const category = req.query.args[1];
            keyParts = category + '.enabled';
            value = true;
            break;
          }

        case 'disable-category':
          {
            req.expectArgumentLength(2);
            const category = req.query.args[1];
            keyParts = category + '.enabled';
            value = false;
            break;
          }

        case 'set':
          {
            req.expectArgumentLength(3);
            [keyParts, value] = req.query.args;
            break;
          }

        default:
          throw req.throwDiagnosticFlagError('Unknown action ' + action, {
            type: 'arg',
            key: 0});}

      try {
        await ___R$romejs$project$save_ts$modifyProjectConfig(project.meta, {
          pre: meta => {
            reporter.success('Setting <emphasis>' + keyParts + '</emphasis> to <emphasis>' + JSON.stringify(
            value) + '</emphasis> in the project config <filelink emphasis target="' + meta.configPath.join() + '" />');

            if (value === 'true' || value === 'false') {
              const suggestedCommand = value === 'true' ? 'enable' : 'disable';
              reporter.warn('Value is the string <emphasis>' + value + '</emphasis> but it looks like a boolean. You probably meant to use the command:');
              reporter.command('config ' + suggestedCommand + ' ' + keyParts);
            }
          },

          modify: consumer => {
            let keyConsumer = consumer;
            for (const key of keyParts.split('.')) {
              if (!keyConsumer.exists()) {
                keyConsumer.setValue({});
              }
              keyConsumer = keyConsumer.get(key);
            }
            keyConsumer.setValue(value);
          }});
      } catch (err) {
        reporter.error(
        'Error occured while testing new project config. Your changes have not been saved.');
        throw err;
      }
    }});

  // romejs/core/master/commands/compile.ts


  const ___R$romejs$core$master$commands$compile_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
    description: 'compile a single file',

    defineFlags(c) {
      return {
        bundle: c.get('bundle').asBoolean(false)};
    },

    async default(req, commandFlags) {
      const {master: master, reporter: reporter} = req;
      const {flags: flags} = req.client;
      const {args: args} = req.query;
      req.expectArgumentLength(1);

      const resolved = await master.resolver.resolveEntryAssert(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: flags.cwd,
        source: ___R$romejs$path$index_ts$createUnknownFilePath(args[0])}), {pointer: req.getDiagnosticPointerFromFlags({type: 'arg', key: 0})});

      let res;
      if (commandFlags.bundle) {
        const bundler = ___R$romejs$core$master$bundler$Bundler_ts$default.createFromMasterRequest(req);
        res = await bundler.compile(resolved.path);
      } else {
        res = await req.requestWorkerCompile(resolved.path, 'compile');
      }

      const {code: code, diagnostics: diagnostics} = res;

      if (diagnostics.length > 0) {
        throw new ___R$romejs$diagnostics$errors_ts$DiagnosticsError('Compile diagnostics', diagnostics);
      }

      reporter.writeAll(code);
    }});

  // romejs/core/master/commands/resolve.ts

  const ___R$romejs$core$master$commands$resolve_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
    description: 'resolve a file',

    async default(req) {
      const {master: master, reporter: reporter} = req;
      const {args: args} = req.query;
      const {flags: flags} = req.client;
      req.expectArgumentLength(1, 2);

      let origin;
      let relative = '';
      let key;

      if (args.length === 2) {
        origin = flags.cwd.resolveMaybeUrl(args[0]);
        relative = args[1];
        key = 1;
      } else {
        origin = flags.cwd;
        relative = args[0];
        key = 0;
      }

      const query = Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: origin,
        source: ___R$romejs$path$index_ts$createUnknownFilePath(relative)});

      const resolved = await master.resolver.resolveEntryAssert(query, {
        pointer: req.getDiagnosticPointerFromFlags({type: 'arg', key: key})});
      const filename = resolved.ref.real.join();
      reporter.logAll(filename);
      return filename;
    }});

  // romejs/core/master/commands/analyzeDependencies.ts


  function ___R$$priv$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(obj) {
    const ___R$ = obj;
    const locless = Object.assign({}, ___R$);
    delete locless.loc;
    const {
      loc: loc} = ___R$;
    return locless;
  }
  const ___R$romejs$core$master$commands$analyzeDependencies_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
    description: 'analyze and dump the dependencies of a file',

    defineFlags(c) {
      return {
        compact: c.get('compact').asBoolean(false),
        focusSource: c.get('focusSource').asStringOrVoid()};
    },

    async default(req, commandFlags) {
      const {master: master, reporter: reporter} = req;
      const {flags: flags} = req.client;
      const {args: args} = req.query;
      req.expectArgumentLength(1);

      const filename = await master.resolver.resolveEntryAssertPath(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: flags.cwd,
        source: ___R$romejs$path$index_ts$createUnknownFilePath(args[0])}), {pointer: req.getDiagnosticPointerFromFlags({type: 'arg', key: 0})});

      let res = await req.requestWorkerAnalyzeDependencies(filename);

      const {focusSource: focusSource} = commandFlags;
      if (focusSource !== undefined) {
        res = Object.assign({}, res, {
          importFirstUsage: res.importFirstUsage.filter(dep => {
            return dep.source === focusSource;
          }),
          dependencies: res.dependencies.filter(dep => {
            return dep.source === focusSource;
          })});
      }

      if (commandFlags.compact) {
        res = Object.assign({}, res, {
          importFirstUsage: res.importFirstUsage.map(imp => {
            return ___R$$priv$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(imp);
          }),
          exports: res.exports.map(exp => {
            switch (exp.type) {
              case 'local':
                return ___R$$priv$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(exp);

              case 'external':
                return ___R$$priv$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(exp);

              case 'externalAll':
                return ___R$$priv$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(exp);}
          }),
          dependencies: res.dependencies.map(dep => {
            return Object.assign({}, ___R$$priv$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(dep), {
              names: dep.names.map(name => {
                return ___R$$priv$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(name);
              })});
          })});
      }

      reporter.inspect(res);
    }});

  // romejs/core/master/commands/parse.ts


  const ___R$romejs$core$master$commands$parse_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
    description: 'parse a single file and dump its ast',

    defineFlags(c) {
      return {
        showDespiteDiagnostics: c.get('showDespiteDiagnostics').asBoolean(false),
        compact: c.get('compact').asBoolean(true),
        sourceType: c.get('sourceType').asStringSetOrVoid(['module', 'script'])};
    },

    async default(req, commandFlags) {
      const {master: master, reporter: reporter} = req;
      const {args: args} = req.query;
      const {flags: flags} = req.client;
      req.expectArgumentLength(1);

      const filename = await master.resolver.resolveEntryAssertPath(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: flags.cwd,
        source: ___R$romejs$path$index_ts$createUnknownFilePath(args[0])}), {pointer: req.getDiagnosticPointerFromFlags({type: 'arg', key: 0})});

      const ast = await req.requestWorkerParse(filename, {
        compact: commandFlags.compact,
        sourceType: commandFlags.sourceType});

      const hasErrors = ast.diagnostics.length > 0;
      if (!hasErrors || commandFlags.showDespiteDiagnostics) {
        reporter.inspect(ast);
      }

      if (hasErrors) {
        throw new ___R$romejs$diagnostics$errors_ts$DiagnosticsError('Parsing failed', ast.diagnostics);
      }
    }});

  // romejs/core/master/commands/bundle.ts

  const ___R$romejs$core$master$commands$bundle_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.SOURCE_CODE,
    description: 'build a standalone js bundle for a package',

    async default(req, flagConsumer) {
      const {flags: flags} = req.client;
      const {args: args} = req.query;
      const {reporter: reporter} = req;
      req.expectArgumentLength(2);

      const [entryFilename, outputFolder] = args;
      const bundler = ___R$romejs$core$master$bundler$Bundler_ts$default.createFromMasterRequest(req);

      const resolution = await bundler.getResolvedEntry(entryFilename);
      const {files: outFiles, entry: entry} = await bundler.bundleManifest(resolution);

      const savedList = [];
      const dir = flags.cwd.resolve(outputFolder);
      for (const [filename, {kind: kind, content: content}] of outFiles) {
        const file = dir.append(filename);
        const loc = file.join();
        savedList.push('<filelink target="' + loc + '">' + filename + '</filelink> <filesize dim>' + Buffer.byteLength(
        content) + '</filesize> <inverse>' + kind + '</inverse>');
        await ___R$romejs$fs$index_ts$createDirectory(file.getParent(), {recursive: true});
        await ___R$romejs$fs$index_ts$writeFile(file, content);
      }

      reporter.success('Saved the following files to <filelink target="' + dir.join() + '" />');
      reporter.list(savedList);

      return {
        content: entry.js.content,
        map: entry.sourceMap.content};
    }});

  // romejs/core/master/linter/CompilerLinter.ts

  class ___R$romejs$core$master$linter$CompilerLinter_ts$default {
    constructor(req, printer) {
      this.request = req;
      this.printer = printer;
    }

    async lint() {
      const {request: request, printer: printer} = this;
      const {master: master, reporter: reporter} = request;
      const globalIgnore = [___R$romejs$path$match$parse_ts$parsePattern({input: 'node_modules'}), ___R$romejs$path$match$parse_ts$parsePattern({input: '__generated__'})];

      const files = await request.getFilesFromArgs(project => project.config.lint.ignore.concat(globalIgnore));

      const filesByWorker = await master.fileAllocator.groupFilesByWorker(files);

      const spinners = filesByWorker.map(files => {
        const spinner = reporter.progress();
        spinner.setTotal(files.length);
        return spinner;
      });

      const lintDisabledProjects = new Set();

      const startTime = Date.now();
      let totalProcessedBytes = 0;

      await Promise.all(
      filesByWorker.map(async (files, workerNum) => {
        const spinner = spinners[workerNum];

        let i = 0;
        for (const path of files) {
          i++;
          spinner.setCurrent(i);
          spinner.setText(path.join());
          totalProcessedBytes += master.memoryFs.getFileStatsAssert(path).size;

          const project = master.projectManager.findProjectExisting(path);
          if (project !== undefined && !project.config.lint.enabled) {
            if (!lintDisabledProjects.has(project)) {
              lintDisabledProjects.add(project);

              const {
                consumer: consumer,
                value: value} = master.projectManager.findProjectConfigConsumer(
              project,
              consumer => consumer.has('lint') ? consumer.get('lint').get('enabled') : undefined);

              if (value === undefined) {
                printer.addDiagnostic(Object.assign({
                  category: '',
                  message: 'Files excluded from linting as it\'s not enabled. Add `lint: {enabled: true}`'}, consumer.getDiagnosticPointer()));
              } else {
                printer.addDiagnostic(Object.assign({
                  category: '',
                  message: 'Files excluded from linting as it\'s disabled in this project config'}, value.getDiagnosticPointer('value')));
              }
            }
            continue;
          }

          const fileDiagnostics = await this.request.requestWorkerLint(
          path,
          false);
          printer.addDiagnostics(fileDiagnostics);

          spinner.tick();
        }

        spinner.setText('Done');
        spinner.pause();
      }));

      for (const spinner of spinners) {
        spinner.end();
      }

      const elapsed = Date.now() - startTime;

      printer.onBeforeFooterPrint(reporter => {
        const kbps = Math.round(totalProcessedBytes / elapsed);
        reporter.verbose('Processing speed ' + ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(kbps) + 'kbps');

        const fileCount = files.length;
        if (fileCount === 0) {
          reporter.warn('No files linted');
        } else if (fileCount === 1) {
          reporter.info('<emphasis>1</emphasis> file linted');
        } else {
          reporter.info('<emphasis>' + ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(fileCount) + '</emphasis> files linted');
        }
      });
    }
  }

  // romejs/core/master/linter/Linter.ts

  class ___R$romejs$core$master$linter$Linter_ts$default {
    constructor(req) {
      this.request = req;
    }

    async lint() {
      const {request: request} = this;
      const printer = request.createDiagnosticsPrinter({
        category: 'lint',
        message: 'Dispatched'});

      const compilerLinter = new ___R$romejs$core$master$linter$CompilerLinter_ts$default(request, printer);

      await compilerLinter.lint();

      throw printer;
    }
  }

  // romejs/core/master/commands/lint.ts

  const ___R$romejs$core$master$commands$lint_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.CODE_QUALITY,
    description: 'run lint against a set of files',

    async default(req) {
      return new Promise((resolve, reject) => {
        if (req.query.requestFlags.watch) {
          ___R$$priv$romejs$core$master$commands$lint_ts$initWatchLint(req, reject);
        } else {
          resolve(___R$$priv$romejs$core$master$commands$lint_ts$runLint(req));
        }
      });
    }});
  function ___R$$priv$romejs$core$master$commands$lint_ts$initWatchLint(req, reject) {
    const {master: master, reporter: reporter} = req;

    let queued = false;

    let running = false;

    let runAgainAfterComplete = false;

    function runWatchLint() {
      if (running) {
        runAgainAfterComplete = true;
        return undefined;
      }

      queued = false;
      running = true;
      reporter.clear();

      ___R$$priv$romejs$core$master$commands$lint_ts$runLint(req).then(() => {
        running = false;

        if (runAgainAfterComplete) {
          runAgainAfterComplete = false;
          runWatchLint();
        }
      }, reject);
    }

    const listener = master.fileChangeEvent.subscribe(() => {
      if (running) {
        runWatchLint();
        return undefined;
      }

      if (queued) {
        return undefined;
      }

      queued = true;
      setTimeout(runWatchLint, 250);
    });

    req.endEvent.subscribe(() => {
      listener.unsubscribe();
    });

    runWatchLint();
  }

  async function ___R$$priv$romejs$core$master$commands$lint_ts$runLint(req) {
    const linter = new ___R$romejs$core$master$linter$Linter_ts$default(req);
    await linter.lint();
  }

  // romejs/core/master/commands/ci.ts

  const ___R$romejs$core$master$commands$ci_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.CODE_QUALITY,
    description: 'install dependencies, run lint and tests',

    async default(req) {}});

  // romejs/core/master/testing/utils.ts

  function ___R$romejs$core$master$testing$utils_ts$sortMapKeys(map) {
    const sortedKeys = Array.from(map.keys()).sort(___R$romejs$string$utils$naturalCompare_ts$naturalCompare);
    const newMap = new Map();
    for (const key of sortedKeys) {
      const val = map.get(key);
      if (val === undefined) {
        throw new Error('Expected value');
      }
      newMap.set(key, val);
    }
    return newMap;
  }

  function ___R$romejs$core$master$testing$utils_ts$formatPercent(num) {
    const str = String(Math.floor(num));
    if (num > 80) {
      return '<green>' + str + '</green>';
    } else if (num > 40) {
      return '<yellow>' + str + '</yellow>';
    } else {
      return '<red>' + str + '</red>';
    }
  }

  function ___R$romejs$core$master$testing$utils_ts$percentInsideCoverageFolder(folder) {
    let totalFiles = 0;
    let functions = 0;
    let branches = 0;
    let lines = 0;

    const folders = [folder];
    while (folders.length > 0) {
      const folder = folders.shift();
      if (folder === undefined) {
        throw new Error('folders.length has already been validated');
      }

      for (const file of folder.files.values()) {
        totalFiles++;
        functions += file.functions.percent;
        branches += file.branches.percent;
        lines += file.lines.percent;
      }

      for (const subFolder of folder.folders.values()) {
        folders.push(subFolder);
      }
    }

    return {
      functions: totalFiles === 0 ? 100 : functions / totalFiles,
      branches: totalFiles === 0 ? 100 : branches / totalFiles,
      lines: totalFiles === 0 ? 100 : lines / totalFiles};
  }

  // romejs/core/master/testing/TestRunner.ts

  class ___R$romejs$core$master$testing$TestRunner_ts$default {
    constructor(opts) {
      this.sources = opts.sources;
      this.reporter = opts.request.reporter;
      this.master = opts.request.master;
      this.cwd = opts.request.client.flags.cwd;
      this.request = opts.request;
      this.options = opts.options;

      this.sourcesQueue = Array.from(opts.sources.entries());

      this.coverageCollector = new ___R$romejs$v8$CoverageCollector_ts$default();

      this.progress = {
        total: 0,
        started: 0,
        finished: 0};

      this.runningTests = new Map();

      this.printer = opts.request.createDiagnosticsPrinter({
        category: 'test',
        message: 'Run initiated'});
      this.printer.addDiagnostics(opts.addDiagnostics);
    }

    async runWorker({bridge: bridge, process: process, inspector: inspector}) {
      const {options: opts, sourcesQueue: sourcesQueue} = this;
      const req = this.request;
      const {flags: flags} = req.client;

      if (inspector !== undefined && opts.coverage === true) {
        await inspector.call('Profiler.enable');
        await inspector.call('Profiler.startPreciseCoverage', {
          callCount: false,

          detailed: true});
      }

      const nextTest = async () => {
        if (sourcesQueue.length === 0) {
          return undefined;
        }

        const item = sourcesQueue.pop();
        if (item === undefined) {
          throw new Error('testQueue.length was validated above');
        }
        const [filename, {path: path, code: code, sourceMap: sourceMap}] = item;

        this.coverageCollector.addSourceMap(filename, code, sourceMap);

        const removeSourceMap = ___R$romejs$v8$index_ts$sourceMapManager.addSourceMap(
        filename,
        sourceMap);

        try {
          await bridge.runTest.call({
            options: opts,
            file: req.master.projectManager.getTransportFileReference(path),
            cwd: flags.cwd.join(),
            code: code,
            sourceMap: sourceMap});
        } finally {
          removeSourceMap();
        }

        await nextTest();
      };

      try {
        await nextTest();
      } catch (err) {
        if (err instanceof ___R$romejs$events$BridgeError_ts$default) {} else {
          throw err;
        }
      } finally {
        if (inspector !== undefined) {
          if (opts.coverage) {
            if (inspector.alive) {
              const profile = await inspector.call(
              'Profiler.takePreciseCoverage');
              this.coverageCollector.addCoverage(profile.get('result').asAny());

              await inspector.call('Profiler.stopPreciseCoverage');
              await inspector.call('Profiler.disable');
            } else {}
          }

          inspector.end();
        }

        process.kill();
      }
    }

    async spawnWorker() {
      const proc = ___R$romejs$core$common$utils$fork_ts$default('test-worker', {
        stdio: 'pipe'});

      const {stdout: stdout, stderr: stderr} = proc;
      if (stdout == null || stderr == null) {
        throw new Error('stdout or stderr was undefined for a spawned Worker');
      }

      stdout.on('data', chunk => {
        process.stdout.write(chunk);
      });

      stderr.on('data', chunk => {
        const str = chunk.toString();

        if (str.startsWith('Debugger listening on ws://')) {
          return undefined;
        }

        if (str.startsWith('Debugger attached')) {
          return undefined;
        }

        process.stderr.write(chunk);
      });

      const bridge = ___R$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess(___R$romejs$core$common$bridges$TestWorkerBridge_ts$default, proc, {
        type: 'client'});
      await bridge.handshake();

      const {inspectorUrl: inspectorUrl} = await bridge.inspectorDetails.call();

      let inspector;
      if (inspectorUrl !== undefined) {
        const locInspector = new ___R$romejs$v8$InspectorClient_ts$default((await ___R$romejs$codec$websocket$index_ts$createClient(inspectorUrl)));
        inspector = locInspector;
        await locInspector.call('Debugger.enable');

        bridge.endEvent.subscribe(() => {
          locInspector.end();
        });
      }

      return {
        bridge: bridge,
        process: proc,
        inspector: inspector};
    }

    async setupWorkers() {
      const containers = [await this.spawnWorker()];

      for (const container of containers) {
        container.bridge.monitorHeartbeat(5000, async () => {
          this.handleWorkerTimeout('10 seconds', container);
        });
      }

      return containers;
    }

    async init() {
      this.workers = await this.setupWorkers();
      this.setupProgress();

      const workerContainers = this.getWorkers();

      await Promise.all(
      workerContainers.map(container => this.runWorker(container)));

      this.printTestResults();
    }

    async handleWorkerTimeout(duration, container) {
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          container.bridge.end('Test worker was unresponsive for ' + duration + '. We tried to collect some additional metadata but we timed out again trying to fetch it...');
          resolve();
        }, 3000);

        this._handleWorkerTimeout(duration, container).then(() => {
          clearTimeout(timeout);
          resolve();
        }).catch(err => {
          clearTimeout(timeout);
          if (err instanceof ___R$romejs$v8$InspectorClient_ts$InspectorClientCloseError) {
            container.bridge.end('Test worker was unresponsive for ' + duration + '. We tried to collect some additional metadata but the inspector connection closed abruptly');
            resolve();
          } else {
            reject(err);
          }
        });
      });
    }

    async _handleWorkerTimeout(duration, {bridge: bridge, inspector: inspector}) {
      if (inspector === undefined) {
        bridge.end('Test worker was unresponsive for ' + duration + '. There was no inspector connected so we were unable to capture stack frames before it was terminated.');
        return undefined;
      }

      inspector.call('Debugger.pause');

      const params = await inspector.wait('Debugger.paused');

      const frames = [];

      const callFrames = params.get('callFrames').asArray().slice(0, 10);
      for (const callFrame of callFrames) {
        const loc = callFrame.get('location');

        const resolved = ___R$romejs$v8$index_ts$sourceMapManager.resolveLocation(
        ___R$romejs$v8$utils_ts$urlToFilename(callFrame.get('url').asString()),
        ___R$romejs$ob1$index_ts$coerce0to1(loc.get('lineNumber').asZeroIndexedNumber()),
        loc.get('columnNumber').asZeroIndexedNumber());

        const name = callFrame.get('scopeChain').asArray()[0].get('name').asString().split('$').pop();

        frames.push({
          resolvedLocation: resolved.found,
          typeName: undefined,
          functionName: name,
          methodName: undefined,
          filename: resolved.filename,
          lineNumber: resolved.line,
          columnNumber: resolved.column,
          isTopLevel: false,
          isEval: false,
          isNative: false,
          isConstructor: false,
          isAsync: false});
      }

      bridge.endWithError(
      ___R$romejs$v8$errors_ts$createErrorFromStructure({
        message: 'Test worker was unresponsive for <emphasis>' + duration + '</emphasis>. Possible infinite loop. Below is a stack trace before the test was terminated.',
        frames: frames}));
    }

    getWorkers() {
      if (this.workers === undefined) {
        throw new Error('TestRunner.init has not been called yet');
      } else {
        return this.workers;
      }
    }

    refToKey(ref) {
      return ref.filename + ': ' + ref.testName;
    }

    onTestStart(container, ref, timeoutMs) {
      this.progress.started++;

      let timeout = undefined;
      if (timeoutMs !== undefined) {
        timeout = setTimeout(() => {
          this.handleWorkerTimeout(String(timeoutMs) + 'ms', container);
        }, timeoutMs);
      }

      this.runningTests.set(this.refToKey(ref), {
        ref: ref,
        timeout: timeout});
    }

    onTestFound(data, isSkipped) {
      if (isSkipped) {
        return;
      }

      data;
      this.progress.total++;
    }

    onTestFinished(ref) {
      const key = this.refToKey(ref);
      const running = this.runningTests.get(key);
      if (running === undefined) {
        throw new Error('Expected there to be a running test');
      }

      if (running.timeout !== undefined) {
        clearTimeout(running.timeout);
      }
      this.runningTests.delete(key);

      this.progress.finished++;
    }

    setupProgress() {
      const workers = this.getWorkers();

      for (let i = 0; i < workers.length; i++) {
        const container = workers[i];
        const {bridge: bridge} = container;

        const ourRunningTests = new Set();

        bridge.endEvent.subscribe(error => {
          for (const key of ourRunningTests) {
            const test = this.runningTests.get(key);
            if (test === undefined) {
              continue;
            }

            const {ref: ref} = test;
            this.onTestFinished(ref);
            this.printer.addDiagnostic(
            ___R$romejs$diagnostics$derive_ts$deriveDiagnosticFromError({
              error: error,
              category: ref.testName,
              filename: ref.filename}),
            {
              category: 'test',
              message: 'Worker died and this diagnostic was automatically generated to fail a test'});
          }
        });

        bridge.testFound.subscribe(data => {
          this.onTestFound(data.ref, data.isSkipped);
        });

        bridge.testStart.subscribe(data => {
          ourRunningTests.add(this.refToKey(data.ref));
          this.onTestStart(container, data.ref, data.timeout);
        });

        bridge.testError.subscribe(data => {
          let origin = {
            category: 'test',
            message: 'Generated from a test worker without being attached to a test'};

          const {ref: ref} = data;
          if (ref !== undefined) {
            const uid = this.master.projectManager.getUid(
            ___R$romejs$path$index_ts$createAbsoluteFilePath(ref.filename));
            origin.message = 'Generated from the file <filelink target="' + uid + '" /> and test name "' + ref.testName + '"';
            this.onTestFinished(ref);
          }

          this.printer.addDiagnostic(data.diagnostic, origin);
        });

        bridge.testSuccess.subscribe(data => {
          this.onTestFinished(data.ref);
        });
      }
    }

    printCoverageReport() {
      const {reporter: reporter, master: master} = this;

      const files = this.coverageCollector.generate();
      if (files.length === 0) {
        return undefined;
      }

      reporter.heading('Code coverage');

      const testedPackages = new Set();
      for (const {path: path} of this.sources.values()) {
        testedPackages.add(master.memoryFs.getOwnedManifest(path));
      }

      let root = {
        name: undefined,
        folders: new Map(),
        files: new Map()};

      let totalFiles = 0;

      for (const file of files) {
        const {filename: filename} = file;

        const absolute = master.projectManager.getFilePathFromUid(filename);
        if (absolute === undefined) {
          continue;
        }

        const pkg = master.memoryFs.getOwnedManifest(absolute);
        if (testedPackages.has(pkg) === false) {
          continue;
        }

        totalFiles++;

        const filenameParts = filename.split('/');
        const basename = filenameParts.pop();
        if (basename === undefined) {
          throw new Error('Should always be at least one element from a split()');
        }

        let target = root;

        for (const part of filenameParts) {
          const existingFolder = target.folders.get(part);
          if (existingFolder === undefined) {
            const newFolder = {
              name: part,
              folders: new Map(),
              files: new Map()};
            target.folders.set(part, newFolder);
            target = newFolder;
          } else {
            target = existingFolder;
          }
        }

        target.files.set(basename, file);
      }

      while (root.folders.size === 1 && root.files.size === 0) {
        const newRoot = root.folders.values().next().value;
        root = Object.assign({}, newRoot, {
          name: root.name !== undefined && newRoot.name !== undefined ? root.name + '/' + newRoot.name : newRoot.name});
      }

      const rows = [];

      const showAllCoverage = this.options.showAllCoverage || totalFiles < 15;

      function buildRows(folder, depth) {
        const name = folder.name === undefined ? 'All files' : folder.name + '/';
        const folderPercent = ___R$romejs$core$master$testing$utils_ts$percentInsideCoverageFolder(folder);

        rows.push([' '.repeat(depth) + ('<emphasis>' + name + '</emphasis>'), ___R$romejs$core$master$testing$utils_ts$formatPercent(folderPercent.functions), ___R$romejs$core$master$testing$utils_ts$formatPercent(folderPercent.branches), ___R$romejs$core$master$testing$utils_ts$formatPercent(folderPercent.lines)]);

        if (!showAllCoverage && depth > 0) {
          return undefined;
        }

        const fileIndent = ' '.repeat(depth + 1);
        for (const [name, file] of ___R$romejs$core$master$testing$utils_ts$sortMapKeys(folder.files)) {
          let absolute = file.filename;

          const absolutePath = master.projectManager.getFilePathFromUid(
          file.filename);
          if (absolutePath !== undefined) {
            absolute = absolutePath.join();
          }

          rows.push([fileIndent + ('<filelink target="' + absolute + '">' + name + '</filelink>'), ___R$romejs$core$master$testing$utils_ts$formatPercent(file.functions.percent), ___R$romejs$core$master$testing$utils_ts$formatPercent(file.branches.percent), ___R$romejs$core$master$testing$utils_ts$formatPercent(file.lines.percent)]);
        }

        for (const subFolder of ___R$romejs$core$master$testing$utils_ts$sortMapKeys(folder.folders).values()) {
          buildRows(subFolder, depth + 1);
        }
      }

      buildRows(root, 0);

      reporter.table(['File', '% Functions', '% Branches', '% Lines'], rows);

      if (!showAllCoverage) {
        reporter.spacer();
        reporter.info(
        'Additional coverage information available. Refine the executed tests or add the <emphasis>--show-all-coverage</emphasis> flag');
      }

      reporter.hr();
    }

    printTestResults() {
      if (this.printer.hasDiagnostics()) {
        this.throwErrorDiagnosticsPrinter();
      } else {
        this.printTestSuccess();
      }
    }

    printTestSuccess() {
      this.printCoverageReport();
      this.reporter.success('All <emphasis>' + ___R$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
      this.progress.total) + '</emphasis> tests passed!');
    }

    getSourceCode(filename) {
      const testSource = this.sources.get(filename);
      if (testSource === undefined) {
        return undefined;
      } else {
        return testSource.code;
      }
    }

    throwErrorDiagnosticsPrinter() {
      const {printer: printer} = this;

      if (this.options.showAllCoverage) {
        printer.onBeforeFooterPrint(() => {
          this.printCoverageReport();
        });
      }

      throw printer;
    }
  }

  // romejs/core/master/commands/test.ts

  function ___R$$priv$romejs$core$master$commands$test_ts$isTestFile(path, testFolder) {
    const parts = path.getSegments();

    for (const part of parts) {
      if (part[0] === '_' && part !== testFolder) {
        return false;
      }

      if (part === 'node_modules') {
        return false;
      }
    }

    for (const part of parts) {
      if (part === testFolder) {
        return true;
      }
    }

    return false;
  }

  const ___R$romejs$core$master$commands$test_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.CODE_QUALITY,
    description: 'run tests',
    hasHeader: true,

    defineFlags(c) {
      return {
        coverage: c.get('coverage').asBoolean(true),
        showAllCoverage: c.get('showAllCoverage').asBoolean(false),
        updateSnapshots: c.get('updateSnapshots').asBoolean(false)};
    },

    async default(req, commandFlags) {
      const {master: master, reporter: reporter} = req;
      const {flags: flags} = req.client;

      const args = [...req.query.args];
      if (args.length === 0) {
        const project = await req.assertClientCwdProject();
        args.push(project.folder);
      }

      const files = [];

      for (const arg of args) {
        const loc = flags.cwd.resolve(arg);
        await master.projectManager.assertProject(loc);
        const matches = master.memoryFs.glob(loc, {extensions: ___R$romejs$core$common$fileHandlers_ts$JS_EXTENSIONS});

        for (const path of matches) {
          const project = master.projectManager.assertProjectExisting(path);

          if (___R$$priv$romejs$core$master$commands$test_ts$isTestFile(path, project.config.tests.folderName)) {
            files.push(path);
          }
        }
      }

      if (files.length === 0) {
        reporter.warn('No tests ran');
        return;
      }

      reporter.info('Bundling <number emphasis>' + files.length + '</number> test files');

      let addDiagnostics = [];

      const tests = new Map();

      const bundler = new ___R$romejs$core$master$bundler$Bundler_ts$default(req, req.reporter.fork({
        silent: true}), req.getBundlerConfigFromFlags({
        mocks: true}));

      for (const [path, res] of await bundler.bundleMultiple(files)) {
        tests.set(path.join(), {
          code: res.entry.js.content,
          sourceMap: res.entry.sourceMap.map,
          path: path});
      }

      reporter.info('Running tests');

      const runner = new ___R$romejs$core$master$testing$TestRunner_ts$default({
        addDiagnostics: addDiagnostics,
        options: {
          coverage: commandFlags.coverage,
          showAllCoverage: commandFlags.showAllCoverage,
          updateSnapshots: commandFlags.updateSnapshots,
          verboseDiagnostics: req.query.requestFlags.verboseDiagnostics},
        sources: tests,
        request: req});
      await runner.init();
    }});

  // romejs/core/master/commands/_evict.ts

  const ___R$romejs$core$master$commands$_evict_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    description: 'evict a file from the memory cache',
    category: ___R$romejs$core$commands_ts$commandCategories.INTERNAL,

    async default(req) {
      const {
        master: master,
        reporter: reporter,
        client: client,
        query: {args: args}} = req;

      const files = args.length === 0 ? master.fileAllocator.getAllOwnedFilenames() : args;

      for (const file of files) {
        await master.fileAllocator.evict(client.flags.cwd.resolve(file));
        reporter.success('Evicted ' + file);
      }

      reporter.info('Evicted ' + String(files.length) + ' files');
    }});

  // romejs/core/master/commands/_moduleSignature.ts

  const ___R$romejs$core$master$commands$_moduleSignature_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.INTERNAL,
    description: 'get the module type signature of a file',

    async default(req) {
      const {master: master, reporter: reporter} = req;
      const {flags: flags} = req.client;
      const {args: args} = req.query;
      req.expectArgumentLength(1);

      const filename = await master.resolver.resolveEntryAssertPath(Object.assign({}, req.getResolverOptionsFromFlags(), {
        origin: flags.cwd,
        source: ___R$romejs$path$index_ts$createUnknownFilePath(args[0])}), {pointer: req.getDiagnosticPointerFromFlags({type: 'arg', key: 0})});
      reporter.inspect((await req.requestWorkerModuleSignature(filename)));
    }});

  // romejs/core/master/commands/noop.ts

  const ___R$romejs$core$master$commands$noop_ts$default = ___R$romejs$core$commands_ts$createMasterCommand({
    category: ___R$romejs$core$commands_ts$commandCategories.INTERNAL,
    description: '',

    async default(req) {
      req;
    }});

  // romejs/core/master/commands/index.ts

  const ___R$romejs$core$master$commands$index_ts$masterCommands = new Map();
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('_moduleSignature', ___R$romejs$core$master$commands$_moduleSignature_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('evict', ___R$romejs$core$master$commands$_evict_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('test', ___R$romejs$core$master$commands$test_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('lint', ___R$romejs$core$master$commands$lint_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('config', ___R$romejs$core$master$commands$config_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('bundle', ___R$romejs$core$master$commands$bundle_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('parse', ___R$romejs$core$master$commands$parse_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('analyzeDependencies', ___R$romejs$core$master$commands$analyzeDependencies_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('resolve', ___R$romejs$core$master$commands$resolve_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('compile', ___R$romejs$core$master$commands$compile_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('stop', ___R$romejs$core$master$commands$stop_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('status', ___R$romejs$core$master$commands$status_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('run', ___R$romejs$core$master$commands$run_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('publish', ___R$romejs$core$master$commands$publish_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('ci', ___R$romejs$core$master$commands$ci_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('develop', ___R$romejs$core$master$commands$develop_ts$default);
  ___R$romejs$core$master$commands$index_ts$masterCommands.set('_noop', ___R$romejs$core$master$commands$noop_ts$default);

  // romejs/core/common/utils/setupGlobalErrorHandlers.ts

  function ___R$romejs$core$common$utils$setupGlobalErrorHandlers_ts$default(callback) {
    const onUncaughtException = err => {
      callback(err);
    };
    process.on('uncaughtException', onUncaughtException);

    const onUnhandledRejection = (reason, promise) => {
      console.log(reason, promise);
      promise.then(() => {
        throw new Error('Promise is rejected so should never hit this condition');
      }).catch(err => {
        callback(err);
      });
    };
    process.on('unhandledRejection', onUnhandledRejection);

    return () => {
      process.removeListener('uncaughtException', onUncaughtException);
      process.removeListener('unhandledRejection', onUnhandledRejection);
    };
  }

  // romejs/core/common/userConfig.ts


  const ___R$romejs$core$common$userConfig_ts$DEFAULT_USER_CONFIG = {
    cachePath: ___R$romejs$path$index_ts$TEMP_PATH.append('rome-' + ___R$romejs$core$common$constants_ts$VERSION)};

  function ___R$romejs$core$common$userConfig_ts$loadUserConfig() {
    for (const configFilename of ___R$romejs$project$constants_ts$ROME_CONFIG_FILENAMES) {
      const configPath = ___R$romejs$path$index_ts$HOME_PATH.append(['.config', configFilename]);

      if (!___R$romejs$fs$index_ts$existsSync(configPath)) {
        continue;
      }

      const configFile = ___R$romejs$fs$index_ts$readFileTextSync(configPath);
      const consumer = ___R$romejs$codec$json$index_ts$consumeJSON({
        path: configPath,
        input: configFile});

      const userConfig = Object.assign({}, ___R$romejs$core$common$userConfig_ts$DEFAULT_USER_CONFIG);

      if (consumer.has('cachePath')) {
        userConfig.cachePath = ___R$romejs$path$index_ts$createAbsoluteFilePath(
        consumer.get('cachePath').asString());
      }

      consumer.enforceUsedProperties('config property');

      return userConfig;
    }

    return ___R$romejs$core$common$userConfig_ts$DEFAULT_USER_CONFIG;
  }

  // romejs/core/master/Master.ts

  const ___R$$priv$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH = 100000;

  class ___R$romejs$core$master$Master_ts$default {
    constructor(opts) {
      this.onFatalErrorBound = this.onFatalError.bind(this);

      this.profiling = undefined;
      this.options = opts;

      this.userConfig = ___R$romejs$core$common$userConfig_ts$loadUserConfig();

      this.fileChangeEvent = new ___R$romejs$events$Event_ts$default({
        name: 'Master.fileChange',
        onError: this.onFatalErrorBound});

      this.clientStartEvent = new ___R$romejs$events$Event_ts$default({
        name: 'Master.clientStart',
        onError: this.onFatalErrorBound});

      this.requestStartEvent = new ___R$romejs$events$Event_ts$default({
        name: 'Master.requestStart',
        onError: this.onFatalErrorBound});

      this.logEvent = new ___R$romejs$events$Event_ts$default({
        name: 'Master.log',
        onError: this.onFatalErrorBound});

      this.endEvent = new ___R$romejs$events$Event_ts$default({
        name: 'Master.end',
        onError: this.onFatalErrorBound,
        serial: true});

      this.logger = new ___R$romejs$core$common$utils$Logger_ts$default('master', this.logEvent, {
        streams: [{
          type: 'all',
          format: 'none',
          columns: 0,
          write: chunk => {
            this.emitMasterLog(chunk);
          }}]});

      this.connectedReporters = new ___R$romejs$cli$reporter$Reporter_ts$default({
        wrapperFactory: this.wrapFatal.bind(this)});
      this.connectedClients = new Set();

      this.memoryFs = new ___R$romejs$core$master$fs$MemoryFileSystem_ts$default(this);
      this.projectManager = new ___R$romejs$core$master$project$ProjectManager_ts$default(this);
      this.workerManager = new ___R$romejs$core$master$WorkerManager_ts$default(this);
      this.fileAllocator = new ___R$romejs$core$master$fs$FileAllocator_ts$default(this);
      this.resolver = new ___R$romejs$core$master$fs$Resolver_ts$default(this);
      this.cache = new ___R$romejs$core$master$Cache_ts$default(this);

      this.memoryFs.deletedFileEvent.subscribe(path => {
        return this.handleFileDelete(path);
      });

      this.memoryFs.changedFileEvent.subscribe(({path: path, oldStats: oldStats, newStats: newStats}) => {
        return this.handleFileChange(path, oldStats, newStats);
      });

      this.warnedCacheClients = new WeakSet();

      this.clientIdCounter = 0;

      this.requestRunningCounter = 0;
      this.terminateWhenIdle = false;
    }

    emitMasterLog(chunk) {
      this.logEvent.send(chunk);

      for (const {bridge: bridge} of this.connectedClients) {
        bridge.log.send({chunk: chunk, origin: 'master'});
      }
    }

    onFatalError(err) {
      const message = '<emphasis>Fatal error occurred</emphasis>: ' + ___R$romejs$string$markup$escape_ts$escapeMarkup(
      err.stack || err.message);
      this.logger.error(message);
      this.connectedReporters.error(message);
      process.exit();
    }

    wrapFatal(callback) {
      return (...args) => {
        try {
          const res = callback.apply(null, [...args]);
          if (res instanceof Promise) {
            res.catch(this.onFatalErrorBound);
          }
          return res;
        } catch (err) {
          throw this.onFatalError(err);
        }
      };
    }

    async handleDisconnectedDiagnostics(diagnostics) {
      this.connectedReporters.error(
      'Generated diagnostics without a current request');
      const printer = new ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default({
        origins: [],
        reporter: this.connectedReporters,
        readFile: this.readDiagnosticsPrinterFile.bind(this)});
      printer.addDiagnostics(diagnostics);
      await printer.print();
    }

    readDiagnosticsPrinterFile(filename) {
      const remoteToLocal = this.projectManager.remoteToLocalPath.get(filename);

      if (remoteToLocal === undefined) {
        return ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal(filename);
      } else {
        return ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal(remoteToLocal.join());
      }
    }

    createDisconnectedDiagnosticsProcessor(origins) {
      return new ___R$romejs$diagnostics$DiagnosticsProcessor_ts$default({
        onDiagnostics: diagnostics => {
          this.handleDisconnectedDiagnostics(diagnostics);
        },
        origins: [...origins, {
          category: 'master',
          message: 'Created disconnected diagnostics collector'}]});
    }

    maybeSetupGlobalErrorHandlers() {
      if (!this.options.globalErrorHandlers) {
        return;
      }

      const teardown = ___R$romejs$core$common$utils$setupGlobalErrorHandlers_ts$default(err => {
        this.onFatalError(err);
      });

      this.endEvent.subscribe(() => {
        teardown();
      });
    }

    async init() {
      this.maybeSetupGlobalErrorHandlers();
      this.memoryFs.init();
      await this.projectManager.init();
      this.fileAllocator.init();
      this.resolver.init();
      await this.cache.init();
      await this.workerManager.init();
    }

    async end() {
      await this.endEvent.callOptional();
      this.workerManager.end();
      this.memoryFs.unwatchAll();
    }

    async attachToBridge(bridge) {
      let profiler;

      if (this.options.dedicated === false) {
        bridge.endEvent.subscribe(() => {
          this.end();
        });
      }

      bridge.profilingStart.subscribe(async data => {
        if (profiler !== undefined) {
          throw new Error('Expected no profiler to be running');
        }
        profiler = new ___R$romejs$v8$Profiler_ts$default();
        await profiler.startProfiling(data.samplingInterval);
        this.profiling = data;
        for (const {bridge: bridge} of this.workerManager.getExternalWorkers()) {
          await bridge.profilingStart.call(data);
        }
      });

      bridge.profilingStop.subscribe(async () => {
        if (profiler === undefined) {
          throw new Error('Expected profiler to be running');
        }
        const masterProfile = await profiler.stopProfiling();
        profiler = undefined;
        this.profiling = undefined;
        return masterProfile;
      });

      bridge.profilingGetWorkers.subscribe(async () => {
        const ids = [];
        for (const {id: id} of this.workerManager.getExternalWorkers()) {
          ids.push(id);
        }
        return ids;
      });

      bridge.profilingStopWorker.subscribe(async id => {
        const worker = this.workerManager.getWorkerAssert(id);
        return await worker.bridge.profilingStop.call();
      });

      await bridge.handshake();

      const client = await this.createClient(bridge);

      if (client.version !== ___R$romejs$core$common$constants_ts$VERSION) {
        client.reporter.error('Client version ' + client.version + ' does not match server version ' + ___R$romejs$core$common$constants_ts$VERSION + '. Goodbye lol.');
        client.bridge.end();
        return;
      }

      await this.clientStartEvent.callOptional(client);

      bridge.query.subscribe(async request => {
        return await this.handleRequest(client, request);
      });
    }

    async createClient(bridge) {
      const {
        flags: rawFlags,
        useRemoteReporter: useRemoteReporter,
        hasClearScreen: hasClearScreen,
        columns: columns,
        format: format,
        version: version} = await bridge.getClientInfo.call();

      const flags = Object.assign({}, rawFlags, {
        cwd: ___R$romejs$path$index_ts$createAbsoluteFilePath(rawFlags.cwd)});

      const outStream = {
        type: 'out',
        columns: columns,
        format: format,
        write(chunk) {
          if (flags.silent === true) {
            return;
          }

          if (chunk.length < ___R$$priv$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH) {
            bridge.stdout.send(chunk);
          } else {
            while (chunk.length > 0) {
              const subChunk = chunk.slice(0, ___R$$priv$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH);
              chunk = chunk.slice(___R$$priv$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH);
              bridge.stdout.send(subChunk);
            }
          }
        }};

      const errStream = Object.assign({}, outStream, {
        type: 'error',

        write(chunk) {
          bridge.stderr.send(chunk);
        }});

      bridge.setColumns.subscribe(columns => {
        reporter.setStreamColumns([outStream, errStream], columns);
      });

      const reporter = new ___R$romejs$cli$reporter$Reporter_ts$default({
        hasClearScreen: hasClearScreen,
        wrapperFactory: this.wrapFatal.bind(this),
        streams: [outStream, errStream],
        verbose: flags.verbose,
        silent: flags.silent,
        markupOptions: {
          cwd: flags.cwd,
          humanizeFilename: filename => {
            const path = ___R$romejs$path$index_ts$createUnknownFilePath(filename);
            if (path.isAbsolute()) {
              const remote = this.projectManager.getRemoteFromLocalPath(
              path.assertAbsolute());
              if (remote !== undefined) {
                return remote.join();
              }
            }
          },
          normalizeFilename: filename => {
            const path = this.projectManager.getFilePathFromUid(filename);
            if (path === undefined) {
              return filename;
            } else {
              return path.join();
            }
          }},
        useRemoteProgressBars: useRemoteReporter});

      bridge.reporterRemoteServerMessage.subscribe(msg => {
        bridge.reporterRemoteServerMessage.send(msg);
      });

      bridge.reporterRemoteClientMessage.subscribe(msg => {
        reporter.receivedRemoteServerMessage(msg);
      });

      this.connectedReporters.addStream(errStream);
      this.connectedReporters.addStream(outStream);

      const client = {
        id: this.clientIdCounter++,
        bridge: bridge,
        reporter: reporter,
        flags: flags,
        version: version};

      this.connectedClients.add(client);

      let subscribedWorkers = false;
      bridge.enableWorkerLogs.subscribe(() => {
        if (subscribedWorkers) {
          return;
        } else {
          subscribedWorkers = true;
        }

        function onLog(chunk) {
          bridge.log.call({origin: 'worker', chunk: chunk});
        }

        for (const worker of this.workerManager.getWorkers()) {
          bridge.attachEndSubscriptionRemoval(worker.bridge.log.subscribe(onLog));
        }

        this.workerManager.workerStartEvent.subscribe(worker => {
          bridge.attachEndSubscriptionRemoval(worker.log.subscribe(onLog));
        });
      });

      bridge.endEvent.subscribe(() => {
        this.connectedClients.delete(client);
        this.connectedReporters.removeStream(errStream);
        this.connectedReporters.removeStream(outStream);
      });

      return client;
    }

    async handleFileDelete(path) {
      this.logger.info('[Master] File delete:', path.join());
      this.fileChangeEvent.send(path);
    }

    async handleFileChange(path, oldStats, newStats) {
      this.logger.info('[Master] File change:', path.join());
      this.fileChangeEvent.send(path);
    }

    async handleRequest(client, partialQuery) {
      const requestFlags = Object.assign({}, ___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS, partialQuery.requestFlags);

      const query = {
        commandName: partialQuery.command,
        args: partialQuery.args === undefined ? [] : partialQuery.args,
        noData: partialQuery.noData === true,
        requestFlags: requestFlags,
        silent: partialQuery.silent === true || requestFlags.benchmark,
        terminateWhenIdle: partialQuery.terminateWhenIdle === true,
        commandFlags: partialQuery.commandFlags === undefined ? {} : partialQuery.commandFlags};

      const {bridge: bridge} = client;
      this.logger.info('[Master] Handling CLI request:', query);

      let bridgeEndEvent;
      const bridgeEndPromise = new Promise((resolve, reject) => {
        bridgeEndEvent = bridge.endEvent.subscribe(err => {
          reject(err);
        });
      });
      if (bridgeEndEvent === undefined) {
        throw new Error('Expected bridgeEndEvent to have been initialized');
      }

      let reporter = client.reporter;
      if (query.silent) {
        reporter = reporter.fork({
          streams: []});
      }

      const req = new ___R$romejs$core$master$MasterRequest_ts$default({
        client: client,
        query: query,
        master: this,
        reporter: reporter,
        bridge: bridge});

      await this.requestStartEvent.callOptional(req);

      this.requestRunningCounter++;

      if (query.terminateWhenIdle) {
        this.terminateWhenIdle = true;
      }

      try {
        const res = await this.dispatchRequest(
        req,
        bridgeEndPromise,
        []);

        req.teardown(res);

        if (query.noData) {
          if (res.type === 'SUCCESS') {
            return {
              type: 'SUCCESS',
              hasData: res.data !== undefined,
              data: undefined,
              markers: res.markers};
          } else if (res.type === 'DIAGNOSTICS') {
            return {
              type: 'DIAGNOSTICS',
              diagnostics: []};
          }
        }

        return res;
      } finally {
        this.requestRunningCounter--;

        this.logger.info('[Master] Replying to CLI request:', query);

        bridgeEndEvent.unsubscribe();

        if (this.terminateWhenIdle && this.requestRunningCounter === 0) {
          this.end();
        }
      }
    }

    async dispatchBenchmarkRequest(req, bridgeEndPromise) {
      const {client: client} = req;
      const {reporter: reporter} = client;
      const {benchmarkIterations: benchmarkIterations} = req.query.requestFlags;

      const warmupStart = Date.now();
      const result = await this.dispatchRequest(req, bridgeEndPromise, ['benchmark']);
      const warmupTook = Date.now() - warmupStart;

      const progress = client.reporter.progress();
      progress.setTitle('Running benchmark');
      progress.setTotal(benchmarkIterations);
      const benchmarkStart = Date.now();
      for (let i = 0; i < benchmarkIterations; i++) {
        await this.dispatchRequest(req, bridgeEndPromise, ['benchmark']);
        progress.tick();
      }
      progress.end();
      const benchmarkTook = Date.now() - benchmarkStart;

      reporter.section('Benchmark results', () => {
        reporter.info(
        'Request artifacts may have been cached after the first run, artificially decreasing subsequent run time');
        reporter.heading('Query');
        reporter.inspect(req.query);
        reporter.heading('Stats');
        reporter.list(['Warmup took <duration emphasis>' + warmupTook + '</duration>', '<number emphasis>' + benchmarkIterations + '</number> runs', '<duration emphasis>' + benchmarkTook + '</duration> total', '<duration emphasis approx>' + benchmarkTook /
        benchmarkIterations + '</duration> per run']);
      });

      return result;
    }

    async dispatchRequest(req, bridgeEndPromise, origins) {
      const {query: query, reporter: reporter, bridge: bridge} = req;

      if (query.requestFlags.benchmark && !origins.includes('benchmark')) {
        return this.dispatchBenchmarkRequest(req, bridgeEndPromise);
      }

      const markers = [];

      if (query.requestFlags.collectMarkers) {
        req.markerEvent.subscribe(marker => {
          markers.push(marker);
        });
      }

      try {
        const defaultCommandFlags = {};

        const commandFlagsConsumer = ___R$romejs$consume$index_ts$consume({
          filePath: ___R$romejs$path$index_ts$createUnknownFilePath('argv'),
          parent: undefined,
          value: query.commandFlags,
          onDefinition(def) {
            defaultCommandFlags[def.objectPath[0]] = def.default;
          },
          objectPath: [],
          context: {
            category: 'cli-flags',

            getOriginalValue: keys => {
              return undefined;
            },

            getDiagnosticPointer: keys => {
              return req.getDiagnosticPointerFromFlags({
                type: 'flag',
                key: String(keys[0]),
                target: 'value'});
            }}});

        let promises = [bridgeEndPromise];

        const commandOpts = ___R$romejs$core$master$commands$index_ts$masterCommands.get(query.commandName);
        if (commandOpts) {
          if (commandOpts.hasHeader === true) {
            reporter.banner(query.commandName);
          }

          if (process.env.ROME_CACHE === '0' &&
          !this.warnedCacheClients.has(bridge)) {
            reporter.warn(
            'Disk caching has been disabled due to the <emphasis>ROME_CACHE=0</emphasis> environment variable');
            this.warnedCacheClients.add(bridge);
          }

          let commandFlags;
          if (commandOpts.defineFlags !== undefined) {
            commandFlags = commandOpts.defineFlags(commandFlagsConsumer);
          }

          req.setNormalizedCommandFlags({
            flags: commandFlags,
            defaultFlags: defaultCommandFlags});

          const commandPromise = commandOpts.default(req, commandFlags);
          promises.push(commandPromise);

          await Promise.race(promises);

          const data = await commandPromise;
          return {
            type: 'SUCCESS',
            hasData: data !== undefined,
            data: data,
            markers: markers};
        } else {
          throw new Error('Unknown command ' + String(query.commandName));
        }
      } catch (err) {
        let diagnostics = await this.handleRequestError(
        req,
        err);

        if (diagnostics === undefined) {
          return {
            type: 'ERROR',
            fatal: false,
            handled: true,
            name: err.name,
            message: err.message,
            stack: err.stack};
        } else {
          return {
            type: 'DIAGNOSTICS',
            diagnostics: diagnostics};
        }
      }
    }

    async handleRequestError(req, err) {
      const diagnostics = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
      if (diagnostics !== undefined) {
        const printer = req.createDiagnosticsPrinter({
          category: 'internal',
          message: 'Derived diagnostics from thrown error'});
        printer.addDiagnostics(diagnostics);
        err = printer;
      }

      if (err instanceof ___R$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default) {
        const printer = err;
        if (req.bridge.alive) {
          await printer.print();
          printer.footer();
        }
        return printer.getDiagnostics();
      }

      if (!req.bridge.alive) {
        return;
      }

      const printer = req.createDiagnosticsPrinter({
        category: 'internal',
        message: 'Error captured and converted into a diagnostic'});
      const errorDiag = ___R$romejs$diagnostics$derive_ts$deriveDiagnosticFromError({
        category: 'internalError',
        error: err});
      printer.addDiagnostic(Object.assign({}, errorDiag, {
        advice: [...(errorDiag.advice || []), ___R$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE]}));
      await printer.print();

      return;
    }
  }

  // romejs/codec-tar/index.ts

  const ___R$$priv$romejs$codec$tar$index_ts$stream = require('stream');

  const ___R$$priv$romejs$codec$tar$index_ts$END_OF_TAR = Buffer.alloc(1024);
  const ___R$$priv$romejs$codec$tar$index_ts$ZEROS = '0000000000000000000';
  const ___R$$priv$romejs$codec$tar$index_ts$SEVENS = '7777777777777777777';
  const ___R$$priv$romejs$codec$tar$index_ts$ZERO_OFFSET = '0'.charCodeAt(0);
  const ___R$$priv$romejs$codec$tar$index_ts$USTAR = 'ustar\x0000';
  const ___R$$priv$romejs$codec$tar$index_ts$MASK = 4095;
  const ___R$$priv$romejs$codec$tar$index_ts$DMODE = 493;
  const ___R$$priv$romejs$codec$tar$index_ts$FMODE = 420;

  function ___R$$priv$romejs$codec$tar$index_ts$encodeOct(num, n) {
    const oct = num.toString(8);
    if (oct.length > n) {
      return ___R$$priv$romejs$codec$tar$index_ts$SEVENS.slice(0, n) + ' ';
    } else {
      return ___R$$priv$romejs$codec$tar$index_ts$ZEROS.slice(0, n - oct.length) + oct + ' ';
    }
  }

  function ___R$$priv$romejs$codec$tar$index_ts$checksum(block) {
    let sum = 8 * 32;
    for (let i = 0; i < 148; i++) {
      sum += block[i];
    }
    for (let j = 156; j < 512; j++) {
      sum += block[j];
    }
    return sum;
  }

  function ___R$$priv$romejs$codec$tar$index_ts$toTypeflag(type) {
    switch (type) {
      case 'file':
        return 0;
      case 'link':
        return 1;
      case 'symlink':
        return 2;
      case 'character-device':
        return 3;
      case 'block-device':
        return 4;
      case 'directory':
        return 5;
      case 'fifo':
        return 6;
      case 'contiguous-file':
        return 7;}

    return 0;
  }

  function ___R$$priv$romejs$codec$tar$index_ts$encodeHeader(header) {
    const buf = Buffer.alloc(512);

    let name = header.name;
    let prefix = '';

    if (Buffer.byteLength(name) !== name.length) {
      throw new Error('utf-8 filename is only supported in PAX, we only support USTAR');
    }

    while (Buffer.byteLength(name) > 100) {
      const i = name.indexOf('/');
      if (i === -1) {
        throw new Error('filename is too long for USTAR and it was in no directory');
      }

      prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i);
      name = name.slice(i + 1);
    }

    if (Buffer.byteLength(name) > 100) {
      throw new Error('filename is too long for USTAR');
    }

    if (Buffer.byteLength(prefix) > 155) {
      throw new Error('prefix is too long for USTAR');
    }

    if (header.linkname !== undefined &&
    Buffer.byteLength(header.linkname) > 100) {
      throw new Error('linkname is too long for USTAR');
    }

    buf.write(name);
    buf.write(___R$$priv$romejs$codec$tar$index_ts$encodeOct(header.mode & ___R$$priv$romejs$codec$tar$index_ts$MASK, 6), 100);
    buf.write(___R$$priv$romejs$codec$tar$index_ts$encodeOct(header.uid, 6), 108);
    buf.write(___R$$priv$romejs$codec$tar$index_ts$encodeOct(header.gid, 6), 116);
    buf.write(___R$$priv$romejs$codec$tar$index_ts$encodeOct(header.size, 11), 124);
    buf.write(___R$$priv$romejs$codec$tar$index_ts$encodeOct(header.mtime.getTime() / 1000 | 0, 11), 136);

    buf[156] = ___R$$priv$romejs$codec$tar$index_ts$ZERO_OFFSET + ___R$$priv$romejs$codec$tar$index_ts$toTypeflag(header.type);

    if (header.linkname !== undefined) {
      buf.write(header.linkname, 157);
    }

    buf.write(___R$$priv$romejs$codec$tar$index_ts$USTAR, 257);
    if (header.uname !== undefined) {
      buf.write(header.uname, 265);
    }
    if (header.gname !== undefined) {
      buf.write(header.gname, 297);
    }
    buf.write(___R$$priv$romejs$codec$tar$index_ts$encodeOct(header.devmajor || 0, 6), 329);
    buf.write(___R$$priv$romejs$codec$tar$index_ts$encodeOct(header.devminor || 0, 6), 337);

    if (prefix !== '') {
      buf.write(prefix, 345);
    }

    buf.write(___R$$priv$romejs$codec$tar$index_ts$encodeOct(___R$$priv$romejs$codec$tar$index_ts$checksum(buf), 6), 148);

    return buf;
  }

  class ___R$romejs$codec$tar$index_ts$TarWriter {
    constructor(stream) {
      this.finalized = false;
      this.stream = stream;
    }

    static normalizeHeader(partial, size) {
      let mode = partial.mode;
      if (mode === undefined) {
        if (partial.type === 'directory') {
          mode = ___R$$priv$romejs$codec$tar$index_ts$DMODE;
        } else {
          mode = ___R$$priv$romejs$codec$tar$index_ts$FMODE;
        }
      }

      return {
        name: partial.name,
        size: size,
        mode: mode,
        mtime: partial.mtime === undefined ? new Date() : partial.mtime,
        type: partial.type === undefined ? 'file' : partial.type,
        linkname: partial.linkname,
        uid: partial.uid === undefined ? 0 : partial.uid,
        gid: partial.gid === undefined ? 0 : partial.gid,
        uname: partial.uname,
        gname: partial.gname,
        devmajor: partial.devmajor === undefined ? 0 : partial.devmajor,
        devminor: partial.devminor === undefined ? 0 : partial.devminor};
    }

    overflow(size) {
      size &= 511;
      if (size > 0) {
        this.stream.write(___R$$priv$romejs$codec$tar$index_ts$END_OF_TAR.slice(0, 512 - size));
      }
    }

    append(rawHeader, rawBuffer) {
      if (this.finalized) {
        throw new Error('Already finalized file');
      }

      const buffer = rawBuffer instanceof Buffer ? rawBuffer : Buffer.from(rawBuffer);
      const header = ___R$romejs$codec$tar$index_ts$TarWriter.normalizeHeader(rawHeader, buffer.length);

      this.stream.write(___R$$priv$romejs$codec$tar$index_ts$encodeHeader(header));
      this.stream.write(buffer);
      this.overflow(header.size);
    }

    finalize() {
      this.finalized = true;

      return new Promise((resolve, reject) => {
        const {stream: stream} = this;

        stream.on('close', () => {
          resolve();
        });

        stream.on('error', err => {
          reject(err);
        });

        stream.write(___R$$priv$romejs$codec$tar$index_ts$END_OF_TAR);
        stream.end();
      });
    }
  }

  // romejs/core/client/Client.ts

  const ___R$$priv$romejs$core$client$Client_ts$stream = require('stream');
  const ___R$$priv$romejs$core$client$Client_ts$net = require('net');
  const ___R$$priv$romejs$core$client$Client_ts$zlib = require('zlib');
  const ___R$$priv$romejs$core$client$Client_ts$fs = require('fs');
  const ___R$$priv$romejs$core$client$Client_ts$child = require('child_process');
  function ___R$romejs$core$client$Client_ts$getFilenameTimestamp() {
    return new Date().toISOString().replace(/[^0-9a-zA-Z]/g, '');
  }

  const ___R$$priv$romejs$core$client$Client_ts$NEW_SERVER_INIT_TIMEOUT = 10000;

  class ___R$romejs$core$client$Client_ts$default {
    constructor(opts) {
      this.options = opts;
      this.userConfig = ___R$romejs$core$common$userConfig_ts$loadUserConfig();

      this.flags = Object.assign({}, ___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS, opts.flags);

      this.requestResponseEvent = new ___R$romejs$events$Event_ts$default({
        name: 'Client.requestResponseEvent'});
      this.endEvent = new ___R$romejs$events$Event_ts$default({name: 'Client.endEvent', serial: true});
      this.bridgeStatus = undefined;

      this.bridgeAttachedEvent = new ___R$romejs$events$Event_ts$default({
        name: 'Client.bridgeAttached'});

      this.stdout = opts.stdout;

      this.reporter = new ___R$romejs$cli$reporter$Reporter_ts$default({
        silent: this.flags.silent === true ||
        opts.stdout === undefined ||
        opts.stderr === undefined,
        verbose: this.flags.verbose === true,
        markupOptions: {
          cwd: this.flags.cwd}});

      this.derivedReporterStreams = this.reporter.attachStdoutStreams(
      opts.stdout,
      opts.stderr);

      this.endEvent.subscribe(() => {
        this.reporter.teardown();
      });
    }

    getBridgeJSONFlags() {
      return Object.assign({}, this.flags, {
        cwd: this.flags.cwd.join()});
    }

    async profile(opts, callback) {
      const {samplingInterval: samplingInterval, timeoutInterval: timeoutInterval, includeWorkers: includeWorkers} = opts;

      this.reporter.info('Starting CPU profile...');

      const bridge = await this.findOrStartMaster();
      await bridge.profilingStart.call({
        samplingInterval: samplingInterval});

      let cliProfiler;
      const bridgeStatus = this.getBridge();
      if (bridgeStatus === undefined || bridgeStatus.dedicated) {
        cliProfiler = new ___R$romejs$v8$Profiler_ts$default();
        await cliProfiler.startProfiling(samplingInterval);
      }

      let hasProfiled;
      let timeout;
      if (timeoutInterval > 0) {
        timeout = setTimeout(() => {
          hasProfiled = stopProfile(true);
        }, timeoutInterval);
      }

      const stopProfile = async isTimeout => {
        if (hasProfiled) {
          return hasProfiled;
        }

        if (timeout !== undefined) {
          clearTimeout(timeout);
        }

        const trace = new ___R$romejs$v8$Trace_ts$default();
        const fetchers = [];

        if (cliProfiler !== undefined) {
          const cliProfilerAssert = cliProfiler;
          fetchers.push(['CLI', async () => {
            return cliProfilerAssert.stopProfiling();
          }]);
        }

        fetchers.push([cliProfiler === undefined ? 'Master/CLI' : 'Master', async () => {
          return await bridge.profilingStop.call(undefined, {
            priority: true});
        }]);

        if (includeWorkers) {
          const workerIds = await bridge.profilingGetWorkers.call();
          for (const id of workerIds) {
            fetchers.push(['Worker ' + id, async () => {
              return await bridge.profilingStopWorker.call(id, {
                priority: true});
            }]);
          }
        }

        const progress = this.reporter.progress();
        progress.setTotal(fetchers.length);
        progress.setTitle('Fetching profiles');
        for (const [text, callback] of fetchers) {
          progress.setText(text);
          const profile = await callback();
          trace.addProfile(text, profile);
          progress.tick();
        }
        progress.end();

        const events = trace.build();
        await callback(events);

        if (isTimeout) {
          this.reporter.hr();
        }
      };

      this.endEvent.subscribe(() => {
        return stopProfile(false);
      });
    }

    async subscribeLogs(includeWorkerLogs, callback) {
      const bridge = await this.findOrStartMaster();

      if (includeWorkerLogs) {
        await bridge.enableWorkerLogs.call();
      }

      bridge.log.subscribe(({origin: origin, chunk: chunk}) => {
        if (origin === 'worker' && !includeWorkerLogs) {
          return;
        }

        callback(chunk);
      });
    }

    async rage(ragePath, profileOpts) {
      if (this.bridgeStatus !== undefined) {
        throw new Error('rage() can only be called before a query has been dispatched');
      }

      let logs = '';
      await this.subscribeLogs(true, chunk => {
        logs += chunk;
      });

      let profileEvents = [];
      await this.profile(profileOpts, async _profileEvents => {
        profileEvents = _profileEvents;
      });

      const responses = [];
      this.requestResponseEvent.subscribe(result => {
        responses.push(result);
      });

      this.endEvent.subscribe(async () => {
        const stream = ___R$$priv$romejs$core$client$Client_ts$zlib.createGzip();
        stream.pipe(___R$$priv$romejs$core$client$Client_ts$fs.createWriteStream(ragePath));

        const writer = new ___R$romejs$codec$tar$index_ts$TarWriter(stream);

        writer.append({name: 'profile.json'}, stringify(profileEvents));
        writer.append({name: 'logs.txt'}, logs);

        for (let i = 0; i < responses.length; i++) {
          const {request: request, response: response} = responses[i];
          const dirname = 'requests/' + i + '-' + request.commandName;
          writer.append({name: dirname + '/request.json'}, stringify(request));
          writer.append({name: dirname + '/response.json'}, stringify(response));
        }

        writer.append(
        {name: 'clientFlags.json'},
        stringify(this.getBridgeJSONFlags()));

        function stringify(val) {
          return JSON.stringify(val, null, '  ');
        }

        function indent(val) {
          const str = typeof val === 'string' ? val : ___R$romejs$pretty$format$index_ts$default(val, {compact: true});
          const lines = str.trim().split('\n');
          const indented = lines.join('\n  ');
          return '\n  ' + indented;
        }

        const env = [];
        env.push('PATH: ' + indent(process.env.PATH));
        env.push('Rome version: ' + indent(___R$romejs$core$common$constants_ts$VERSION));
        env.push('Node version: ' + indent(process.versions.node));
        env.push('Platform: ' + indent(process.platform + ' ' + process.arch));
        writer.append({name: 'environment.txt'}, env.join('\n\n') + '\n');

        const bridgeStatus = this.getBridge();
        if (bridgeStatus !== undefined) {
          const status = await this.query({
            silent: true,
            command: 'status'});
          if (status.type === 'SUCCESS') {
            writer.append(
            {name: 'status.txt'},
            ___R$romejs$pretty$format$index_ts$default(status.data, {compact: true}) + '\n');
          }
        }

        await writer.finalize();
        this.reporter.success('Rage archive written to', ragePath);
      });
    }

    async query(query, type) {
      const request = new ___R$romejs$core$client$ClientRequest_ts$default(this, type, query);
      const res = await request.init();
      this.requestResponseEvent.send({request: query, response: res});
      return res;
    }

    getBridge() {
      return this.bridgeStatus;
    }

    async end() {
      await this.endEvent.callOptional();

      const status = this.bridgeStatus;
      if (status !== undefined) {
        status.bridge.end();
        this.bridgeStatus = undefined;
      }
    }

    async attachBridge(bridge, dedicated) {
      const {stdout: stdout, stderr: stderr, columnsUpdated: columnsUpdated} = this.derivedReporterStreams;

      if (this.bridgeStatus !== undefined) {
        throw new Error('Already attached bridge to API');
      }

      this.bridgeStatus = {bridge: bridge, dedicated: dedicated};

      bridge.stderr.subscribe(chunk => {
        stderr.write(chunk);
      });

      bridge.stdout.subscribe(chunk => {
        stdout.write(chunk);
      });

      bridge.reporterRemoteServerMessage.subscribe(msg => {
        this.reporter.processRemoteClientMessage(msg);
      });

      this.reporter.sendRemoteServerMessage.subscribe(msg => {
        bridge.reporterRemoteClientMessage.send(msg);
      });

      columnsUpdated.subscribe(columns => {
        bridge.setColumns.call(columns);
      });

      await Promise.all([bridge.getClientInfo.wait({
        version: ___R$romejs$core$common$constants_ts$VERSION,
        format: stdout.format,
        hasClearScreen: this.reporter.hasClearScreen,
        columns: stdout.columns,
        useRemoteReporter: true,
        flags: this.getBridgeJSONFlags()}), bridge.handshake()]);

      await this.bridgeAttachedEvent.call();
    }

    async findOrStartMaster() {
      const connected = this.getBridge();
      if (connected !== undefined) {
        return connected.bridge;
      }

      const runningDaemon = await this.tryConnectToExistingDaemon();
      if (runningDaemon) {
        return runningDaemon;
      }

      const master = new ___R$romejs$core$master$Master_ts$default({
        dedicated: false,
        globalErrorHandlers: this.options.globalErrorHandlers === true});
      await master.init();

      const bridge = ___R$romejs$events$bridgeCreators_ts$createBridgeFromLocal(___R$romejs$core$common$bridges$MasterBridge_ts$default, {});
      await Promise.all([master.attachToBridge(bridge), this.attachBridge(bridge, false)]);

      this.endEvent.subscribe(async () => {
        await master.end();
      });

      return bridge;
    }

    async forceStartDaemon() {
      const daemon = await this.startDaemon();
      if (daemon === undefined) {
        this.reporter.error('Failed to start daemon');
        throw new Error('Failed to start daemon');
      } else {
        return daemon;
      }
    }

    async startDaemon() {
      const {reporter: reporter} = this;

      if (this.bridgeStatus !== undefined) {
        throw new Error('Already started master');
      }

      reporter.info('No running daemon found. Starting one...');

      let exited = false;
      let proc;

      const newDaemon = await new Promise(resolve => {
        const timeout = setTimeout(() => {
          reporter.error('Daemon connection timed out');
          cleanup();
          resolve();
        }, ___R$$priv$romejs$core$client$Client_ts$NEW_SERVER_INIT_TIMEOUT);

        const socketServer = ___R$$priv$romejs$core$client$Client_ts$net.createServer(() => {
          cleanup();
          resolve(this.tryConnectToNewDaemon());
        });

        function listen() {
          socketServer.listen(___R$romejs$core$common$constants_ts$CLI_SOCKET_PATH.join());

          proc = ___R$romejs$core$common$utils$fork_ts$default('master', {
            detached: true});
          proc.unref();

          proc.on('close', () => {
            exited = true;
            cleanup();
            resolve();
          });
        }

        ___R$romejs$fs$index_ts$unlink(___R$romejs$core$common$constants_ts$CLI_SOCKET_PATH).finally(() => {
          listen();
        });

        function cleanup() {
          clearTimeout(timeout);
          socketServer.close();
        }
      });
      if (newDaemon) {
        return newDaemon;
      }

      if (exited) {
        reporter.error('Daemon died while initialising.');
      } else {
        reporter.error('Failed to connect. Killing daemon.');
      }

      if (proc !== undefined) {
        proc.kill();
      }

      console.log('ughhh???');
      return undefined;
    }

    async tryConnectToNewDaemon() {
      const bridge = await this.tryConnectToExistingDaemon();
      if (bridge !== undefined) {
        this.reporter.success('Started daemon!');
        return bridge;
      }
    }

    async tryConnectToExistingDaemon() {
      const promise = new Promise((resolve, reject) => {
        const socket = ___R$$priv$romejs$core$client$Client_ts$net.createConnection(
        {
          path: ___R$romejs$core$common$constants_ts$SOCKET_PATH.join()},
        () => {
          resolve(socket);
        });

        socket.on('error', err => {
          if (err.code === 'ENOENT' ||
          err.code === 'ECONNREFUSED' ||
          err.code === 'EADDRINUSE') {
            resolve();
          } else {
            reject(err);
          }
        });
      });

      const socket = await promise;
      if (socket === undefined) {
        return undefined;
      }

      const server = ___R$romejs$events$bridgeCreators_ts$createBridgeFromSocket(___R$romejs$core$common$bridges$MasterBridge_ts$default, socket, {
        type: 'server'});
      await this.attachBridge(server, true);
      this.reporter.success('Connected to daemon');
      return server;
    }
  }

  // romejs/core/common/types/bundler.ts

  const ___R$romejs$core$common$types$bundler_ts = {
    get BUNDLER_MODES() {
      return ___R$romejs$core$common$types$bundler_ts$BUNDLER_MODES;
    }};

  const ___R$romejs$core$common$types$bundler_ts$BUNDLER_MODES = ['modern', 'legacy'];

  // romejs/core/common/types/files.ts

  const ___R$romejs$core$common$types$files_ts = {
    convertTransportFileReference: ___R$romejs$core$common$types$files_ts$convertTransportFileReference};

  function ___R$romejs$core$common$types$files_ts$convertTransportFileReference(ref) {
    return Object.assign({}, ref, {
      real: ___R$romejs$path$index_ts$createAbsoluteFilePath(ref.real)});
  }

  // romejs/core/worker/WorkerAPI.ts

  class ___R$romejs$core$worker$WorkerAPI_ts$default {
    constructor(worker) {
      this.worker = worker;
      this.logger = worker.logger;
    }

    interceptAndAddGeneratedToDiagnostics(val, generated) {
      if (generated) {
        const diagnostics = val.diagnostics.map(diag => {
          const diagAdvice = diag.advice === undefined ? [] : diag.advice;
          return Object.assign({}, diag, {
            advice: [...diagAdvice, {
              type: 'log',
              category: 'warn',
              message: 'This diagnostic was generated on a file that has been converted to JavaScript. The source locations are most likely incorrect'}]});
        });

        return Object.assign({}, val, {
          diagnostics: diagnostics});
      } else {
        return val;
      }
    }

    async moduleSignatureJS(ref) {
      const {ast: ast, project: project} = await this.worker.parseJS(ref);

      this.logger.info('Generating export types:', ref.real);

      return await ___R$romejs$js$analysis$index_ts.getModuleSignature({
        ast: ast,
        project: project,
        provider: await this.worker.getTypeCheckProvider(ref.project)});
    }

    async analyzeDependencies(ref) {
      const project = this.worker.getProject(ref.project);
      const {handler: handler} = ___R$romejs$core$common$fileHandlers_ts$getFileHandlerAssert(ref.real, project.config);
      this.logger.info('Analyze dependencies:', ref.real);

      const {analyzeDependencies: analyzeDependencies} = handler;
      if (analyzeDependencies === undefined) {
        return ___R$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT;
      }

      return analyzeDependencies({
        file: ref,
        project: project,
        worker: this.worker});
    }

    async workerCompilerOptionsToCompilerOptions(ref, workerOptions) {
      const ___R$ = workerOptions;
      const options = Object.assign({}, ___R$);
      delete options.bundle;
      const {
        bundle: bundle} = ___R$;
      if (bundle === undefined) {
        return options;
      } else {
        return Object.assign({}, options, {
          bundle: Object.assign({}, bundle, {
            analyze: await this.analyzeDependencies(ref)})});
      }
    }

    async compileJS(ref, stage, workerOptions) {
      const {ast: ast, project: project, sourceText: sourceText, generated: generated} = await this.worker.parseJS(
      ref);
      this.logger.info('Compiling:', ref.real);

      const options = await this.workerCompilerOptionsToCompilerOptions(
      ref,
      workerOptions);
      return this.interceptAndAddGeneratedToDiagnostics(
      (await ___R$romejs$js$compiler$api$compile_ts$default({
        ast: ast,
        sourceText: sourceText,
        options: options,
        project: project,
        stage: stage})),
      generated);
    }

    async parseJS(ref, opts) {
      let {ast: ast, generated: generated} = await this.worker.parseJS(ref, {
        sourceType: opts.sourceType,
        cache: false});

      ast = this.interceptAndAddGeneratedToDiagnostics(ast, generated);

      if (opts.compact) {
        return ___R$romejs$js$ast$core$Program_ts$program.assert(___R$romejs$js$ast$utils$removeLoc_ts$default(ast));
      } else {
        return ast;
      }
    }

    async lint(ref, prefetchedModuleSignatures, fix) {
      const project = this.worker.getProject(ref.project);
      this.logger.info('Linting:', ref.real);

      const {handler: handler} = ___R$romejs$core$common$fileHandlers_ts$getFileHandlerAssert(ref.real, project.config);

      const {lint: lint} = handler;
      if (lint === undefined) {
        return [];
      }

      const res = await ___R$romejs$diagnostics$wrap_ts$catchDiagnostics(
      {
        category: 'lint',
        message: 'Caught by WorkerAPI.lint'},
      () => lint({
        file: ref,
        project: project,
        prefetchedModuleSignatures: prefetchedModuleSignatures,
        worker: this.worker}));

      if (res.diagnostics !== undefined) {
        return res.diagnostics;
      }

      const {
        formatted: formatted,
        sourceText: raw,
        diagnostics: diagnostics} = res.value;

      const needsFix = formatted !== raw;

      if (fix && needsFix) {
        await this.worker.writeFile(ref.real, formatted);

        return this.lint(ref, prefetchedModuleSignatures, false);
      }

      if (!needsFix) {
        return diagnostics;
      }

      return [...diagnostics, {
        category: 'lint/pendingFixes',
        filename: ref.uid,
        message: 'Pending lint fixes',
        advice: [{
          type: 'diff',
          diff: ___R$romejs$string$diff$index_ts$default(raw, formatted)}]}];
    }
  }

  // romejs/core/worker/Worker.ts


  class ___R$romejs$core$worker$Worker_ts$default {
    constructor(opts) {
      this.bridge = opts.bridge;

      this.userConfig = ___R$romejs$core$common$userConfig_ts$loadUserConfig();
      this.partialManifests = new Map();
      this.projects = new Map();
      this.astCache = new ___R$romejs$path$collections_ts$UnknownFilePathMap();
      this.moduleSignatureCache = new ___R$romejs$path$collections_ts$UnknownFilePathMap();

      this.logger = new ___R$romejs$core$common$utils$Logger_ts$default('worker', opts.bridge.log, {
        streams: [{
          type: 'all',
          format: 'none',
          columns: ___R$romejs$cli$reporter$Reporter_ts$default.DEFAULT_COLUMNS,
          write(chunk) {
            opts.bridge.log.send(chunk.toString());
          }}]});

      this.api = new ___R$romejs$core$worker$WorkerAPI_ts$default(this);

      if (opts.globalErrorHandlers) {
        ___R$romejs$core$common$utils$setupGlobalErrorHandlers_ts$default(err => {});
      }
    }

    getPartialManifest(id) {
      const manifest = this.partialManifests.get(id);
      if (manifest === undefined) {
        throw new Error('Requested manifest ' + id + ' but we don\'t have it');
      }
      return manifest;
    }

    end() {
      this.astCache.clear();
      this.projects.clear();
      this.moduleSignatureCache.clear();
    }

    async init() {
      const bridge = this.bridge;

      bridge.endEvent.subscribe(() => {
        this.end();
      });

      let profiler;
      bridge.profilingStart.subscribe(async data => {
        if (profiler !== undefined) {
          throw new Error('Expected no profiler to be running');
        }
        profiler = new ___R$romejs$v8$Profiler_ts$default();
        await profiler.startProfiling(data.samplingInterval);
      });

      bridge.profilingStop.subscribe(async () => {
        if (profiler === undefined) {
          throw new Error('Expected a profiler to be running');
        }
        const workerProfile = await profiler.stopProfiling();
        profiler = undefined;
        return workerProfile;
      });

      bridge.compileJS.subscribe(payload => {
        return this.api.compileJS(
        ___R$romejs$core$common$types$files_ts$convertTransportFileReference(payload.file),
        payload.stage,
        payload.options);
      });

      bridge.parseJS.subscribe(payload => {
        return this.api.parseJS(
        ___R$romejs$core$common$types$files_ts$convertTransportFileReference(payload.file),
        payload.opts);
      });

      bridge.lint.subscribe(payload => {
        return this.api.lint(
        ___R$romejs$core$common$types$files_ts$convertTransportFileReference(payload.file),
        payload.prefetchedModuleSignatures,
        payload.fix);
      });

      bridge.analyzeDependencies.subscribe(payload => {
        return this.api.analyzeDependencies(
        ___R$romejs$core$common$types$files_ts$convertTransportFileReference(payload.file));
      });

      bridge.evict.subscribe(payload => {
        this.evict(___R$romejs$path$index_ts$createAbsoluteFilePath(payload.filename));
        return undefined;
      });

      bridge.moduleSignatureJS.subscribe(payload => {
        return this.api.moduleSignatureJS(
        ___R$romejs$core$common$types$files_ts$convertTransportFileReference(payload.file));
      });

      bridge.updateProjects.subscribe(payload => {
        return this.updateProjects(payload.projects);
      });

      bridge.updateManifests.subscribe(payload => {
        return this.updateManifests(payload.manifests);
      });

      bridge.status.subscribe(() => {
        return {
          astCacheSize: this.astCache.size,
          pid: process.pid,
          memoryUsage: process.memoryUsage(),
          uptime: process.uptime()};
      });
    }

    async getTypeCheckProvider(projectId, prefetchedModuleSignatures = {}) {
      const libs = [];

      const resolveGraph = async key => {
        const value = prefetchedModuleSignatures[key];
        if (value === undefined) {
          return undefined;
        }

        switch (value.type) {
          case 'RESOLVED':
            this.moduleSignatureCache.set(
            ___R$romejs$path$index_ts$createUnknownFilePath(value.graph.filename),
            value.graph);
            return value.graph;

          case 'OWNED':
            return this.api.moduleSignatureJS(
            ___R$romejs$core$common$types$files_ts$convertTransportFileReference(value.file));

          case 'POINTER':
            return resolveGraph(value.key);

          case 'USE_CACHED':
            const cached = this.moduleSignatureCache.get(
            ___R$romejs$path$index_ts$createUnknownFilePath(value.filename));
            if (cached === undefined) {
              throw new Error('Master told us we have the export types for ' + value.filename + ' cached but we dont!');
            }
            return cached;}
      };

      return {
        getExportTypes: async (origin, relative) => {
          return resolveGraph(origin + ':' + relative);
        },
        libs: libs};
    }

    populateDiagnosticsMtime(diagnostics) {
      return diagnostics;
    }

    async parseJS(ref, opts = {}) {
      const path = ___R$romejs$path$index_ts$createAbsoluteFilePath(ref.real);

      const {project: projectId, uid: uid} = ref;
      const project = this.getProject(projectId);

      const {handler: handler} = ___R$romejs$core$common$fileHandlers_ts$getFileHandlerAssert(ref.real, project.config);
      if (handler.toJavaScript === undefined) {
        throw new Error('We don\'t know how to convert the file ' + path + ' to js');
      }

      let syntax = [];
      if (opts.syntax !== undefined) {
        syntax = opts.syntax;
      } else if (handler.syntax !== undefined) {
        syntax = handler.syntax;
      }

      let sourceType;
      if (opts.sourceType !== undefined) {
        sourceType = opts.sourceType;
      } else if (handler.sourceType !== undefined) {
        sourceType = handler.sourceType;
      } else {
        sourceType = 'script';

        if (ref.manifest !== undefined) {
          const manifest = this.getPartialManifest(ref.manifest);
          if (manifest.type === 'module') {
            sourceType = 'module';
          }
        }
      }

      if (project.config.bundler.mode === 'legacy') {
        sourceType = 'module';
      }

      const cacheEnabled = opts.cache !== false;

      if (cacheEnabled) {
        const cachedResult = this.astCache.get(path);
        if (cachedResult && cachedResult.ast.sourceType === sourceType) {
          this.astCache.set(path, Object.assign({}, cachedResult, {
            lastAccessed: Date.now()}));
          return cachedResult;
        }
      }

      this.logger.info('Parsing:', path);

      const stat = await ___R$romejs$fs$index_ts$lstat(path);

      const {sourceText: sourceText, generated: generated} = await handler.toJavaScript({
        file: ref,
        worker: this,
        project: project});

      const ast = ___R$romejs$js$parser$index_ts$parseJS({
        input: sourceText,
        mtime: stat.mtimeMs,
        path: ___R$romejs$path$index_ts$createUnknownFilePath(uid),
        sourceType: sourceType,
        syntax: syntax});

      const res = {
        ast: ast,
        lastAccessed: Date.now(),
        sourceText: sourceText,
        project: project,
        path: path,
        generated: generated};

      if (cacheEnabled) {
        this.astCache.set(path, res);
      }

      return res;
    }

    getProject(id) {
      const config = this.projects.get(id);
      if (config === undefined) {
        throw new Error('Unknown project ' + id + ', known projects are ' + this.projects.keys());
      }
      return config;
    }

    async writeFile(filename, content) {
      await ___R$romejs$fs$index_ts$writeFile(filename, content);

      this.evict(filename);
    }

    evict(filename) {
      this.astCache.delete(filename);
      this.moduleSignatureCache.delete(filename);
    }

    updateManifests(manifests) {
      for (const {id: id, manifest: manifest} of manifests) {
        if (manifest === undefined) {
          this.partialManifests.delete(id);
        } else {
          this.partialManifests.set(id, manifest);
        }
      }
    }

    updateProjects(projects) {
      for (const {config: config, folder: folder, id: id} of projects) {
        if (config === undefined) {
          this.projects.delete(id);
        } else {
          this.projects.set(id, {
            folder: ___R$romejs$path$index_ts$createAbsoluteFilePath(folder),
            config: ___R$romejs$project$transport_ts$hydrateJSONProjectConfig(config)});
        }
      }
    }
  }

  // romejs/core/test-worker/TestAPI.ts


  function ___R$$priv$romejs$core$test$worker$TestAPI_ts$formatExpectedError(expected) {
    if (typeof expected === 'string') {
      return JSON.stringify(expected);
    }

    if (expected instanceof RegExp) {
      return String(expected);
    }

    if (typeof expected === 'function') {
      return expected.name;
    }

    return 'unknown';
  }

  function ___R$$priv$romejs$core$test$worker$TestAPI_ts$matchExpectedError(error, expected) {
    if (expected === undefined) {
      return true;
    }

    if (typeof expected === 'string') {
      return error.message.includes(expected);
    }

    if (expected instanceof RegExp) {
      return expected.test(error.message);
    }

    if (typeof expected === 'function') {
      return error instanceof expected;
    }

    return false;
  }

  const ___R$$priv$romejs$core$test$worker$TestAPI_ts$TRUNCATION_MATCH_LIMIT = 500;

  function ___R$$priv$romejs$core$test$worker$TestAPI_ts$maybeTruncate(str, noTruncate) {
    if (noTruncate || str.length < ___R$$priv$romejs$core$test$worker$TestAPI_ts$TRUNCATION_MATCH_LIMIT) {
      return str;
    } else {
      return str.slice(0, ___R$$priv$romejs$core$test$worker$TestAPI_ts$TRUNCATION_MATCH_LIMIT) + '...';
    }
  }

  class ___R$romejs$core$test$worker$TestAPI_ts$default {
    constructor(testName, onTimeout, snapshotManager, options) {
      this.testName = testName;
      this.options = options;
      this.snapshotManager = snapshotManager;
      this.snapshotCounter = 0;

      this.teardownEvent = new ___R$romejs$events$Event_ts$default({name: 'TestAPI.teardown'});

      this.startTime = Date.now();
      this.onTimeout = onTimeout;
      this.timeoutMax = 0;
      this.timeoutId = undefined;
      this.setTimeout(5000);

      this.advice = [];
    }

    buildMatchParts(received, expected, visualMethod) {
      let expectedFormat;
      let receivedFormat;
      if (typeof received === 'string' && typeof expected === 'string') {
        expectedFormat = expected;
        receivedFormat = received;
      } else {
        expectedFormat = ___R$romejs$pretty$format$index_ts$default(expected);
        receivedFormat = ___R$romejs$pretty$format$index_ts$default(received);
      }

      const expectedFormatCode = ___R$$priv$romejs$core$test$worker$TestAPI_ts$maybeTruncate(
      expectedFormat,
      this.options.verboseDiagnostics);
      const receivedFormatCode = ___R$$priv$romejs$core$test$worker$TestAPI_ts$maybeTruncate(
      receivedFormat,
      this.options.verboseDiagnostics);
      const hasTruncated = expectedFormatCode !== expectedFormat ||
      receivedFormatCode !== receivedFormat;
      const hasAllTruncated = expectedFormatCode !== expectedFormat &&
      receivedFormatCode !== receivedFormat;

      const advice = [];

      if (expectedFormat === receivedFormat) {
        advice.push({
          type: 'log',
          category: 'info',
          message: 'Both the received and expected values are visually identical'});

        advice.push({
          type: 'code',
          code: expectedFormatCode});

        if (visualMethod !== undefined) {
          advice.push({
            type: 'log',
            category: 'info',
            message: 'Try using t.' + visualMethod + ' if you wanted a visual match'});
        }
      } else {
        if (!hasAllTruncated) {
          advice.push({
            type: 'log',
            category: 'info',
            message: 'Expected to receive'});

          advice.push({
            type: 'code',
            code: expectedFormatCode});

          advice.push({
            type: 'log',
            category: 'info',
            message: 'But got'});

          advice.push({
            type: 'code',
            code: receivedFormatCode});
        }

        advice.push({
          type: 'log',
          category: 'info',
          message: 'Diff'});

        advice.push({
          type: 'diff',
          diff: ___R$romejs$string$diff$index_ts$default(receivedFormat, expectedFormat)});
      }

      if (hasAllTruncated) {
        advice.push({
          type: 'log',
          category: 'info',
          message: 'Add the --verbose-diagnostics flag to show the values being compared'});
      } else if (hasTruncated) {
        advice.push({
          type: 'log',
          category: 'info',
          message: 'Some values have been truncated for being too long, add the --verbose-diagnostics flag to disable truncation'});
      }

      return advice;
    }

    addToAdvice(item) {
      this.advice.push(item);
    }

    onTeardown(callback) {
      this.teardownEvent.subscribe(callback);
    }

    clearTimeout() {
      if (this.timeoutId !== undefined) {
        clearTimeout(this.timeoutId);
      }

      this.timeoutMax = undefined;
      this.timeoutStart = undefined;
    }

    extendTimeout(time) {
      const {timeoutMax: timeoutMax, timeoutStart: timeoutStart} = this;
      if (timeoutMax === undefined || timeoutStart === undefined) {
        throw new Error('No timeout set');
      }

      const elapsed = Date.now() - timeoutStart;
      const newTime = timeoutMax - elapsed + time;
      this.setTimeout(newTime);
    }

    setTimeout(time) {
      this.clearTimeout();

      this.timeoutStart = Date.now();
      this.timeoutMax = time;

      this.timeoutId = setTimeout(() => {
        this.onTimeout(time);
      }, time);
    }

    checkTimeout() {
      const {startTime: startTime, timeoutMax: timeoutMax} = this;
      if (timeoutMax === undefined) {
        return undefined;
      }

      const delta = Date.now() - startTime;
      if (delta > timeoutMax) {
        throw new Error('Test timeout - exceeded ' + String(timeoutMax) + 'ms');
      }
    }

    fail(message, advice, framesToPop = 0) {
      const actualMessage = message === undefined ? 'Test failure triggered by t.fail()' : message;
      const error = ___R$romejs$v8$errors_ts$createErrorFromStructure({
        message: actualMessage,
        advice: advice,
        framesToPop: framesToPop + 1});
      throw error;
    }

    truthy(value, message = 'Expected value to be truthy') {
      if (Boolean(value) === false) {
        this.fail(
        message,
        [{
          type: 'log',
          category: 'info',
          message: 'Received'}, {
          type: 'code',
          code: ___R$romejs$pretty$format$index_ts$default(value)}],
        1);
      }
    }

    falsy(value, message = 'Expected value to be falsy') {
      if (Boolean(value) === true) {
        this.fail(
        message,
        [{
          type: 'log',
          category: 'info',
          message: 'Received'}, {
          type: 'code',
          code: ___R$romejs$pretty$format$index_ts$default(value)}],
        1);
      }
    }

    true(value, message = 'Expected value to be true') {
      if (value !== true) {
        this.fail(
        message,
        [{
          type: 'log',
          category: 'info',
          message: 'Received'}, {
          type: 'code',
          code: ___R$romejs$pretty$format$index_ts$default(value)}],
        1);
      }
    }

    false(value, message = 'Expected value to be false') {
      if (value !== false) {
        this.fail(
        message,
        [{
          type: 'log',
          category: 'info',
          message: 'Received'}, {
          type: 'code',
          code: ___R$romejs$pretty$format$index_ts$default(value)}],
        1);
      }
    }

    is(received, expected, message = 't.is() failed, using Object.is semantics') {
      if (Object.is(received, expected) !== true) {
        this.fail(
        message,
        this.buildMatchParts(received, expected, 'looksLike'),
        1);
      }
    }

    not(received, expected, message = 't.not() failed, using !Object.is() semantics') {
      if (Object.is(received, expected) === true) {
        this.fail(
        message,
        this.buildMatchParts(received, expected, 'notLooksLike'),
        1);
      }
    }

    looksLike(received, expected, message = 't.looksLike() failed, using prettyFormat semantics') {
      const actualInspect = ___R$romejs$pretty$format$index_ts$default(received);
      const expectedInspect = ___R$romejs$pretty$format$index_ts$default(expected);

      if (actualInspect !== expectedInspect) {
        this.fail(message, this.buildMatchParts(received, expected), 1);
      }
    }

    notLooksLike(received, expected, message = 't.notLooksLike() failed, using !prettyFormat semantics') {
      const actualInspect = ___R$romejs$pretty$format$index_ts$default(received);
      const expectedInspect = ___R$romejs$pretty$format$index_ts$default(expected);

      if (actualInspect === expectedInspect) {
        this.fail(message, this.buildMatchParts(received, expected), 1);
      }
    }

    throws(thrower, expected, message = 't.throws() failed, callback did not throw an error') {
      try {
        thrower();
      } catch (err) {
        if (___R$$priv$romejs$core$test$worker$TestAPI_ts$matchExpectedError(err, expected)) {
          return undefined;
        } else {
          this.fail('t.throws() expected an error to be thrown that matches ' + ___R$$priv$romejs$core$test$worker$TestAPI_ts$formatExpectedError(
          expected) + ' but got ' + err.name + ': ' + JSON.stringify(err.message), ___R$romejs$diagnostics$derive_ts$getErrorStackAdvice(err, 'Incorrect error stack trace'), 1);
        }
      }

      this.fail(message, undefined, 1);
    }

    async throwsAsync(thrower, expected, message) {
      throw new Error('unimplemented');
    }

    notThrows(nonThrower, message) {
      try {
        nonThrower();
      } catch (err) {
        message;
        throw err;
      }
    }

    async notThrowsAsync(nonThrower, message) {
      throw new Error('unimplemented');
    }

    regex(contents, regex, message) {
      throw new Error('unimplemented');
    }

    notRegex(contents, regex, message) {
      throw new Error('unimplemented');
    }

    snapshot(expected, message) {
      const id = this.snapshotCounter++;
      return this._snapshotNamed(id, expected, message, 2);
    }

    snapshotNamed(name, expected, message) {
      return this._snapshotNamed(name, expected, message, 1);
    }

    getSnapshot(name) {
      const key = this.snapshotManager.toSnapshotKey(this.testName, name);
      return this.snapshotManager.get(key);
    }

    _snapshotNamed(name, expected, message = 'Snapshots don\'t match', framesToPop) {
      const key = this.snapshotManager.toSnapshotKey(this.testName, name);

      const formatted = ___R$romejs$pretty$format$index_ts$default(expected);

      const existingSnapshot = this.snapshotManager.get(key);
      if (existingSnapshot === undefined) {
        this.snapshotManager.set(key, formatted);
        return undefined;
      }

      if (formatted !== existingSnapshot) {
        this.fail(
        message,
        [{
          type: 'log',
          category: 'info',
          message: 'Snapshot diff'}, {
          type: 'diff',
          diff: ___R$romejs$string$diff$index_ts$default(existingSnapshot, formatted)}],
        framesToPop);
      }
    }
  }

  // romejs/core/test-worker/SnapshotManager.ts

  const ___R$$priv$romejs$core$test$worker$SnapshotManager_ts$SNAPSHOTS_DIR = '__rsnapshots__';
  const ___R$$priv$romejs$core$test$worker$SnapshotManager_ts$SNAPSHOT_EXT = '.rsnap';

  class ___R$romejs$core$test$worker$SnapshotManager_ts$default {
    constructor(testFilename, forceUpdate) {
      this.testFilename = testFilename.join();

      const snapshotFolder = testFilename.getParent().append(___R$$priv$romejs$core$test$worker$SnapshotManager_ts$SNAPSHOTS_DIR);
      this.snapshotFolder = snapshotFolder;

      this.snapshotFilename = snapshotFolder.append(
      testFilename.getBasename() + ___R$$priv$romejs$core$test$worker$SnapshotManager_ts$SNAPSHOT_EXT);

      this.forceUpdate = forceUpdate;

      this.snapshots = new Map();
    }

    async load() {
      const {snapshotFilename: snapshotFilename} = this;
      if (!(await ___R$romejs$fs$index_ts$exists(snapshotFilename))) {
        return undefined;
      }

      if (this.forceUpdate) {
        return undefined;
      }

      const file = await ___R$romejs$fs$index_ts$readFileText(snapshotFilename);
      const json = JSON.parse(file);

      for (const key in json) {
        this.snapshots.set(key, String(json[key]));
      }
    }

    async save() {
      if (this.snapshots.size === 0) {
        return undefined;
      }

      const {snapshotFolder: snapshotFolder, snapshotFilename: snapshotFilename} = this;

      if (!(await ___R$romejs$fs$index_ts$exists(snapshotFolder))) {
        await ___R$romejs$fs$index_ts$createDirectory(snapshotFolder);
      }

      const json = {};
      for (const [key, value] of this.snapshots) {
        json[key] = value;
      }
      const formatted = JSON.stringify(json, undefined, '  ');

      await ___R$romejs$fs$index_ts$writeFile(snapshotFilename, formatted);
    }

    toSnapshotKey(testName, id) {
      if (id === 0) {
        return testName;
      } else {
        return testName + ': ' + id;
      }
    }

    get(key) {
      return this.snapshots.get(key);
    }

    set(key, value) {
      this.snapshots.set(key, value);
    }
  }

  // romejs/core/test-worker/TestWorkerRunner.ts

  const ___R$$priv$romejs$core$test$worker$TestWorkerRunner_ts$MAX_RUNNING_TESTS = 20;

  class ___R$romejs$core$test$worker$TestWorkerRunner_ts$default {
    constructor(opts, bridge) {
      this.opts = opts;
      this.locked = false;
      this.file = ___R$romejs$core$common$types$files_ts$convertTransportFileReference(opts.file);
      this.options = opts.options;
      this.bridge = bridge;
      this.snapshotManager = new ___R$romejs$core$test$worker$SnapshotManager_ts$default(___R$romejs$path$index_ts$createAbsoluteFilePath(opts.file.real), opts.options.updateSnapshots);

      this.hasFocusedTest = false;
      this.foundTests = new Map();
    }

    getEnvironment() {
      const testOptions = {
        dirname: this.file.real.getParent().join(),
        register: (callsiteError, opts, callback) => {
          this.registerTest(callsiteError, opts, callback);
        }};

      return {
        __ROME__TEST_OPTIONS__: testOptions};
    }

    async discoverTests() {
      const {code: code, sourceMap: sourceMap} = this.opts;

      const res = await ___R$romejs$core$common$utils$executeMain_ts$default({
        path: this.file.real,
        code: code,
        sourceMap: sourceMap,
        globals: this.getEnvironment()});

      if (res.syntaxError !== undefined) {
        const message = 'A bundle was generated that contained a syntax error: ' + res.syntaxError.message;

        throw new ___R$romejs$diagnostics$errors_ts$DiagnosticsError(message, [Object.assign({}, res.syntaxError, {
          message: message,
          filename: this.file.uid,
          advice: [___R$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE]})]);
      }
    }

    lockTests() {
      this.locked = true;
    }

    registerTest(callsiteError, options, callback) {
      if (this.locked) {
        throw new Error('Test can\'t be added outside of init');
      }

      let testName = options.name;
      if (Array.isArray(testName)) {
        testName = testName.join(' > ');
      }

      if (this.foundTests.has(testName)) {
        throw new Error('Test ' + testName + ' has already been defined');
      }

      this.foundTests.set(testName, {
        callback: callback,
        options: options,
        callsiteError: callsiteError});

      if (options.only === true) {
        this.hasFocusedTest = true;
      }
    }

    onError(testName, opts) {
      const filename = this.file.real.join();

      let ref = undefined;
      if (testName === undefined) {
        testName = 'unknown';
      } else {
        ref = {
          filename: filename,
          testName: testName};
      }

      let diagnostic = ___R$romejs$diagnostics$derive_ts$deriveDiagnosticFromError({
        error: opts.error,
        category: testName,
        filename: filename,
        cleanFrames(frames) {
          let latestTestWorkerFrame = frames.find((frame, i) => {
            if (frame.typeName === 'global' &&
            frame.methodName === undefined &&
            frame.functionName === undefined) {
              const nextFrame = frames[i + 1];
              if (nextFrame !== undefined &&
              nextFrame.typeName === 'Script' &&
              nextFrame.methodName === 'runInContext') {
                return true;
              }
            }

            return false;
          });

          if (latestTestWorkerFrame === undefined) {
            latestTestWorkerFrame = frames.find(frame => {
              return frame.filename !== undefined &&
              frame.filename.includes('core/test-worker');
            });
          }

          if (latestTestWorkerFrame === undefined) {
            return frames;
          }

          return frames.slice(0, frames.indexOf(latestTestWorkerFrame));
        }});

      diagnostic = Object.assign({}, diagnostic, {
        advice: [...opts.firstAdvice, ...(diagnostic.advice || []), ...opts.lastAdvice]});

      this.bridge.testError.send({
        ref: ref,
        diagnostic: diagnostic});
    }

    async teardownTest(testName, api) {
      api.clearTimeout();

      try {
        await api.teardownEvent.callOptional();
      } catch (err) {
        this.onError(testName, {
          error: err,
          firstAdvice: [],
          lastAdvice: [{
            type: 'log',
            category: 'info',
            message: 'Error occured while running <emphasis>teardown</emphasis> for test <emphasis>' + testName + '</emphasis>'}]});
      }
    }

    async runTest(testName, callback) {
      let onTimeout = () => {
        throw new Error('Promise wasn\'t created. Should be impossible.');
      };

      const timeoutPromise = new Promise((resolve, reject) => {
        onTimeout = time => {
          reject(new Error('Test timeout - exceeded ' + String(time) + 'ms'));
        };
      });

      const api = new ___R$romejs$core$test$worker$TestAPI_ts$default(testName, onTimeout, this.snapshotManager, this.options);

      try {
        const res = callback(api);

        if (res !== undefined && typeof res.then === 'function') {
          await Promise.race([timeoutPromise, res]);
        }

        this.bridge.testSuccess.send({
          ref: {
            filename: this.file.real.join(),
            testName: testName}});
      } catch (err) {
        this.onError(testName, {
          error: err,
          firstAdvice: [],
          lastAdvice: api.advice});
      } finally {
        await this.teardownTest(testName, api);
      }
    }

    async runTests() {
      const promises = new Set();

      for (const [testName, {options: options, callback: callback}] of this.foundTests) {
        if (callback === undefined) {
          continue;
        }

        this.bridge.testStart.send({
          ref: {
            filename: this.file.real.join(),
            testName: testName},
          timeout: options.timeout});

        const promise = this.runTest(testName, callback);
        promise.then(() => {
          promises.delete(promise);
        });
        promises.add(promise);

        if (promises.size > ___R$$priv$romejs$core$test$worker$TestWorkerRunner_ts$MAX_RUNNING_TESTS) {
          await Promise.race(Array.from(promises));
        }
      }

      await Promise.all(Array.from(promises));

      await this.snapshotManager.save();
    }

    async emitFoundTests() {
      const promises = [];

      for (const [testName, {callback: callback, options: options}] of this.foundTests) {
        let isSkipped = callback === undefined;
        if (this.hasFocusedTest && options.only !== true) {
          isSkipped = true;
        }

        promises.push(
        this.bridge.testFound.call({
          ref: {
            filename: this.file.real.join(),
            testName: testName},
          isSkipped: isSkipped}));
      }

      await Promise.all(promises);
    }

    async run() {
      try {
        await this.snapshotManager.load();
        await this.discoverTests();
        await this.emitFoundTests();

        this.lockTests();
        await this.runTests();
      } catch (err) {
        const diagnostics = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
        if (diagnostics === undefined) {
          this.onError(undefined, {
            error: err,
            firstAdvice: [],
            lastAdvice: [{
              type: 'log',
              category: 'info',
              message: 'Error occured while executing test file <filelink emphasis target="' + this.file.uid + '" />'}, ___R$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE]});
        } else {
          for (const diagnostic of diagnostics) {
            await this.bridge.testError.call({
              ref: undefined,
              diagnostic: diagnostic});
          }
        }
      }
    }
  }

  // romejs/core/test-worker/TestWorker.ts

  const ___R$$priv$romejs$core$test$worker$TestWorker_ts$inspector = require('inspector');
  class ___R$romejs$core$test$worker$TestWorker_ts$default {
    constructor() {
      this.bridge = this.buildBridge();
    }

    async init() {
      ___R$$priv$romejs$core$test$worker$TestWorker_ts$inspector.open();

      await this.bridge.handshake();
    }

    buildBridge() {
      const bridge = ___R$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess(___R$romejs$core$common$bridges$TestWorkerBridge_ts$default, {
        type: 'server'});

      process.on('unhandledRejection', err => {
        bridge.testError.send({
          ref: undefined,
          diagnostic: ___R$romejs$diagnostics$derive_ts$deriveDiagnosticFromError({
            error: err,
            category: 'unhandledRejection'})});
      });

      bridge.inspectorDetails.subscribe(() => {
        return {
          inspectorUrl: ___R$$priv$romejs$core$test$worker$TestWorker_ts$inspector.url()};
      });

      bridge.runTest.subscribe(data => {
        return this.runTest(data);
      });

      return bridge;
    }

    async runTest(opts) {
      const testRun = new ___R$romejs$core$test$worker$TestWorkerRunner_ts$default(opts, this.bridge);
      await testRun.run();
    }
  }

  // romejs/core/common/bridges/WorkerBridge.ts


  class ___R$romejs$core$common$bridges$WorkerBridge_ts$default extends ___R$romejs$events$Bridge_ts$default {
    constructor(...args) {
      super(...args);
      this.log = this.createEvent({
        name: 'log',
        direction: 'server->client'});
      this.updateProjects = this.createEvent({
        name: 'updateProjects',
        direction: 'server->client'});
      this.updateManifests = this.createEvent(
      {
        name: 'updateManifests',
        direction: 'server->client'});
      this.profilingStart = this.createEvent({
        name: 'profiling.start',
        direction: 'server->client'});
      this.profilingStop = this.createEvent({
        name: 'profiling.stop',
        direction: 'server->client'});
      this.status = this.createEvent({
        name: 'status',
        direction: 'server->client'});
      this.evict = this.createEvent({
        name: 'evict',
        direction: 'server->client'});
      this.moduleSignatureJS = this.createEvent(
      {
        name: 'moduleSignatureJS',
        direction: 'server->client'});
      this.analyzeDependencies = this.createEvent(
      {
        name: 'analyzeDependencies',
        direction: 'server->client'});
      this.lint = this.createEvent(
      {name: 'lint', direction: 'server->client'});
      this.compileJS = this.createEvent(
      {name: 'compileJS', direction: 'server->client'});
      this.parseJS = this.createEvent(
      {name: 'parseJS', direction: 'server->client'});
    }
    init() {
      this.addErrorTransport('DiagnosticsError', {
        serialize(err) {
          if (!(err instanceof ___R$romejs$diagnostics$errors_ts$DiagnosticsError)) {
            throw new Error('Expected DiagnosticsError');
          }

          return {
            diagnostic: err.diagnostics};
        },
        hydrate(err, data) {
          return new ___R$romejs$diagnostics$errors_ts$DiagnosticsError(String(err.message), data.diagnostics);
        }});
    }
  }

  // romejs/core/common/bridges/MasterBridge.ts


  class ___R$romejs$core$common$bridges$MasterBridge_ts$default extends ___R$romejs$events$Bridge_ts$default {
    constructor(...args) {
      super(...args);
      this.getClientInfo = this.createEvent({
        name: 'getClientInfo',
        direction: 'server->client'});
      this.stdout = this.createEvent({
        name: 'stdout',
        direction: 'server->client'});
      this.stderr = this.createEvent({
        name: 'stderr',
        direction: 'server->client'});
      this.enableWorkerLogs = this.createEvent({
        name: 'enableWorkerLogs',
        direction: 'server<-client'});
      this.log = this.createEvent({
        name: 'log',
        direction: 'server->client'});
      this.setColumns = this.createEvent({
        name: 'columns.set',
        direction: 'server<-client'});
      this.reporterRemoteServerMessage = this.createEvent(
      {
        name: 'reporterRemoteToLocalMessage',
        direction: 'server->client'});
      this.reporterRemoteClientMessage = this.createEvent(
      {
        name: 'reporterLocalToRemoteMessage',
        direction: 'server<-client'});
      this.query = this.createEvent({
        name: 'query',
        direction: 'server<-client'});
      this.profilingGetWorkers = this.createEvent({
        name: 'profiling.getWorkers',
        direction: 'server<-client'});
      this.profilingStart = this.createEvent({
        name: 'profiling.start',
        direction: 'server<-client'});
      this.profilingStop = this.createEvent({
        name: 'profiling.stop',
        direction: 'server<-client'});
      this.profilingStopWorker = this.createEvent({
        name: 'profile.stopWorker',
        direction: 'server<-client'});
    }
  }

  // romejs/core/common/bridges/WebBridge.ts

  class ___R$romejs$core$common$bridges$WebBridge_ts$default extends ___R$romejs$events$Bridge_ts$default {
    constructor(...args) {
      super(...args);
      this.requests = this.createEvent(
      {
        name: 'WebBridge.requests',
        direction: 'server->client'});
    }
  }

  // romejs/core/common/bridges/TestWorkerBridge.ts


  class ___R$romejs$core$common$bridges$TestWorkerBridge_ts$default extends ___R$romejs$events$Bridge_ts$default {
    constructor(...args) {
      super(...args);
      this.inspectorDetails = this.createEvent(
      {
        name: 'inspectorDetails',
        direction: 'server->client'});
      this.runTest = this.createEvent({
        name: 'runTest',
        direction: 'server->client'});
      this.testFound = this.createEvent({
        name: 'onTestFound',
        direction: 'server<-client'});
      this.testStart = this.createEvent(
      {
        name: 'onTestStart',
        direction: 'server<-client'});
      this.testError = this.createEvent(
      {name: 'onTestError', direction: 'server<-client'});
      this.testSuccess = this.createEvent({
        name: 'onTestSuccess',
        direction: 'server<-client'});
    }
  }

  // romejs/core/index.ts


  // romejs/cli/utils/setProcessTitle.ts

  function ___R$romejs$cli$utils$setProcessTitle_ts$default(title) {
    process.title = 'rome-' + title;
  }

  // romejs/cli/cli.ts

  const ___R$$priv$romejs$cli$cli_ts$fs = require('fs');

  async function ___R$romejs$cli$cli_ts$default() {
    ___R$romejs$cli$utils$setProcessTitle_ts$default('cli');

    const p = ___R$romejs$cli$flags$index_ts$parseCLIFlagsFromProcess({
      programName: 'rome',
      usage: '[command] [flags]',
      defineFlags(c) {
        return {
          clientFlags: Object.assign({
            clientName: 'cli',
            cwd: ___R$romejs$path$index_ts$createAbsoluteFilePath(c.get('cwd').asString(process.cwd())),
            verbose: c.get('verbose').asBoolean(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS.verbose),
            silent: c.get('silent').asBoolean(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS.silent)}, overrideClientFlags),

          cliFlags: Object.assign({
            markersPath: ___R$romejs$path$index_ts$maybeCreateAbsoluteFilePath(
            c.get('markersPath').asStringOrVoid()),
            profile: c.get('profile').asBoolean(false),
            profilePath: ___R$romejs$path$index_ts$maybeCreateAbsoluteFilePath(
            c.get('profilePath').asStringOrVoid()),
            profileTimeout: c.get('profileTimeout').asNumber(0),
            profileWorkers: c.get('profileWorkers').asBoolean(true),
            profileSampling: c.get('profileSampling').asNumber(100),
            temporaryDaemon: c.get('temporaryDaemon').asBoolean(false),
            rage: c.get('rage').asBoolean(false),
            ragePath: ___R$romejs$path$index_ts$maybeCreateAbsoluteFilePath(
            c.get('ragePath').asStringOrVoid()),
            logs: c.get('logs').asBoolean(false),
            logWorkers: c.get('logWorkers').asBooleanOrVoid(),
            logPath: ___R$romejs$path$index_ts$maybeCreateAbsoluteFilePath(
            c.get('logPath').asStringOrVoid())}, overrideCLIFlags),

          requestFlags: Object.assign({
            benchmark: c.get('benchmark').asBoolean(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.benchmark),
            benchmarkIterations: c.get('benchmarkIterations').asNumber(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.benchmarkIterations),
            collectMarkers: c.get('collectMarkers').asBoolean(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.collectMarkers),
            watch: c.get('watch').asBoolean(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.watch),
            fieri: c.get('fieri').asBoolean(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.fieri),
            focus: c.get('focus').asString(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.focus),
            grep: c.get('grep').asString(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.grep),
            maxDiagnostics: c.get('maxDiagnostics').asNumber(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.maxDiagnostics),
            verboseDiagnostics: c.get('verboseDiagnostics').asBoolean(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.verboseDiagnostics),
            showAllDiagnostics: c.get('showAllDiagnostics').asBoolean(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.showAllDiagnostics),
            inverseGrep: c.get('inverseGrep').asBoolean(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.inverseGrep),
            resolverPlatform: c.get('resolverPlatform').asStringSetOrVoid(___R$romejs$core$common$types$platform_ts$PLATFORMS),
            resolverScale: c.get('resolverScale').asNumberOrVoid(),
            resolverMocks: c.get('resolverMocks').asBoolean(___R$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.resolverMocks)}, overrideRequestFlags)};
      }});

    let command = '';
    let overrideClientFlags = {};
    let overrideRequestFlags = {};
    let overrideCLIFlags = {};
    let commandFlags = {};
    let args = [];

    const commandNames = new Set([...___R$romejs$core$client$commands_ts$localCommands.keys(), ...___R$romejs$core$master$commands$index_ts$masterCommands.keys()]);
    for (const cmd of commandNames) {
      const local = ___R$romejs$core$client$commands_ts$localCommands.get(cmd);
      if (local !== undefined) {
        p.command({
          name: cmd,
          category: local.category,
          description: local.description,
          callback() {
            args = p.getArgs();
            command = cmd;
          }});
        continue;
      }

      const master = ___R$romejs$core$master$commands$index_ts$masterCommands.get(cmd);
      if (master !== undefined) {
        p.command({
          name: cmd,
          category: master.category,
          description: master.description,
          defineFlags: master.defineFlags,

          callback(_commandFlags) {
            if (master.defineFlags !== undefined) {
              commandFlags = _commandFlags;
            }

            if (master.overrideClientFlags !== undefined) {
              overrideClientFlags = master.overrideClientFlags;
            }

            if (master.overrideRequestFlags !== undefined) {
              overrideRequestFlags = master.overrideRequestFlags;
            }

            args = p.getArgs();
            command = cmd;
          }});
      }
    }

    p.command({
      name: 'rage',
      category: ___R$romejs$core$commands_ts$commandCategories.INTERNAL,
      description: '',

      callback(_commandFlags) {
        overrideCLIFlags = {
          rage: true};

        command = '_noop';
      }});

    p.command({
      name: 'logs',
      category: ___R$romejs$core$commands_ts$commandCategories.INTERNAL,
      description: '',

      callback(_commandFlags) {
        overrideCLIFlags = {
          logs: true};

        command = '_noop';
      }});

    let {clientFlags: clientFlags, cliFlags: cliFlags, requestFlags: requestFlags} = await p.init();

    if (cliFlags.markersPath || cliFlags.rage) {
      requestFlags.collectMarkers = true;
    }

    if (cliFlags.logPath !== undefined || cliFlags.logWorkers === true) {
      cliFlags.logs = true;
    }

    p.commandRequired();

    const client = new ___R$romejs$core$client$Client_ts$default({
      globalErrorHandlers: true,
      flags: clientFlags,
      stdout: process.stdout,
      stderr: process.stderr});

    client.bridgeAttachedEvent.subscribe(async () => {
      const profileOptions = {
        samplingInterval: cliFlags.profileSampling,
        timeoutInterval: cliFlags.profileTimeout,
        includeWorkers: cliFlags.profileWorkers};

      if (cliFlags.rage) {
        const {ragePath: ragePath} = cliFlags;
        const filename = clientFlags.cwd.resolve(
        ragePath === undefined ? 'rome-rage-' + ___R$romejs$core$client$Client_ts$getFilenameTimestamp() + '.tar.gz' : ragePath).join();
        await client.rage(filename, profileOptions);
        return;
      }

      if (cliFlags.profile) {
        await client.profile(profileOptions, async events => {
          const {cwd: cwd} = clientFlags;
          const {profilePath: profilePath} = cliFlags;

          const resolvedProfilePath = cwd.resolve(
          profilePath === undefined ? 'Profile-' + ___R$romejs$core$client$Client_ts$getFilenameTimestamp() + '.json' : profilePath);

          const str = JSON.stringify(events, undefined, '  ');
          await ___R$romejs$fs$index_ts$writeFile(resolvedProfilePath, str);

          client.reporter.success('Wrote CPU profile to <filelink emphasis target="' + resolvedProfilePath.join() + '" />');
        });
      }

      if (cliFlags.logs) {
        let fileout;
        if (cliFlags.logPath !== undefined) {
          fileout = ___R$$priv$romejs$cli$cli_ts$fs.createWriteStream(
          clientFlags.cwd.resolve(cliFlags.logPath).join());

          client.endEvent.subscribe(() => {
            if (fileout !== undefined) {
              fileout.end();
            }
          });
        }

        await client.subscribeLogs(cliFlags.logWorkers === true, chunk => {
          if (fileout === undefined) {
            client.reporter.writeAll(chunk);
          } else {
            fileout.write(___R$romejs$string$ansi$format_ts$stripAnsi(chunk));
          }
        });
      }
    });

    if (cliFlags.temporaryDaemon) {
      await client.forceStartDaemon();
    }

    const res = await client.query({
      command: command,
      commandFlags: commandFlags,
      args: args,
      requestFlags: requestFlags,

      terminateWhenIdle: cliFlags.temporaryDaemon,

      noData: true});

    await client.end();

    if (res.type === 'SUCCESS') {
      if (requestFlags.collectMarkers) {
        const markersPath = clientFlags.cwd.resolve(
        cliFlags.markersPath === undefined ? 'Markers-' + ___R$romejs$core$client$Client_ts$getFilenameTimestamp() + '.json' : cliFlags.markersPath);

        await ___R$romejs$fs$index_ts$writeFile(markersPath, JSON.stringify(res.markers, null, '  '));

        client.reporter.success('Wrote markers to <filelink emphasis target="' + markersPath.join() + '" />');
      }
    }

    switch (res.type) {
      case 'ERROR':
        if (!res.handled) {
          console.error('Unhandled CLI query error');
          console.error(res.stack);
        }
        process.exit(1);
        break;

      case 'DIAGNOSTICS':
        process.exit(1);
        break;

      case 'SUCCESS':
        process.exit(0);
        break;}
  }

  // romejs/cli/master.ts

  const ___R$$priv$romejs$cli$master_ts$net = require('net');
  async function ___R$romejs$cli$master_ts$default() {
    ___R$romejs$cli$utils$setProcessTitle_ts$default('master');

    const master = new ___R$romejs$core$master$Master_ts$default({
      dedicated: true,
      globalErrorHandlers: true});

    await master.init();

    const socketServer = ___R$$priv$romejs$cli$master_ts$net.createServer(function(socket) {
      const client = ___R$romejs$events$bridgeCreators_ts$createBridgeFromSocket(___R$romejs$core$common$bridges$MasterBridge_ts$default, socket, {
        type: 'client'});
      master.attachToBridge(client);
    });

    if (await ___R$romejs$fs$index_ts$exists(___R$romejs$core$common$constants_ts$SOCKET_PATH)) {
      await ___R$romejs$fs$index_ts$unlink(___R$romejs$core$common$constants_ts$SOCKET_PATH);
    }

    socketServer.listen(___R$romejs$core$common$constants_ts$SOCKET_PATH.join(), () => {
      const socket = ___R$$priv$romejs$cli$master_ts$net.createConnection(___R$romejs$core$common$constants_ts$CLI_SOCKET_PATH.join(), () => {
        socket.end();
      });

      socket.on('error', err => {
        err;
        console.log(err);
        process.exit();
      });
    });
  }

  // romejs/cli/testWorker.ts

  function ___R$romejs$cli$testWorker_ts$default() {
    ___R$romejs$cli$utils$setProcessTitle_ts$default('test-worker');
    const worker = new ___R$romejs$core$test$worker$TestWorker_ts$default();
    worker.init();
  }

  // romejs/cli/worker.ts

  async function ___R$romejs$cli$worker_ts$default() {
    ___R$romejs$cli$utils$setProcessTitle_ts$default('worker');
    const bridge = ___R$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess(___R$romejs$core$common$bridges$WorkerBridge_ts$default, {
      type: 'server'});
    const worker = new ___R$romejs$core$worker$Worker_ts$default({
      bridge: bridge,
      globalErrorHandlers: true});
    await worker.init();
    bridge.handshake();
  }

  // romejs/cli/bin/rome.ts

  async function ___R$$priv$romejs$cli$bin$rome_ts$main() {
    switch (process.env.ROME_PROCESS_VERSION === ___R$romejs$core$common$constants_ts$VERSION &&
    process.env.ROME_PROCESS_TYPE) {
      case 'master':
        return ___R$romejs$cli$master_ts$default();

      case 'worker':
        return ___R$romejs$cli$worker_ts$default();

      case 'test-worker':
        return ___R$romejs$cli$testWorker_ts$default();

      default:
        return ___R$romejs$cli$cli_ts$default();}
  }

  ___R$romejs$v8$index_ts$sourceMapManager.init();
  ___R$romejs$v8$index_ts$sourceMapManager.addSourceMapFactory(___R$romejs$core$common$constants_ts$BIN.join(), () => JSON.parse(___R$romejs$fs$index_ts$readFileTextSync(___R$romejs$core$common$constants_ts$MAP)));

  ___R$$priv$romejs$cli$bin$rome_ts$main().catch(err => {
    const diags = ___R$romejs$diagnostics$errors_ts$getDiagnosticsFromError(err);
    if (diags === undefined) {
      console.error('Error thrown inside the CLI handler');
      console.error(___R$romejs$v8$errors_ts$getErrorStructure(err).stack);
    } else {
      const reporter = ___R$romejs$cli$reporter$Reporter_ts$default.fromProcess();
      ___R$romejs$cli$diagnostics$index_ts$printDiagnosticsSync(diags, {
        origins: [],
        reporter: reporter});
    }
    process.exit(1);
  });

  // rome/bin/rome.ts

  const ___R$rome$bin$rome_ts = {};

  return ___R$rome$bin$rome_ts;
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
